{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1525426716000},{"_id":"themes/hexo-theme-next/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1525656449838},{"_id":"themes/hexo-theme-next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1525656044178},{"_id":"themes/hexo-theme-next/README.en.md","hash":"32d6cdfec1447f54aae1d7f1365ce6733dfcec8f","modified":1525656044178},{"_id":"themes/hexo-theme-next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1525656044178},{"_id":"themes/hexo-theme-next/_config.yml","hash":"1736fcffb01473fc2ca0612c4dd25ef88d2becd8","modified":1526374396432},{"_id":"themes/hexo-theme-next/bower.json","hash":"7d7938f9da896fe710aa0e9120140e528bf058df","modified":1525656044179},{"_id":"themes/hexo-theme-next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1525656044179},{"_id":"themes/hexo-theme-next/package.json","hash":"193dad6f59a588908fac082cc46fe067dac1b84d","modified":1525656044195},{"_id":"source/_posts/.DS_Store","hash":"61a130a17b026dd3a116b55b1affdbfc77accc5b","modified":1526372912062},{"_id":"source/_posts/ArrayList源码解析.md","hash":"9b9a3097ddb99c5052513f923638dcef9c5d4d0f","modified":1525658660166},{"_id":"source/_posts/Enum的正确使用方式.md","hash":"58747020573c049c3bf80e357dd2f7eb04977977","modified":1525658527486},{"_id":"source/_posts/EventBus源码解析.md","hash":"1905b7f4ee18eb1f247712768e34cb120b018910","modified":1525658630325},{"_id":"source/_posts/Glide源码解析1.md","hash":"320bacf48a59950ba8adc9326ba330a71403bfc2","modified":1525658514186},{"_id":"source/_posts/HashMap源码解析1.md","hash":"a8399f36def22fdb60ad36230fb16ebbda585c1e","modified":1525658590546},{"_id":"source/_posts/LruCache解析.md","hash":"17c6d33451e65118aac4007495cd12c45f57b371","modified":1525658575247},{"_id":"source/_posts/ObjectBox使用说明.md","hash":"430d7259f06b86754b405d1c616b85d6b53e77ba","modified":1525658488287},{"_id":"source/_posts/RxJava2源码解析1.md","hash":"543fc913c338b8ad1f9a2ce8141ce28be021fc87","modified":1525658602839},{"_id":"source/_posts/RxJava2源码解析2.md","hash":"ee4fd211dc56689ad22f760127ab181d479bd639","modified":1525658615090},{"_id":"source/_posts/rxJabaObservableUML.gliffy","hash":"06888a960a2581a8a41bfb5956fa50a898597038","modified":1525339458000},{"_id":"source/_posts/基于as3.0 多aar打包发布.md","hash":"29bb19d3e2d636a787ce843c471e55bf5c4a2142","modified":1525658306098},{"_id":"source/_posts/记录一次Gradle的踩坑.md","hash":"d759c06c43c298b8892b507419046a497364a77d","modified":1526373232887},{"_id":"source/_posts/谈谈GC和引用.md","hash":"d99a1ede517409009adfff2f970222fc57a91811","modified":1525658559127},{"_id":"source/about/index.md","hash":"bec84ac07b18c2396cfe6a3f0eea6415fbe6a520","modified":1525339458000},{"_id":"source/articles/index.md","hash":"85864ee480a5d845c4df9799d8f3224eda9bc9c0","modified":1525339458000},{"_id":"source/categories/index.md","hash":"6f83e5cdbd7bef76e96c7e540a316d94fc700a81","modified":1525339458000},{"_id":"source/tags/index.md","hash":"74c49f4cbdea1dbb28802eb8178c5cfff08c7f58","modified":1525339458000},{"_id":"themes/hexo-theme-next/languages/de.yml","hash":"306db8c865630f32c6b6260ade9d3209fbec8011","modified":1525656044179},{"_id":"themes/hexo-theme-next/languages/default.yml","hash":"4cc6aeb1ac09a58330e494c8771773758ab354af","modified":1525656044179},{"_id":"themes/hexo-theme-next/languages/en.yml","hash":"e7def07a709ef55684490b700a06998c67f35f39","modified":1525656044179},{"_id":"themes/hexo-theme-next/languages/fr-FR.yml","hash":"24180322c83587a153cea110e74e96eacc3355ad","modified":1525656044180},{"_id":"themes/hexo-theme-next/languages/id.yml","hash":"2835ea80dadf093fcf47edd957680973f1fb6b85","modified":1525656044180},{"_id":"themes/hexo-theme-next/languages/ja.yml","hash":"1c3a05ab80a6f8be63268b66da6f19da7aa2c638","modified":1525656044180},{"_id":"themes/hexo-theme-next/languages/ko.yml","hash":"be150543379150f78329815af427bf152c0e9431","modified":1525656044180},{"_id":"themes/hexo-theme-next/languages/pt-BR.yml","hash":"958e49571818a34fdf4af3232a07a024050f8f4e","modified":1525656044180},{"_id":"themes/hexo-theme-next/languages/pt.yml","hash":"36c8f60dacbe5d27d84d0e0d6974d7679f928da0","modified":1525656044181},{"_id":"themes/hexo-theme-next/languages/ru.yml","hash":"1549a7c2fe23caa7cbedcd0aa2b77c46e57caf27","modified":1525656044181},{"_id":"themes/hexo-theme-next/languages/zh-Hans.yml","hash":"3c0c7dfd0256457ee24df9e9879226c58cb084b5","modified":1525656044181},{"_id":"themes/hexo-theme-next/languages/zh-hk.yml","hash":"1c917997413bf566cb79e0975789f3c9c9128ccd","modified":1525656044181},{"_id":"themes/hexo-theme-next/languages/zh-tw.yml","hash":"0b2c18aa76570364003c8d1cd429fa158ae89022","modified":1525656044181},{"_id":"themes/hexo-theme-next/layout/_layout.swig","hash":"06b1eab2e00273e0b94bd32dc682bd92c1e0a747","modified":1525656044182},{"_id":"themes/hexo-theme-next/layout/archive.swig","hash":"383f64deab105724fd5512371963bd9e9aafbffd","modified":1525656044194},{"_id":"themes/hexo-theme-next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1525656044194},{"_id":"themes/hexo-theme-next/layout/index.swig","hash":"03e8a2cda03bad42ac0cb827025eb81f95d496a2","modified":1525656044194},{"_id":"themes/hexo-theme-next/layout/page.swig","hash":"37c874cd720acf0eda8d26e063278f2b6ae8d3a6","modified":1525656044194},{"_id":"themes/hexo-theme-next/layout/post.swig","hash":"2d5f8d7f0a96b611e2d5a5e4d111fc17726a990f","modified":1525656044195},{"_id":"themes/hexo-theme-next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1525656044195},{"_id":"themes/hexo-theme-next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1525656044195},{"_id":"themes/hexo-theme-next/scripts/merge-configs.js","hash":"13c8b3a2d9fce06c2488820d9248d190c8100e0a","modified":1525656044195},{"_id":"themes/hexo-theme-next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1525656044196},{"_id":"themes/hexo-theme-next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1525656044265},{"_id":"themes/hexo-theme-next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1525656044266},{"_id":"themes/hexo-theme-next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1525656044266},{"_id":"themes/hexo-theme-next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525656044219},{"_id":"source/_posts/Glide源码解析1/decodeJob流程图.png","hash":"94e8007884a6c7665346a2b4ce8d3f337ed25643","modified":1525339458000},{"_id":"source/_posts/RxJava2源码解析1/rxjava实现原理.jpg","hash":"5704e8dbad45c042049d4da9dc04177858b06c1e","modified":1525339458000},{"_id":"source/_posts/基于as3.0 多aar打包发布/demopic.png","hash":"e4c624d006f5175998336f58677f815a12a665d4","modified":1525339458000},{"_id":"source/_posts/谈谈GC和引用/gc.png","hash":"61470a0acc9eda5281d68579701600200e7171a6","modified":1525339458000},{"_id":"themes/hexo-theme-next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1525656044182},{"_id":"themes/hexo-theme-next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1525656044182},{"_id":"themes/hexo-theme-next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1525656044182},{"_id":"themes/hexo-theme-next/layout/_macro/post-copyright.swig","hash":"53d4f83b2b7fb4387dfc9fe81519abd56fbce4ae","modified":1525656044182},{"_id":"themes/hexo-theme-next/layout/_macro/post.swig","hash":"911363776867d9523a3e322cdf591d49cd166403","modified":1525656044183},{"_id":"themes/hexo-theme-next/layout/_macro/sidebar.swig","hash":"faa7886ccf986890cd776f4e9d70cb89fe9fda5f","modified":1525656044183},{"_id":"themes/hexo-theme-next/layout/_macro/reward.swig","hash":"5d5f70deb6074cb4dd0438463e14ccf89213c282","modified":1525656044183},{"_id":"themes/hexo-theme-next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1525656044184},{"_id":"themes/hexo-theme-next/layout/_partials/comments.swig","hash":"ce7094ee05878161e7568a6dfae5b56ff3fbd6e1","modified":1525656044184},{"_id":"themes/hexo-theme-next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1525656044184},{"_id":"themes/hexo-theme-next/layout/_partials/head.swig","hash":"1f14d3f494b2dbbcee802fd6f6d1abd5b7e2304c","modified":1525656044184},{"_id":"themes/hexo-theme-next/layout/_partials/header.swig","hash":"a1ffbb691dfad3eaf2832a11766e58a179003b8b","modified":1525656044185},{"_id":"themes/hexo-theme-next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1525656044185},{"_id":"themes/hexo-theme-next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1525656044185},{"_id":"themes/hexo-theme-next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1525656044185},{"_id":"themes/hexo-theme-next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1525656044187},{"_id":"themes/hexo-theme-next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1525656044187},{"_id":"themes/hexo-theme-next/layout/_scripts/vendors.swig","hash":"9baf90f7c40b3b10f288e9268c3191e895890cea","modified":1525656044188},{"_id":"themes/hexo-theme-next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1525656044192},{"_id":"themes/hexo-theme-next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1525656044192},{"_id":"themes/hexo-theme-next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1525656044192},{"_id":"themes/hexo-theme-next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1525656044192},{"_id":"themes/hexo-theme-next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1525656044192},{"_id":"themes/hexo-theme-next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1525656044192},{"_id":"themes/hexo-theme-next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1525656044196},{"_id":"themes/hexo-theme-next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1525656044196},{"_id":"themes/hexo-theme-next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1525656044196},{"_id":"themes/hexo-theme-next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1525656044197},{"_id":"themes/hexo-theme-next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1525656044196},{"_id":"themes/hexo-theme-next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1525656044197},{"_id":"themes/hexo-theme-next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1525656044197},{"_id":"themes/hexo-theme-next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1525656044197},{"_id":"themes/hexo-theme-next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1525656044197},{"_id":"themes/hexo-theme-next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1525656044219},{"_id":"themes/hexo-theme-next/source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1525660230435},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1525656044219},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1525656044220},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1525656044220},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1525656044220},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1525656044220},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1525656044221},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1525656044221},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1525656044221},{"_id":"themes/hexo-theme-next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1525656044221},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1525656044221},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1525656044221},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1525656044221},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1525656044222},{"_id":"source/_posts/Glide源码解析1/glide_load时序图.png","hash":"e8d305accaf9a949f5859ed55ef15212fc640c06","modified":1525339458000},{"_id":"source/_posts/HashMap源码解析1/put.jpg","hash":"9db130504f10a1da8867c3f48e95ef44d1529901","modified":1525339458000},{"_id":"source/_posts/记录一次Gradle的踩坑/Gradle执行时序.png","hash":"86d3af61eaf327aa2d0860abf7ee7b41b6a3ad9f","modified":1526366866281},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525656044188},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525656044188},{"_id":"themes/hexo-theme-next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525656044212},{"_id":"themes/hexo-theme-next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525656044212},{"_id":"themes/hexo-theme-next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525656044213},{"_id":"themes/hexo-theme-next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525656044218},{"_id":"themes/hexo-theme-next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525656044219},{"_id":"themes/hexo-theme-next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1525656044184},{"_id":"themes/hexo-theme-next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1525656044185},{"_id":"themes/hexo-theme-next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1525656044186},{"_id":"themes/hexo-theme-next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1525656044186},{"_id":"themes/hexo-theme-next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1525656044186},{"_id":"themes/hexo-theme-next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1525656044186},{"_id":"themes/hexo-theme-next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1525656044186},{"_id":"themes/hexo-theme-next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1525656044187},{"_id":"themes/hexo-theme-next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1525656044187},{"_id":"themes/hexo-theme-next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1525656044187},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1525656044188},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1525656044188},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1525656044189},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1525656044189},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1525656044189},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1525656044189},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1525656044189},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1525656044189},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/index.swig","hash":"3358d11b9a26185a2d36c96049e4340e701646e4","modified":1525656044190},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1525656044190},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1525656044190},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1525656044190},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1525656044190},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1525656044191},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1525656044191},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1525656044191},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1525656044191},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/index.swig","hash":"ee63aa2e49507b884a2d56778479cf01c723d751","modified":1525656044191},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1525656044191},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1525656044191},{"_id":"themes/hexo-theme-next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1525656044193},{"_id":"themes/hexo-theme-next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1525656044193},{"_id":"themes/hexo-theme-next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1525656044193},{"_id":"themes/hexo-theme-next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1525656044194},{"_id":"themes/hexo-theme-next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1525656044211},{"_id":"themes/hexo-theme-next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1525656044212},{"_id":"themes/hexo-theme-next/source/css/_mixins/Pisces.styl","hash":"eaedfaf06dae94ba77a8f4893e2e434bf8859bac","modified":1525656044212},{"_id":"themes/hexo-theme-next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1525656044212},{"_id":"themes/hexo-theme-next/source/css/_variables/Gemini.styl","hash":"49b5210fa62d6cbc6a98f57d89d5067a06ab3561","modified":1525656044218},{"_id":"themes/hexo-theme-next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1525656044218},{"_id":"themes/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"cfee25d790e4f9b7d57f0dc7e2ea9c1649f08f11","modified":1525656044218},{"_id":"themes/hexo-theme-next/source/css/_variables/base.styl","hash":"d477196c5699c8261b08e993a77ef67054d86166","modified":1525656044219},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1525656044222},{"_id":"themes/hexo-theme-next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1525656044222},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","hash":"6117f97b4984b8e33f21c726132da64ba678e4ed","modified":1525656044222},{"_id":"themes/hexo-theme-next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1525656044222},{"_id":"themes/hexo-theme-next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1525656044223},{"_id":"themes/hexo-theme-next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1525656044223},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","hash":"dc0365b2fb315a8b43d3ef19b59d3a82a366fcc1","modified":1525656044223},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","hash":"0693695a9512641daff63d99da772625a058ab18","modified":1525656044223},{"_id":"themes/hexo-theme-next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1525656044223},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1525656044224},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","hash":"2917c39c75b14b6dab7e1c46ab4d87b4df9fcd5d","modified":1525656044224},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1525656044227},{"_id":"themes/hexo-theme-next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1525656044230},{"_id":"themes/hexo-theme-next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1525656044230},{"_id":"themes/hexo-theme-next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1525656044230},{"_id":"themes/hexo-theme-next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1525656044230},{"_id":"themes/hexo-theme-next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1525656044235},{"_id":"themes/hexo-theme-next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1525656044235},{"_id":"themes/hexo-theme-next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1525656044236},{"_id":"themes/hexo-theme-next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1525656044236},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1525656044237},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1525656044237},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1525656044237},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1525656044237},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1525656044237},{"_id":"themes/hexo-theme-next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1525656044247},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1525656044248},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1525656044248},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1525656044248},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1525656044248},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1525656044248},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1525656044249},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1525656044249},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1525656044249},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1525656044249},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1525656044249},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1525656044250},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1525656044250},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1525656044250},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1525656044251},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1525656044251},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1525656044251},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1525656044251},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1525656044252},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1525656044252},{"_id":"themes/hexo-theme-next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1525656044252},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1525656044253},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1525656044254},{"_id":"themes/hexo-theme-next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1525656044254},{"_id":"themes/hexo-theme-next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1525656044260},{"_id":"themes/hexo-theme-next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1525656044261},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1525656044264},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1525656044264},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1525656044265},{"_id":"themes/hexo-theme-next/source/images/avatar.png","hash":"e236f5447b379b018c625567084ce85658277e00","modified":1525657431411},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1525656044247},{"_id":"themes/hexo-theme-next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1525656044193},{"_id":"themes/hexo-theme-next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1525656044193},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top-sidebar.styl","hash":"d026c8489f66ab6c12ad04bd37f1d5b6f2f3f0d1","modified":1525656044198},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1525656044198},{"_id":"themes/hexo-theme-next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1525656044198},{"_id":"themes/hexo-theme-next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1525656044198},{"_id":"themes/hexo-theme-next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1525656044198},{"_id":"themes/hexo-theme-next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1525656044201},{"_id":"themes/hexo-theme-next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1525656044206},{"_id":"themes/hexo-theme-next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1525656044209},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"2915df7152ea095a6290ef69157fd67669e0e793","modified":1525656044210},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1525656044210},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/mobile.styl","hash":"86b6fd7f1b1be3ae98f8af6b23a6b1299c670ce9","modified":1525656044210},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1525656044211},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1525656044211},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1525656044211},{"_id":"themes/hexo-theme-next/source/css/_schemes/Gemini/index.styl","hash":"bc8c388553bbcf95897459a466ba35bffd5ec5f0","modified":1525656044213},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1525656044213},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1525656044214},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1525656044214},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1525656044214},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1525656044214},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1525656044214},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1525656044215},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1525656044216},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1525656044216},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1525656044216},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1525656044216},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1525656044217},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1525656044217},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1525656044217},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1525656044217},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1525656044217},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e3e23751d4ad24e8714b425d768cf68e37de7ded","modified":1525656044218},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1525656044218},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1525656044223},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1525656044225},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1525656044226},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1525656044227},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1525656044230},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1525656044231},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1525656044231},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1525656044231},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1525656044231},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1525656044231},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1525656044233},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1525656044234},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1525656044235},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1525656044236},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1525656044236},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1525656044238},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1525656044238},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1525656044238},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1525656044260},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1525656044260},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1525656044226},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1525656044246},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1525656044246},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1525656044263},{"_id":"themes/hexo-theme-next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1525656044199},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1525656044199},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1525656044199},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1525656044199},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1525656044199},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1525656044199},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1525656044200},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/highlight.styl","hash":"740d37f428b8f4574a76fc95cc25e50e0565f45e","modified":1525656044200},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1525656044200},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1525656044200},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1525656044200},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1525656044201},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1525656044201},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1525656044201},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1525656044201},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1525656044201},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1525656044202},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1525656044202},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-expand.styl","hash":"88c7d75646b66b168213190ee4cd874609afd5e3","modified":1525656044202},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1525656044202},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-meta.styl","hash":"ed88c8b51d0517759c777e71a6bfbe2907bcd994","modified":1525656044202},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1525656044202},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"ee554b1031ef0070a5916477939021800e3c9d27","modified":1525656044203},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1525656044203},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1525656044203},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1525656044203},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1525656044203},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-widgets.styl","hash":"08a500b2984f109b751f3697ca33172d1340591a","modified":1525656044204},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-wordcount.styl","hash":"4fda5d38c6c8d910e3bf5c74a48a8d4a3f3dc73d","modified":1525656044204},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post.styl","hash":"51eca243220cf57133a4becae9b78514bcfdc723","modified":1525656044204},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"65a64d5662637b66e2f039a5f58217afe7a6e800","modified":1525656044204},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1525656044204},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"5f6ea57aabfa30a437059bf8352f1ad829dbd4ff","modified":1525656044204},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1525656044205},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1525656044205},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1525656044205},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"77c92a449ce84d558d26d052681f2e0dd77c70c9","modified":1525656044205},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1525656044205},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar.styl","hash":"57d2c8a060f5e4e1a0aef9aae11a0016cf7ac5ba","modified":1525656044206},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1525656044206},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1525656044206},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1525656044206},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1525656044206},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1525656044207},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1525656044207},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note-modern.styl","hash":"45df0cf4c97b47e05573bcd41028ee50f3fdf432","modified":1525656044207},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1525656044207},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1525656044207},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1525656044207},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1525656044208},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1525656044208},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1525656044208},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1525656044208},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1525656044209},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1525656044209},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1525656044209},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/third-party.styl","hash":"aeff0e6e23725e8baea27c890ccbbf466024f767","modified":1525656044209},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1525656044215},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1525656044215},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1525656044217},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1525656044224},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1525656044225},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1525656044225},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1525656044225},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1525656044232},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1525656044232},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1525656044232},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1525656044232},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1525656044233},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1525656044233},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1525656044239},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1525656044241},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1525656044246},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1525656044229},{"_id":"themes/hexo-theme-next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1525656044259},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1525656044244},{"_id":"public/atom.xml","hash":"1eb001d7f5af4ff7ea3c58c33baea7263aa492a5","modified":1526373875065},{"_id":"public/sitemap.xml","hash":"ee247fa52ee6f30957e81077a08e05177c823a8c","modified":1526373875075},{"_id":"public/about/index.html","hash":"4591018c5fdc5ac51484f23b0a6e6c27631f209d","modified":1526373875096},{"_id":"public/articles/index.html","hash":"1f0009dfbeda0caecdda9b270f2c32a5f6f50e4f","modified":1526373875096},{"_id":"public/categories/index.html","hash":"94d0cf90261907013b5c1355cb648e9157fac407","modified":1526373875096},{"_id":"public/tags/index.html","hash":"cd629adb49271c0894850a30c7aeac298d190390","modified":1526373875096},{"_id":"public/archives/2017/index.html","hash":"2ec1e07303f0ee3805f7181d46a390d091c37f48","modified":1526373875096},{"_id":"public/archives/2017/12/index.html","hash":"7324b0a759048407390b6f443d91be1fc1c75ce3","modified":1526373875096},{"_id":"public/archives/2018/01/index.html","hash":"1e5cda7759708dd893e19af467c9d4d98ff0e792","modified":1526373875096},{"_id":"public/archives/2018/02/index.html","hash":"35e37a50b070a239605f9e9e581665d106901c0b","modified":1526373875096},{"_id":"public/archives/2018/03/index.html","hash":"6b861bed4ef55a54508df04ad349ce7b016dca8c","modified":1526373875097},{"_id":"public/archives/2018/04/index.html","hash":"b88658085c774420844dd0eddc688ccfcb5fcb0f","modified":1526373875097},{"_id":"public/archives/2018/05/index.html","hash":"84925470ca366bfdffeb01421b8cffe1eb5628b8","modified":1526373875097},{"_id":"public/categories/android学习记录/index.html","hash":"a70e64bf3807bc6570490838c8baf0d10941ea49","modified":1526373875097},{"_id":"public/categories/源码解析/index.html","hash":"186dd306e065605b4c30ed9ff044c157abef2e09","modified":1526373875097},{"_id":"public/categories/日常开发踩坑记录/index.html","hash":"a12532eb4bd79c395fd12907bfb5ec4e9e36f23b","modified":1526373875097},{"_id":"public/categories/java/index.html","hash":"40944fde95c381313ee000bc640cb470655b1d56","modified":1526373875097},{"_id":"public/categories/android学习记录/源码解析/index.html","hash":"f20a7ae009113ee9f30e019ca8a7a49148382172","modified":1526373875097},{"_id":"public/tags/objectbox/index.html","hash":"a697a696e98063ae5bb7aea25e01fa771b3345b8","modified":1526373875097},{"_id":"public/tags/gradle/index.html","hash":"8de655302c161ed2714db8a0e12d72755a35fe1e","modified":1526373875097},{"_id":"public/tags/java/index.html","hash":"301741ec6e2e82bc92e72dd447420ff4378ff73b","modified":1526373875097},{"_id":"public/tags/jvm/index.html","hash":"dfdd8147126e03a9bdd662787fd012bc6d5eb7db","modified":1526373875097},{"_id":"public/tags/glide/index.html","hash":"3a54d16e52667698e263e86fdf4ff0781c7f9e1e","modified":1526373875097},{"_id":"public/tags/rxjava2/index.html","hash":"b099d8f2a47e618a13201174688987e71f08f0c8","modified":1526373875097},{"_id":"public/2018/05/15/记录一次Gradle的踩坑/index.html","hash":"81cf78cc4be3ca06a97dff87b6e83a0fb3fd5bf8","modified":1526373875097},{"_id":"public/2018/04/26/ArrayList源码解析/index.html","hash":"ae478bdfdc3e987e347caf2acec7cd0b4a7c332d","modified":1526373875098},{"_id":"public/2018/03/30/EventBus源码解析/index.html","hash":"bd0e1be0dbb0b4582b51ea3ee4727395353d30d9","modified":1526373875098},{"_id":"public/2018/02/08/RxJava2源码解析2/index.html","hash":"e827f7a3c280765ebe1ad78b0c9be7a35b41d40a","modified":1526373875098},{"_id":"public/2018/02/07/RxJava2源码解析1/index.html","hash":"0e97d8f604b13d1803285a0f648bf133905c291e","modified":1526373875098},{"_id":"public/2018/02/02/HashMap源码解析1/index.html","hash":"0426a07e2f4f36150c6f0d1f5ef435f3ae4f1a88","modified":1526373875098},{"_id":"public/2018/01/31/LruCache解析/index.html","hash":"d2eaadb54164627d8edaf92799a88f8a5a2f30de","modified":1526373875098},{"_id":"public/2018/01/12/谈谈GC和引用/index.html","hash":"310880ffeaf72a6fc0720c216d9053afa272c195","modified":1526373875098},{"_id":"public/2017/12/26/Enum的正确使用方式/index.html","hash":"164c3f49c80c64e666f39ebf4a5ce51e5a437aed","modified":1526373875098},{"_id":"public/2017/12/22/Glide源码解析1/index.html","hash":"7a46d1f1769a2e76d6f09920b60c6be8e5f267c3","modified":1526373875098},{"_id":"public/2017/12/19/基于as3.0 多aar打包发布/index.html","hash":"df7a0c36ad702dd3cf44499d01c02d0a49edd17b","modified":1526373875098},{"_id":"public/2017/12/19/ObjectBox使用说明/index.html","hash":"91710fbe8f4fc71abb8dbd88d3abbbaa32d2513e","modified":1526373875098},{"_id":"public/archives/index.html","hash":"7a45bb7dd2b2f0dfad3a9eec9d8136bf7f6b9343","modified":1526373875098},{"_id":"public/archives/2018/index.html","hash":"993e9adff701641c30a4adadf58e399d7eeb41a8","modified":1526373875099},{"_id":"public/index.html","hash":"aa1aaf96e4a9aa508fb9bdf3220e9bc029618761","modified":1526373875099},{"_id":"public/page/2/index.html","hash":"04adb21e31b23193f679556dcfff848a683e05da","modified":1526373875099},{"_id":"public/tags/android/index.html","hash":"2039985e38fba49454e65f266ff9a2c0586722e0","modified":1526373875099},{"_id":"public/tags/源码解析/index.html","hash":"05b6290e70f38829abf4679e8e431610a16f7b4e","modified":1526373875099},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1526373875106},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1526373875106},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1526373875106},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1526373875107},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1526373875107},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1526373875107},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1526373875107},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1526373875107},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1526373875107},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1526373875107},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1526373875107},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1526373875107},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1526373875107},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1526373875107},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1526373875107},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1526373875107},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1526373875107},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1526373875107},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1526373875108},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1526373875108},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1526373875108},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1526373875108},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1526373875108},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1526373875108},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1526373875108},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1526373875108},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1526373875108},{"_id":"public/2017/12/19/基于as3.0 多aar打包发布/demopic.png","hash":"e4c624d006f5175998336f58677f815a12a665d4","modified":1526373875108},{"_id":"public/2018/01/12/谈谈GC和引用/gc.png","hash":"61470a0acc9eda5281d68579701600200e7171a6","modified":1526373875108},{"_id":"public/2018/02/07/RxJava2源码解析1/rxjava实现原理.jpg","hash":"5704e8dbad45c042049d4da9dc04177858b06c1e","modified":1526373875108},{"_id":"public/2017/12/22/Glide源码解析1/decodeJob流程图.png","hash":"94e8007884a6c7665346a2b4ce8d3f337ed25643","modified":1526373875108},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1526373875617},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1526373875620},{"_id":"public/2018/05/15/记录一次Gradle的踩坑/Gradle执行时序.png","hash":"86d3af61eaf327aa2d0860abf7ee7b41b6a3ad9f","modified":1526373875620},{"_id":"public/2018/02/02/HashMap源码解析1/put.jpg","hash":"9db130504f10a1da8867c3f48e95ef44d1529901","modified":1526373875620},{"_id":"public/2017/12/22/Glide源码解析1/glide_load时序图.png","hash":"e8d305accaf9a949f5859ed55ef15212fc640c06","modified":1526373875620},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1526373875629},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1526373875629},{"_id":"public/js/src/bootstrap.js","hash":"6117f97b4984b8e33f21c726132da64ba678e4ed","modified":1526373875629},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1526373875629},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1526373875629},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1526373875630},{"_id":"public/js/src/post-details.js","hash":"0693695a9512641daff63d99da772625a058ab18","modified":1526373875630},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1526373875630},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1526373875630},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1526373875630},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1526373875630},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1526373875630},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1526373875630},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1526373875630},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1526373875630},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1526373875630},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1526373875630},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1526373875630},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1526373875630},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1526373875630},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1526373875630},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1526373875631},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1526373875631},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1526373875631},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1526373875631},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1526373875631},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1526373875631},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1526373875631},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1526373875631},{"_id":"public/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1526373875632},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1526373875632},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1526373875632},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1526373875632},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1526373875632},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1526373875632},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1526373875632},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1526373875632},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1526373875632},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1526373875632},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1526373875632},{"_id":"public/css/main.css","hash":"027e41def897390ece643419d66158045e495ecc","modified":1526373875633},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1526373875633},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1526373875633},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1526373875633},{"_id":"public/js/src/motion.js","hash":"dc0365b2fb315a8b43d3ef19b59d3a82a366fcc1","modified":1526373875643},{"_id":"public/js/src/utils.js","hash":"2917c39c75b14b6dab7e1c46ab4d87b4df9fcd5d","modified":1526373875643},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1526373875643},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1526373875644},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1526373875644},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1526373875644},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1526373875644},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1526373875644},{"_id":"public/images/avatar.png","hash":"e236f5447b379b018c625567084ce85658277e00","modified":1526373875644},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1526373875651},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1526373875662},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1526373875662},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1526373875682},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1526373875682},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1526373875683},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1526373875683},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1526373875716},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1526373875716},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1526373875717},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1526373875717},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1526373875735},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1526373875735},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1526373875744},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1526373875783},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1526373875787},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1526373875793},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1526373875845},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1526373875849}],"Category":[{"name":"android学习记录","_id":"cjh7fldi200048os6ehph868y"},{"name":"源码解析","_id":"cjh7fldi9000a8os6a0avslaj"},{"name":"日常开发踩坑记录","_id":"cjh7fldig000i8os6lt3w1zhz"},{"name":"Java","_id":"cjh7fldii000p8os6o3d0j9ei"},{"name":"源码解析","parent":"cjh7fldi200048os6ehph868y","_id":"cjh7fldnh001a8os6xyzldvde"}],"Data":[],"Page":[{"title":"关于","date":"2017-12-19T02:49:32.000Z","comments":0,"_content":"","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2017-12-19 10:49:32\ncomments: false\n---\n","updated":"2018-05-03T09:24:18.000Z","path":"about/index.html","layout":"page","_id":"cjh7fldhy00018os6xhcegi5r","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Articles","date":"2017-12-19T02:47:25.000Z","comments":0,"_content":"","source":"articles/index.md","raw":"---\ntitle: Articles\ndate: 2017-12-19 10:47:25\ncomments: false\n---\n","updated":"2018-05-03T09:24:18.000Z","path":"articles/index.html","layout":"page","_id":"cjh7fldi000038os6bz8mf7x7","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分类","date":"2017-12-22T11:36:02.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2017-12-22 19:36:02\ntype: \"categories\"\ncomments: false\n---\n","updated":"2018-05-03T09:24:18.000Z","path":"categories/index.html","layout":"page","_id":"cjh7fldi500078os6urabubpa","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2017-12-19T08:10:18.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2017-12-19 16:10:18\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-05-03T09:24:18.000Z","path":"tags/index.html","layout":"page","_id":"cjh7fldna00158os68miwslu6","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Enum的正确使用方式","date":"2017-12-25T16:00:00.000Z","_content":"## 前言\n\n看到目前项目里用到蛮多枚举, 才有了这篇小文章分享\n\n## 为什么使用Enum\n\njava中的Enum是包含固定常量集的数据类型.当我们需要预定义一组代表某种数据的值时一般都会使用枚举, 而当要保证类型安全时, 我们经常会使用Enum。\n\n比如, 当我们要保证常量使用正常时, 我们经常使用Enum在编译时校验确保类型安全\n<!-- more -->\n\n## 使用Enum的缺点\n\n在[Android开发者官网](https://developer.android.com/topic/performance/memory.html?hl=zh-cn)上, 有这样一段话\n\n> enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.\n\nEnum中的每个值都是一个对象,每个声明都将使用一些运行时内存来简单引用该对象,所以Enum相较于static int会`占用更多的内存`.\n\n另外添加单个Enum将`增加最终DEX文件的大小`（是static int的**13**倍）.\n\n## 解决方案\n\nGoogle提供了[注解库](https://developer.android.com/studio/write/annotations.html#enum-annotations)通过`Typedef`协助我们解决了Enum的问题,它可以确保特定参数, 返回值或字段引用特定的常量集,还可以完成代码以自动提供允许的常量.\n\n我们可以通过使用`@IntDef`和`@StringDef`来帮助我们在编译时检查像Enum这项的变量赋值.\n\n## 使用姿势\n1. 首先我们需要依赖注解库\n``` groovy\ndependencies {compile 'com.android.support:support-annotations:24.2.0'}\n```\n2. 直接上代码了, 因为还是蛮简单的\n``` java\npublic class Person {\n        public static final int MALE = 0;\n        public static final int FEMALE = 1;\n        private  int sex;\n        public String getSexValue(){\n            if(MALE == sex){\n                return \"男\";\n            }else if(FEMALE == sex){\n                return \"女\";\n            }\n            return \"\";\n        }\n        public void setSex(@sexDef int sex) {\n            this.sex = sex;\n        }\n        //  定义该注解被保留的时间长短\n        //  RetentionPolicy.CLASS      注解被保留到class文件, 但jvm加载class文件时候被遗弃, 这是默认生命周期; 用于在编译时进行一些预处理操作, 比如生成一些辅助代码(ButterKnife)\n        //  RetentionPolicy.RUNTIME    注解不仅被保存到class文件中, jvm加载class文件之后, 仍然存在;用于在运行时去动态获取注解信息\n        //  RetentionPolicy.SOURCE      注解只保留在源文件, 当Java文件编译成class文件的时候, 注解被遗弃; 用于做一些检查性操作\n        @Retention(RetentionPolicy.SOURCE)\n        //  使用@IntDef定义声明常量作为枚举\n        @IntDef({MALE, FEMALE})\n        //  使用@interface声明新的枚举注解类型\n        public @interface sexDef{}\n    }\n```\n3. 当我们调用setSex设置性别的时候, 如果输入非指定类型, 则编译不会通过\n\n## 总结\n\n与普通static常量相比, Enum的使用至少为整个apk添加至少两倍以上的字节数，并且使用5到10倍的RAM内存。所以建议尽量避免使用Enum, 当需要使用上述特性时,建议以@IntDef 或 @StringDef 替代使用。\n\n更多的可以看看[The price of ENUMs][https://www.youtube.com/watch?v=Hzs6OBcvNQE&feature=youtu.be]视频, 需科学上网\n","source":"_posts/Enum的正确使用方式.md","raw":"title: Enum的正确使用方式\ndate: 2017-12-26 00:00:00\ncategories:\n- android学习记录\ntags:\n- android\n---\n## 前言\n\n看到目前项目里用到蛮多枚举, 才有了这篇小文章分享\n\n## 为什么使用Enum\n\njava中的Enum是包含固定常量集的数据类型.当我们需要预定义一组代表某种数据的值时一般都会使用枚举, 而当要保证类型安全时, 我们经常会使用Enum。\n\n比如, 当我们要保证常量使用正常时, 我们经常使用Enum在编译时校验确保类型安全\n<!-- more -->\n\n## 使用Enum的缺点\n\n在[Android开发者官网](https://developer.android.com/topic/performance/memory.html?hl=zh-cn)上, 有这样一段话\n\n> enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.\n\nEnum中的每个值都是一个对象,每个声明都将使用一些运行时内存来简单引用该对象,所以Enum相较于static int会`占用更多的内存`.\n\n另外添加单个Enum将`增加最终DEX文件的大小`（是static int的**13**倍）.\n\n## 解决方案\n\nGoogle提供了[注解库](https://developer.android.com/studio/write/annotations.html#enum-annotations)通过`Typedef`协助我们解决了Enum的问题,它可以确保特定参数, 返回值或字段引用特定的常量集,还可以完成代码以自动提供允许的常量.\n\n我们可以通过使用`@IntDef`和`@StringDef`来帮助我们在编译时检查像Enum这项的变量赋值.\n\n## 使用姿势\n1. 首先我们需要依赖注解库\n``` groovy\ndependencies {compile 'com.android.support:support-annotations:24.2.0'}\n```\n2. 直接上代码了, 因为还是蛮简单的\n``` java\npublic class Person {\n        public static final int MALE = 0;\n        public static final int FEMALE = 1;\n        private  int sex;\n        public String getSexValue(){\n            if(MALE == sex){\n                return \"男\";\n            }else if(FEMALE == sex){\n                return \"女\";\n            }\n            return \"\";\n        }\n        public void setSex(@sexDef int sex) {\n            this.sex = sex;\n        }\n        //  定义该注解被保留的时间长短\n        //  RetentionPolicy.CLASS      注解被保留到class文件, 但jvm加载class文件时候被遗弃, 这是默认生命周期; 用于在编译时进行一些预处理操作, 比如生成一些辅助代码(ButterKnife)\n        //  RetentionPolicy.RUNTIME    注解不仅被保存到class文件中, jvm加载class文件之后, 仍然存在;用于在运行时去动态获取注解信息\n        //  RetentionPolicy.SOURCE      注解只保留在源文件, 当Java文件编译成class文件的时候, 注解被遗弃; 用于做一些检查性操作\n        @Retention(RetentionPolicy.SOURCE)\n        //  使用@IntDef定义声明常量作为枚举\n        @IntDef({MALE, FEMALE})\n        //  使用@interface声明新的枚举注解类型\n        public @interface sexDef{}\n    }\n```\n3. 当我们调用setSex设置性别的时候, 如果输入非指定类型, 则编译不会通过\n\n## 总结\n\n与普通static常量相比, Enum的使用至少为整个apk添加至少两倍以上的字节数，并且使用5到10倍的RAM内存。所以建议尽量避免使用Enum, 当需要使用上述特性时,建议以@IntDef 或 @StringDef 替代使用。\n\n更多的可以看看[The price of ENUMs][https://www.youtube.com/watch?v=Hzs6OBcvNQE&feature=youtu.be]视频, 需科学上网\n","slug":"Enum的正确使用方式","published":1,"updated":"2018-05-07T02:02:07.486Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh7fldhs00008os6cgwhvl8a","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>看到目前项目里用到蛮多枚举, 才有了这篇小文章分享</p>\n<h2 id=\"为什么使用Enum\"><a href=\"#为什么使用Enum\" class=\"headerlink\" title=\"为什么使用Enum\"></a>为什么使用Enum</h2><p>java中的Enum是包含固定常量集的数据类型.当我们需要预定义一组代表某种数据的值时一般都会使用枚举, 而当要保证类型安全时, 我们经常会使用Enum。</p>\n<p>比如, 当我们要保证常量使用正常时, 我们经常使用Enum在编译时校验确保类型安全<br><a id=\"more\"></a></p>\n<h2 id=\"使用Enum的缺点\"><a href=\"#使用Enum的缺点\" class=\"headerlink\" title=\"使用Enum的缺点\"></a>使用Enum的缺点</h2><p>在<a href=\"https://developer.android.com/topic/performance/memory.html?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">Android开发者官网</a>上, 有这样一段话</p>\n<blockquote>\n<p>enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.</p>\n</blockquote>\n<p>Enum中的每个值都是一个对象,每个声明都将使用一些运行时内存来简单引用该对象,所以Enum相较于static int会<code>占用更多的内存</code>.</p>\n<p>另外添加单个Enum将<code>增加最终DEX文件的大小</code>（是static int的<strong>13</strong>倍）.</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>Google提供了<a href=\"https://developer.android.com/studio/write/annotations.html#enum-annotations\" target=\"_blank\" rel=\"noopener\">注解库</a>通过<code>Typedef</code>协助我们解决了Enum的问题,它可以确保特定参数, 返回值或字段引用特定的常量集,还可以完成代码以自动提供允许的常量.</p>\n<p>我们可以通过使用<code>@IntDef</code>和<code>@StringDef</code>来帮助我们在编译时检查像Enum这项的变量赋值.</p>\n<h2 id=\"使用姿势\"><a href=\"#使用姿势\" class=\"headerlink\" title=\"使用姿势\"></a>使用姿势</h2><ol>\n<li><p>首先我们需要依赖注解库</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;compile <span class=\"string\">'com.android.support:support-annotations:24.2.0'</span>&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>直接上代码了, 因为还是蛮简单的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MALE = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FEMALE = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">private</span>  <span class=\"keyword\">int</span> sex;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getSexValue</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(MALE == sex)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"男\"</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(FEMALE == sex)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"女\"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSex</span><span class=\"params\">(@sexDef <span class=\"keyword\">int</span> sex)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.sex = sex;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//  定义该注解被保留的时间长短</span></span><br><span class=\"line\">        <span class=\"comment\">//  RetentionPolicy.CLASS      注解被保留到class文件, 但jvm加载class文件时候被遗弃, 这是默认生命周期; 用于在编译时进行一些预处理操作, 比如生成一些辅助代码(ButterKnife)</span></span><br><span class=\"line\">        <span class=\"comment\">//  RetentionPolicy.RUNTIME    注解不仅被保存到class文件中, jvm加载class文件之后, 仍然存在;用于在运行时去动态获取注解信息</span></span><br><span class=\"line\">        <span class=\"comment\">//  RetentionPolicy.SOURCE      注解只保留在源文件, 当Java文件编译成class文件的时候, 注解被遗弃; 用于做一些检查性操作</span></span><br><span class=\"line\">        <span class=\"meta\">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class=\"line\">        <span class=\"comment\">//  使用@IntDef定义声明常量作为枚举</span></span><br><span class=\"line\">        <span class=\"meta\">@IntDef</span>(&#123;MALE, FEMALE&#125;)</span><br><span class=\"line\">        <span class=\"comment\">//  使用@interface声明新的枚举注解类型</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> sexDef&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>当我们调用setSex设置性别的时候, 如果输入非指定类型, 则编译不会通过</p>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>与普通static常量相比, Enum的使用至少为整个apk添加至少两倍以上的字节数，并且使用5到10倍的RAM内存。所以建议尽量避免使用Enum, 当需要使用上述特性时,建议以@IntDef 或 @StringDef 替代使用。</p>\n<p>更多的可以看看[The price of ENUMs][<a href=\"https://www.youtube.com/watch?v=Hzs6OBcvNQE&amp;feature=youtu.be]视频\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=Hzs6OBcvNQE&amp;feature=youtu.be]视频</a>, 需科学上网</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>看到目前项目里用到蛮多枚举, 才有了这篇小文章分享</p>\n<h2 id=\"为什么使用Enum\"><a href=\"#为什么使用Enum\" class=\"headerlink\" title=\"为什么使用Enum\"></a>为什么使用Enum</h2><p>java中的Enum是包含固定常量集的数据类型.当我们需要预定义一组代表某种数据的值时一般都会使用枚举, 而当要保证类型安全时, 我们经常会使用Enum。</p>\n<p>比如, 当我们要保证常量使用正常时, 我们经常使用Enum在编译时校验确保类型安全<br>","more":"</p>\n<h2 id=\"使用Enum的缺点\"><a href=\"#使用Enum的缺点\" class=\"headerlink\" title=\"使用Enum的缺点\"></a>使用Enum的缺点</h2><p>在<a href=\"https://developer.android.com/topic/performance/memory.html?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">Android开发者官网</a>上, 有这样一段话</p>\n<blockquote>\n<p>enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.</p>\n</blockquote>\n<p>Enum中的每个值都是一个对象,每个声明都将使用一些运行时内存来简单引用该对象,所以Enum相较于static int会<code>占用更多的内存</code>.</p>\n<p>另外添加单个Enum将<code>增加最终DEX文件的大小</code>（是static int的<strong>13</strong>倍）.</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>Google提供了<a href=\"https://developer.android.com/studio/write/annotations.html#enum-annotations\" target=\"_blank\" rel=\"noopener\">注解库</a>通过<code>Typedef</code>协助我们解决了Enum的问题,它可以确保特定参数, 返回值或字段引用特定的常量集,还可以完成代码以自动提供允许的常量.</p>\n<p>我们可以通过使用<code>@IntDef</code>和<code>@StringDef</code>来帮助我们在编译时检查像Enum这项的变量赋值.</p>\n<h2 id=\"使用姿势\"><a href=\"#使用姿势\" class=\"headerlink\" title=\"使用姿势\"></a>使用姿势</h2><ol>\n<li><p>首先我们需要依赖注解库</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;compile <span class=\"string\">'com.android.support:support-annotations:24.2.0'</span>&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>直接上代码了, 因为还是蛮简单的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MALE = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FEMALE = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">private</span>  <span class=\"keyword\">int</span> sex;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getSexValue</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(MALE == sex)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"男\"</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(FEMALE == sex)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"女\"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSex</span><span class=\"params\">(@sexDef <span class=\"keyword\">int</span> sex)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.sex = sex;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//  定义该注解被保留的时间长短</span></span><br><span class=\"line\">        <span class=\"comment\">//  RetentionPolicy.CLASS      注解被保留到class文件, 但jvm加载class文件时候被遗弃, 这是默认生命周期; 用于在编译时进行一些预处理操作, 比如生成一些辅助代码(ButterKnife)</span></span><br><span class=\"line\">        <span class=\"comment\">//  RetentionPolicy.RUNTIME    注解不仅被保存到class文件中, jvm加载class文件之后, 仍然存在;用于在运行时去动态获取注解信息</span></span><br><span class=\"line\">        <span class=\"comment\">//  RetentionPolicy.SOURCE      注解只保留在源文件, 当Java文件编译成class文件的时候, 注解被遗弃; 用于做一些检查性操作</span></span><br><span class=\"line\">        <span class=\"meta\">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class=\"line\">        <span class=\"comment\">//  使用@IntDef定义声明常量作为枚举</span></span><br><span class=\"line\">        <span class=\"meta\">@IntDef</span>(&#123;MALE, FEMALE&#125;)</span><br><span class=\"line\">        <span class=\"comment\">//  使用@interface声明新的枚举注解类型</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> sexDef&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>当我们调用setSex设置性别的时候, 如果输入非指定类型, 则编译不会通过</p>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>与普通static常量相比, Enum的使用至少为整个apk添加至少两倍以上的字节数，并且使用5到10倍的RAM内存。所以建议尽量避免使用Enum, 当需要使用上述特性时,建议以@IntDef 或 @StringDef 替代使用。</p>\n<p>更多的可以看看[The price of ENUMs][<a href=\"https://www.youtube.com/watch?v=Hzs6OBcvNQE&amp;feature=youtu.be]视频\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=Hzs6OBcvNQE&amp;feature=youtu.be]视频</a>, 需科学上网</p>"},{"title":"LruCache解析","date":"2018-01-30T16:00:00.000Z","_content":"## 前言\n在学习`Glide`的时候, 我们会看到Glide的`二级缓存`, 分别分为`内存缓存`和`磁盘缓存`, 而不论哪种缓存都使用到了`Lru`算法, 本篇主要看一下Android里的`LruCache`的实现\n<!-- more -->\n## Lrucache实现原理\n以v4包的LruCahce类源码为准, 我们先看下他的构造函数\n``` java\npublic LruCache(int maxSize) {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize <= 0\");\n        }\n        this.maxSize = maxSize;\n        this.map = new LinkedHashMap<K, V>(0, 0.75f, true);\n    }\n```\n主要关注的是,LruCache内部通过`LinkedHashMap`用来管理缓存列表, `LinkedHashMap`是一个由数组+双向链表的数据结构实现的(我们以api26代码为准)\n``` java\n/**\n     * Constructs a new {@code LinkedHashMap} instance with the specified\n     * capacity, load factor and a flag specifying the ordering behavior.\n     *\n     * @param initialCapacity\n     *            the initial capacity of this hash map.\n     * @param loadFactor\n     *            the initial load factor.\n     * @param accessOrder\n     *            {@code true} if the ordering should be done based on the last\n     *            access (from least-recently accessed to most-recently\n     *            accessed), and {@code false} if the ordering should be the\n     *            order in which the entries were inserted.\n     * @throws IllegalArgumentException\n     *             when the capacity is less than zero or the load factor is\n     *             less or equal to zero.\n     */\n    public LinkedHashMap(\n            int initialCapacity, float loadFactor, boolean accessOrder) {\n        super(initialCapacity, loadFactor);\n        init();\n        this.accessOrder = accessOrder;\n    }\n```\n它的构造函数中的accessOrder表示的是如果为`true`,则为访问顺序; 否则, 为插入顺序排序, 我们可以看下`accessOrder`的相关的处理逻辑, 当我们调用`map.get(key)`和`map.put()`的使用, 都会调用到`afterNodeAccess()`方法, 该方法的作用就是将命中获取的引用对象, 放到链表的尾部, 就是说明, `LinkedHashMap`本身每次访问读取的时候, 都会把读取到的值放在尾部, 那么越不常用的对象越会在链表的头部\n``` java\npublic V get(Object key) {\n        Node<K,V> e;\n        if ((e = getNode(hash(key), key)) == null)\n            return null;\n        if (accessOrder)\n            afterNodeAccess(e);\n        return e.value;\n    }\n```\n这一段代码的处理就是判断目标节点的前后是否有对象, 摘除出目标节点, 将其放在last\n``` java\nvoid afterNodeAccess(Node<K,V> e) { // move node to last\n        LinkedHashMapEntry<K,V> last;\n        if (accessOrder && (last = tail) != e) {\n            LinkedHashMapEntry<K,V> p =\n                (LinkedHashMapEntry<K,V>)e, b = p.before, a = p.after;\n            p.after = null;\n            if (b == null)\n                head = a;\n            else\n                b.after = a;\n            if (a != null)\n                a.before = b;\n            else\n                last = b;\n            if (last == null)\n                head = p;\n            else {\n                p.before = last;\n                last.after = p;\n            }\n            tail = p;\n            ++modCount;\n        }\n    }\n```\n我们可以由此了解到`LruCache`类是通过`LinkedHashMap`来做缓存的`Lru`(Least Recently Used)管理, 我们在来看下`LruCache`的几个主要的方法\n### get()\n``` java\npublic final V get(K key) {\n        if (key == null) {\n            throw new NullPointerException(\"key == null\");\n        }\n\n        V mapValue;\n        synchronized (this) {\n            // LinkedHashMap 的get(key)方法会重新链接排序\n            mapValue = map.get(key);\n            if (mapValue != null) {\n                // 命中次数\n                hitCount++;\n                return mapValue;\n            }\n            // 非命中次数\n            missCount++;\n        }\n\n        // create是个空方法, 可以自己实现\n        V createdValue = create(key);\n        if (createdValue == null) {\n            return null;\n        }\n\n        synchronized (this) {\n            createCount++;\n            mapValue = map.put(key, createdValue);\n\n            // 如果对应的key之前是有值, 说明是有冲突的\n            if (mapValue != null) {\n                // 有冲突的情况, 则替换为旧值\n                // There was a conflict so undo that last put\n                map.put(key, mapValue);\n            } else {\n                size += safeSizeOf(key, createdValue);\n            }\n        }\n\n        // 冲突的情况下\n        if (mapValue != null) {\n            entryRemoved(false, key, createdValue, mapValue);\n            return mapValue;\n        } else {\n            trimToSize(maxSize);\n            return createdValue;\n        }\n    }\n```\n### put()\n``` java\npublic final V put(K key, V value) {\n        if (key == null || value == null) {\n            throw new NullPointerException(\"key == null || value == null\");\n        }\n\n        V previous;\n        synchronized (this) {\n            // 缓存次数添加\n            putCount++;\n            size += safeSizeOf(key, value);\n            previous = map.put(key, value);\n            // size是缓存大小数, 如果之前对应key有缓存的情况下, 缓存大小其实是不变的, 所以要减去原来的数\n            if (previous != null) {\n                size -= safeSizeOf(key, previous);\n            }\n        }\n\n        if (previous != null) {\n            // 缓存被替换, 调用到的方法\n            entryRemoved(false, key, previous, value);\n        }\n\n        trimToSize(maxSize);\n        return previous;\n    }\n```\n### trimToSize()\n不论是`get`还是`put`还是设置最大缓存大小`resize`,我们都会调用到`trimToSize`方法, 这个方法就是用来处理当超出缓存大小要求的时候, 删除最老的缓存, 直到缓存大小低于要求\n``` java\npublic void trimToSize(int maxSize) {\n        while (true) {\n            K key;\n            V value;\n            synchronized (this) {\n                if (size < 0 || (map.isEmpty() && size != 0)) {\n                    throw new IllegalStateException(getClass().getName()\n                            + \".sizeOf() is reporting inconsistent results!\");\n                }\n\n                if (size <= maxSize || map.isEmpty()) {\n                    break;\n                }\n\n                Map.Entry<K, V> toEvict = map.entrySet().iterator().next();\n                key = toEvict.getKey();\n                value = toEvict.getValue();\n                // LinkedHashMap构造函数中的accessOrder字段为true, 表示有读取排序\n                // 从最少使用顺序排序到最多排序\n                // 所以移除第一个value, 等于是移除最少使用的缓存\n                // map存储缓存, 直接移除第一个\n                map.remove(key);\n                size -= safeSizeOf(key, value);\n                evictionCount++;\n            }\n\n            entryRemoved(true, key, value, null);\n        }\n    }\n```\n## 总结\n现在, 我们可以了解到, 真正辅助`LruCache`实现它的算法的`LinkedHashMap`, 它会以读取的顺序来做顺序排序, 最近读取的在队尾, 当我们调用`LruCache.put`的时候, 将插入元素放在`map`队尾, 然后通过调用`trimToSize`判断是否超出缓存大小, 如果超出, 则移除`map`的队首对象.当我们调用`LruCache.get`的时候, 直接读取map对应`key`的`value`, 并由于`LinkedHashMap`的内部机制, 对读取顺序重排序, 将对应的元素更新到队尾\n","source":"_posts/LruCache解析.md","raw":"title: LruCache解析\ndate: 2018-01-31 00:00:00\ncategories:\n- 源码解析\ntags:\n- android\n- 源码解析\n---\n## 前言\n在学习`Glide`的时候, 我们会看到Glide的`二级缓存`, 分别分为`内存缓存`和`磁盘缓存`, 而不论哪种缓存都使用到了`Lru`算法, 本篇主要看一下Android里的`LruCache`的实现\n<!-- more -->\n## Lrucache实现原理\n以v4包的LruCahce类源码为准, 我们先看下他的构造函数\n``` java\npublic LruCache(int maxSize) {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize <= 0\");\n        }\n        this.maxSize = maxSize;\n        this.map = new LinkedHashMap<K, V>(0, 0.75f, true);\n    }\n```\n主要关注的是,LruCache内部通过`LinkedHashMap`用来管理缓存列表, `LinkedHashMap`是一个由数组+双向链表的数据结构实现的(我们以api26代码为准)\n``` java\n/**\n     * Constructs a new {@code LinkedHashMap} instance with the specified\n     * capacity, load factor and a flag specifying the ordering behavior.\n     *\n     * @param initialCapacity\n     *            the initial capacity of this hash map.\n     * @param loadFactor\n     *            the initial load factor.\n     * @param accessOrder\n     *            {@code true} if the ordering should be done based on the last\n     *            access (from least-recently accessed to most-recently\n     *            accessed), and {@code false} if the ordering should be the\n     *            order in which the entries were inserted.\n     * @throws IllegalArgumentException\n     *             when the capacity is less than zero or the load factor is\n     *             less or equal to zero.\n     */\n    public LinkedHashMap(\n            int initialCapacity, float loadFactor, boolean accessOrder) {\n        super(initialCapacity, loadFactor);\n        init();\n        this.accessOrder = accessOrder;\n    }\n```\n它的构造函数中的accessOrder表示的是如果为`true`,则为访问顺序; 否则, 为插入顺序排序, 我们可以看下`accessOrder`的相关的处理逻辑, 当我们调用`map.get(key)`和`map.put()`的使用, 都会调用到`afterNodeAccess()`方法, 该方法的作用就是将命中获取的引用对象, 放到链表的尾部, 就是说明, `LinkedHashMap`本身每次访问读取的时候, 都会把读取到的值放在尾部, 那么越不常用的对象越会在链表的头部\n``` java\npublic V get(Object key) {\n        Node<K,V> e;\n        if ((e = getNode(hash(key), key)) == null)\n            return null;\n        if (accessOrder)\n            afterNodeAccess(e);\n        return e.value;\n    }\n```\n这一段代码的处理就是判断目标节点的前后是否有对象, 摘除出目标节点, 将其放在last\n``` java\nvoid afterNodeAccess(Node<K,V> e) { // move node to last\n        LinkedHashMapEntry<K,V> last;\n        if (accessOrder && (last = tail) != e) {\n            LinkedHashMapEntry<K,V> p =\n                (LinkedHashMapEntry<K,V>)e, b = p.before, a = p.after;\n            p.after = null;\n            if (b == null)\n                head = a;\n            else\n                b.after = a;\n            if (a != null)\n                a.before = b;\n            else\n                last = b;\n            if (last == null)\n                head = p;\n            else {\n                p.before = last;\n                last.after = p;\n            }\n            tail = p;\n            ++modCount;\n        }\n    }\n```\n我们可以由此了解到`LruCache`类是通过`LinkedHashMap`来做缓存的`Lru`(Least Recently Used)管理, 我们在来看下`LruCache`的几个主要的方法\n### get()\n``` java\npublic final V get(K key) {\n        if (key == null) {\n            throw new NullPointerException(\"key == null\");\n        }\n\n        V mapValue;\n        synchronized (this) {\n            // LinkedHashMap 的get(key)方法会重新链接排序\n            mapValue = map.get(key);\n            if (mapValue != null) {\n                // 命中次数\n                hitCount++;\n                return mapValue;\n            }\n            // 非命中次数\n            missCount++;\n        }\n\n        // create是个空方法, 可以自己实现\n        V createdValue = create(key);\n        if (createdValue == null) {\n            return null;\n        }\n\n        synchronized (this) {\n            createCount++;\n            mapValue = map.put(key, createdValue);\n\n            // 如果对应的key之前是有值, 说明是有冲突的\n            if (mapValue != null) {\n                // 有冲突的情况, 则替换为旧值\n                // There was a conflict so undo that last put\n                map.put(key, mapValue);\n            } else {\n                size += safeSizeOf(key, createdValue);\n            }\n        }\n\n        // 冲突的情况下\n        if (mapValue != null) {\n            entryRemoved(false, key, createdValue, mapValue);\n            return mapValue;\n        } else {\n            trimToSize(maxSize);\n            return createdValue;\n        }\n    }\n```\n### put()\n``` java\npublic final V put(K key, V value) {\n        if (key == null || value == null) {\n            throw new NullPointerException(\"key == null || value == null\");\n        }\n\n        V previous;\n        synchronized (this) {\n            // 缓存次数添加\n            putCount++;\n            size += safeSizeOf(key, value);\n            previous = map.put(key, value);\n            // size是缓存大小数, 如果之前对应key有缓存的情况下, 缓存大小其实是不变的, 所以要减去原来的数\n            if (previous != null) {\n                size -= safeSizeOf(key, previous);\n            }\n        }\n\n        if (previous != null) {\n            // 缓存被替换, 调用到的方法\n            entryRemoved(false, key, previous, value);\n        }\n\n        trimToSize(maxSize);\n        return previous;\n    }\n```\n### trimToSize()\n不论是`get`还是`put`还是设置最大缓存大小`resize`,我们都会调用到`trimToSize`方法, 这个方法就是用来处理当超出缓存大小要求的时候, 删除最老的缓存, 直到缓存大小低于要求\n``` java\npublic void trimToSize(int maxSize) {\n        while (true) {\n            K key;\n            V value;\n            synchronized (this) {\n                if (size < 0 || (map.isEmpty() && size != 0)) {\n                    throw new IllegalStateException(getClass().getName()\n                            + \".sizeOf() is reporting inconsistent results!\");\n                }\n\n                if (size <= maxSize || map.isEmpty()) {\n                    break;\n                }\n\n                Map.Entry<K, V> toEvict = map.entrySet().iterator().next();\n                key = toEvict.getKey();\n                value = toEvict.getValue();\n                // LinkedHashMap构造函数中的accessOrder字段为true, 表示有读取排序\n                // 从最少使用顺序排序到最多排序\n                // 所以移除第一个value, 等于是移除最少使用的缓存\n                // map存储缓存, 直接移除第一个\n                map.remove(key);\n                size -= safeSizeOf(key, value);\n                evictionCount++;\n            }\n\n            entryRemoved(true, key, value, null);\n        }\n    }\n```\n## 总结\n现在, 我们可以了解到, 真正辅助`LruCache`实现它的算法的`LinkedHashMap`, 它会以读取的顺序来做顺序排序, 最近读取的在队尾, 当我们调用`LruCache.put`的时候, 将插入元素放在`map`队尾, 然后通过调用`trimToSize`判断是否超出缓存大小, 如果超出, 则移除`map`的队首对象.当我们调用`LruCache.get`的时候, 直接读取map对应`key`的`value`, 并由于`LinkedHashMap`的内部机制, 对读取顺序重排序, 将对应的元素更新到队尾\n","slug":"LruCache解析","published":1,"updated":"2018-05-07T02:02:55.247Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh7fldhy00028os6cld9qaiu","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在学习<code>Glide</code>的时候, 我们会看到Glide的<code>二级缓存</code>, 分别分为<code>内存缓存</code>和<code>磁盘缓存</code>, 而不论哪种缓存都使用到了<code>Lru</code>算法, 本篇主要看一下Android里的<code>LruCache</code>的实现<br><a id=\"more\"></a></p>\n<h2 id=\"Lrucache实现原理\"><a href=\"#Lrucache实现原理\" class=\"headerlink\" title=\"Lrucache实现原理\"></a>Lrucache实现原理</h2><p>以v4包的LruCahce类源码为准, 我们先看下他的构造函数<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LruCache</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (maxSize &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"maxSize &lt;= 0\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.maxSize = maxSize;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.map = <span class=\"keyword\">new</span> LinkedHashMap&lt;K, V&gt;(<span class=\"number\">0</span>, <span class=\"number\">0.75f</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>主要关注的是,LruCache内部通过<code>LinkedHashMap</code>用来管理缓存列表, <code>LinkedHashMap</code>是一个由数组+双向链表的数据结构实现的(我们以api26代码为准)<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructs a new &#123;<span class=\"doctag\">@code</span> LinkedHashMap&#125; instance with the specified</span></span><br><span class=\"line\"><span class=\"comment\">     * capacity, load factor and a flag specifying the ordering behavior.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> initialCapacity</span></span><br><span class=\"line\"><span class=\"comment\">     *            the initial capacity of this hash map.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> loadFactor</span></span><br><span class=\"line\"><span class=\"comment\">     *            the initial load factor.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> accessOrder</span></span><br><span class=\"line\"><span class=\"comment\">     *            &#123;<span class=\"doctag\">@code</span> true&#125; if the ordering should be done based on the last</span></span><br><span class=\"line\"><span class=\"comment\">     *            access (from least-recently accessed to most-recently</span></span><br><span class=\"line\"><span class=\"comment\">     *            accessed), and &#123;<span class=\"doctag\">@code</span> false&#125; if the ordering should be the</span></span><br><span class=\"line\"><span class=\"comment\">     *            order in which the entries were inserted.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> IllegalArgumentException</span></span><br><span class=\"line\"><span class=\"comment\">     *             when the capacity is less than zero or the load factor is</span></span><br><span class=\"line\"><span class=\"comment\">     *             less or equal to zero.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedHashMap</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor, <span class=\"keyword\">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(initialCapacity, loadFactor);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.accessOrder = accessOrder;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>它的构造函数中的accessOrder表示的是如果为<code>true</code>,则为访问顺序; 否则, 为插入顺序排序, 我们可以看下<code>accessOrder</code>的相关的处理逻辑, 当我们调用<code>map.get(key)</code>和<code>map.put()</code>的使用, 都会调用到<code>afterNodeAccess()</code>方法, 该方法的作用就是将命中获取的引用对象, 放到链表的尾部, 就是说明, <code>LinkedHashMap</code>本身每次访问读取的时候, 都会把读取到的值放在尾部, 那么越不常用的对象越会在链表的头部<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = getNode(hash(key), key)) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (accessOrder)</span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这一段代码的处理就是判断目标节点的前后是否有对象, 摘除出目标节点, 将其放在last<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">afterNodeAccess</span><span class=\"params\">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class=\"comment\">// move node to last</span></span><br><span class=\"line\">        LinkedHashMapEntry&lt;K,V&gt; last;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class=\"line\">            LinkedHashMapEntry&lt;K,V&gt; p =</span><br><span class=\"line\">                (LinkedHashMapEntry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class=\"line\">            p.after = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (b == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                head = a;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                b.after = a;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                a.before = b;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                last = b;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (last == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                head = p;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                p.before = last;</span><br><span class=\"line\">                last.after = p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tail = p;</span><br><span class=\"line\">            ++modCount;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以由此了解到<code>LruCache</code>类是通过<code>LinkedHashMap</code>来做缓存的<code>Lru</code>(Least Recently Used)管理, 我们在来看下<code>LruCache</code>的几个主要的方法</p>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">get</span><span class=\"params\">(K key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        V mapValue;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// LinkedHashMap 的get(key)方法会重新链接排序</span></span><br><span class=\"line\">            mapValue = map.get(key);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 命中次数</span></span><br><span class=\"line\">                hitCount++;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mapValue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 非命中次数</span></span><br><span class=\"line\">            missCount++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// create是个空方法, 可以自己实现</span></span><br><span class=\"line\">        V createdValue = create(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (createdValue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            createCount++;</span><br><span class=\"line\">            mapValue = map.put(key, createdValue);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 如果对应的key之前是有值, 说明是有冲突的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 有冲突的情况, 则替换为旧值</span></span><br><span class=\"line\">                <span class=\"comment\">// There was a conflict so undo that last put</span></span><br><span class=\"line\">                map.put(key, mapValue);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                size += safeSizeOf(key, createdValue);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 冲突的情况下</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            entryRemoved(<span class=\"keyword\">false</span>, key, createdValue, mapValue);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mapValue;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            trimToSize(maxSize);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> createdValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put()\"></a>put()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span> || value == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null || value == null\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        V previous;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 缓存次数添加</span></span><br><span class=\"line\">            putCount++;</span><br><span class=\"line\">            size += safeSizeOf(key, value);</span><br><span class=\"line\">            previous = map.put(key, value);</span><br><span class=\"line\">            <span class=\"comment\">// size是缓存大小数, 如果之前对应key有缓存的情况下, 缓存大小其实是不变的, 所以要减去原来的数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                size -= safeSizeOf(key, previous);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 缓存被替换, 调用到的方法</span></span><br><span class=\"line\">            entryRemoved(<span class=\"keyword\">false</span>, key, previous, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        trimToSize(maxSize);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> previous;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"trimToSize\"><a href=\"#trimToSize\" class=\"headerlink\" title=\"trimToSize()\"></a>trimToSize()</h3><p>不论是<code>get</code>还是<code>put</code>还是设置最大缓存大小<code>resize</code>,我们都会调用到<code>trimToSize</code>方法, 这个方法就是用来处理当超出缓存大小要求的时候, 删除最老的缓存, 直到缓存大小低于要求<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trimToSize</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            K key;</span><br><span class=\"line\">            V value;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (size &lt; <span class=\"number\">0</span> || (map.isEmpty() &amp;&amp; size != <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(getClass().getName()</span><br><span class=\"line\">                            + <span class=\"string\">\".sizeOf() is reporting inconsistent results!\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();</span><br><span class=\"line\">                key = toEvict.getKey();</span><br><span class=\"line\">                value = toEvict.getValue();</span><br><span class=\"line\">                <span class=\"comment\">// LinkedHashMap构造函数中的accessOrder字段为true, 表示有读取排序</span></span><br><span class=\"line\">                <span class=\"comment\">// 从最少使用顺序排序到最多排序</span></span><br><span class=\"line\">                <span class=\"comment\">// 所以移除第一个value, 等于是移除最少使用的缓存</span></span><br><span class=\"line\">                <span class=\"comment\">// map存储缓存, 直接移除第一个</span></span><br><span class=\"line\">                map.remove(key);</span><br><span class=\"line\">                size -= safeSizeOf(key, value);</span><br><span class=\"line\">                evictionCount++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            entryRemoved(<span class=\"keyword\">true</span>, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>现在, 我们可以了解到, 真正辅助<code>LruCache</code>实现它的算法的<code>LinkedHashMap</code>, 它会以读取的顺序来做顺序排序, 最近读取的在队尾, 当我们调用<code>LruCache.put</code>的时候, 将插入元素放在<code>map</code>队尾, 然后通过调用<code>trimToSize</code>判断是否超出缓存大小, 如果超出, 则移除<code>map</code>的队首对象.当我们调用<code>LruCache.get</code>的时候, 直接读取map对应<code>key</code>的<code>value</code>, 并由于<code>LinkedHashMap</code>的内部机制, 对读取顺序重排序, 将对应的元素更新到队尾</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在学习<code>Glide</code>的时候, 我们会看到Glide的<code>二级缓存</code>, 分别分为<code>内存缓存</code>和<code>磁盘缓存</code>, 而不论哪种缓存都使用到了<code>Lru</code>算法, 本篇主要看一下Android里的<code>LruCache</code>的实现<br>","more":"</p>\n<h2 id=\"Lrucache实现原理\"><a href=\"#Lrucache实现原理\" class=\"headerlink\" title=\"Lrucache实现原理\"></a>Lrucache实现原理</h2><p>以v4包的LruCahce类源码为准, 我们先看下他的构造函数<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LruCache</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (maxSize &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"maxSize &lt;= 0\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.maxSize = maxSize;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.map = <span class=\"keyword\">new</span> LinkedHashMap&lt;K, V&gt;(<span class=\"number\">0</span>, <span class=\"number\">0.75f</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>主要关注的是,LruCache内部通过<code>LinkedHashMap</code>用来管理缓存列表, <code>LinkedHashMap</code>是一个由数组+双向链表的数据结构实现的(我们以api26代码为准)<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructs a new &#123;<span class=\"doctag\">@code</span> LinkedHashMap&#125; instance with the specified</span></span><br><span class=\"line\"><span class=\"comment\">     * capacity, load factor and a flag specifying the ordering behavior.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> initialCapacity</span></span><br><span class=\"line\"><span class=\"comment\">     *            the initial capacity of this hash map.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> loadFactor</span></span><br><span class=\"line\"><span class=\"comment\">     *            the initial load factor.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> accessOrder</span></span><br><span class=\"line\"><span class=\"comment\">     *            &#123;<span class=\"doctag\">@code</span> true&#125; if the ordering should be done based on the last</span></span><br><span class=\"line\"><span class=\"comment\">     *            access (from least-recently accessed to most-recently</span></span><br><span class=\"line\"><span class=\"comment\">     *            accessed), and &#123;<span class=\"doctag\">@code</span> false&#125; if the ordering should be the</span></span><br><span class=\"line\"><span class=\"comment\">     *            order in which the entries were inserted.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> IllegalArgumentException</span></span><br><span class=\"line\"><span class=\"comment\">     *             when the capacity is less than zero or the load factor is</span></span><br><span class=\"line\"><span class=\"comment\">     *             less or equal to zero.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedHashMap</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor, <span class=\"keyword\">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(initialCapacity, loadFactor);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.accessOrder = accessOrder;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>它的构造函数中的accessOrder表示的是如果为<code>true</code>,则为访问顺序; 否则, 为插入顺序排序, 我们可以看下<code>accessOrder</code>的相关的处理逻辑, 当我们调用<code>map.get(key)</code>和<code>map.put()</code>的使用, 都会调用到<code>afterNodeAccess()</code>方法, 该方法的作用就是将命中获取的引用对象, 放到链表的尾部, 就是说明, <code>LinkedHashMap</code>本身每次访问读取的时候, 都会把读取到的值放在尾部, 那么越不常用的对象越会在链表的头部<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = getNode(hash(key), key)) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (accessOrder)</span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这一段代码的处理就是判断目标节点的前后是否有对象, 摘除出目标节点, 将其放在last<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">afterNodeAccess</span><span class=\"params\">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class=\"comment\">// move node to last</span></span><br><span class=\"line\">        LinkedHashMapEntry&lt;K,V&gt; last;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class=\"line\">            LinkedHashMapEntry&lt;K,V&gt; p =</span><br><span class=\"line\">                (LinkedHashMapEntry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class=\"line\">            p.after = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (b == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                head = a;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                b.after = a;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                a.before = b;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                last = b;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (last == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                head = p;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                p.before = last;</span><br><span class=\"line\">                last.after = p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tail = p;</span><br><span class=\"line\">            ++modCount;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以由此了解到<code>LruCache</code>类是通过<code>LinkedHashMap</code>来做缓存的<code>Lru</code>(Least Recently Used)管理, 我们在来看下<code>LruCache</code>的几个主要的方法</p>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">get</span><span class=\"params\">(K key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        V mapValue;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// LinkedHashMap 的get(key)方法会重新链接排序</span></span><br><span class=\"line\">            mapValue = map.get(key);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 命中次数</span></span><br><span class=\"line\">                hitCount++;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mapValue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 非命中次数</span></span><br><span class=\"line\">            missCount++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// create是个空方法, 可以自己实现</span></span><br><span class=\"line\">        V createdValue = create(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (createdValue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            createCount++;</span><br><span class=\"line\">            mapValue = map.put(key, createdValue);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 如果对应的key之前是有值, 说明是有冲突的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 有冲突的情况, 则替换为旧值</span></span><br><span class=\"line\">                <span class=\"comment\">// There was a conflict so undo that last put</span></span><br><span class=\"line\">                map.put(key, mapValue);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                size += safeSizeOf(key, createdValue);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 冲突的情况下</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            entryRemoved(<span class=\"keyword\">false</span>, key, createdValue, mapValue);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mapValue;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            trimToSize(maxSize);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> createdValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put()\"></a>put()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span> || value == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null || value == null\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        V previous;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 缓存次数添加</span></span><br><span class=\"line\">            putCount++;</span><br><span class=\"line\">            size += safeSizeOf(key, value);</span><br><span class=\"line\">            previous = map.put(key, value);</span><br><span class=\"line\">            <span class=\"comment\">// size是缓存大小数, 如果之前对应key有缓存的情况下, 缓存大小其实是不变的, 所以要减去原来的数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                size -= safeSizeOf(key, previous);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 缓存被替换, 调用到的方法</span></span><br><span class=\"line\">            entryRemoved(<span class=\"keyword\">false</span>, key, previous, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        trimToSize(maxSize);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> previous;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"trimToSize\"><a href=\"#trimToSize\" class=\"headerlink\" title=\"trimToSize()\"></a>trimToSize()</h3><p>不论是<code>get</code>还是<code>put</code>还是设置最大缓存大小<code>resize</code>,我们都会调用到<code>trimToSize</code>方法, 这个方法就是用来处理当超出缓存大小要求的时候, 删除最老的缓存, 直到缓存大小低于要求<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trimToSize</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            K key;</span><br><span class=\"line\">            V value;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (size &lt; <span class=\"number\">0</span> || (map.isEmpty() &amp;&amp; size != <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(getClass().getName()</span><br><span class=\"line\">                            + <span class=\"string\">\".sizeOf() is reporting inconsistent results!\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();</span><br><span class=\"line\">                key = toEvict.getKey();</span><br><span class=\"line\">                value = toEvict.getValue();</span><br><span class=\"line\">                <span class=\"comment\">// LinkedHashMap构造函数中的accessOrder字段为true, 表示有读取排序</span></span><br><span class=\"line\">                <span class=\"comment\">// 从最少使用顺序排序到最多排序</span></span><br><span class=\"line\">                <span class=\"comment\">// 所以移除第一个value, 等于是移除最少使用的缓存</span></span><br><span class=\"line\">                <span class=\"comment\">// map存储缓存, 直接移除第一个</span></span><br><span class=\"line\">                map.remove(key);</span><br><span class=\"line\">                size -= safeSizeOf(key, value);</span><br><span class=\"line\">                evictionCount++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            entryRemoved(<span class=\"keyword\">true</span>, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>现在, 我们可以了解到, 真正辅助<code>LruCache</code>实现它的算法的<code>LinkedHashMap</code>, 它会以读取的顺序来做顺序排序, 最近读取的在队尾, 当我们调用<code>LruCache.put</code>的时候, 将插入元素放在<code>map</code>队尾, 然后通过调用<code>trimToSize</code>判断是否超出缓存大小, 如果超出, 则移除<code>map</code>的队首对象.当我们调用<code>LruCache.get</code>的时候, 直接读取map对应<code>key</code>的<code>value</code>, 并由于<code>LinkedHashMap</code>的内部机制, 对读取顺序重排序, 将对应的元素更新到队尾</p>"},{"title":"ObjectBox-Java (android)使用手册","date":"2017-12-18T16:00:00.000Z","intro":"ObjectBox使用手册翻译","_content":"## 前前言\n本篇主要是方便自己记忆所写, 基本是撸完官方文档后的笔记\n## 前言\nObjectBox是一款由greenrobot出的基于noSql的ORM数据库, 但又支持表关系的定义以及事务的处理, 另外在性能上有着非常卓越的表现\n(关于性能比较, 可以看[这篇](1)),\n同时可以接入rxJava的扩展库, 并与google最新出的框架组件(Android Architecture Components)中的LiveData结合使用, 支持Kotlin.\n目前版本更新到1.2.1\n<!-- more -->\n## 依赖\n1. 在项目根目录的gradle添加它的依赖仓库地址\n``` groovy\nbuildscript {\n    ext.objectboxVersion = '1.2.1'\n    repositories {\n        jcenter()\n        maven { url \"http://objectbox.net/beta-repo/\" }\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:2.3.3'\n        classpath \"io.objectbox:objectbox-gradle-plugin:$objectboxVersion\"\n    }\n}\nallprojects {\n    repositories {\n        jcenter()\n        maven { url \"http://objectbox.net/beta-repo/\" }\n    }\n}\n```\n2. 在应用项目模块(app module)中添加插件\n``` groovy\napply plugin: 'com.android.application'\napply plugin: 'io.objectbox'\n```\n\n## 基本使用\n1. 准备`ObjectBox`对象单例并实例化, 可以放在application的`onCreate()`中\n``` java\n// MyObjectBox类文件这时候是引用不到, 它是根据实体类自动生成(build), 用来设置BoxStore对象\nboxStore = MyObjectBox.builder().androidContext(applicationContext).build();\n```\n2. 添加一个对象类, 添加`@Entity`注解, 进行表映射\n``` java\n@Entity\npublic class User{\n    // 主键, 必须有, 并且必须是long类型\n    @Id\n    private long id;\n\n    private String userName;\n    private int userAge;\n    // 必须有\n    public User(){}\n}\n```\nP.S 这时候记得build一下, MyObjectBox就自动生成了\n3. 这时候我们就可以通过`Box<User>`对象来针对这张表做增删改查工作了\n``` java\nBox<User> userBox = boxStore.boxFor(User.class).build();\n```\n\n## 增删改查\n`Box`分别有`put` 添加or修改, `query` 查找, `remove` 移除 等开放API可调用.\n在调用`put`时, 当Entity的Id不设置, 则会自动为其赋值, 并新增数据. 当有设置Id, 并在表内有对应Id, 则会被覆盖, 相当于更新对应数据.\n另外关于`@Id`,有几点需要注意:\n- `0`和`-1(0xFFFFFFFFFFFFFFFF)`不能作为Id的值使用\n- `0` 或者`null`(如果类型是Long, 但不建议使用Long, 使用long的速度会更快)会是通知永远新增一笔新数据\n- 如果`put`一个id比当前最大id大的对象, ObjectBox可能会抛出异常\n- 如果要自己分配id, 可以使用注解`@Id(assignable = true)`\n\n相关的方法, 可以参考[JavaDoc](2)中关于`Box`和`QueryBuilder`类中的方法\n## 注解\n除了本文其他地方已提到的注解, 补充几个比较大概率会用到的, 其他的建议大家可以看看[JavaDoc][2]中的`io.objectbox.annotation`包:\n``` java\n@Entity\npublic class User{\n    @Id\n    private long id;\n\n    @Index\n    private String uid;\n    @NameInDb(\"userName\")\n    private String name;\n    @Transient\n    private boolean country;\n}\n```\n- `@Index`: 因为在ObjectBox中主键是必须设置为long类型的id, 当我们业务上需要另外主键时, 可以再标注`@Index`, 在ObjectBox中查询时根据他标注的字段来查询, 会加快查询速度\n- `@NameInDb`: 字段在数据库中的命名\n- `@Transient`: 忽略字段, 不在表中生成\n\n## 数据迁移\nObjectBox可以实现大部分的数据迁移自动化, 当我们要删除或者新增一个字段的时候, 针对数据库我们是不需要做任何操作的.\n\n但是当我们需要重命名字段名或者表名, 或者需要更改字段类型时, 我们需要使用`@Uid`通知ObjectBox\n\n下面我们会分别举两个例子:\n1. 重命名操作, 实体类重命名或者字段重命名操作流程都一样, 区别只在于是在在哪里放`@Uid`, 以实体类重命名为例:\n  - 在类名上添加`@Uid`\n  ``` java\n  @Entity\n  @Uid\n  public class User{\n      @Id\n      private long id;\n\n      private String userName;\n      private int userAge;\n\n      public User(){}\n  }\n  ```\n  - `rebuild`一下, 在`Gradle Console`中会找到下面类似一段\n  ```\n  错误: [ObjectBox] UID operations for entity \"User2\":\n   [Rename] apply the current UID using @Uid(6966387148602341622L) - [Change/reset] apply a new UID using @Uid(2383770126231565339L)\n1 个错误\n  ```\n  - copy `[Rename]`的`@Uid`值6966387148602341622L, 并针对实体类进行重命名\n  ``` java\n  @Entity\n  @Uid(6966387148602341622L)\n  public class User2{\n      @Id\n      private long id;\n\n      private String userName;\n      private int userAge;\n\n      public User2(){}\n  }\n  ```\n  - 重新编译, 就已经迁移成功, 这时候`@Uid(6966387148602341622L)`这条代码就没有用了, 相关记录会在`objectbox-models/default.json`中体现\n\n2. 变更字段类型, 要注意的是, 会导致原类型字段Column的数据会被清空, 大体流程与重命名流程大致相同, 但是赋值的`@Uid` 需要使用的是`[Change/reset]`的值, 表示是一个`新字段`.\n\nP.S 前文提到了`objectbox-models/default.json`这个JSON文件, 这个文件相当于是我们做Migration时处理的文件记录, 所以是需要加入VCS控制\n## 关系\n- 以后补充\n\n##  事务\nObjectBox的所有操作都是在事务中运行的, 只是这个对我们来说是透明的, 我们不需要关注, 但是当我们需要进行多个操作的时候, 通过显示事务来控制, 可以大大提高app的效率和一致性.\n在`BoxStore`中, 提供了四个方法来执行显示事务:\n- `runInReadTx` : 在事务中运行给定的Runnable, 不可并发处理\n- `runIxTx` : 只读事务, 可以并发处理\n- `runInTxAsync` : 在单独的线程中运行, 事务完成后会回调callback(可能为空)\n- `callInTx` : 和`runIxTx`类似, 不过允许返回值并可以抛出一个异常\n\n要注意的是, 事务的提交开销较大, 所以在使用隐式事务时, 譬如大批量调用`put`时, 我们需要统一写到一个事务里去提交\n``` java\nfor(User user: userList){\n  user.plusAge();\n  box.put(user);\n}\n```\n以上的demo我们应该优化为下面这种:\n``` java\nfor(User user: userList){\n user.plusAge();\n}\nbox.put(userList);\n```\n\n## 数据库查看\n1. 在项目app gradle文件中, 必须在`'io.objectbox'`插件apply之前依赖一下代码\n``` groovy\ndebugCompile \"io.objectbox:objectbox-android-objectbrowser:1.2.1\"\nreleaseCompile \"io.objectbox:objectbox-android:1.2.1\"\n```\n2. 清单文件申请权限\n``` java\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n```\n3. 然后在BoxStore构建`之后`, 加入以下代码\n``` java\nif(BuildConfig.DEBUG){\n            new AndroidObjectBrowser(boxStore).start(this);\n  }\n```\n\n运行后, 就可以从设备的通知栏点击进入查看数据库, 也可以通过在cmd中输入`adb forward tcp:8090 tcp:8090`, 打开浏览器, 输入http://localhost:8090/index.html 网址查看\n\n## 后记\n关于它和rxJava如何使用, 如何做数据的观测, 以及和LiveData的搭配使用, 鉴于目前篇幅过长, 而且LiveData我目前还没有玩过, 所以暂时不写. 后续可能会新补一篇.\n\n具体可以看[Demo](https://github.com/YuTianTina/DatabaseChoice)\n\n[1]:https://notes.devlabs.bg/realm-objectbox-or-room-which-one-is-for-you-3a552234fd6e\n\n[2]:http://objectbox.io/files/objectbox-java/current/\n","source":"_posts/ObjectBox使用说明.md","raw":"title: ObjectBox-Java (android)使用手册\ndate: 2017-12-19 00:00:00\nintro: ObjectBox使用手册翻译\ncategories:  \n- android学习记录\ntags:\n- android\n- ObjectBox\n---\n## 前前言\n本篇主要是方便自己记忆所写, 基本是撸完官方文档后的笔记\n## 前言\nObjectBox是一款由greenrobot出的基于noSql的ORM数据库, 但又支持表关系的定义以及事务的处理, 另外在性能上有着非常卓越的表现\n(关于性能比较, 可以看[这篇](1)),\n同时可以接入rxJava的扩展库, 并与google最新出的框架组件(Android Architecture Components)中的LiveData结合使用, 支持Kotlin.\n目前版本更新到1.2.1\n<!-- more -->\n## 依赖\n1. 在项目根目录的gradle添加它的依赖仓库地址\n``` groovy\nbuildscript {\n    ext.objectboxVersion = '1.2.1'\n    repositories {\n        jcenter()\n        maven { url \"http://objectbox.net/beta-repo/\" }\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:2.3.3'\n        classpath \"io.objectbox:objectbox-gradle-plugin:$objectboxVersion\"\n    }\n}\nallprojects {\n    repositories {\n        jcenter()\n        maven { url \"http://objectbox.net/beta-repo/\" }\n    }\n}\n```\n2. 在应用项目模块(app module)中添加插件\n``` groovy\napply plugin: 'com.android.application'\napply plugin: 'io.objectbox'\n```\n\n## 基本使用\n1. 准备`ObjectBox`对象单例并实例化, 可以放在application的`onCreate()`中\n``` java\n// MyObjectBox类文件这时候是引用不到, 它是根据实体类自动生成(build), 用来设置BoxStore对象\nboxStore = MyObjectBox.builder().androidContext(applicationContext).build();\n```\n2. 添加一个对象类, 添加`@Entity`注解, 进行表映射\n``` java\n@Entity\npublic class User{\n    // 主键, 必须有, 并且必须是long类型\n    @Id\n    private long id;\n\n    private String userName;\n    private int userAge;\n    // 必须有\n    public User(){}\n}\n```\nP.S 这时候记得build一下, MyObjectBox就自动生成了\n3. 这时候我们就可以通过`Box<User>`对象来针对这张表做增删改查工作了\n``` java\nBox<User> userBox = boxStore.boxFor(User.class).build();\n```\n\n## 增删改查\n`Box`分别有`put` 添加or修改, `query` 查找, `remove` 移除 等开放API可调用.\n在调用`put`时, 当Entity的Id不设置, 则会自动为其赋值, 并新增数据. 当有设置Id, 并在表内有对应Id, 则会被覆盖, 相当于更新对应数据.\n另外关于`@Id`,有几点需要注意:\n- `0`和`-1(0xFFFFFFFFFFFFFFFF)`不能作为Id的值使用\n- `0` 或者`null`(如果类型是Long, 但不建议使用Long, 使用long的速度会更快)会是通知永远新增一笔新数据\n- 如果`put`一个id比当前最大id大的对象, ObjectBox可能会抛出异常\n- 如果要自己分配id, 可以使用注解`@Id(assignable = true)`\n\n相关的方法, 可以参考[JavaDoc](2)中关于`Box`和`QueryBuilder`类中的方法\n## 注解\n除了本文其他地方已提到的注解, 补充几个比较大概率会用到的, 其他的建议大家可以看看[JavaDoc][2]中的`io.objectbox.annotation`包:\n``` java\n@Entity\npublic class User{\n    @Id\n    private long id;\n\n    @Index\n    private String uid;\n    @NameInDb(\"userName\")\n    private String name;\n    @Transient\n    private boolean country;\n}\n```\n- `@Index`: 因为在ObjectBox中主键是必须设置为long类型的id, 当我们业务上需要另外主键时, 可以再标注`@Index`, 在ObjectBox中查询时根据他标注的字段来查询, 会加快查询速度\n- `@NameInDb`: 字段在数据库中的命名\n- `@Transient`: 忽略字段, 不在表中生成\n\n## 数据迁移\nObjectBox可以实现大部分的数据迁移自动化, 当我们要删除或者新增一个字段的时候, 针对数据库我们是不需要做任何操作的.\n\n但是当我们需要重命名字段名或者表名, 或者需要更改字段类型时, 我们需要使用`@Uid`通知ObjectBox\n\n下面我们会分别举两个例子:\n1. 重命名操作, 实体类重命名或者字段重命名操作流程都一样, 区别只在于是在在哪里放`@Uid`, 以实体类重命名为例:\n  - 在类名上添加`@Uid`\n  ``` java\n  @Entity\n  @Uid\n  public class User{\n      @Id\n      private long id;\n\n      private String userName;\n      private int userAge;\n\n      public User(){}\n  }\n  ```\n  - `rebuild`一下, 在`Gradle Console`中会找到下面类似一段\n  ```\n  错误: [ObjectBox] UID operations for entity \"User2\":\n   [Rename] apply the current UID using @Uid(6966387148602341622L) - [Change/reset] apply a new UID using @Uid(2383770126231565339L)\n1 个错误\n  ```\n  - copy `[Rename]`的`@Uid`值6966387148602341622L, 并针对实体类进行重命名\n  ``` java\n  @Entity\n  @Uid(6966387148602341622L)\n  public class User2{\n      @Id\n      private long id;\n\n      private String userName;\n      private int userAge;\n\n      public User2(){}\n  }\n  ```\n  - 重新编译, 就已经迁移成功, 这时候`@Uid(6966387148602341622L)`这条代码就没有用了, 相关记录会在`objectbox-models/default.json`中体现\n\n2. 变更字段类型, 要注意的是, 会导致原类型字段Column的数据会被清空, 大体流程与重命名流程大致相同, 但是赋值的`@Uid` 需要使用的是`[Change/reset]`的值, 表示是一个`新字段`.\n\nP.S 前文提到了`objectbox-models/default.json`这个JSON文件, 这个文件相当于是我们做Migration时处理的文件记录, 所以是需要加入VCS控制\n## 关系\n- 以后补充\n\n##  事务\nObjectBox的所有操作都是在事务中运行的, 只是这个对我们来说是透明的, 我们不需要关注, 但是当我们需要进行多个操作的时候, 通过显示事务来控制, 可以大大提高app的效率和一致性.\n在`BoxStore`中, 提供了四个方法来执行显示事务:\n- `runInReadTx` : 在事务中运行给定的Runnable, 不可并发处理\n- `runIxTx` : 只读事务, 可以并发处理\n- `runInTxAsync` : 在单独的线程中运行, 事务完成后会回调callback(可能为空)\n- `callInTx` : 和`runIxTx`类似, 不过允许返回值并可以抛出一个异常\n\n要注意的是, 事务的提交开销较大, 所以在使用隐式事务时, 譬如大批量调用`put`时, 我们需要统一写到一个事务里去提交\n``` java\nfor(User user: userList){\n  user.plusAge();\n  box.put(user);\n}\n```\n以上的demo我们应该优化为下面这种:\n``` java\nfor(User user: userList){\n user.plusAge();\n}\nbox.put(userList);\n```\n\n## 数据库查看\n1. 在项目app gradle文件中, 必须在`'io.objectbox'`插件apply之前依赖一下代码\n``` groovy\ndebugCompile \"io.objectbox:objectbox-android-objectbrowser:1.2.1\"\nreleaseCompile \"io.objectbox:objectbox-android:1.2.1\"\n```\n2. 清单文件申请权限\n``` java\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n```\n3. 然后在BoxStore构建`之后`, 加入以下代码\n``` java\nif(BuildConfig.DEBUG){\n            new AndroidObjectBrowser(boxStore).start(this);\n  }\n```\n\n运行后, 就可以从设备的通知栏点击进入查看数据库, 也可以通过在cmd中输入`adb forward tcp:8090 tcp:8090`, 打开浏览器, 输入http://localhost:8090/index.html 网址查看\n\n## 后记\n关于它和rxJava如何使用, 如何做数据的观测, 以及和LiveData的搭配使用, 鉴于目前篇幅过长, 而且LiveData我目前还没有玩过, 所以暂时不写. 后续可能会新补一篇.\n\n具体可以看[Demo](https://github.com/YuTianTina/DatabaseChoice)\n\n[1]:https://notes.devlabs.bg/realm-objectbox-or-room-which-one-is-for-you-3a552234fd6e\n\n[2]:http://objectbox.io/files/objectbox-java/current/\n","slug":"ObjectBox使用说明","published":1,"updated":"2018-05-07T02:01:28.287Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh7fldi400068os6gyku7acv","content":"<h2 id=\"前前言\"><a href=\"#前前言\" class=\"headerlink\" title=\"前前言\"></a>前前言</h2><p>本篇主要是方便自己记忆所写, 基本是撸完官方文档后的笔记</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>ObjectBox是一款由greenrobot出的基于noSql的ORM数据库, 但又支持表关系的定义以及事务的处理, 另外在性能上有着非常卓越的表现<br>(关于性能比较, 可以看<a href=\"1\">这篇</a>),<br>同时可以接入rxJava的扩展库, 并与google最新出的框架组件(Android Architecture Components)中的LiveData结合使用, 支持Kotlin.<br>目前版本更新到1.2.1<br><a id=\"more\"></a></p>\n<h2 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h2><ol>\n<li><p>在项目根目录的gradle添加它的依赖仓库地址</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    ext.objectboxVersion = <span class=\"string\">'1.2.1'</span></span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">        maven &#123; url <span class=\"string\">\"http://objectbox.net/beta-repo/\"</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath <span class=\"string\">'com.android.tools.build:gradle:2.3.3'</span></span><br><span class=\"line\">        classpath <span class=\"string\">\"io.objectbox:objectbox-gradle-plugin:$objectboxVersion\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">allprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">        maven &#123; url <span class=\"string\">\"http://objectbox.net/beta-repo/\"</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在应用项目模块(app module)中添加插件</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'io.objectbox'</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><ol>\n<li><p>准备<code>ObjectBox</code>对象单例并实例化, 可以放在application的<code>onCreate()</code>中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MyObjectBox类文件这时候是引用不到, 它是根据实体类自动生成(build), 用来设置BoxStore对象</span></span><br><span class=\"line\">boxStore = MyObjectBox.builder().androidContext(applicationContext).build();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加一个对象类, 添加<code>@Entity</code>注解, 进行表映射</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 主键, 必须有, 并且必须是long类型</span></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> userAge;</span><br><span class=\"line\">    <span class=\"comment\">// 必须有</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>P.S 这时候记得build一下, MyObjectBox就自动生成了</p>\n<ol>\n<li>这时候我们就可以通过<code>Box&lt;User&gt;</code>对象来针对这张表做增删改查工作了<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Box&lt;User&gt; userBox = boxStore.boxFor(User.class).build();</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"增删改查\"><a href=\"#增删改查\" class=\"headerlink\" title=\"增删改查\"></a>增删改查</h2><p><code>Box</code>分别有<code>put</code> 添加or修改, <code>query</code> 查找, <code>remove</code> 移除 等开放API可调用.<br>在调用<code>put</code>时, 当Entity的Id不设置, 则会自动为其赋值, 并新增数据. 当有设置Id, 并在表内有对应Id, 则会被覆盖, 相当于更新对应数据.<br>另外关于<code>@Id</code>,有几点需要注意:</p>\n<ul>\n<li><code>0</code>和<code>-1(0xFFFFFFFFFFFFFFFF)</code>不能作为Id的值使用</li>\n<li><code>0</code> 或者<code>null</code>(如果类型是Long, 但不建议使用Long, 使用long的速度会更快)会是通知永远新增一笔新数据</li>\n<li>如果<code>put</code>一个id比当前最大id大的对象, ObjectBox可能会抛出异常</li>\n<li>如果要自己分配id, 可以使用注解<code>@Id(assignable = true)</code></li>\n</ul>\n<p>相关的方法, 可以参考<a href=\"2\">JavaDoc</a>中关于<code>Box</code>和<code>QueryBuilder</code>类中的方法</p>\n<h2 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h2><p>除了本文其他地方已提到的注解, 补充几个比较大概率会用到的, 其他的建议大家可以看看<a href=\"http://objectbox.io/files/objectbox-java/current/\" target=\"_blank\" rel=\"noopener\">JavaDoc</a>中的<code>io.objectbox.annotation</code>包:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Index</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String uid;</span><br><span class=\"line\">    <span class=\"meta\">@NameInDb</span>(<span class=\"string\">\"userName\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"meta\">@Transient</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> country;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>@Index</code>: 因为在ObjectBox中主键是必须设置为long类型的id, 当我们业务上需要另外主键时, 可以再标注<code>@Index</code>, 在ObjectBox中查询时根据他标注的字段来查询, 会加快查询速度</li>\n<li><code>@NameInDb</code>: 字段在数据库中的命名</li>\n<li><code>@Transient</code>: 忽略字段, 不在表中生成</li>\n</ul>\n<h2 id=\"数据迁移\"><a href=\"#数据迁移\" class=\"headerlink\" title=\"数据迁移\"></a>数据迁移</h2><p>ObjectBox可以实现大部分的数据迁移自动化, 当我们要删除或者新增一个字段的时候, 针对数据库我们是不需要做任何操作的.</p>\n<p>但是当我们需要重命名字段名或者表名, 或者需要更改字段类型时, 我们需要使用<code>@Uid</code>通知ObjectBox</p>\n<p>下面我们会分别举两个例子:</p>\n<ol>\n<li><p>重命名操作, 实体类重命名或者字段重命名操作流程都一样, 区别只在于是在在哪里放<code>@Uid</code>, 以实体类重命名为例:</p>\n<ul>\n<li><p>在类名上添加<code>@Uid</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Uid</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> userAge;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>rebuild</code>一下, 在<code>Gradle Console</code>中会找到下面类似一段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  错误: [ObjectBox] UID operations for entity &quot;User2&quot;:</span><br><span class=\"line\">   [Rename] apply the current UID using @Uid(6966387148602341622L) - [Change/reset] apply a new UID using @Uid(2383770126231565339L)</span><br><span class=\"line\">1 个错误</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>copy <code>[Rename]</code>的<code>@Uid</code>值6966387148602341622L, 并针对实体类进行重命名</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Uid</span>(<span class=\"number\">6966387148602341622L</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User2</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> userAge;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User2</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重新编译, 就已经迁移成功, 这时候<code>@Uid(6966387148602341622L)</code>这条代码就没有用了, 相关记录会在<code>objectbox-models/default.json</code>中体现</p>\n</li>\n</ul>\n</li>\n<li><p>变更字段类型, 要注意的是, 会导致原类型字段Column的数据会被清空, 大体流程与重命名流程大致相同, 但是赋值的<code>@Uid</code> 需要使用的是<code>[Change/reset]</code>的值, 表示是一个<code>新字段</code>.</p>\n</li>\n</ol>\n<p>P.S 前文提到了<code>objectbox-models/default.json</code>这个JSON文件, 这个文件相当于是我们做Migration时处理的文件记录, 所以是需要加入VCS控制</p>\n<h2 id=\"关系\"><a href=\"#关系\" class=\"headerlink\" title=\"关系\"></a>关系</h2><ul>\n<li>以后补充</li>\n</ul>\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><p>ObjectBox的所有操作都是在事务中运行的, 只是这个对我们来说是透明的, 我们不需要关注, 但是当我们需要进行多个操作的时候, 通过显示事务来控制, 可以大大提高app的效率和一致性.<br>在<code>BoxStore</code>中, 提供了四个方法来执行显示事务:</p>\n<ul>\n<li><code>runInReadTx</code> : 在事务中运行给定的Runnable, 不可并发处理</li>\n<li><code>runIxTx</code> : 只读事务, 可以并发处理</li>\n<li><code>runInTxAsync</code> : 在单独的线程中运行, 事务完成后会回调callback(可能为空)</li>\n<li><code>callInTx</code> : 和<code>runIxTx</code>类似, 不过允许返回值并可以抛出一个异常</li>\n</ul>\n<p>要注意的是, 事务的提交开销较大, 所以在使用隐式事务时, 譬如大批量调用<code>put</code>时, 我们需要统一写到一个事务里去提交<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(User user: userList)&#123;</span><br><span class=\"line\">  user.plusAge();</span><br><span class=\"line\">  box.put(user);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上的demo我们应该优化为下面这种:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(User user: userList)&#123;</span><br><span class=\"line\"> user.plusAge();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">box.put(userList);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数据库查看\"><a href=\"#数据库查看\" class=\"headerlink\" title=\"数据库查看\"></a>数据库查看</h2><ol>\n<li><p>在项目app gradle文件中, 必须在<code>&#39;io.objectbox&#39;</code>插件apply之前依赖一下代码</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debugCompile <span class=\"string\">\"io.objectbox:objectbox-android-objectbrowser:1.2.1\"</span></span><br><span class=\"line\">releaseCompile <span class=\"string\">\"io.objectbox:objectbox-android:1.2.1\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>清单文件申请权限</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.INTERNET\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后在BoxStore构建<code>之后</code>, 加入以下代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(BuildConfig.DEBUG)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> AndroidObjectBrowser(boxStore).start(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>运行后, 就可以从设备的通知栏点击进入查看数据库, 也可以通过在cmd中输入<code>adb forward tcp:8090 tcp:8090</code>, 打开浏览器, 输入<a href=\"http://localhost:8090/index.html\" target=\"_blank\" rel=\"noopener\">http://localhost:8090/index.html</a> 网址查看</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>关于它和rxJava如何使用, 如何做数据的观测, 以及和LiveData的搭配使用, 鉴于目前篇幅过长, 而且LiveData我目前还没有玩过, 所以暂时不写. 后续可能会新补一篇.</p>\n<p>具体可以看<a href=\"https://github.com/YuTianTina/DatabaseChoice\" target=\"_blank\" rel=\"noopener\">Demo</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前前言\"><a href=\"#前前言\" class=\"headerlink\" title=\"前前言\"></a>前前言</h2><p>本篇主要是方便自己记忆所写, 基本是撸完官方文档后的笔记</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>ObjectBox是一款由greenrobot出的基于noSql的ORM数据库, 但又支持表关系的定义以及事务的处理, 另外在性能上有着非常卓越的表现<br>(关于性能比较, 可以看<a href=\"1\">这篇</a>),<br>同时可以接入rxJava的扩展库, 并与google最新出的框架组件(Android Architecture Components)中的LiveData结合使用, 支持Kotlin.<br>目前版本更新到1.2.1<br>","more":"</p>\n<h2 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h2><ol>\n<li><p>在项目根目录的gradle添加它的依赖仓库地址</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    ext.objectboxVersion = <span class=\"string\">'1.2.1'</span></span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">        maven &#123; url <span class=\"string\">\"http://objectbox.net/beta-repo/\"</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath <span class=\"string\">'com.android.tools.build:gradle:2.3.3'</span></span><br><span class=\"line\">        classpath <span class=\"string\">\"io.objectbox:objectbox-gradle-plugin:$objectboxVersion\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">allprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">        maven &#123; url <span class=\"string\">\"http://objectbox.net/beta-repo/\"</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在应用项目模块(app module)中添加插件</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'io.objectbox'</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><ol>\n<li><p>准备<code>ObjectBox</code>对象单例并实例化, 可以放在application的<code>onCreate()</code>中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MyObjectBox类文件这时候是引用不到, 它是根据实体类自动生成(build), 用来设置BoxStore对象</span></span><br><span class=\"line\">boxStore = MyObjectBox.builder().androidContext(applicationContext).build();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加一个对象类, 添加<code>@Entity</code>注解, 进行表映射</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 主键, 必须有, 并且必须是long类型</span></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> userAge;</span><br><span class=\"line\">    <span class=\"comment\">// 必须有</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>P.S 这时候记得build一下, MyObjectBox就自动生成了</p>\n<ol>\n<li>这时候我们就可以通过<code>Box&lt;User&gt;</code>对象来针对这张表做增删改查工作了<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Box&lt;User&gt; userBox = boxStore.boxFor(User.class).build();</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"增删改查\"><a href=\"#增删改查\" class=\"headerlink\" title=\"增删改查\"></a>增删改查</h2><p><code>Box</code>分别有<code>put</code> 添加or修改, <code>query</code> 查找, <code>remove</code> 移除 等开放API可调用.<br>在调用<code>put</code>时, 当Entity的Id不设置, 则会自动为其赋值, 并新增数据. 当有设置Id, 并在表内有对应Id, 则会被覆盖, 相当于更新对应数据.<br>另外关于<code>@Id</code>,有几点需要注意:</p>\n<ul>\n<li><code>0</code>和<code>-1(0xFFFFFFFFFFFFFFFF)</code>不能作为Id的值使用</li>\n<li><code>0</code> 或者<code>null</code>(如果类型是Long, 但不建议使用Long, 使用long的速度会更快)会是通知永远新增一笔新数据</li>\n<li>如果<code>put</code>一个id比当前最大id大的对象, ObjectBox可能会抛出异常</li>\n<li>如果要自己分配id, 可以使用注解<code>@Id(assignable = true)</code></li>\n</ul>\n<p>相关的方法, 可以参考<a href=\"2\">JavaDoc</a>中关于<code>Box</code>和<code>QueryBuilder</code>类中的方法</p>\n<h2 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h2><p>除了本文其他地方已提到的注解, 补充几个比较大概率会用到的, 其他的建议大家可以看看<a href=\"http://objectbox.io/files/objectbox-java/current/\" target=\"_blank\" rel=\"noopener\">JavaDoc</a>中的<code>io.objectbox.annotation</code>包:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Index</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String uid;</span><br><span class=\"line\">    <span class=\"meta\">@NameInDb</span>(<span class=\"string\">\"userName\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"meta\">@Transient</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> country;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>@Index</code>: 因为在ObjectBox中主键是必须设置为long类型的id, 当我们业务上需要另外主键时, 可以再标注<code>@Index</code>, 在ObjectBox中查询时根据他标注的字段来查询, 会加快查询速度</li>\n<li><code>@NameInDb</code>: 字段在数据库中的命名</li>\n<li><code>@Transient</code>: 忽略字段, 不在表中生成</li>\n</ul>\n<h2 id=\"数据迁移\"><a href=\"#数据迁移\" class=\"headerlink\" title=\"数据迁移\"></a>数据迁移</h2><p>ObjectBox可以实现大部分的数据迁移自动化, 当我们要删除或者新增一个字段的时候, 针对数据库我们是不需要做任何操作的.</p>\n<p>但是当我们需要重命名字段名或者表名, 或者需要更改字段类型时, 我们需要使用<code>@Uid</code>通知ObjectBox</p>\n<p>下面我们会分别举两个例子:</p>\n<ol>\n<li><p>重命名操作, 实体类重命名或者字段重命名操作流程都一样, 区别只在于是在在哪里放<code>@Uid</code>, 以实体类重命名为例:</p>\n<ul>\n<li><p>在类名上添加<code>@Uid</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Uid</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> userAge;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>rebuild</code>一下, 在<code>Gradle Console</code>中会找到下面类似一段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  错误: [ObjectBox] UID operations for entity &quot;User2&quot;:</span><br><span class=\"line\">   [Rename] apply the current UID using @Uid(6966387148602341622L) - [Change/reset] apply a new UID using @Uid(2383770126231565339L)</span><br><span class=\"line\">1 个错误</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>copy <code>[Rename]</code>的<code>@Uid</code>值6966387148602341622L, 并针对实体类进行重命名</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Uid</span>(<span class=\"number\">6966387148602341622L</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User2</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> userAge;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User2</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重新编译, 就已经迁移成功, 这时候<code>@Uid(6966387148602341622L)</code>这条代码就没有用了, 相关记录会在<code>objectbox-models/default.json</code>中体现</p>\n</li>\n</ul>\n</li>\n<li><p>变更字段类型, 要注意的是, 会导致原类型字段Column的数据会被清空, 大体流程与重命名流程大致相同, 但是赋值的<code>@Uid</code> 需要使用的是<code>[Change/reset]</code>的值, 表示是一个<code>新字段</code>.</p>\n</li>\n</ol>\n<p>P.S 前文提到了<code>objectbox-models/default.json</code>这个JSON文件, 这个文件相当于是我们做Migration时处理的文件记录, 所以是需要加入VCS控制</p>\n<h2 id=\"关系\"><a href=\"#关系\" class=\"headerlink\" title=\"关系\"></a>关系</h2><ul>\n<li>以后补充</li>\n</ul>\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><p>ObjectBox的所有操作都是在事务中运行的, 只是这个对我们来说是透明的, 我们不需要关注, 但是当我们需要进行多个操作的时候, 通过显示事务来控制, 可以大大提高app的效率和一致性.<br>在<code>BoxStore</code>中, 提供了四个方法来执行显示事务:</p>\n<ul>\n<li><code>runInReadTx</code> : 在事务中运行给定的Runnable, 不可并发处理</li>\n<li><code>runIxTx</code> : 只读事务, 可以并发处理</li>\n<li><code>runInTxAsync</code> : 在单独的线程中运行, 事务完成后会回调callback(可能为空)</li>\n<li><code>callInTx</code> : 和<code>runIxTx</code>类似, 不过允许返回值并可以抛出一个异常</li>\n</ul>\n<p>要注意的是, 事务的提交开销较大, 所以在使用隐式事务时, 譬如大批量调用<code>put</code>时, 我们需要统一写到一个事务里去提交<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(User user: userList)&#123;</span><br><span class=\"line\">  user.plusAge();</span><br><span class=\"line\">  box.put(user);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上的demo我们应该优化为下面这种:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(User user: userList)&#123;</span><br><span class=\"line\"> user.plusAge();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">box.put(userList);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数据库查看\"><a href=\"#数据库查看\" class=\"headerlink\" title=\"数据库查看\"></a>数据库查看</h2><ol>\n<li><p>在项目app gradle文件中, 必须在<code>&#39;io.objectbox&#39;</code>插件apply之前依赖一下代码</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debugCompile <span class=\"string\">\"io.objectbox:objectbox-android-objectbrowser:1.2.1\"</span></span><br><span class=\"line\">releaseCompile <span class=\"string\">\"io.objectbox:objectbox-android:1.2.1\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>清单文件申请权限</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.INTERNET\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后在BoxStore构建<code>之后</code>, 加入以下代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(BuildConfig.DEBUG)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> AndroidObjectBrowser(boxStore).start(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>运行后, 就可以从设备的通知栏点击进入查看数据库, 也可以通过在cmd中输入<code>adb forward tcp:8090 tcp:8090</code>, 打开浏览器, 输入<a href=\"http://localhost:8090/index.html\" target=\"_blank\" rel=\"noopener\">http://localhost:8090/index.html</a> 网址查看</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>关于它和rxJava如何使用, 如何做数据的观测, 以及和LiveData的搭配使用, 鉴于目前篇幅过长, 而且LiveData我目前还没有玩过, 所以暂时不写. 后续可能会新补一篇.</p>\n<p>具体可以看<a href=\"https://github.com/YuTianTina/DatabaseChoice\" target=\"_blank\" rel=\"noopener\">Demo</a></p>"},{"title":"利用gradle多aar发布私有maven","date":"2017-12-18T16:00:00.000Z","intro":"多aar发布","_content":"## 前言\n为了精简目前底层的基础组件库, 拆分出必要依赖项目(有一定精简)和完全的依赖项目,\n第一想法是在library上构建变种(Variant)版本, 一次发布所有的变种,在研究了一些相关的资料后,\n最后完美解决\n<!-- more -->\n## 基础部署到maven仓库\n我们可以通过gradle部署到远程或者本地的maven仓库,\n首先添加maven插件, 然后我们通过updaloadArchives任务自动生成POM文件, 并打包部署到指定的仓库中\n\n```\n  apply plugin: 'maven'  // 添加maven插件\n  uploadArchives {\n    repositories {\n        mavenDeployer {\n            repository(url: \"maven仓库地址\")\n            }\n        }\n    }\n```\n当然我们也可以通过authentication来添加服务器的认证信息, 也可以定义快照(snapshot)仓库\n```\napply plugin: 'maven'  // 添加maven插件\nuploadArchives {\n  repositories {\n      mavenDeployer {\n          repository(url: \"maven仓库地址\"){\n              authentication(userName: \"yourUserName\", password: \"yourPsw\")\n              }\n          snapshotRepository(url: \"maven snapshot仓库地址\"){\n              authentication(userName: \"yourUserName\", password: \"yourPsw\")\n          }\n      }\n  }\n```\n## POM文件的自定义\n我们可以针对POM做自定义处理, 最常见的就是设置版本号等等\n```\napply plugin: 'maven'  // 添加maven插件\nuploadArchives {\n  repositories {\n      mavenDeployer {\n          repository(url: \"maven仓库地址\")\n          }\n          pom.groupId = \"com.maven.test\"\n          pom.artifactId = \"myLibrary\"\n          pom.version = \"1.0.0\"\n          pom.packaging = \"aar\"\n      }\n  }\n```\n针对上面的设置, 我们依赖引用的就应该是\n```\nimplementation \"com.maven.test:myLibrary:1.0.0\"\n```\nMaven默认每个项目只会处理一个artifact, 当我们library没有设置productFlavor和buildType时, 默认上传的是release的variant.\n当我们两个variant代码不同, 依赖不同时, 需要生产不同的POM进行上传,这种情况下我们需要显示声明每个artifact, 并针对每个POM进行自定义上传.\n在这方面我们可以分别参考[MavenDeployer][0]和[MavenPom][1]开放的API\n```\n// 上略\nmavenDeployer {\n            repository(url: \"仓库地址\")\n            android.libraryVariants.all {variant->\n                def isFlavor = !variant.flavorName.isEmpty()\n                def _name = \"${variant.name}\"\n                // 生成多个pom\n                addFilter(_name){artifact, file->\n                    true\n                }\n                // 对应pom属性设置\n                pom(_name).artifactId = project.archivesBaseName + \"-\" + _name\n                pom(_name).version = \"1.0.0\"\n                pom(_name).groupId = \"com.maven.test\"\n                pom(_name).packaging = 'aar'\n                // 自定义pom的依赖集\n                pom(_name).withXml{\n                    def root = asNode()\n                    def depsNode = root[\"dependencies\"][0] ?: root.appendNode(\"dependencies\")\n                    def addDep = {\n                        if (it.group == null) return // Avoid empty dependency nodes\n                        def dependencyNode = depsNode.appendNode('dependency')\n                        dependencyNode.appendNode('groupId', it.group)\n                        dependencyNode.appendNode('artifactId', it.name)\n                        dependencyNode.appendNode('version', it.version)\n                        if (it.hasProperty('optional') && it.optional) {\n                            dependencyNode.appendNode('optional', 'true')\n                        }\n                    }\n                    // 添加基本依赖\n                    configurations.api.allDependencies.each addDep\n                    configurations.implementation.allDependencies.each addDep\n                    // 添加特殊依赖\n                    if (isFlavor) {\n                        configurations[\"${_name}Implementation\"].allDependencies.each addDep\n                        def flavorName = variant.flavorName\n                        configurations[\"${flavorName}Implementation\"].allDependencies.each addDep\n                        configurations[\"${_name}Api\"].allDependencies.each addDep\n                        configurations[\"${flavorName}Api\"].allDependencies.each addDep\n                    }\n                }\n\n            }\n        }\n```\n相关demo可以看[这里][2]\n\n## 依赖对应的组件库\n在成功发布后, 我们仓库内容应该如下图\n\n![pic](基于as3.0 多aar打包发布/demopic.png)\n\n假设我们的flavor分别为full和simple,当我们去依赖的时候, 就可以通过\n```\nreleaseImplementation \"com.maven.test:libraryNameFullRelease:1.0.0\"\ndebugImplementation \"com.maven.test:libraryNameFullDebug:1.0.0\"\n```\n[0]:https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/maven/MavenDeployer.html\n[1]:https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/maven/MavenPom.html\n[2]:https://github.com/YuTianTina/ForMultiUploadMaven\n[3]:https://github.com/YuTianTina/ForMultiUploadMaven/blob/master/demopic.png\n","source":"_posts/基于as3.0 多aar打包发布.md","raw":"title: 利用gradle多aar发布私有maven\ndate: 2017-12-19 00:00:00\nintro: 多aar发布\ncategories :\n- android学习记录\ntags:\n- android\n- gradle\n---\n## 前言\n为了精简目前底层的基础组件库, 拆分出必要依赖项目(有一定精简)和完全的依赖项目,\n第一想法是在library上构建变种(Variant)版本, 一次发布所有的变种,在研究了一些相关的资料后,\n最后完美解决\n<!-- more -->\n## 基础部署到maven仓库\n我们可以通过gradle部署到远程或者本地的maven仓库,\n首先添加maven插件, 然后我们通过updaloadArchives任务自动生成POM文件, 并打包部署到指定的仓库中\n\n```\n  apply plugin: 'maven'  // 添加maven插件\n  uploadArchives {\n    repositories {\n        mavenDeployer {\n            repository(url: \"maven仓库地址\")\n            }\n        }\n    }\n```\n当然我们也可以通过authentication来添加服务器的认证信息, 也可以定义快照(snapshot)仓库\n```\napply plugin: 'maven'  // 添加maven插件\nuploadArchives {\n  repositories {\n      mavenDeployer {\n          repository(url: \"maven仓库地址\"){\n              authentication(userName: \"yourUserName\", password: \"yourPsw\")\n              }\n          snapshotRepository(url: \"maven snapshot仓库地址\"){\n              authentication(userName: \"yourUserName\", password: \"yourPsw\")\n          }\n      }\n  }\n```\n## POM文件的自定义\n我们可以针对POM做自定义处理, 最常见的就是设置版本号等等\n```\napply plugin: 'maven'  // 添加maven插件\nuploadArchives {\n  repositories {\n      mavenDeployer {\n          repository(url: \"maven仓库地址\")\n          }\n          pom.groupId = \"com.maven.test\"\n          pom.artifactId = \"myLibrary\"\n          pom.version = \"1.0.0\"\n          pom.packaging = \"aar\"\n      }\n  }\n```\n针对上面的设置, 我们依赖引用的就应该是\n```\nimplementation \"com.maven.test:myLibrary:1.0.0\"\n```\nMaven默认每个项目只会处理一个artifact, 当我们library没有设置productFlavor和buildType时, 默认上传的是release的variant.\n当我们两个variant代码不同, 依赖不同时, 需要生产不同的POM进行上传,这种情况下我们需要显示声明每个artifact, 并针对每个POM进行自定义上传.\n在这方面我们可以分别参考[MavenDeployer][0]和[MavenPom][1]开放的API\n```\n// 上略\nmavenDeployer {\n            repository(url: \"仓库地址\")\n            android.libraryVariants.all {variant->\n                def isFlavor = !variant.flavorName.isEmpty()\n                def _name = \"${variant.name}\"\n                // 生成多个pom\n                addFilter(_name){artifact, file->\n                    true\n                }\n                // 对应pom属性设置\n                pom(_name).artifactId = project.archivesBaseName + \"-\" + _name\n                pom(_name).version = \"1.0.0\"\n                pom(_name).groupId = \"com.maven.test\"\n                pom(_name).packaging = 'aar'\n                // 自定义pom的依赖集\n                pom(_name).withXml{\n                    def root = asNode()\n                    def depsNode = root[\"dependencies\"][0] ?: root.appendNode(\"dependencies\")\n                    def addDep = {\n                        if (it.group == null) return // Avoid empty dependency nodes\n                        def dependencyNode = depsNode.appendNode('dependency')\n                        dependencyNode.appendNode('groupId', it.group)\n                        dependencyNode.appendNode('artifactId', it.name)\n                        dependencyNode.appendNode('version', it.version)\n                        if (it.hasProperty('optional') && it.optional) {\n                            dependencyNode.appendNode('optional', 'true')\n                        }\n                    }\n                    // 添加基本依赖\n                    configurations.api.allDependencies.each addDep\n                    configurations.implementation.allDependencies.each addDep\n                    // 添加特殊依赖\n                    if (isFlavor) {\n                        configurations[\"${_name}Implementation\"].allDependencies.each addDep\n                        def flavorName = variant.flavorName\n                        configurations[\"${flavorName}Implementation\"].allDependencies.each addDep\n                        configurations[\"${_name}Api\"].allDependencies.each addDep\n                        configurations[\"${flavorName}Api\"].allDependencies.each addDep\n                    }\n                }\n\n            }\n        }\n```\n相关demo可以看[这里][2]\n\n## 依赖对应的组件库\n在成功发布后, 我们仓库内容应该如下图\n\n![pic](基于as3.0 多aar打包发布/demopic.png)\n\n假设我们的flavor分别为full和simple,当我们去依赖的时候, 就可以通过\n```\nreleaseImplementation \"com.maven.test:libraryNameFullRelease:1.0.0\"\ndebugImplementation \"com.maven.test:libraryNameFullDebug:1.0.0\"\n```\n[0]:https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/maven/MavenDeployer.html\n[1]:https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/maven/MavenPom.html\n[2]:https://github.com/YuTianTina/ForMultiUploadMaven\n[3]:https://github.com/YuTianTina/ForMultiUploadMaven/blob/master/demopic.png\n","slug":"基于as3.0 多aar打包发布","published":1,"updated":"2018-05-07T01:58:26.098Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh7fldi700088os6z4iqergd","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>为了精简目前底层的基础组件库, 拆分出必要依赖项目(有一定精简)和完全的依赖项目,<br>第一想法是在library上构建变种(Variant)版本, 一次发布所有的变种,在研究了一些相关的资料后,<br>最后完美解决<br><a id=\"more\"></a></p>\n<h2 id=\"基础部署到maven仓库\"><a href=\"#基础部署到maven仓库\" class=\"headerlink\" title=\"基础部署到maven仓库\"></a>基础部署到maven仓库</h2><p>我们可以通过gradle部署到远程或者本地的maven仓库,<br>首先添加maven插件, 然后我们通过updaloadArchives任务自动生成POM文件, 并打包部署到指定的仓库中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &apos;maven&apos;  // 添加maven插件</span><br><span class=\"line\">uploadArchives &#123;</span><br><span class=\"line\">  repositories &#123;</span><br><span class=\"line\">      mavenDeployer &#123;</span><br><span class=\"line\">          repository(url: &quot;maven仓库地址&quot;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>当然我们也可以通过authentication来添加服务器的认证信息, 也可以定义快照(snapshot)仓库<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &apos;maven&apos;  // 添加maven插件</span><br><span class=\"line\">uploadArchives &#123;</span><br><span class=\"line\">  repositories &#123;</span><br><span class=\"line\">      mavenDeployer &#123;</span><br><span class=\"line\">          repository(url: &quot;maven仓库地址&quot;)&#123;</span><br><span class=\"line\">              authentication(userName: &quot;yourUserName&quot;, password: &quot;yourPsw&quot;)</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          snapshotRepository(url: &quot;maven snapshot仓库地址&quot;)&#123;</span><br><span class=\"line\">              authentication(userName: &quot;yourUserName&quot;, password: &quot;yourPsw&quot;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"POM文件的自定义\"><a href=\"#POM文件的自定义\" class=\"headerlink\" title=\"POM文件的自定义\"></a>POM文件的自定义</h2><p>我们可以针对POM做自定义处理, 最常见的就是设置版本号等等<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &apos;maven&apos;  // 添加maven插件</span><br><span class=\"line\">uploadArchives &#123;</span><br><span class=\"line\">  repositories &#123;</span><br><span class=\"line\">      mavenDeployer &#123;</span><br><span class=\"line\">          repository(url: &quot;maven仓库地址&quot;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          pom.groupId = &quot;com.maven.test&quot;</span><br><span class=\"line\">          pom.artifactId = &quot;myLibrary&quot;</span><br><span class=\"line\">          pom.version = &quot;1.0.0&quot;</span><br><span class=\"line\">          pom.packaging = &quot;aar&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>针对上面的设置, 我们依赖引用的就应该是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation &quot;com.maven.test:myLibrary:1.0.0&quot;</span><br></pre></td></tr></table></figure></p>\n<p>Maven默认每个项目只会处理一个artifact, 当我们library没有设置productFlavor和buildType时, 默认上传的是release的variant.<br>当我们两个variant代码不同, 依赖不同时, 需要生产不同的POM进行上传,这种情况下我们需要显示声明每个artifact, 并针对每个POM进行自定义上传.<br>在这方面我们可以分别参考<a href=\"https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/maven/MavenDeployer.html\" target=\"_blank\" rel=\"noopener\">MavenDeployer</a>和<a href=\"https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/maven/MavenPom.html\" target=\"_blank\" rel=\"noopener\">MavenPom</a>开放的API<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 上略</span><br><span class=\"line\">mavenDeployer &#123;</span><br><span class=\"line\">            repository(url: &quot;仓库地址&quot;)</span><br><span class=\"line\">            android.libraryVariants.all &#123;variant-&gt;</span><br><span class=\"line\">                def isFlavor = !variant.flavorName.isEmpty()</span><br><span class=\"line\">                def _name = &quot;$&#123;variant.name&#125;&quot;</span><br><span class=\"line\">                // 生成多个pom</span><br><span class=\"line\">                addFilter(_name)&#123;artifact, file-&gt;</span><br><span class=\"line\">                    true</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                // 对应pom属性设置</span><br><span class=\"line\">                pom(_name).artifactId = project.archivesBaseName + &quot;-&quot; + _name</span><br><span class=\"line\">                pom(_name).version = &quot;1.0.0&quot;</span><br><span class=\"line\">                pom(_name).groupId = &quot;com.maven.test&quot;</span><br><span class=\"line\">                pom(_name).packaging = &apos;aar&apos;</span><br><span class=\"line\">                // 自定义pom的依赖集</span><br><span class=\"line\">                pom(_name).withXml&#123;</span><br><span class=\"line\">                    def root = asNode()</span><br><span class=\"line\">                    def depsNode = root[&quot;dependencies&quot;][0] ?: root.appendNode(&quot;dependencies&quot;)</span><br><span class=\"line\">                    def addDep = &#123;</span><br><span class=\"line\">                        if (it.group == null) return // Avoid empty dependency nodes</span><br><span class=\"line\">                        def dependencyNode = depsNode.appendNode(&apos;dependency&apos;)</span><br><span class=\"line\">                        dependencyNode.appendNode(&apos;groupId&apos;, it.group)</span><br><span class=\"line\">                        dependencyNode.appendNode(&apos;artifactId&apos;, it.name)</span><br><span class=\"line\">                        dependencyNode.appendNode(&apos;version&apos;, it.version)</span><br><span class=\"line\">                        if (it.hasProperty(&apos;optional&apos;) &amp;&amp; it.optional) &#123;</span><br><span class=\"line\">                            dependencyNode.appendNode(&apos;optional&apos;, &apos;true&apos;)</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    // 添加基本依赖</span><br><span class=\"line\">                    configurations.api.allDependencies.each addDep</span><br><span class=\"line\">                    configurations.implementation.allDependencies.each addDep</span><br><span class=\"line\">                    // 添加特殊依赖</span><br><span class=\"line\">                    if (isFlavor) &#123;</span><br><span class=\"line\">                        configurations[&quot;$&#123;_name&#125;Implementation&quot;].allDependencies.each addDep</span><br><span class=\"line\">                        def flavorName = variant.flavorName</span><br><span class=\"line\">                        configurations[&quot;$&#123;flavorName&#125;Implementation&quot;].allDependencies.each addDep</span><br><span class=\"line\">                        configurations[&quot;$&#123;_name&#125;Api&quot;].allDependencies.each addDep</span><br><span class=\"line\">                        configurations[&quot;$&#123;flavorName&#125;Api&quot;].allDependencies.each addDep</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>相关demo可以看<a href=\"https://github.com/YuTianTina/ForMultiUploadMaven\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h2 id=\"依赖对应的组件库\"><a href=\"#依赖对应的组件库\" class=\"headerlink\" title=\"依赖对应的组件库\"></a>依赖对应的组件库</h2><p>在成功发布后, 我们仓库内容应该如下图</p>\n<p><img src=\"基于as3.0 多aar打包发布/demopic.png\" alt=\"pic\"></p>\n<p>假设我们的flavor分别为full和simple,当我们去依赖的时候, 就可以通过<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">releaseImplementation &quot;com.maven.test:libraryNameFullRelease:1.0.0&quot;</span><br><span class=\"line\">debugImplementation &quot;com.maven.test:libraryNameFullDebug:1.0.0&quot;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>为了精简目前底层的基础组件库, 拆分出必要依赖项目(有一定精简)和完全的依赖项目,<br>第一想法是在library上构建变种(Variant)版本, 一次发布所有的变种,在研究了一些相关的资料后,<br>最后完美解决<br>","more":"</p>\n<h2 id=\"基础部署到maven仓库\"><a href=\"#基础部署到maven仓库\" class=\"headerlink\" title=\"基础部署到maven仓库\"></a>基础部署到maven仓库</h2><p>我们可以通过gradle部署到远程或者本地的maven仓库,<br>首先添加maven插件, 然后我们通过updaloadArchives任务自动生成POM文件, 并打包部署到指定的仓库中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &apos;maven&apos;  // 添加maven插件</span><br><span class=\"line\">uploadArchives &#123;</span><br><span class=\"line\">  repositories &#123;</span><br><span class=\"line\">      mavenDeployer &#123;</span><br><span class=\"line\">          repository(url: &quot;maven仓库地址&quot;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>当然我们也可以通过authentication来添加服务器的认证信息, 也可以定义快照(snapshot)仓库<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &apos;maven&apos;  // 添加maven插件</span><br><span class=\"line\">uploadArchives &#123;</span><br><span class=\"line\">  repositories &#123;</span><br><span class=\"line\">      mavenDeployer &#123;</span><br><span class=\"line\">          repository(url: &quot;maven仓库地址&quot;)&#123;</span><br><span class=\"line\">              authentication(userName: &quot;yourUserName&quot;, password: &quot;yourPsw&quot;)</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          snapshotRepository(url: &quot;maven snapshot仓库地址&quot;)&#123;</span><br><span class=\"line\">              authentication(userName: &quot;yourUserName&quot;, password: &quot;yourPsw&quot;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"POM文件的自定义\"><a href=\"#POM文件的自定义\" class=\"headerlink\" title=\"POM文件的自定义\"></a>POM文件的自定义</h2><p>我们可以针对POM做自定义处理, 最常见的就是设置版本号等等<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &apos;maven&apos;  // 添加maven插件</span><br><span class=\"line\">uploadArchives &#123;</span><br><span class=\"line\">  repositories &#123;</span><br><span class=\"line\">      mavenDeployer &#123;</span><br><span class=\"line\">          repository(url: &quot;maven仓库地址&quot;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          pom.groupId = &quot;com.maven.test&quot;</span><br><span class=\"line\">          pom.artifactId = &quot;myLibrary&quot;</span><br><span class=\"line\">          pom.version = &quot;1.0.0&quot;</span><br><span class=\"line\">          pom.packaging = &quot;aar&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>针对上面的设置, 我们依赖引用的就应该是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation &quot;com.maven.test:myLibrary:1.0.0&quot;</span><br></pre></td></tr></table></figure></p>\n<p>Maven默认每个项目只会处理一个artifact, 当我们library没有设置productFlavor和buildType时, 默认上传的是release的variant.<br>当我们两个variant代码不同, 依赖不同时, 需要生产不同的POM进行上传,这种情况下我们需要显示声明每个artifact, 并针对每个POM进行自定义上传.<br>在这方面我们可以分别参考<a href=\"https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/maven/MavenDeployer.html\" target=\"_blank\" rel=\"noopener\">MavenDeployer</a>和<a href=\"https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/maven/MavenPom.html\" target=\"_blank\" rel=\"noopener\">MavenPom</a>开放的API<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 上略</span><br><span class=\"line\">mavenDeployer &#123;</span><br><span class=\"line\">            repository(url: &quot;仓库地址&quot;)</span><br><span class=\"line\">            android.libraryVariants.all &#123;variant-&gt;</span><br><span class=\"line\">                def isFlavor = !variant.flavorName.isEmpty()</span><br><span class=\"line\">                def _name = &quot;$&#123;variant.name&#125;&quot;</span><br><span class=\"line\">                // 生成多个pom</span><br><span class=\"line\">                addFilter(_name)&#123;artifact, file-&gt;</span><br><span class=\"line\">                    true</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                // 对应pom属性设置</span><br><span class=\"line\">                pom(_name).artifactId = project.archivesBaseName + &quot;-&quot; + _name</span><br><span class=\"line\">                pom(_name).version = &quot;1.0.0&quot;</span><br><span class=\"line\">                pom(_name).groupId = &quot;com.maven.test&quot;</span><br><span class=\"line\">                pom(_name).packaging = &apos;aar&apos;</span><br><span class=\"line\">                // 自定义pom的依赖集</span><br><span class=\"line\">                pom(_name).withXml&#123;</span><br><span class=\"line\">                    def root = asNode()</span><br><span class=\"line\">                    def depsNode = root[&quot;dependencies&quot;][0] ?: root.appendNode(&quot;dependencies&quot;)</span><br><span class=\"line\">                    def addDep = &#123;</span><br><span class=\"line\">                        if (it.group == null) return // Avoid empty dependency nodes</span><br><span class=\"line\">                        def dependencyNode = depsNode.appendNode(&apos;dependency&apos;)</span><br><span class=\"line\">                        dependencyNode.appendNode(&apos;groupId&apos;, it.group)</span><br><span class=\"line\">                        dependencyNode.appendNode(&apos;artifactId&apos;, it.name)</span><br><span class=\"line\">                        dependencyNode.appendNode(&apos;version&apos;, it.version)</span><br><span class=\"line\">                        if (it.hasProperty(&apos;optional&apos;) &amp;&amp; it.optional) &#123;</span><br><span class=\"line\">                            dependencyNode.appendNode(&apos;optional&apos;, &apos;true&apos;)</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    // 添加基本依赖</span><br><span class=\"line\">                    configurations.api.allDependencies.each addDep</span><br><span class=\"line\">                    configurations.implementation.allDependencies.each addDep</span><br><span class=\"line\">                    // 添加特殊依赖</span><br><span class=\"line\">                    if (isFlavor) &#123;</span><br><span class=\"line\">                        configurations[&quot;$&#123;_name&#125;Implementation&quot;].allDependencies.each addDep</span><br><span class=\"line\">                        def flavorName = variant.flavorName</span><br><span class=\"line\">                        configurations[&quot;$&#123;flavorName&#125;Implementation&quot;].allDependencies.each addDep</span><br><span class=\"line\">                        configurations[&quot;$&#123;_name&#125;Api&quot;].allDependencies.each addDep</span><br><span class=\"line\">                        configurations[&quot;$&#123;flavorName&#125;Api&quot;].allDependencies.each addDep</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>相关demo可以看<a href=\"https://github.com/YuTianTina/ForMultiUploadMaven\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h2 id=\"依赖对应的组件库\"><a href=\"#依赖对应的组件库\" class=\"headerlink\" title=\"依赖对应的组件库\"></a>依赖对应的组件库</h2><p>在成功发布后, 我们仓库内容应该如下图</p>\n<p><img src=\"基于as3.0 多aar打包发布/demopic.png\" alt=\"pic\"></p>\n<p>假设我们的flavor分别为full和simple,当我们去依赖的时候, 就可以通过<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">releaseImplementation &quot;com.maven.test:libraryNameFullRelease:1.0.0&quot;</span><br><span class=\"line\">debugImplementation &quot;com.maven.test:libraryNameFullDebug:1.0.0&quot;</span><br></pre></td></tr></table></figure></p>"},{"title":"记录一次Gradle的踩坑","date":"2018-05-14T16:00:00.000Z","_content":"### 前提背景\n来了新公司后第一个任务是给项目升级支持gradle插件3.0, 这个当初还是3.0.1的时候就做过, 所以并没有什么难度, 但是顺带要将内部的热更新插件同样升级碰到了个百思不得其解的问题.\n<!-- more -->\n### 问题\n我们先看下出现问题的伪代码, 当我在AS上需要编译运行项目的时候, 会提示`dexTask`为空的错误信息, 而在同事的PC上却可以顺利的运行.(gradle插件环境都是3.0.1, gradle使用的是4.1版本)\n``` groovy\nafterEvaluate{\n  android.buildTypes.each{\n    type ->\n    def typeName = type.name\n    if(\"release\" == typeName){\n        def dexTask = project.tasks.findByName(\"transformClassesWithDexForRelease\")\n        // 针对于dexTask的逻辑处理...\n    }\n  }\n}\n```\n由于`Gradle`开发经验少的可怜, 所以此次我们一行行来看代码\n### Gradle的执行流程\n要解释`afterEvaluate`, 我们必须先了解Gradle的执行流程.它主要可分为三个步骤\n1. 初始化, 解析`settings.gradle`, 根据module生成对应`project`的实例\n2. 配置, 解析每个`project`, 获取对应的`task`\n3. 执行task\n\n当然这一块流程, 我们可以从AS的Build上分析得出.\n![执行流程](./记录一次Gradle的踩坑/Gradle执行时序.png)\n然后我们再回头说到`afterEvaluate`, 它是在配置阶段后, 已经获取对应`project`的`task`后, 回调执行的.具体可以看[官方文档的说明](https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html#afterEvaluate-groovy.lang.Closure-)(这里放的是最新版本的API文档, 要看对应版本的文档, 可以看本地的gradle文件夹内的javadoc文档)\n### 问题和解决\nok, 那么关于`afterEvaluate`我们已经了解了, 再往下看,`android.buildTypes.each`就是对`project`的配置的`buildType`进行遍历, 然后当`buildType`为`release`的时候, 获取对应`buildType`的`transformClassesWithDex`.\n而在调试的过程中, 我发现走debug的时候`transformClassesWithDexForDebug`是有的, 可以看出配置阶段只会获取当前`buildType`的task.\n那么现在我们要做的就是改为判断当前`buildType`为`release`的时候, 再获取对应的task.\n``` groovy\nandroid.applicationVariants.all{\n    variant ->\n      variant.outputs.each{\n        type ->\n        if(\"release\" == type.name){\n          def dexTask = project.tasks.findByName(\"transformClassesWithDexForRelease\")\n          // 针对于dexTask的逻辑处理...\n        }\n      }\n}\n```\n然后这里还有个问题, 我们已知task的获取是要在配置结束后才能获得的, 这里不通过`afterEvaluate`是否可以获取到对应的task? 这块我们可以看下源码注释\n``` java\n/**\n     * Returns a collection of <a\n     * href=\"https://developer.android.com/studio/build/build-variants.html\">build variants</a> that\n     * the app project includes.\n     *\n     * <p>To process elements in this collection, you should use the <a\n     * href=\"https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectCollection.html#all(org.gradle.api.Action)\">\n     * <code>all</code></a> iterator. That's because the plugin populates this collection only after\n     * the project is evaluated. Unlike the <code>each</code> iterator, using <code>all</code>\n     * processes future elements as the plugin creates them.\n     *\n     * <p>The following sample iterates through all <code>applicationVariants</code> elements to <a\n     * href=\"https://developer.android.com/studio/build/manifest-build-variables.html\">inject a\n     * build variable into the manifest</a>:\n     *\n     * <pre>\n     * android.applicationVariants.all { variant -&gt;\n     *     def mergedFlavor = variant.getMergedFlavor()\n     *     // Defines the value of a build variable you can use in the manifest.\n     *     mergedFlavor.manifestPlaceholders = [hostName:\"www.example.com/${variant.versionName}\"]\n     * }\n     * </pre>\n     */\n    public DomainObjectSet<ApplicationVariant> getApplicationVariants() {\n        return applicationVariantList;\n    }\n```\n`all`与`each`不同, 他只会在`configuration`阶段后进行获取填充.\n## 其他\n至于为什么同事的PC上可以运行, 我的不行, 后来排查下来, 应该是在AS`3.1.2`版本(同事的AS是3.0.1)在执行获取配置这块, 校验更为严格的原因. 但是具体的我并没有查询相关的文档.\n## 总结\n其实本次问题并不难解决, 可能是前期因为同事可以运行, 本地环境却不能运行的状况给搞懵逼了. 但是后来还是顺利解决了.关于Gradle, 这次的踩坑经验是教了我去看官方API...虽然说Gradle的文档是真的好难定位\n","source":"_posts/记录一次Gradle的踩坑.md","raw":"title: 记录一次Gradle的踩坑\ndate: 2018-05-15 00:00:00\ncategories :\n- 日常开发踩坑记录\ntags:\n- android\n- gradle\n---\n### 前提背景\n来了新公司后第一个任务是给项目升级支持gradle插件3.0, 这个当初还是3.0.1的时候就做过, 所以并没有什么难度, 但是顺带要将内部的热更新插件同样升级碰到了个百思不得其解的问题.\n<!-- more -->\n### 问题\n我们先看下出现问题的伪代码, 当我在AS上需要编译运行项目的时候, 会提示`dexTask`为空的错误信息, 而在同事的PC上却可以顺利的运行.(gradle插件环境都是3.0.1, gradle使用的是4.1版本)\n``` groovy\nafterEvaluate{\n  android.buildTypes.each{\n    type ->\n    def typeName = type.name\n    if(\"release\" == typeName){\n        def dexTask = project.tasks.findByName(\"transformClassesWithDexForRelease\")\n        // 针对于dexTask的逻辑处理...\n    }\n  }\n}\n```\n由于`Gradle`开发经验少的可怜, 所以此次我们一行行来看代码\n### Gradle的执行流程\n要解释`afterEvaluate`, 我们必须先了解Gradle的执行流程.它主要可分为三个步骤\n1. 初始化, 解析`settings.gradle`, 根据module生成对应`project`的实例\n2. 配置, 解析每个`project`, 获取对应的`task`\n3. 执行task\n\n当然这一块流程, 我们可以从AS的Build上分析得出.\n![执行流程](./记录一次Gradle的踩坑/Gradle执行时序.png)\n然后我们再回头说到`afterEvaluate`, 它是在配置阶段后, 已经获取对应`project`的`task`后, 回调执行的.具体可以看[官方文档的说明](https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html#afterEvaluate-groovy.lang.Closure-)(这里放的是最新版本的API文档, 要看对应版本的文档, 可以看本地的gradle文件夹内的javadoc文档)\n### 问题和解决\nok, 那么关于`afterEvaluate`我们已经了解了, 再往下看,`android.buildTypes.each`就是对`project`的配置的`buildType`进行遍历, 然后当`buildType`为`release`的时候, 获取对应`buildType`的`transformClassesWithDex`.\n而在调试的过程中, 我发现走debug的时候`transformClassesWithDexForDebug`是有的, 可以看出配置阶段只会获取当前`buildType`的task.\n那么现在我们要做的就是改为判断当前`buildType`为`release`的时候, 再获取对应的task.\n``` groovy\nandroid.applicationVariants.all{\n    variant ->\n      variant.outputs.each{\n        type ->\n        if(\"release\" == type.name){\n          def dexTask = project.tasks.findByName(\"transformClassesWithDexForRelease\")\n          // 针对于dexTask的逻辑处理...\n        }\n      }\n}\n```\n然后这里还有个问题, 我们已知task的获取是要在配置结束后才能获得的, 这里不通过`afterEvaluate`是否可以获取到对应的task? 这块我们可以看下源码注释\n``` java\n/**\n     * Returns a collection of <a\n     * href=\"https://developer.android.com/studio/build/build-variants.html\">build variants</a> that\n     * the app project includes.\n     *\n     * <p>To process elements in this collection, you should use the <a\n     * href=\"https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectCollection.html#all(org.gradle.api.Action)\">\n     * <code>all</code></a> iterator. That's because the plugin populates this collection only after\n     * the project is evaluated. Unlike the <code>each</code> iterator, using <code>all</code>\n     * processes future elements as the plugin creates them.\n     *\n     * <p>The following sample iterates through all <code>applicationVariants</code> elements to <a\n     * href=\"https://developer.android.com/studio/build/manifest-build-variables.html\">inject a\n     * build variable into the manifest</a>:\n     *\n     * <pre>\n     * android.applicationVariants.all { variant -&gt;\n     *     def mergedFlavor = variant.getMergedFlavor()\n     *     // Defines the value of a build variable you can use in the manifest.\n     *     mergedFlavor.manifestPlaceholders = [hostName:\"www.example.com/${variant.versionName}\"]\n     * }\n     * </pre>\n     */\n    public DomainObjectSet<ApplicationVariant> getApplicationVariants() {\n        return applicationVariantList;\n    }\n```\n`all`与`each`不同, 他只会在`configuration`阶段后进行获取填充.\n## 其他\n至于为什么同事的PC上可以运行, 我的不行, 后来排查下来, 应该是在AS`3.1.2`版本(同事的AS是3.0.1)在执行获取配置这块, 校验更为严格的原因. 但是具体的我并没有查询相关的文档.\n## 总结\n其实本次问题并不难解决, 可能是前期因为同事可以运行, 本地环境却不能运行的状况给搞懵逼了. 但是后来还是顺利解决了.关于Gradle, 这次的踩坑经验是教了我去看官方API...虽然说Gradle的文档是真的好难定位\n","slug":"记录一次Gradle的踩坑","published":1,"updated":"2018-05-15T08:33:52.887Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh7fldi800098os6jb1259mf","content":"<h3 id=\"前提背景\"><a href=\"#前提背景\" class=\"headerlink\" title=\"前提背景\"></a>前提背景</h3><p>来了新公司后第一个任务是给项目升级支持gradle插件3.0, 这个当初还是3.0.1的时候就做过, 所以并没有什么难度, 但是顺带要将内部的热更新插件同样升级碰到了个百思不得其解的问题.<br><a id=\"more\"></a></p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>我们先看下出现问题的伪代码, 当我在AS上需要编译运行项目的时候, 会提示<code>dexTask</code>为空的错误信息, 而在同事的PC上却可以顺利的运行.(gradle插件环境都是3.0.1, gradle使用的是4.1版本)<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">afterEvaluate&#123;</span><br><span class=\"line\">  android.buildTypes.each&#123;</span><br><span class=\"line\">    type -&gt;</span><br><span class=\"line\">    <span class=\"keyword\">def</span> typeName = type.name</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"string\">\"release\"</span> == typeName)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">def</span> dexTask = project.tasks.findByName(<span class=\"string\">\"transformClassesWithDexForRelease\"</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 针对于dexTask的逻辑处理...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于<code>Gradle</code>开发经验少的可怜, 所以此次我们一行行来看代码</p>\n<h3 id=\"Gradle的执行流程\"><a href=\"#Gradle的执行流程\" class=\"headerlink\" title=\"Gradle的执行流程\"></a>Gradle的执行流程</h3><p>要解释<code>afterEvaluate</code>, 我们必须先了解Gradle的执行流程.它主要可分为三个步骤</p>\n<ol>\n<li>初始化, 解析<code>settings.gradle</code>, 根据module生成对应<code>project</code>的实例</li>\n<li>配置, 解析每个<code>project</code>, 获取对应的<code>task</code></li>\n<li>执行task</li>\n</ol>\n<p>当然这一块流程, 我们可以从AS的Build上分析得出.<br><img src=\"./记录一次Gradle的踩坑/Gradle执行时序.png\" alt=\"执行流程\"><br>然后我们再回头说到<code>afterEvaluate</code>, 它是在配置阶段后, 已经获取对应<code>project</code>的<code>task</code>后, 回调执行的.具体可以看<a href=\"https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html#afterEvaluate-groovy.lang.Closure-\" target=\"_blank\" rel=\"noopener\">官方文档的说明</a>(这里放的是最新版本的API文档, 要看对应版本的文档, 可以看本地的gradle文件夹内的javadoc文档)</p>\n<h3 id=\"问题和解决\"><a href=\"#问题和解决\" class=\"headerlink\" title=\"问题和解决\"></a>问题和解决</h3><p>ok, 那么关于<code>afterEvaluate</code>我们已经了解了, 再往下看,<code>android.buildTypes.each</code>就是对<code>project</code>的配置的<code>buildType</code>进行遍历, 然后当<code>buildType</code>为<code>release</code>的时候, 获取对应<code>buildType</code>的<code>transformClassesWithDex</code>.<br>而在调试的过程中, 我发现走debug的时候<code>transformClassesWithDexForDebug</code>是有的, 可以看出配置阶段只会获取当前<code>buildType</code>的task.<br>那么现在我们要做的就是改为判断当前<code>buildType</code>为<code>release</code>的时候, 再获取对应的task.<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android.applicationVariants.all&#123;</span><br><span class=\"line\">    variant -&gt;</span><br><span class=\"line\">      variant.outputs.each&#123;</span><br><span class=\"line\">        type -&gt;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">\"release\"</span> == type.name)&#123;</span><br><span class=\"line\">          <span class=\"keyword\">def</span> dexTask = project.tasks.findByName(<span class=\"string\">\"transformClassesWithDexForRelease\"</span>)</span><br><span class=\"line\">          <span class=\"comment\">// 针对于dexTask的逻辑处理...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后这里还有个问题, 我们已知task的获取是要在配置结束后才能获得的, 这里不通过<code>afterEvaluate</code>是否可以获取到对应的task? 这块我们可以看下源码注释<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns a collection of &lt;a</span></span><br><span class=\"line\"><span class=\"comment\">     * href=\"https://developer.android.com/studio/build/build-variants.html\"&gt;build variants&lt;/a&gt; that</span></span><br><span class=\"line\"><span class=\"comment\">     * the app project includes.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;To process elements in this collection, you should use the &lt;a</span></span><br><span class=\"line\"><span class=\"comment\">     * href=\"https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectCollection.html#all(org.gradle.api.Action)\"&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;code&gt;all&lt;/code&gt;&lt;/a&gt; iterator. That's because the plugin populates this collection only after</span></span><br><span class=\"line\"><span class=\"comment\">     * the project is evaluated. Unlike the &lt;code&gt;each&lt;/code&gt; iterator, using &lt;code&gt;all&lt;/code&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * processes future elements as the plugin creates them.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;The following sample iterates through all &lt;code&gt;applicationVariants&lt;/code&gt; elements to &lt;a</span></span><br><span class=\"line\"><span class=\"comment\">     * href=\"https://developer.android.com/studio/build/manifest-build-variables.html\"&gt;inject a</span></span><br><span class=\"line\"><span class=\"comment\">     * build variable into the manifest&lt;/a&gt;:</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * android.applicationVariants.all &#123; variant -&amp;gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *     def mergedFlavor = variant.getMergedFlavor()</span></span><br><span class=\"line\"><span class=\"comment\">     *     // Defines the value of a build variable you can use in the manifest.</span></span><br><span class=\"line\"><span class=\"comment\">     *     mergedFlavor.manifestPlaceholders = [hostName:\"www.example.com/$&#123;variant.versionName&#125;\"]</span></span><br><span class=\"line\"><span class=\"comment\">     * &#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;/pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DomainObjectSet&lt;ApplicationVariant&gt; <span class=\"title\">getApplicationVariants</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> applicationVariantList;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>all</code>与<code>each</code>不同, 他只会在<code>configuration</code>阶段后进行获取填充.</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>至于为什么同事的PC上可以运行, 我的不行, 后来排查下来, 应该是在AS<code>3.1.2</code>版本(同事的AS是3.0.1)在执行获取配置这块, 校验更为严格的原因. 但是具体的我并没有查询相关的文档.</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>其实本次问题并不难解决, 可能是前期因为同事可以运行, 本地环境却不能运行的状况给搞懵逼了. 但是后来还是顺利解决了.关于Gradle, 这次的踩坑经验是教了我去看官方API…虽然说Gradle的文档是真的好难定位</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前提背景\"><a href=\"#前提背景\" class=\"headerlink\" title=\"前提背景\"></a>前提背景</h3><p>来了新公司后第一个任务是给项目升级支持gradle插件3.0, 这个当初还是3.0.1的时候就做过, 所以并没有什么难度, 但是顺带要将内部的热更新插件同样升级碰到了个百思不得其解的问题.<br>","more":"</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>我们先看下出现问题的伪代码, 当我在AS上需要编译运行项目的时候, 会提示<code>dexTask</code>为空的错误信息, 而在同事的PC上却可以顺利的运行.(gradle插件环境都是3.0.1, gradle使用的是4.1版本)<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">afterEvaluate&#123;</span><br><span class=\"line\">  android.buildTypes.each&#123;</span><br><span class=\"line\">    type -&gt;</span><br><span class=\"line\">    <span class=\"keyword\">def</span> typeName = type.name</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"string\">\"release\"</span> == typeName)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">def</span> dexTask = project.tasks.findByName(<span class=\"string\">\"transformClassesWithDexForRelease\"</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 针对于dexTask的逻辑处理...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于<code>Gradle</code>开发经验少的可怜, 所以此次我们一行行来看代码</p>\n<h3 id=\"Gradle的执行流程\"><a href=\"#Gradle的执行流程\" class=\"headerlink\" title=\"Gradle的执行流程\"></a>Gradle的执行流程</h3><p>要解释<code>afterEvaluate</code>, 我们必须先了解Gradle的执行流程.它主要可分为三个步骤</p>\n<ol>\n<li>初始化, 解析<code>settings.gradle</code>, 根据module生成对应<code>project</code>的实例</li>\n<li>配置, 解析每个<code>project</code>, 获取对应的<code>task</code></li>\n<li>执行task</li>\n</ol>\n<p>当然这一块流程, 我们可以从AS的Build上分析得出.<br><img src=\"./记录一次Gradle的踩坑/Gradle执行时序.png\" alt=\"执行流程\"><br>然后我们再回头说到<code>afterEvaluate</code>, 它是在配置阶段后, 已经获取对应<code>project</code>的<code>task</code>后, 回调执行的.具体可以看<a href=\"https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html#afterEvaluate-groovy.lang.Closure-\" target=\"_blank\" rel=\"noopener\">官方文档的说明</a>(这里放的是最新版本的API文档, 要看对应版本的文档, 可以看本地的gradle文件夹内的javadoc文档)</p>\n<h3 id=\"问题和解决\"><a href=\"#问题和解决\" class=\"headerlink\" title=\"问题和解决\"></a>问题和解决</h3><p>ok, 那么关于<code>afterEvaluate</code>我们已经了解了, 再往下看,<code>android.buildTypes.each</code>就是对<code>project</code>的配置的<code>buildType</code>进行遍历, 然后当<code>buildType</code>为<code>release</code>的时候, 获取对应<code>buildType</code>的<code>transformClassesWithDex</code>.<br>而在调试的过程中, 我发现走debug的时候<code>transformClassesWithDexForDebug</code>是有的, 可以看出配置阶段只会获取当前<code>buildType</code>的task.<br>那么现在我们要做的就是改为判断当前<code>buildType</code>为<code>release</code>的时候, 再获取对应的task.<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android.applicationVariants.all&#123;</span><br><span class=\"line\">    variant -&gt;</span><br><span class=\"line\">      variant.outputs.each&#123;</span><br><span class=\"line\">        type -&gt;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">\"release\"</span> == type.name)&#123;</span><br><span class=\"line\">          <span class=\"keyword\">def</span> dexTask = project.tasks.findByName(<span class=\"string\">\"transformClassesWithDexForRelease\"</span>)</span><br><span class=\"line\">          <span class=\"comment\">// 针对于dexTask的逻辑处理...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后这里还有个问题, 我们已知task的获取是要在配置结束后才能获得的, 这里不通过<code>afterEvaluate</code>是否可以获取到对应的task? 这块我们可以看下源码注释<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns a collection of &lt;a</span></span><br><span class=\"line\"><span class=\"comment\">     * href=\"https://developer.android.com/studio/build/build-variants.html\"&gt;build variants&lt;/a&gt; that</span></span><br><span class=\"line\"><span class=\"comment\">     * the app project includes.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;To process elements in this collection, you should use the &lt;a</span></span><br><span class=\"line\"><span class=\"comment\">     * href=\"https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectCollection.html#all(org.gradle.api.Action)\"&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;code&gt;all&lt;/code&gt;&lt;/a&gt; iterator. That's because the plugin populates this collection only after</span></span><br><span class=\"line\"><span class=\"comment\">     * the project is evaluated. Unlike the &lt;code&gt;each&lt;/code&gt; iterator, using &lt;code&gt;all&lt;/code&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * processes future elements as the plugin creates them.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;The following sample iterates through all &lt;code&gt;applicationVariants&lt;/code&gt; elements to &lt;a</span></span><br><span class=\"line\"><span class=\"comment\">     * href=\"https://developer.android.com/studio/build/manifest-build-variables.html\"&gt;inject a</span></span><br><span class=\"line\"><span class=\"comment\">     * build variable into the manifest&lt;/a&gt;:</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * android.applicationVariants.all &#123; variant -&amp;gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *     def mergedFlavor = variant.getMergedFlavor()</span></span><br><span class=\"line\"><span class=\"comment\">     *     // Defines the value of a build variable you can use in the manifest.</span></span><br><span class=\"line\"><span class=\"comment\">     *     mergedFlavor.manifestPlaceholders = [hostName:\"www.example.com/$&#123;variant.versionName&#125;\"]</span></span><br><span class=\"line\"><span class=\"comment\">     * &#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;/pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DomainObjectSet&lt;ApplicationVariant&gt; <span class=\"title\">getApplicationVariants</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> applicationVariantList;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>all</code>与<code>each</code>不同, 他只会在<code>configuration</code>阶段后进行获取填充.</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>至于为什么同事的PC上可以运行, 我的不行, 后来排查下来, 应该是在AS<code>3.1.2</code>版本(同事的AS是3.0.1)在执行获取配置这块, 校验更为严格的原因. 但是具体的我并没有查询相关的文档.</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>其实本次问题并不难解决, 可能是前期因为同事可以运行, 本地环境却不能运行的状况给搞懵逼了. 但是后来还是顺利解决了.关于Gradle, 这次的踩坑经验是教了我去看官方API…虽然说Gradle的文档是真的好难定位</p>"},{"title":"谈谈GC和引用","date":"2018-01-11T16:00:00.000Z","_content":"## 前言\nA拿了一串代码和[一篇文章](http://www.cnblogs.com/absfree/p/5555687.html)来问我,\n\n      ...当productA变为null时（表明它所引用的Product已经无需存在于内存中），这时指向这个Product对象的就是由弱引用对象weakProductA了，那么显然这时候相应的Product对象时弱可达的，\n      所以指向它的弱引用会被清除，这个Product对象随即会被回收，指向它的弱引用对象会进入引用队列中。\n根据文章上述引用内容, 当他在执行下文代码的`putnull`方法时, 为什么`userWeakReference.get()`对象不为null, 难道`userWeakReference.get()` 和 `user` 不是一个对象吗?\n``` java\npublic class MainActivity extends AppCompatActivity {\n    private User user;\n    public static final int period = 2000;\n    private WeakReference<User> userWeakReference;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        user = new User();\n        userWeakReference = new WeakReference<>(user);\n\n        Observable.interval(period, TimeUnit.MILLISECONDS)\n                .subscribe(new Consumer<Long>() {\n                    @Override\n                    public void accept(Long aLong) throws Exception {\n                        Log.d(\"gc\", String.format(\"user is %s null\", (null == user) ? \"\" : \"not\") +\n                                String.format(\" ****\" +\n                                        \" userWeakReference.get() is %s null\", (null == userWeakReference.get()) ? \"\" : \"not\"));\n                    }\n                });\n\n    }\n\n    public void putnull(View view) {\n        Log.i(\"gc\", \"============ user = null ==============\");\n        user = null;\n    }\n\n    public void excutegc(View view) {\n        Log.i(\"gc\", \"========== gc done =============\");\n        System.runFinalization();\n        System.gc();\n\n    }\n}\n```\n<!-- more -->\n我们不妨先看下打印日志![打印日志](谈谈GC和引用/gc.png)\n当`user`为空的时候, `userWeakReference.get()`不为空, 直到GC以后, 才为空.\n## 对象的初始化\n这个问题的道理其实很简单.首先我们来看下下面代码的含义\n``` java\nUser user = new User();\n```\n当虚拟机遇到一条`new`指令的时候, 在类加载检查通过以后, 会为新生对象分配内存, 然后将分配到的内存空间都初始化为零值, 然后通过对象头(Object Header)对对象进行一些必要的设置(譬如对象GC分代年龄等等), 最后, 把对象按照程序员的意愿进行初始化(执行`<init>`方法), 这个时候, 从Java程序角度上来讲, 一个新的对象就产生了.而`user`这个引用变量通过`=`指向的就是这个新生成的对象的内存地址.\n\n需要注意的是, 真正的对象是`new User()`, 而`user`表示的是引用.\n\n这时候当我们执行下面的代码\n``` java\nuser = null;\n```\n`null`既不是对象, 也不是类型, 它是一种特殊的值, 这里可以表示为`user`引用没有指向任何对象.但是从内存分配上来说, `new User()`这个对象仍然存在, 只是没有引用指向它.\n``` java\n/**\n     * Returns this reference object's referent.  If this reference object has\n     * been cleared, either by the program or by the garbage collector, then\n     * this method returns <code>null</code>.\n     *\n     * @return   The object to which this reference refers, or\n     *           <code>null</code> if this reference object has been cleared\n     */\n    public T get() {\n        return getReferent();\n    }\n```\n然后我们看下`Reference.get()`返回的是什么, 这个源码的注释给了我们答案, 它指向目标引用地址.那么我们就可以解释, 为什么`user`为空的时候, `userWeakReference.get()`仍然不为空.\n## GC\n我们先复习下GC的一些基础知识\n### 如何判断对象可回收\n在当前常用的虚拟机, 都是使用`可达性分析算法`, 通过可达判断(`GC Root`作为起始点, 引用链向下搜索, 如果对象和GC Root之前没有引用链, 则认为不可达, 即GC可回收)GC是否可以回收.`GC Roots`的对象可包括以下几种:\n- 虚拟机栈中引用的对象\n- 方法区中类静态属性引用的对象\n- 方法区中常量引用的对象\n- 本地方法栈中JNI(Native方法)引用的对象\n\n### 引用级别\n同样, 我们在看下`WeakReference`是什么. 在判断对象的引用链是否可达的时候, 我们都需要用到引用.引用级别可分为四层, 引用强度分别自强到弱\n- 强引用: 代码中最常见的, 譬如上面的`user`就是强引用, 强引用只要存在, GC就永远不会回收它\n- 软引用`SoftReference`: 软引用只有在内存不足时, GC才会回收. 当要发生OOM的时候, GC会把这些对象列进回收范围进行第二次回收, 如果这次回收后还是没有足够的内存, 则会报OOM\n- 弱引用`WeakReference`: 无论内存是否足够, GC肯定会回收. 所以弱引用关联的对象无法存活到下一次GC.`LeakCanary`就是通过使用`WeakReference`和引用队列通过二次回收判定来判断是否存在内存泄漏.\n- 虚引用`PhantomReference`:最弱的一种引用关系, 一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响, 也无法通过虚引用来取得一个对象实例。他存在的唯一目的即是能在这个对象被收集器回收时受到一个系统通知.\n\n## 结论\n  由此可以理解, 当发生GC时, `WeakReference`引用相关的对象就不会再存活, 这也是为什么,上面的代码里, 要等到GC发生后`userWeakReference.get()`才为空.\n\n  从这个问题我们引申出来的还是比较基础的东西, 不过不妨碍我们再去做一次巩固.\n","source":"_posts/谈谈GC和引用.md","raw":"title: 谈谈GC和引用\ndate: 2018-01-12 00:00:00\ncategories :\n- Java\ntags:\n- java\n- JVM\n---\n## 前言\nA拿了一串代码和[一篇文章](http://www.cnblogs.com/absfree/p/5555687.html)来问我,\n\n      ...当productA变为null时（表明它所引用的Product已经无需存在于内存中），这时指向这个Product对象的就是由弱引用对象weakProductA了，那么显然这时候相应的Product对象时弱可达的，\n      所以指向它的弱引用会被清除，这个Product对象随即会被回收，指向它的弱引用对象会进入引用队列中。\n根据文章上述引用内容, 当他在执行下文代码的`putnull`方法时, 为什么`userWeakReference.get()`对象不为null, 难道`userWeakReference.get()` 和 `user` 不是一个对象吗?\n``` java\npublic class MainActivity extends AppCompatActivity {\n    private User user;\n    public static final int period = 2000;\n    private WeakReference<User> userWeakReference;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        user = new User();\n        userWeakReference = new WeakReference<>(user);\n\n        Observable.interval(period, TimeUnit.MILLISECONDS)\n                .subscribe(new Consumer<Long>() {\n                    @Override\n                    public void accept(Long aLong) throws Exception {\n                        Log.d(\"gc\", String.format(\"user is %s null\", (null == user) ? \"\" : \"not\") +\n                                String.format(\" ****\" +\n                                        \" userWeakReference.get() is %s null\", (null == userWeakReference.get()) ? \"\" : \"not\"));\n                    }\n                });\n\n    }\n\n    public void putnull(View view) {\n        Log.i(\"gc\", \"============ user = null ==============\");\n        user = null;\n    }\n\n    public void excutegc(View view) {\n        Log.i(\"gc\", \"========== gc done =============\");\n        System.runFinalization();\n        System.gc();\n\n    }\n}\n```\n<!-- more -->\n我们不妨先看下打印日志![打印日志](谈谈GC和引用/gc.png)\n当`user`为空的时候, `userWeakReference.get()`不为空, 直到GC以后, 才为空.\n## 对象的初始化\n这个问题的道理其实很简单.首先我们来看下下面代码的含义\n``` java\nUser user = new User();\n```\n当虚拟机遇到一条`new`指令的时候, 在类加载检查通过以后, 会为新生对象分配内存, 然后将分配到的内存空间都初始化为零值, 然后通过对象头(Object Header)对对象进行一些必要的设置(譬如对象GC分代年龄等等), 最后, 把对象按照程序员的意愿进行初始化(执行`<init>`方法), 这个时候, 从Java程序角度上来讲, 一个新的对象就产生了.而`user`这个引用变量通过`=`指向的就是这个新生成的对象的内存地址.\n\n需要注意的是, 真正的对象是`new User()`, 而`user`表示的是引用.\n\n这时候当我们执行下面的代码\n``` java\nuser = null;\n```\n`null`既不是对象, 也不是类型, 它是一种特殊的值, 这里可以表示为`user`引用没有指向任何对象.但是从内存分配上来说, `new User()`这个对象仍然存在, 只是没有引用指向它.\n``` java\n/**\n     * Returns this reference object's referent.  If this reference object has\n     * been cleared, either by the program or by the garbage collector, then\n     * this method returns <code>null</code>.\n     *\n     * @return   The object to which this reference refers, or\n     *           <code>null</code> if this reference object has been cleared\n     */\n    public T get() {\n        return getReferent();\n    }\n```\n然后我们看下`Reference.get()`返回的是什么, 这个源码的注释给了我们答案, 它指向目标引用地址.那么我们就可以解释, 为什么`user`为空的时候, `userWeakReference.get()`仍然不为空.\n## GC\n我们先复习下GC的一些基础知识\n### 如何判断对象可回收\n在当前常用的虚拟机, 都是使用`可达性分析算法`, 通过可达判断(`GC Root`作为起始点, 引用链向下搜索, 如果对象和GC Root之前没有引用链, 则认为不可达, 即GC可回收)GC是否可以回收.`GC Roots`的对象可包括以下几种:\n- 虚拟机栈中引用的对象\n- 方法区中类静态属性引用的对象\n- 方法区中常量引用的对象\n- 本地方法栈中JNI(Native方法)引用的对象\n\n### 引用级别\n同样, 我们在看下`WeakReference`是什么. 在判断对象的引用链是否可达的时候, 我们都需要用到引用.引用级别可分为四层, 引用强度分别自强到弱\n- 强引用: 代码中最常见的, 譬如上面的`user`就是强引用, 强引用只要存在, GC就永远不会回收它\n- 软引用`SoftReference`: 软引用只有在内存不足时, GC才会回收. 当要发生OOM的时候, GC会把这些对象列进回收范围进行第二次回收, 如果这次回收后还是没有足够的内存, 则会报OOM\n- 弱引用`WeakReference`: 无论内存是否足够, GC肯定会回收. 所以弱引用关联的对象无法存活到下一次GC.`LeakCanary`就是通过使用`WeakReference`和引用队列通过二次回收判定来判断是否存在内存泄漏.\n- 虚引用`PhantomReference`:最弱的一种引用关系, 一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响, 也无法通过虚引用来取得一个对象实例。他存在的唯一目的即是能在这个对象被收集器回收时受到一个系统通知.\n\n## 结论\n  由此可以理解, 当发生GC时, `WeakReference`引用相关的对象就不会再存活, 这也是为什么,上面的代码里, 要等到GC发生后`userWeakReference.get()`才为空.\n\n  从这个问题我们引申出来的还是比较基础的东西, 不过不妨碍我们再去做一次巩固.\n","slug":"谈谈GC和引用","published":1,"updated":"2018-05-07T02:02:39.127Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh7fldib000d8os6vj4y3erv","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>A拿了一串代码和<a href=\"http://www.cnblogs.com/absfree/p/5555687.html\" target=\"_blank\" rel=\"noopener\">一篇文章</a>来问我,</p>\n<pre><code>...当productA变为null时（表明它所引用的Product已经无需存在于内存中），这时指向这个Product对象的就是由弱引用对象weakProductA了，那么显然这时候相应的Product对象时弱可达的，\n所以指向它的弱引用会被清除，这个Product对象随即会被回收，指向它的弱引用对象会进入引用队列中。\n</code></pre><p>根据文章上述引用内容, 当他在执行下文代码的<code>putnull</code>方法时, 为什么<code>userWeakReference.get()</code>对象不为null, 难道<code>userWeakReference.get()</code> 和 <code>user</code> 不是一个对象吗?<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> User user;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> period = <span class=\"number\">2000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> WeakReference&lt;User&gt; userWeakReference;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\"></span><br><span class=\"line\">        user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">        userWeakReference = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(user);</span><br><span class=\"line\"></span><br><span class=\"line\">        Observable.interval(period, TimeUnit.MILLISECONDS)</span><br><span class=\"line\">                .subscribe(<span class=\"keyword\">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Long aLong)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                        Log.d(<span class=\"string\">\"gc\"</span>, String.format(<span class=\"string\">\"user is %s null\"</span>, (<span class=\"keyword\">null</span> == user) ? <span class=\"string\">\"\"</span> : <span class=\"string\">\"not\"</span>) +</span><br><span class=\"line\">                                String.format(<span class=\"string\">\" ****\"</span> +</span><br><span class=\"line\">                                        <span class=\"string\">\" userWeakReference.get() is %s null\"</span>, (<span class=\"keyword\">null</span> == userWeakReference.get()) ? <span class=\"string\">\"\"</span> : <span class=\"string\">\"not\"</span>));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putnull</span><span class=\"params\">(View view)</span> </span>&#123;</span><br><span class=\"line\">        Log.i(<span class=\"string\">\"gc\"</span>, <span class=\"string\">\"============ user = null ==============\"</span>);</span><br><span class=\"line\">        user = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">excutegc</span><span class=\"params\">(View view)</span> </span>&#123;</span><br><span class=\"line\">        Log.i(<span class=\"string\">\"gc\"</span>, <span class=\"string\">\"========== gc done =============\"</span>);</span><br><span class=\"line\">        System.runFinalization();</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>我们不妨先看下打印日志<img src=\"谈谈GC和引用/gc.png\" alt=\"打印日志\"><br>当<code>user</code>为空的时候, <code>userWeakReference.get()</code>不为空, 直到GC以后, 才为空.</p>\n<h2 id=\"对象的初始化\"><a href=\"#对象的初始化\" class=\"headerlink\" title=\"对象的初始化\"></a>对象的初始化</h2><p>这个问题的道理其实很简单.首先我们来看下下面代码的含义<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">User user = <span class=\"keyword\">new</span> User();</span><br></pre></td></tr></table></figure></p>\n<p>当虚拟机遇到一条<code>new</code>指令的时候, 在类加载检查通过以后, 会为新生对象分配内存, 然后将分配到的内存空间都初始化为零值, 然后通过对象头(Object Header)对对象进行一些必要的设置(譬如对象GC分代年龄等等), 最后, 把对象按照程序员的意愿进行初始化(执行<code>&lt;init&gt;</code>方法), 这个时候, 从Java程序角度上来讲, 一个新的对象就产生了.而<code>user</code>这个引用变量通过<code>=</code>指向的就是这个新生成的对象的内存地址.</p>\n<p>需要注意的是, 真正的对象是<code>new User()</code>, 而<code>user</code>表示的是引用.</p>\n<p>这时候当我们执行下面的代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure></p>\n<p><code>null</code>既不是对象, 也不是类型, 它是一种特殊的值, 这里可以表示为<code>user</code>引用没有指向任何对象.但是从内存分配上来说, <code>new User()</code>这个对象仍然存在, 只是没有引用指向它.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns this reference object's referent.  If this reference object has</span></span><br><span class=\"line\"><span class=\"comment\">     * been cleared, either by the program or by the garbage collector, then</span></span><br><span class=\"line\"><span class=\"comment\">     * this method returns &lt;code&gt;null&lt;/code&gt;.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span>   The object to which this reference refers, or</span></span><br><span class=\"line\"><span class=\"comment\">     *           &lt;code&gt;null&lt;/code&gt; if this reference object has been cleared</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getReferent();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后我们看下<code>Reference.get()</code>返回的是什么, 这个源码的注释给了我们答案, 它指向目标引用地址.那么我们就可以解释, 为什么<code>user</code>为空的时候, <code>userWeakReference.get()</code>仍然不为空.</p>\n<h2 id=\"GC\"><a href=\"#GC\" class=\"headerlink\" title=\"GC\"></a>GC</h2><p>我们先复习下GC的一些基础知识</p>\n<h3 id=\"如何判断对象可回收\"><a href=\"#如何判断对象可回收\" class=\"headerlink\" title=\"如何判断对象可回收\"></a>如何判断对象可回收</h3><p>在当前常用的虚拟机, 都是使用<code>可达性分析算法</code>, 通过可达判断(<code>GC Root</code>作为起始点, 引用链向下搜索, 如果对象和GC Root之前没有引用链, 则认为不可达, 即GC可回收)GC是否可以回收.<code>GC Roots</code>的对象可包括以下几种:</p>\n<ul>\n<li>虚拟机栈中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中JNI(Native方法)引用的对象</li>\n</ul>\n<h3 id=\"引用级别\"><a href=\"#引用级别\" class=\"headerlink\" title=\"引用级别\"></a>引用级别</h3><p>同样, 我们在看下<code>WeakReference</code>是什么. 在判断对象的引用链是否可达的时候, 我们都需要用到引用.引用级别可分为四层, 引用强度分别自强到弱</p>\n<ul>\n<li>强引用: 代码中最常见的, 譬如上面的<code>user</code>就是强引用, 强引用只要存在, GC就永远不会回收它</li>\n<li>软引用<code>SoftReference</code>: 软引用只有在内存不足时, GC才会回收. 当要发生OOM的时候, GC会把这些对象列进回收范围进行第二次回收, 如果这次回收后还是没有足够的内存, 则会报OOM</li>\n<li>弱引用<code>WeakReference</code>: 无论内存是否足够, GC肯定会回收. 所以弱引用关联的对象无法存活到下一次GC.<code>LeakCanary</code>就是通过使用<code>WeakReference</code>和引用队列通过二次回收判定来判断是否存在内存泄漏.</li>\n<li>虚引用<code>PhantomReference</code>:最弱的一种引用关系, 一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响, 也无法通过虚引用来取得一个对象实例。他存在的唯一目的即是能在这个对象被收集器回收时受到一个系统通知.</li>\n</ul>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>  由此可以理解, 当发生GC时, <code>WeakReference</code>引用相关的对象就不会再存活, 这也是为什么,上面的代码里, 要等到GC发生后<code>userWeakReference.get()</code>才为空.</p>\n<p>  从这个问题我们引申出来的还是比较基础的东西, 不过不妨碍我们再去做一次巩固.</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>A拿了一串代码和<a href=\"http://www.cnblogs.com/absfree/p/5555687.html\" target=\"_blank\" rel=\"noopener\">一篇文章</a>来问我,</p>\n<pre><code>...当productA变为null时（表明它所引用的Product已经无需存在于内存中），这时指向这个Product对象的就是由弱引用对象weakProductA了，那么显然这时候相应的Product对象时弱可达的，\n所以指向它的弱引用会被清除，这个Product对象随即会被回收，指向它的弱引用对象会进入引用队列中。\n</code></pre><p>根据文章上述引用内容, 当他在执行下文代码的<code>putnull</code>方法时, 为什么<code>userWeakReference.get()</code>对象不为null, 难道<code>userWeakReference.get()</code> 和 <code>user</code> 不是一个对象吗?<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> User user;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> period = <span class=\"number\">2000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> WeakReference&lt;User&gt; userWeakReference;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\"></span><br><span class=\"line\">        user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">        userWeakReference = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(user);</span><br><span class=\"line\"></span><br><span class=\"line\">        Observable.interval(period, TimeUnit.MILLISECONDS)</span><br><span class=\"line\">                .subscribe(<span class=\"keyword\">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Long aLong)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                        Log.d(<span class=\"string\">\"gc\"</span>, String.format(<span class=\"string\">\"user is %s null\"</span>, (<span class=\"keyword\">null</span> == user) ? <span class=\"string\">\"\"</span> : <span class=\"string\">\"not\"</span>) +</span><br><span class=\"line\">                                String.format(<span class=\"string\">\" ****\"</span> +</span><br><span class=\"line\">                                        <span class=\"string\">\" userWeakReference.get() is %s null\"</span>, (<span class=\"keyword\">null</span> == userWeakReference.get()) ? <span class=\"string\">\"\"</span> : <span class=\"string\">\"not\"</span>));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putnull</span><span class=\"params\">(View view)</span> </span>&#123;</span><br><span class=\"line\">        Log.i(<span class=\"string\">\"gc\"</span>, <span class=\"string\">\"============ user = null ==============\"</span>);</span><br><span class=\"line\">        user = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">excutegc</span><span class=\"params\">(View view)</span> </span>&#123;</span><br><span class=\"line\">        Log.i(<span class=\"string\">\"gc\"</span>, <span class=\"string\">\"========== gc done =============\"</span>);</span><br><span class=\"line\">        System.runFinalization();</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>","more":"<p>我们不妨先看下打印日志<img src=\"谈谈GC和引用/gc.png\" alt=\"打印日志\"><br>当<code>user</code>为空的时候, <code>userWeakReference.get()</code>不为空, 直到GC以后, 才为空.</p>\n<h2 id=\"对象的初始化\"><a href=\"#对象的初始化\" class=\"headerlink\" title=\"对象的初始化\"></a>对象的初始化</h2><p>这个问题的道理其实很简单.首先我们来看下下面代码的含义<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">User user = <span class=\"keyword\">new</span> User();</span><br></pre></td></tr></table></figure></p>\n<p>当虚拟机遇到一条<code>new</code>指令的时候, 在类加载检查通过以后, 会为新生对象分配内存, 然后将分配到的内存空间都初始化为零值, 然后通过对象头(Object Header)对对象进行一些必要的设置(譬如对象GC分代年龄等等), 最后, 把对象按照程序员的意愿进行初始化(执行<code>&lt;init&gt;</code>方法), 这个时候, 从Java程序角度上来讲, 一个新的对象就产生了.而<code>user</code>这个引用变量通过<code>=</code>指向的就是这个新生成的对象的内存地址.</p>\n<p>需要注意的是, 真正的对象是<code>new User()</code>, 而<code>user</code>表示的是引用.</p>\n<p>这时候当我们执行下面的代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure></p>\n<p><code>null</code>既不是对象, 也不是类型, 它是一种特殊的值, 这里可以表示为<code>user</code>引用没有指向任何对象.但是从内存分配上来说, <code>new User()</code>这个对象仍然存在, 只是没有引用指向它.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns this reference object's referent.  If this reference object has</span></span><br><span class=\"line\"><span class=\"comment\">     * been cleared, either by the program or by the garbage collector, then</span></span><br><span class=\"line\"><span class=\"comment\">     * this method returns &lt;code&gt;null&lt;/code&gt;.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span>   The object to which this reference refers, or</span></span><br><span class=\"line\"><span class=\"comment\">     *           &lt;code&gt;null&lt;/code&gt; if this reference object has been cleared</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getReferent();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后我们看下<code>Reference.get()</code>返回的是什么, 这个源码的注释给了我们答案, 它指向目标引用地址.那么我们就可以解释, 为什么<code>user</code>为空的时候, <code>userWeakReference.get()</code>仍然不为空.</p>\n<h2 id=\"GC\"><a href=\"#GC\" class=\"headerlink\" title=\"GC\"></a>GC</h2><p>我们先复习下GC的一些基础知识</p>\n<h3 id=\"如何判断对象可回收\"><a href=\"#如何判断对象可回收\" class=\"headerlink\" title=\"如何判断对象可回收\"></a>如何判断对象可回收</h3><p>在当前常用的虚拟机, 都是使用<code>可达性分析算法</code>, 通过可达判断(<code>GC Root</code>作为起始点, 引用链向下搜索, 如果对象和GC Root之前没有引用链, 则认为不可达, 即GC可回收)GC是否可以回收.<code>GC Roots</code>的对象可包括以下几种:</p>\n<ul>\n<li>虚拟机栈中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中JNI(Native方法)引用的对象</li>\n</ul>\n<h3 id=\"引用级别\"><a href=\"#引用级别\" class=\"headerlink\" title=\"引用级别\"></a>引用级别</h3><p>同样, 我们在看下<code>WeakReference</code>是什么. 在判断对象的引用链是否可达的时候, 我们都需要用到引用.引用级别可分为四层, 引用强度分别自强到弱</p>\n<ul>\n<li>强引用: 代码中最常见的, 譬如上面的<code>user</code>就是强引用, 强引用只要存在, GC就永远不会回收它</li>\n<li>软引用<code>SoftReference</code>: 软引用只有在内存不足时, GC才会回收. 当要发生OOM的时候, GC会把这些对象列进回收范围进行第二次回收, 如果这次回收后还是没有足够的内存, 则会报OOM</li>\n<li>弱引用<code>WeakReference</code>: 无论内存是否足够, GC肯定会回收. 所以弱引用关联的对象无法存活到下一次GC.<code>LeakCanary</code>就是通过使用<code>WeakReference</code>和引用队列通过二次回收判定来判断是否存在内存泄漏.</li>\n<li>虚引用<code>PhantomReference</code>:最弱的一种引用关系, 一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响, 也无法通过虚引用来取得一个对象实例。他存在的唯一目的即是能在这个对象被收集器回收时受到一个系统通知.</li>\n</ul>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>  由此可以理解, 当发生GC时, <code>WeakReference</code>引用相关的对象就不会再存活, 这也是为什么,上面的代码里, 要等到GC发生后<code>userWeakReference.get()</code>才为空.</p>\n<p>  从这个问题我们引申出来的还是比较基础的东西, 不过不妨碍我们再去做一次巩固.</p>"},{"title":"ArrayList源码解析","date":"2018-04-25T16:00:00.000Z","_content":"## 前言\n每个`ArrayList`都有一个容量(capacity)的含义, 他接近于本身队列长度大小, 基本每个元素在新增的时候,都可以做到自动扩容.本篇主要是了解他的扩容机制.本篇源码以openjdk8为准\n<!-- more -->\n## 构造\n`ArrayList`实现了`Serializable`接口, 说明它是支持序列化的, 在它的内部有个`elementData`数组对象元素用来实现内存中的元素缓存, 它的长度相当于就是ArrayList的长度.这里有个关于`transient`关键字的知识点, 它保证了`elementData`不会被序列化, 使得它的生命周期保在调用者的内存中而不会被保存在磁盘中.\n``` java\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable{\n          transient Object[] elementData;\n        }\n```\n首先我们看下, 日常开发中我们最常用到的无参构造函数, 它主要做的就是将`elementData`引用指向默认静态的一个空数组.\n``` java\npublic ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n```\n还有其他的两个构造函数, 一个是可以初始定义队列的容量, 当传入的`initialCapacity`为负数的时候, 会抛出异常.要注意的是, 当定义的初始容量为0的时候, `elementData`指向的是另外一个空数组`EMPTY_ELEMENTDATA`, 具体为什么要区分两个静态空数组实例, 留在后面的扩容机制上说明.\n``` java\npublic ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n```\n最后一个构造函数式可以直接传集合进去, `elementData`引用指向传入的集合数组, 当集合长度为`0`的时候, 仍然会使它指向 `EMPTY_ELEMENTDATA`空数组.而当传入的集合有元素的情况下, 从注释上看是为了处理6260652的bug, 所以需要判断不是`Object[]`的情况下的时候, 使用`Arrays`内部实现的拷贝的方法`copyOf`进行元素的拷贝.\n``` java\n    public ArrayList(Collection<? extends E> c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n```\n具体我们可以稍微看下`Arrays.copyOf`的源码, 后面会发现他是内部核心调用方法, 可以看出每次调用的时候, 实际是实例化了一个新的数组, 将原来的数组元素填充进去实现了copy的目的.\n``` java\npublic static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {\n        @SuppressWarnings(\"unchecked\")\n        T[] copy = ((Object)newType == (Object)Object[].class)\n            ? (T[]) new Object[newLength]\n            : (T[]) Array.newInstance(newType.getComponentType(), newLength);\n        System.arraycopy(original, 0, copy, 0,\n                         Math.min(original.length, newLength));\n        return copy;\n    }\n```\n## add\n我们首先看下几个add的方法, 其实内部实现的原理都不会错过扩容的操作, 所以我们具体看下扩容的原理.\n``` java\npublic boolean add(E e) {\n        // size为arrayList的长度大小\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        elementData[size++] = e;\n        return true;\n    }\n\npublic void add(int index, E element) {\n    if (index > size || index < 0)\n        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n\n    // 容量确保\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    // 空出index位, 进行拷贝\n    System.arraycopy(elementData, index, elementData, index + 1,\n                     size - index);\n    // 根据索引获取数组index位进行赋值\n    elementData[index] = element;\n    // 长度 + 1\n    size++;\n}\n```\n首先, 每次都需要调用到`ensureCapacityInternal`, 进行容量的确定\n``` java\n/**\n     * 确保内部容量大小\n     * @param minCapacity\n     */\n    private void ensureCapacityInternal(int minCapacity) {\n        // 当调用ArrayList()构造函数, 内部维护的数组是DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n        // 则minCapacity = 10\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n        // minCapacity为10 或者为 size + 1\n        ensureExplicitCapacity(minCapacity);\n    }\n```\n这里可以看到, 当内部管理数组`elementData`指向内存地址与`DEFAULTCAPACITY_EMPTY_ELEMENTDATA`默认空数组实例相等的时候, 最小的容量会以传入的最小容量和默认容量(10)的最大值为准, 同时, 这里可以了解到, 区分两个空数组的实例, 就是为了扩容的时候确定容量的时候, 可以区分到调用无参构造函数的arrayList, 在第一次添加元素的时候, 可以保证他的容量首先是10(`DEFAULT_CAPACITY`)).然后再是调用到`ensureExplicitCapacity`方法.\n``` java\nprivate void ensureExplicitCapacity(int minCapacity) {\n        // 操作数记录\n        modCount++;\n\n        // overflow-conscious code\n        // 如果 当前数组的长度比添加元素后的长度要小则进行扩容\n        if (minCapacity - elementData.length > 0)\n            grow(minCapacity);\n    }\n```\n当内部当前管理的数组`elementData`的长度小于添加元素后的长度, 则需要进行真正的扩容方法`grow`\n\n可以看到, 每次容量是根据原来容量的1.5倍来扩充的, 当扩充后的容量仍然没有加入新元素后的长度大的时候, 那么直接扩容到加入后的长度.\n\n而实现扩容的真正机制, 其实还是调用了`Arrays.copyOf`方法, 声明了目标容量的数组, 进行元素拷贝. 这样的话, 其实每次`ArrayList`的内部元素变化的时候, 都会存在相对的内存开销.\n``` java\n/**\n     * 将原来的数组, 拷贝到一个扩容后新长度的数组内\n     * Increases the capacity to ensure that it can hold at least the\n     * number of elements specified by the minimum capacity argument.\n     *\n     * @param minCapacity the desired minimum capacity\n     */\n    private void grow(int minCapacity) {\n        // overflow-conscious code\n        int oldCapacity = elementData.length;\n        // oldCapacity >> 1 相当于 oldCapacity / 2\n        // 新容量为老容量的1.5倍\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        // 如果扩容后容量比添加元素后的长度小\n        if (newCapacity - minCapacity < 0)\n            // 直接扩容到添加元素后的长度大小\n            newCapacity = minCapacity;\n        // 新容量大小比 MAX_ARRAY_SIZE 大\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        // 构建newCapacity长度的新数组, elementData指向它\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\nprivate static int hugeCapacity(int minCapacity) {\n    if (minCapacity < 0) // overflow\n        throw new OutOfMemoryError();\n    // 如果是添加元素后的长度大于 MAX_ARRAY_SIZE, 则容量设为Integer的最大. 否则 -8\n    return (minCapacity > MAX_ARRAY_SIZE) ?\n        Integer.MAX_VALUE :\n        MAX_ARRAY_SIZE;\n}\n```\n## remove\n搞懂扩容机制后, 我们可以对应看下其他我们常用的API, 首先看下`remove`相关, 可以看出在移除元素的时候, 其实实际上我们还是做了个拷贝的动作, 将除去移除目标元素的数组其他元素, 拷贝到新的数组中, 同时, 这个时候容量其实是没有变的.\n``` java\npublic E remove(int index) {\n        if (index >= size)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n\n        modCount++;\n        E oldValue = (E) elementData[index];\n\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n\n        return oldValue;\n    }\n\npublic boolean remove(Object o) {\n        if (o == null) {\n            for (int index = 0; index < size; index++)\n                if (elementData[index] == null) {\n                    fastRemove(index);\n                    return true;\n                }\n        } else {\n            for (int index = 0; index < size; index++)\n                if (o.equals(elementData[index])) {\n                    fastRemove(index);\n                    return true;\n                }\n        }\n        return false;\n    }\nprivate void fastRemove(int index) {\n    // 操作数的新增\n    modCount++;\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        System.arraycopy(elementData, index+1, elementData, index,\n                         numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n}\n```\n## 其他\n我们在看下`get`和`contains`是怎么实现的\n``` java\npublic E get(int index) {\n        if (index >= size)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n\n        return (E) elementData[index];\n    }\n```\n可以看到`get`的方法, 实际就是对于内部数组的索引查找\n``` java\npublic boolean contains(Object o) {\n        return indexOf(o) >= 0;\n    }\n\npublic int indexOf(Object o) {\n    if (o == null) {\n        for (int i = 0; i < size; i++)\n            if (elementData[i]==null)\n                return i;\n    } else {\n        for (int i = 0; i < size; i++)\n            if (o.equals(elementData[i]))\n                return i;\n    }\n    return -1;\n}\n```\n而`contains(Object o)`方法其实做的就是对内部数组进行遍历查找.\n## 总结\n考量到使用无参构造函数的时候, 当添加元素的时候, 初始容量为10, 以10为基准进行1.5倍的扩容, 通过源码的解读, 我们可以就可以进行一定的内存优化, 譬如在使用ArrayList的时候, 就应该避免使用无参构造函数, 尽量多的给它定义明确的初始容量, 一个是可以导致不会有过多的内存空间被浪费, 另外一个是可以减少调用到`System.arraycopy`native方法, 保证了一定的内存开销的节省.\n","source":"_posts/ArrayList源码解析.md","raw":"title: ArrayList源码解析\ndate: 2018-04-26 00:00:00\ncategories:  \n- 源码解析\ntags:\n- Java\n- 源码解析\n---\n## 前言\n每个`ArrayList`都有一个容量(capacity)的含义, 他接近于本身队列长度大小, 基本每个元素在新增的时候,都可以做到自动扩容.本篇主要是了解他的扩容机制.本篇源码以openjdk8为准\n<!-- more -->\n## 构造\n`ArrayList`实现了`Serializable`接口, 说明它是支持序列化的, 在它的内部有个`elementData`数组对象元素用来实现内存中的元素缓存, 它的长度相当于就是ArrayList的长度.这里有个关于`transient`关键字的知识点, 它保证了`elementData`不会被序列化, 使得它的生命周期保在调用者的内存中而不会被保存在磁盘中.\n``` java\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable{\n          transient Object[] elementData;\n        }\n```\n首先我们看下, 日常开发中我们最常用到的无参构造函数, 它主要做的就是将`elementData`引用指向默认静态的一个空数组.\n``` java\npublic ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n```\n还有其他的两个构造函数, 一个是可以初始定义队列的容量, 当传入的`initialCapacity`为负数的时候, 会抛出异常.要注意的是, 当定义的初始容量为0的时候, `elementData`指向的是另外一个空数组`EMPTY_ELEMENTDATA`, 具体为什么要区分两个静态空数组实例, 留在后面的扩容机制上说明.\n``` java\npublic ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n```\n最后一个构造函数式可以直接传集合进去, `elementData`引用指向传入的集合数组, 当集合长度为`0`的时候, 仍然会使它指向 `EMPTY_ELEMENTDATA`空数组.而当传入的集合有元素的情况下, 从注释上看是为了处理6260652的bug, 所以需要判断不是`Object[]`的情况下的时候, 使用`Arrays`内部实现的拷贝的方法`copyOf`进行元素的拷贝.\n``` java\n    public ArrayList(Collection<? extends E> c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n```\n具体我们可以稍微看下`Arrays.copyOf`的源码, 后面会发现他是内部核心调用方法, 可以看出每次调用的时候, 实际是实例化了一个新的数组, 将原来的数组元素填充进去实现了copy的目的.\n``` java\npublic static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {\n        @SuppressWarnings(\"unchecked\")\n        T[] copy = ((Object)newType == (Object)Object[].class)\n            ? (T[]) new Object[newLength]\n            : (T[]) Array.newInstance(newType.getComponentType(), newLength);\n        System.arraycopy(original, 0, copy, 0,\n                         Math.min(original.length, newLength));\n        return copy;\n    }\n```\n## add\n我们首先看下几个add的方法, 其实内部实现的原理都不会错过扩容的操作, 所以我们具体看下扩容的原理.\n``` java\npublic boolean add(E e) {\n        // size为arrayList的长度大小\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        elementData[size++] = e;\n        return true;\n    }\n\npublic void add(int index, E element) {\n    if (index > size || index < 0)\n        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n\n    // 容量确保\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    // 空出index位, 进行拷贝\n    System.arraycopy(elementData, index, elementData, index + 1,\n                     size - index);\n    // 根据索引获取数组index位进行赋值\n    elementData[index] = element;\n    // 长度 + 1\n    size++;\n}\n```\n首先, 每次都需要调用到`ensureCapacityInternal`, 进行容量的确定\n``` java\n/**\n     * 确保内部容量大小\n     * @param minCapacity\n     */\n    private void ensureCapacityInternal(int minCapacity) {\n        // 当调用ArrayList()构造函数, 内部维护的数组是DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n        // 则minCapacity = 10\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n        // minCapacity为10 或者为 size + 1\n        ensureExplicitCapacity(minCapacity);\n    }\n```\n这里可以看到, 当内部管理数组`elementData`指向内存地址与`DEFAULTCAPACITY_EMPTY_ELEMENTDATA`默认空数组实例相等的时候, 最小的容量会以传入的最小容量和默认容量(10)的最大值为准, 同时, 这里可以了解到, 区分两个空数组的实例, 就是为了扩容的时候确定容量的时候, 可以区分到调用无参构造函数的arrayList, 在第一次添加元素的时候, 可以保证他的容量首先是10(`DEFAULT_CAPACITY`)).然后再是调用到`ensureExplicitCapacity`方法.\n``` java\nprivate void ensureExplicitCapacity(int minCapacity) {\n        // 操作数记录\n        modCount++;\n\n        // overflow-conscious code\n        // 如果 当前数组的长度比添加元素后的长度要小则进行扩容\n        if (minCapacity - elementData.length > 0)\n            grow(minCapacity);\n    }\n```\n当内部当前管理的数组`elementData`的长度小于添加元素后的长度, 则需要进行真正的扩容方法`grow`\n\n可以看到, 每次容量是根据原来容量的1.5倍来扩充的, 当扩充后的容量仍然没有加入新元素后的长度大的时候, 那么直接扩容到加入后的长度.\n\n而实现扩容的真正机制, 其实还是调用了`Arrays.copyOf`方法, 声明了目标容量的数组, 进行元素拷贝. 这样的话, 其实每次`ArrayList`的内部元素变化的时候, 都会存在相对的内存开销.\n``` java\n/**\n     * 将原来的数组, 拷贝到一个扩容后新长度的数组内\n     * Increases the capacity to ensure that it can hold at least the\n     * number of elements specified by the minimum capacity argument.\n     *\n     * @param minCapacity the desired minimum capacity\n     */\n    private void grow(int minCapacity) {\n        // overflow-conscious code\n        int oldCapacity = elementData.length;\n        // oldCapacity >> 1 相当于 oldCapacity / 2\n        // 新容量为老容量的1.5倍\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        // 如果扩容后容量比添加元素后的长度小\n        if (newCapacity - minCapacity < 0)\n            // 直接扩容到添加元素后的长度大小\n            newCapacity = minCapacity;\n        // 新容量大小比 MAX_ARRAY_SIZE 大\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        // 构建newCapacity长度的新数组, elementData指向它\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\nprivate static int hugeCapacity(int minCapacity) {\n    if (minCapacity < 0) // overflow\n        throw new OutOfMemoryError();\n    // 如果是添加元素后的长度大于 MAX_ARRAY_SIZE, 则容量设为Integer的最大. 否则 -8\n    return (minCapacity > MAX_ARRAY_SIZE) ?\n        Integer.MAX_VALUE :\n        MAX_ARRAY_SIZE;\n}\n```\n## remove\n搞懂扩容机制后, 我们可以对应看下其他我们常用的API, 首先看下`remove`相关, 可以看出在移除元素的时候, 其实实际上我们还是做了个拷贝的动作, 将除去移除目标元素的数组其他元素, 拷贝到新的数组中, 同时, 这个时候容量其实是没有变的.\n``` java\npublic E remove(int index) {\n        if (index >= size)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n\n        modCount++;\n        E oldValue = (E) elementData[index];\n\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n\n        return oldValue;\n    }\n\npublic boolean remove(Object o) {\n        if (o == null) {\n            for (int index = 0; index < size; index++)\n                if (elementData[index] == null) {\n                    fastRemove(index);\n                    return true;\n                }\n        } else {\n            for (int index = 0; index < size; index++)\n                if (o.equals(elementData[index])) {\n                    fastRemove(index);\n                    return true;\n                }\n        }\n        return false;\n    }\nprivate void fastRemove(int index) {\n    // 操作数的新增\n    modCount++;\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        System.arraycopy(elementData, index+1, elementData, index,\n                         numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n}\n```\n## 其他\n我们在看下`get`和`contains`是怎么实现的\n``` java\npublic E get(int index) {\n        if (index >= size)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n\n        return (E) elementData[index];\n    }\n```\n可以看到`get`的方法, 实际就是对于内部数组的索引查找\n``` java\npublic boolean contains(Object o) {\n        return indexOf(o) >= 0;\n    }\n\npublic int indexOf(Object o) {\n    if (o == null) {\n        for (int i = 0; i < size; i++)\n            if (elementData[i]==null)\n                return i;\n    } else {\n        for (int i = 0; i < size; i++)\n            if (o.equals(elementData[i]))\n                return i;\n    }\n    return -1;\n}\n```\n而`contains(Object o)`方法其实做的就是对内部数组进行遍历查找.\n## 总结\n考量到使用无参构造函数的时候, 当添加元素的时候, 初始容量为10, 以10为基准进行1.5倍的扩容, 通过源码的解读, 我们可以就可以进行一定的内存优化, 譬如在使用ArrayList的时候, 就应该避免使用无参构造函数, 尽量多的给它定义明确的初始容量, 一个是可以导致不会有过多的内存空间被浪费, 另外一个是可以减少调用到`System.arraycopy`native方法, 保证了一定的内存开销的节省.\n","slug":"ArrayList源码解析","published":1,"updated":"2018-05-07T02:04:20.166Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh7fldn900148os6tr0uvmbk","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>每个<code>ArrayList</code>都有一个容量(capacity)的含义, 他接近于本身队列长度大小, 基本每个元素在新增的时候,都可以做到自动扩容.本篇主要是了解他的扩容机制.本篇源码以openjdk8为准<br><a id=\"more\"></a></p>\n<h2 id=\"构造\"><a href=\"#构造\" class=\"headerlink\" title=\"构造\"></a>构造</h2><p><code>ArrayList</code>实现了<code>Serializable</code>接口, 说明它是支持序列化的, 在它的内部有个<code>elementData</code>数组对象元素用来实现内存中的元素缓存, 它的长度相当于就是ArrayList的长度.这里有个关于<code>transient</code>关键字的知识点, 它保证了<code>elementData</code>不会被序列化, 使得它的生命周期保在调用者的内存中而不会被保存在磁盘中.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">RandomAccess</span>, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">transient</span> Object[] elementData;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先我们看下, 日常开发中我们最常用到的无参构造函数, 它主要做的就是将<code>elementData</code>引用指向默认静态的一个空数组.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>还有其他的两个构造函数, 一个是可以初始定义队列的容量, 当传入的<code>initialCapacity</code>为负数的时候, 会抛出异常.要注意的是, 当定义的初始容量为0的时候, <code>elementData</code>指向的是另外一个空数组<code>EMPTY_ELEMENTDATA</code>, 具体为什么要区分两个静态空数组实例, 留在后面的扩容机制上说明.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+</span><br><span class=\"line\">                                               initialCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后一个构造函数式可以直接传集合进去, <code>elementData</code>引用指向传入的集合数组, 当集合长度为<code>0</code>的时候, 仍然会使它指向 <code>EMPTY_ELEMENTDATA</code>空数组.而当传入的集合有元素的情况下, 从注释上看是为了处理6260652的bug, 所以需要判断不是<code>Object[]</code>的情况下的时候, 使用<code>Arrays</code>内部实现的拷贝的方法<code>copyOf</code>进行元素的拷贝.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    elementData = c.toArray();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// replace with empty array.</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>具体我们可以稍微看下<code>Arrays.copyOf</code>的源码, 后面会发现他是内部核心调用方法, 可以看出每次调用的时候, 实际是实例化了一个新的数组, 将原来的数组元素填充进去实现了copy的目的.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class=\"keyword\">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">        T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class=\"line\">            ? (T[]) <span class=\"keyword\">new</span> Object[newLength]</span><br><span class=\"line\">            : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class=\"line\">        System.arraycopy(original, <span class=\"number\">0</span>, copy, <span class=\"number\">0</span>,</span><br><span class=\"line\">                         Math.min(original.length, newLength));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> copy;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add\"></a>add</h2><p>我们首先看下几个add的方法, 其实内部实现的原理都不会错过扩容的操作, 所以我们具体看下扩容的原理.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// size为arrayList的长度大小</span></span><br><span class=\"line\">        ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">        elementData[size++] = e;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt; size || index &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 容量确保</span></span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    <span class=\"comment\">// 空出index位, 进行拷贝</span></span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>,</span><br><span class=\"line\">                     size - index);</span><br><span class=\"line\">    <span class=\"comment\">// 根据索引获取数组index位进行赋值</span></span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    <span class=\"comment\">// 长度 + 1</span></span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先, 每次都需要调用到<code>ensureCapacityInternal</code>, 进行容量的确定<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 确保内部容量大小</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> minCapacity</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当调用ArrayList()构造函数, 内部维护的数组是DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class=\"line\">        <span class=\"comment\">// 则minCapacity = 10</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// minCapacity为10 或者为 size + 1</span></span><br><span class=\"line\">        ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里可以看到, 当内部管理数组<code>elementData</code>指向内存地址与<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>默认空数组实例相等的时候, 最小的容量会以传入的最小容量和默认容量(10)的最大值为准, 同时, 这里可以了解到, 区分两个空数组的实例, 就是为了扩容的时候确定容量的时候, 可以区分到调用无参构造函数的arrayList, 在第一次添加元素的时候, 可以保证他的容量首先是10(<code>DEFAULT_CAPACITY</code>)).然后再是调用到<code>ensureExplicitCapacity</code>方法.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 操作数记录</span></span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果 当前数组的长度比添加元素后的长度要小则进行扩容</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            grow(minCapacity);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>当内部当前管理的数组<code>elementData</code>的长度小于添加元素后的长度, 则需要进行真正的扩容方法<code>grow</code></p>\n<p>可以看到, 每次容量是根据原来容量的1.5倍来扩充的, 当扩充后的容量仍然没有加入新元素后的长度大的时候, 那么直接扩容到加入后的长度.</p>\n<p>而实现扩容的真正机制, 其实还是调用了<code>Arrays.copyOf</code>方法, 声明了目标容量的数组, 进行元素拷贝. 这样的话, 其实每次<code>ArrayList</code>的内部元素变化的时候, 都会存在相对的内存开销.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将原来的数组, 拷贝到一个扩容后新长度的数组内</span></span><br><span class=\"line\"><span class=\"comment\">     * Increases the capacity to ensure that it can hold at least the</span></span><br><span class=\"line\"><span class=\"comment\">     * number of elements specified by the minimum capacity argument.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> minCapacity the desired minimum capacity</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">        <span class=\"comment\">// oldCapacity &gt;&gt; 1 相当于 oldCapacity / 2</span></span><br><span class=\"line\">        <span class=\"comment\">// 新容量为老容量的1.5倍</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 如果扩容后容量比添加元素后的长度小</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\">// 直接扩容到添加元素后的长度大小</span></span><br><span class=\"line\">            newCapacity = minCapacity;</span><br><span class=\"line\">        <span class=\"comment\">// 新容量大小比 MAX_ARRAY_SIZE 大</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">        <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">        <span class=\"comment\">// 构建newCapacity长度的新数组, elementData指向它</span></span><br><span class=\"line\">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();</span><br><span class=\"line\">    <span class=\"comment\">// 如果是添加元素后的长度大于 MAX_ARRAY_SIZE, 则容量设为Integer的最大. 否则 -8</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">        Integer.MAX_VALUE :</span><br><span class=\"line\">        MAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove\"></a>remove</h2><p>搞懂扩容机制后, 我们可以对应看下其他我们常用的API, 首先看下<code>remove</code>相关, 可以看出在移除元素的时候, 其实实际上我们还是做了个拷贝的动作, 将除去移除目标元素的数组其他元素, 拷贝到新的数组中, 同时, 这个时候容量其实是没有变的.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt;= size)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\"></span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        E oldValue = (E) elementData[index];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                             numMoved);</span><br><span class=\"line\">        elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (elementData[index] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    fastRemove(index);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(elementData[index])) &#123;</span><br><span class=\"line\">                    fastRemove(index);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fastRemove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 操作数的新增</span></span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                         numMoved);</span><br><span class=\"line\">    elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>我们在看下<code>get</code>和<code>contains</code>是怎么实现的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt;= size)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (E) elementData[index];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到<code>get</code>的方法, 实际就是对于内部数组的索引查找<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> indexOf(o) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elementData[i]==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(elementData[i]))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>而<code>contains(Object o)</code>方法其实做的就是对内部数组进行遍历查找.</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>考量到使用无参构造函数的时候, 当添加元素的时候, 初始容量为10, 以10为基准进行1.5倍的扩容, 通过源码的解读, 我们可以就可以进行一定的内存优化, 譬如在使用ArrayList的时候, 就应该避免使用无参构造函数, 尽量多的给它定义明确的初始容量, 一个是可以导致不会有过多的内存空间被浪费, 另外一个是可以减少调用到<code>System.arraycopy</code>native方法, 保证了一定的内存开销的节省.</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>每个<code>ArrayList</code>都有一个容量(capacity)的含义, 他接近于本身队列长度大小, 基本每个元素在新增的时候,都可以做到自动扩容.本篇主要是了解他的扩容机制.本篇源码以openjdk8为准<br>","more":"</p>\n<h2 id=\"构造\"><a href=\"#构造\" class=\"headerlink\" title=\"构造\"></a>构造</h2><p><code>ArrayList</code>实现了<code>Serializable</code>接口, 说明它是支持序列化的, 在它的内部有个<code>elementData</code>数组对象元素用来实现内存中的元素缓存, 它的长度相当于就是ArrayList的长度.这里有个关于<code>transient</code>关键字的知识点, 它保证了<code>elementData</code>不会被序列化, 使得它的生命周期保在调用者的内存中而不会被保存在磁盘中.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">RandomAccess</span>, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">transient</span> Object[] elementData;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先我们看下, 日常开发中我们最常用到的无参构造函数, 它主要做的就是将<code>elementData</code>引用指向默认静态的一个空数组.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>还有其他的两个构造函数, 一个是可以初始定义队列的容量, 当传入的<code>initialCapacity</code>为负数的时候, 会抛出异常.要注意的是, 当定义的初始容量为0的时候, <code>elementData</code>指向的是另外一个空数组<code>EMPTY_ELEMENTDATA</code>, 具体为什么要区分两个静态空数组实例, 留在后面的扩容机制上说明.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+</span><br><span class=\"line\">                                               initialCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后一个构造函数式可以直接传集合进去, <code>elementData</code>引用指向传入的集合数组, 当集合长度为<code>0</code>的时候, 仍然会使它指向 <code>EMPTY_ELEMENTDATA</code>空数组.而当传入的集合有元素的情况下, 从注释上看是为了处理6260652的bug, 所以需要判断不是<code>Object[]</code>的情况下的时候, 使用<code>Arrays</code>内部实现的拷贝的方法<code>copyOf</code>进行元素的拷贝.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    elementData = c.toArray();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// replace with empty array.</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>具体我们可以稍微看下<code>Arrays.copyOf</code>的源码, 后面会发现他是内部核心调用方法, 可以看出每次调用的时候, 实际是实例化了一个新的数组, 将原来的数组元素填充进去实现了copy的目的.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class=\"keyword\">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">        T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class=\"line\">            ? (T[]) <span class=\"keyword\">new</span> Object[newLength]</span><br><span class=\"line\">            : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class=\"line\">        System.arraycopy(original, <span class=\"number\">0</span>, copy, <span class=\"number\">0</span>,</span><br><span class=\"line\">                         Math.min(original.length, newLength));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> copy;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add\"></a>add</h2><p>我们首先看下几个add的方法, 其实内部实现的原理都不会错过扩容的操作, 所以我们具体看下扩容的原理.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// size为arrayList的长度大小</span></span><br><span class=\"line\">        ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">        elementData[size++] = e;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt; size || index &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 容量确保</span></span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    <span class=\"comment\">// 空出index位, 进行拷贝</span></span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>,</span><br><span class=\"line\">                     size - index);</span><br><span class=\"line\">    <span class=\"comment\">// 根据索引获取数组index位进行赋值</span></span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    <span class=\"comment\">// 长度 + 1</span></span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先, 每次都需要调用到<code>ensureCapacityInternal</code>, 进行容量的确定<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 确保内部容量大小</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> minCapacity</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当调用ArrayList()构造函数, 内部维护的数组是DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class=\"line\">        <span class=\"comment\">// 则minCapacity = 10</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// minCapacity为10 或者为 size + 1</span></span><br><span class=\"line\">        ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里可以看到, 当内部管理数组<code>elementData</code>指向内存地址与<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>默认空数组实例相等的时候, 最小的容量会以传入的最小容量和默认容量(10)的最大值为准, 同时, 这里可以了解到, 区分两个空数组的实例, 就是为了扩容的时候确定容量的时候, 可以区分到调用无参构造函数的arrayList, 在第一次添加元素的时候, 可以保证他的容量首先是10(<code>DEFAULT_CAPACITY</code>)).然后再是调用到<code>ensureExplicitCapacity</code>方法.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 操作数记录</span></span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果 当前数组的长度比添加元素后的长度要小则进行扩容</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            grow(minCapacity);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>当内部当前管理的数组<code>elementData</code>的长度小于添加元素后的长度, 则需要进行真正的扩容方法<code>grow</code></p>\n<p>可以看到, 每次容量是根据原来容量的1.5倍来扩充的, 当扩充后的容量仍然没有加入新元素后的长度大的时候, 那么直接扩容到加入后的长度.</p>\n<p>而实现扩容的真正机制, 其实还是调用了<code>Arrays.copyOf</code>方法, 声明了目标容量的数组, 进行元素拷贝. 这样的话, 其实每次<code>ArrayList</code>的内部元素变化的时候, 都会存在相对的内存开销.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将原来的数组, 拷贝到一个扩容后新长度的数组内</span></span><br><span class=\"line\"><span class=\"comment\">     * Increases the capacity to ensure that it can hold at least the</span></span><br><span class=\"line\"><span class=\"comment\">     * number of elements specified by the minimum capacity argument.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> minCapacity the desired minimum capacity</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">        <span class=\"comment\">// oldCapacity &gt;&gt; 1 相当于 oldCapacity / 2</span></span><br><span class=\"line\">        <span class=\"comment\">// 新容量为老容量的1.5倍</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 如果扩容后容量比添加元素后的长度小</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\">// 直接扩容到添加元素后的长度大小</span></span><br><span class=\"line\">            newCapacity = minCapacity;</span><br><span class=\"line\">        <span class=\"comment\">// 新容量大小比 MAX_ARRAY_SIZE 大</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">        <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">        <span class=\"comment\">// 构建newCapacity长度的新数组, elementData指向它</span></span><br><span class=\"line\">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();</span><br><span class=\"line\">    <span class=\"comment\">// 如果是添加元素后的长度大于 MAX_ARRAY_SIZE, 则容量设为Integer的最大. 否则 -8</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">        Integer.MAX_VALUE :</span><br><span class=\"line\">        MAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove\"></a>remove</h2><p>搞懂扩容机制后, 我们可以对应看下其他我们常用的API, 首先看下<code>remove</code>相关, 可以看出在移除元素的时候, 其实实际上我们还是做了个拷贝的动作, 将除去移除目标元素的数组其他元素, 拷贝到新的数组中, 同时, 这个时候容量其实是没有变的.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt;= size)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\"></span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        E oldValue = (E) elementData[index];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                             numMoved);</span><br><span class=\"line\">        elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (elementData[index] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    fastRemove(index);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(elementData[index])) &#123;</span><br><span class=\"line\">                    fastRemove(index);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fastRemove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 操作数的新增</span></span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                         numMoved);</span><br><span class=\"line\">    elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>我们在看下<code>get</code>和<code>contains</code>是怎么实现的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt;= size)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (E) elementData[index];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到<code>get</code>的方法, 实际就是对于内部数组的索引查找<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> indexOf(o) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elementData[i]==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(elementData[i]))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>而<code>contains(Object o)</code>方法其实做的就是对内部数组进行遍历查找.</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>考量到使用无参构造函数的时候, 当添加元素的时候, 初始容量为10, 以10为基准进行1.5倍的扩容, 通过源码的解读, 我们可以就可以进行一定的内存优化, 譬如在使用ArrayList的时候, 就应该避免使用无参构造函数, 尽量多的给它定义明确的初始容量, 一个是可以导致不会有过多的内存空间被浪费, 另外一个是可以减少调用到<code>System.arraycopy</code>native方法, 保证了一定的内存开销的节省.</p>"},{"title":"Glide源码解析","date":"2017-12-21T16:00:00.000Z","_content":"基于v4最新版本的Glide解析, 从最开始的简单加载开始看源码, 仅作个人记录.\n<!-- more -->\n一个Glide加载图片的核心用法如下:\n``` java\nGlideApp.with(this)\n                .load(uri)\n                .into(imageViewLookup);\n```\n我们通过一步步链式调用进去查看\n## Glide.with : 同步生命周期\n``` java\nprivate RequestManager supportFragmentGet(@NonNull Context context, @NonNull FragmentManager fm,\n      @Nullable Fragment parentHint) {\n    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);\n    RequestManager requestManager = current.getRequestManager();\n    if (requestManager == null) {\n      Glide glide = Glide.get(context);\n      requestManager =\n          factory.build(\n              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);\n      current.setRequestManager(requestManager);\n    }\n    return requestManager;\n  }\n```\n通过`getSupportRequestManagerFragment(final FragmentManager fm, Fragment parentHint)`方法调用, 在`Glide.with(context)`中传入的组件中,\n新增一个子Fragment, 这个Fragment类根据传入的是`support.fragment`或者是`fragment`来决定是`RequestManagerFragment`还是`SupportRequestManagerFragment`,然后通过`current.SupportRequestManagerFragment()` 将Glide的生命周期与这个子fragment的声明周期绑定, 实现了组件与Glide加载同步的功能\n## 图片的加载\n我们通过暴露的into的API跳进去, 最终到了`RequestBuilder.into(@NonNull Y target, @Nullable RequestListener<TranscodeType> targetListener, @NonNull RequestOptions options)`, 详细代码如下:\n``` java\nprivate <Y extends Target<TranscodeType>> Y into(\n      @NonNull Y target,\n      @Nullable RequestListener<TranscodeType> targetListener,\n      @NonNull RequestOptions options) {\n    // 判断是否在主线程\n    Util.assertMainThread();\n    // target是否为空判断\n    Preconditions.checkNotNull(target);\n    // load()方法是否已经被调用, 如果没被调用, 则将抛出异常\n    if (!isModelSet) {\n      throw new IllegalArgumentException(\"You must call #load() before calling #into()\");\n    }\n    options = options.autoClone();\n    // 创建请求\n    Request request = buildRequest(target, targetListener, options);\n    // 获取target当前的请求\n    Request previous = target.getRequest();\n    // 如果请求相同, 而且当前请求设置可以使用内存缓存\n    // 则请求回收\n    if (request.isEquivalentTo(previous)\n        && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {\n      request.recycle();\n      // If the request is completed, beginning again will ensure the result is re-delivered,\n      // triggering RequestListeners and Targets. If the request is failed, beginning again will\n      // restart the request, giving it another chance to complete. If the request is already\n      // running, we can let it continue running without interruption.\n      // 如果当前请求不在执行, 则会重新开始请求\n      if (!Preconditions.checkNotNull(previous).isRunning()) {\n        // Use the previous request rather than the new one to allow for optimizations like skipping\n        // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions\n        // that are done in the individual Request.\n        previous.begin();\n      }\n      return target;\n    }\n    requestManager.clear(target);\n    target.setRequest(request);\n    // 请求追踪\n    requestManager.track(target, request);\n\n    return target;\n  }\n```\n然后通过`requestManager.track()`发起Request执行, 如果当前状态(`status`)既不是`RUNNING`也不是`COMPLETE`, 则会执行`onSizeReady`, 到这里直到`Engine.load()`才开始资源的加载, 相关的代码及注释如下:\n``` java\npublic <R> LoadStatus load(\n      GlideContext glideContext,\n      Object model,\n      Key signature,\n      int width,\n      int height,\n      Class<?> resourceClass,\n      Class<R> transcodeClass,\n      Priority priority,\n      DiskCacheStrategy diskCacheStrategy,\n      Map<Class<?>, Transformation<?>> transformations,\n      boolean isTransformationRequired,\n      boolean isScaleOnlyOrNoTransform,\n      Options options,\n      boolean isMemoryCacheable,\n      boolean useUnlimitedSourceExecutorPool,\n      boolean useAnimationPool,\n      boolean onlyRetrieveFromCache,\n      ResourceCallback cb) {\n    Util.assertMainThread();\n    long startTime = LogTime.getLogTime();\n    // 创建缓存key\n    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,\n        resourceClass, transcodeClass, options);\n\n    // 从存活资源内读取数据, 内部缓存由value为弱引用对象的map做管理, 做手动的计数管理\n    // 当资源计数为0时, 则回收\n    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);\n    if (active != null) {\n      // 如果命中, 则回调加载\n      cb.onResourceReady(active, DataSource.MEMORY_CACHE);\n      if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logWithTimeAndKey(\"Loaded resource from active resources\", startTime, key);\n      }\n      return null;\n    }\n\n    // 获取内存缓存数据\n    // 当内存缓存中有命中, 则删除Cache, 并将目标资源加到activeResources中\n    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);\n    if (cached != null) {\n      // 如果命中, 则回调加载\n      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);\n      if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logWithTimeAndKey(\"Loaded resource from cache\", startTime, key);\n      }\n      return null;\n    }\n    //  EngineJob : 调度DecodeJob，添加，移除资源回调，并notify回调\n    EngineJob<?> current = jobs.get(key, onlyRetrieveFromCache);\n    // 当前存活的资源和内存缓存都没有的情况下\n    // 1. 先判断是否有资源(resouce什么时候回调true 不明), 如果有, 则回调加载\n    // 2. 如果加载失败, 则加载抛出异常\n    // 3. 否则, 在资源回调中添加\n    if (current != null) {\n      current.addCallback(cb);\n      if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logWithTimeAndKey(\"Added to existing load\", startTime, key);\n      }\n      // 返回当前的LoadStatus\n      return new LoadStatus(cb, current);\n    }\n    // 当资源回调中都没有的情况\n    EngineJob<R> engineJob =\n        engineJobFactory.build(\n            key,\n            isMemoryCacheable,\n            useUnlimitedSourceExecutorPool,\n            useAnimationPool,\n            onlyRetrieveFromCache);\n\n    // 实现了Runnable接口，调度任务的核心类，整个请求的繁重工作都在这里完成：处理来自缓存或者原始的资源，应用转换动画以及transcode。\n    // 负责根据缓存类型获取不同的Generator加载数据，数据加载成功后回调DecodeJob的onDataFetcherReady方法对资源进行处理\n    DecodeJob<R> decodeJob =\n        decodeJobFactory.build(\n            glideContext,\n            model,\n            key,\n            signature,\n            width,\n            height,\n            resourceClass,\n            transcodeClass,\n            priority,\n            diskCacheStrategy,\n            transformations,\n            isTransformationRequired,\n            isScaleOnlyOrNoTransform,\n            onlyRetrieveFromCache,\n            options,\n            engineJob);\n\n    jobs.put(key, engineJob);\n\n    engineJob.addCallback(cb);\n    engineJob.start(decodeJob);\n\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n      logWithTimeAndKey(\"Started new load\", startTime, key);\n    }\n    return new LoadStatus(cb, engineJob);\n  }\n```\n这里的流程图可以看下图:\n![Engine.load()流程图](Glide源码解析1/glide_load时序图.png)\n## 资源图片的缓存\n当无法再当前存活的资源以及缓存内找到对应key的资源时, 会通过`engineJob`开始执行`decodeJob`, 所以我们可以直接看`decodeJob`的`run()`.\n``` java\n/**\n   * 根据不同的runReason执行不同任务\n   */\n  private void runWrapped() {\n     switch (runReason) {\n       // 首次请求时\n      case INITIALIZE:\n        stage = getNextStage(Stage.INITIALIZE);\n        currentGenerator = getNextGenerator();\n        // load数据\n        runGenerators();\n        break;\n      case SWITCH_TO_SOURCE_SERVICE:\n        // load数据\n        runGenerators();\n        break;\n      case DECODE_DATA:\n        // 数据处理\n        decodeFromRetrievedData();\n        break;\n      default:\n        throw new IllegalStateException(\"Unrecognized run reason: \" + runReason);\n    }\n  }\n```\n核心的执行流程如下代码:\n``` java\n/**\n   * 执行Generators\n   */\n  private void runGenerators() {\n    // 获取当前线程\n    currentThread = Thread.currentThread();\n    startFetchTime = LogTime.getLogTime();\n    boolean isStarted = false;\n    // currentGenerator.startNext() : 从当前策略对应的Generator获取数据，数据获取成功则回调DecodeJob的onDataFetcherReady对资源进行处理。否则尝试从下一个策略的Generator获取数据\n    while (!isCancelled && currentGenerator != null\n        && !(isStarted = currentGenerator.startNext())) {\n      stage = getNextStage(stage);\n      // 根据Stage获取到相应的Generator后会执行currentGenerator.startNext()，如果中途startNext返回true，则直接回调，否则最终会得到SOURCE的stage，重新调度任务\n      currentGenerator = getNextGenerator();\n\n      if (stage == Stage.SOURCE) {\n        // 重新调度当前任务\n        reschedule();\n        return;\n      }\n    }\n    // We've run out of stages and generators, give up.\n    if ((stage == Stage.FINISHED || isCancelled) && !isStarted) {\n      notifyFailed();\n    }\n\n    // Otherwise a generator started a new load and we expect to be called back in\n    // onDataFetcherReady.\n  }\n```\n我们看下DecodeJob的执行流程\n![decodeJob执行流程](Glide源码解析1/decodeJob流程图.png)\n## 总结\n到这里, 整体的流程大致是搞清楚了, 至于说是缓存的原理机制, 在之前`Engine.load()`的方法内, 删除缓存的方法进去可以看到一个`LruCache`的类文件, 从名字可以推断是Glide自己实现的`Lru算法`作为缓存的处理, 关于Lru的算法原理, 在本篇内就不再做赘述了, 而`ActiveCache`用到了`引用计数`算法.\nGlide用到了大量的抽象工厂类, 另外方法内经常是包括了十来个参数, 在阅读的经过上还是有点困难(对我而言).\n相应的代码注释可看[Github上我补充的注释](https://github.com/YuTianTina/glide)\n","source":"_posts/Glide源码解析1.md","raw":"title: Glide源码解析\ndate: 2017-12-22 00:00:00\ncategories:\n- android学习记录\n- 源码解析\ntags:\n- android\n- Glide\n- 源码解析\n---\n基于v4最新版本的Glide解析, 从最开始的简单加载开始看源码, 仅作个人记录.\n<!-- more -->\n一个Glide加载图片的核心用法如下:\n``` java\nGlideApp.with(this)\n                .load(uri)\n                .into(imageViewLookup);\n```\n我们通过一步步链式调用进去查看\n## Glide.with : 同步生命周期\n``` java\nprivate RequestManager supportFragmentGet(@NonNull Context context, @NonNull FragmentManager fm,\n      @Nullable Fragment parentHint) {\n    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);\n    RequestManager requestManager = current.getRequestManager();\n    if (requestManager == null) {\n      Glide glide = Glide.get(context);\n      requestManager =\n          factory.build(\n              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);\n      current.setRequestManager(requestManager);\n    }\n    return requestManager;\n  }\n```\n通过`getSupportRequestManagerFragment(final FragmentManager fm, Fragment parentHint)`方法调用, 在`Glide.with(context)`中传入的组件中,\n新增一个子Fragment, 这个Fragment类根据传入的是`support.fragment`或者是`fragment`来决定是`RequestManagerFragment`还是`SupportRequestManagerFragment`,然后通过`current.SupportRequestManagerFragment()` 将Glide的生命周期与这个子fragment的声明周期绑定, 实现了组件与Glide加载同步的功能\n## 图片的加载\n我们通过暴露的into的API跳进去, 最终到了`RequestBuilder.into(@NonNull Y target, @Nullable RequestListener<TranscodeType> targetListener, @NonNull RequestOptions options)`, 详细代码如下:\n``` java\nprivate <Y extends Target<TranscodeType>> Y into(\n      @NonNull Y target,\n      @Nullable RequestListener<TranscodeType> targetListener,\n      @NonNull RequestOptions options) {\n    // 判断是否在主线程\n    Util.assertMainThread();\n    // target是否为空判断\n    Preconditions.checkNotNull(target);\n    // load()方法是否已经被调用, 如果没被调用, 则将抛出异常\n    if (!isModelSet) {\n      throw new IllegalArgumentException(\"You must call #load() before calling #into()\");\n    }\n    options = options.autoClone();\n    // 创建请求\n    Request request = buildRequest(target, targetListener, options);\n    // 获取target当前的请求\n    Request previous = target.getRequest();\n    // 如果请求相同, 而且当前请求设置可以使用内存缓存\n    // 则请求回收\n    if (request.isEquivalentTo(previous)\n        && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {\n      request.recycle();\n      // If the request is completed, beginning again will ensure the result is re-delivered,\n      // triggering RequestListeners and Targets. If the request is failed, beginning again will\n      // restart the request, giving it another chance to complete. If the request is already\n      // running, we can let it continue running without interruption.\n      // 如果当前请求不在执行, 则会重新开始请求\n      if (!Preconditions.checkNotNull(previous).isRunning()) {\n        // Use the previous request rather than the new one to allow for optimizations like skipping\n        // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions\n        // that are done in the individual Request.\n        previous.begin();\n      }\n      return target;\n    }\n    requestManager.clear(target);\n    target.setRequest(request);\n    // 请求追踪\n    requestManager.track(target, request);\n\n    return target;\n  }\n```\n然后通过`requestManager.track()`发起Request执行, 如果当前状态(`status`)既不是`RUNNING`也不是`COMPLETE`, 则会执行`onSizeReady`, 到这里直到`Engine.load()`才开始资源的加载, 相关的代码及注释如下:\n``` java\npublic <R> LoadStatus load(\n      GlideContext glideContext,\n      Object model,\n      Key signature,\n      int width,\n      int height,\n      Class<?> resourceClass,\n      Class<R> transcodeClass,\n      Priority priority,\n      DiskCacheStrategy diskCacheStrategy,\n      Map<Class<?>, Transformation<?>> transformations,\n      boolean isTransformationRequired,\n      boolean isScaleOnlyOrNoTransform,\n      Options options,\n      boolean isMemoryCacheable,\n      boolean useUnlimitedSourceExecutorPool,\n      boolean useAnimationPool,\n      boolean onlyRetrieveFromCache,\n      ResourceCallback cb) {\n    Util.assertMainThread();\n    long startTime = LogTime.getLogTime();\n    // 创建缓存key\n    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,\n        resourceClass, transcodeClass, options);\n\n    // 从存活资源内读取数据, 内部缓存由value为弱引用对象的map做管理, 做手动的计数管理\n    // 当资源计数为0时, 则回收\n    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);\n    if (active != null) {\n      // 如果命中, 则回调加载\n      cb.onResourceReady(active, DataSource.MEMORY_CACHE);\n      if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logWithTimeAndKey(\"Loaded resource from active resources\", startTime, key);\n      }\n      return null;\n    }\n\n    // 获取内存缓存数据\n    // 当内存缓存中有命中, 则删除Cache, 并将目标资源加到activeResources中\n    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);\n    if (cached != null) {\n      // 如果命中, 则回调加载\n      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);\n      if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logWithTimeAndKey(\"Loaded resource from cache\", startTime, key);\n      }\n      return null;\n    }\n    //  EngineJob : 调度DecodeJob，添加，移除资源回调，并notify回调\n    EngineJob<?> current = jobs.get(key, onlyRetrieveFromCache);\n    // 当前存活的资源和内存缓存都没有的情况下\n    // 1. 先判断是否有资源(resouce什么时候回调true 不明), 如果有, 则回调加载\n    // 2. 如果加载失败, 则加载抛出异常\n    // 3. 否则, 在资源回调中添加\n    if (current != null) {\n      current.addCallback(cb);\n      if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logWithTimeAndKey(\"Added to existing load\", startTime, key);\n      }\n      // 返回当前的LoadStatus\n      return new LoadStatus(cb, current);\n    }\n    // 当资源回调中都没有的情况\n    EngineJob<R> engineJob =\n        engineJobFactory.build(\n            key,\n            isMemoryCacheable,\n            useUnlimitedSourceExecutorPool,\n            useAnimationPool,\n            onlyRetrieveFromCache);\n\n    // 实现了Runnable接口，调度任务的核心类，整个请求的繁重工作都在这里完成：处理来自缓存或者原始的资源，应用转换动画以及transcode。\n    // 负责根据缓存类型获取不同的Generator加载数据，数据加载成功后回调DecodeJob的onDataFetcherReady方法对资源进行处理\n    DecodeJob<R> decodeJob =\n        decodeJobFactory.build(\n            glideContext,\n            model,\n            key,\n            signature,\n            width,\n            height,\n            resourceClass,\n            transcodeClass,\n            priority,\n            diskCacheStrategy,\n            transformations,\n            isTransformationRequired,\n            isScaleOnlyOrNoTransform,\n            onlyRetrieveFromCache,\n            options,\n            engineJob);\n\n    jobs.put(key, engineJob);\n\n    engineJob.addCallback(cb);\n    engineJob.start(decodeJob);\n\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n      logWithTimeAndKey(\"Started new load\", startTime, key);\n    }\n    return new LoadStatus(cb, engineJob);\n  }\n```\n这里的流程图可以看下图:\n![Engine.load()流程图](Glide源码解析1/glide_load时序图.png)\n## 资源图片的缓存\n当无法再当前存活的资源以及缓存内找到对应key的资源时, 会通过`engineJob`开始执行`decodeJob`, 所以我们可以直接看`decodeJob`的`run()`.\n``` java\n/**\n   * 根据不同的runReason执行不同任务\n   */\n  private void runWrapped() {\n     switch (runReason) {\n       // 首次请求时\n      case INITIALIZE:\n        stage = getNextStage(Stage.INITIALIZE);\n        currentGenerator = getNextGenerator();\n        // load数据\n        runGenerators();\n        break;\n      case SWITCH_TO_SOURCE_SERVICE:\n        // load数据\n        runGenerators();\n        break;\n      case DECODE_DATA:\n        // 数据处理\n        decodeFromRetrievedData();\n        break;\n      default:\n        throw new IllegalStateException(\"Unrecognized run reason: \" + runReason);\n    }\n  }\n```\n核心的执行流程如下代码:\n``` java\n/**\n   * 执行Generators\n   */\n  private void runGenerators() {\n    // 获取当前线程\n    currentThread = Thread.currentThread();\n    startFetchTime = LogTime.getLogTime();\n    boolean isStarted = false;\n    // currentGenerator.startNext() : 从当前策略对应的Generator获取数据，数据获取成功则回调DecodeJob的onDataFetcherReady对资源进行处理。否则尝试从下一个策略的Generator获取数据\n    while (!isCancelled && currentGenerator != null\n        && !(isStarted = currentGenerator.startNext())) {\n      stage = getNextStage(stage);\n      // 根据Stage获取到相应的Generator后会执行currentGenerator.startNext()，如果中途startNext返回true，则直接回调，否则最终会得到SOURCE的stage，重新调度任务\n      currentGenerator = getNextGenerator();\n\n      if (stage == Stage.SOURCE) {\n        // 重新调度当前任务\n        reschedule();\n        return;\n      }\n    }\n    // We've run out of stages and generators, give up.\n    if ((stage == Stage.FINISHED || isCancelled) && !isStarted) {\n      notifyFailed();\n    }\n\n    // Otherwise a generator started a new load and we expect to be called back in\n    // onDataFetcherReady.\n  }\n```\n我们看下DecodeJob的执行流程\n![decodeJob执行流程](Glide源码解析1/decodeJob流程图.png)\n## 总结\n到这里, 整体的流程大致是搞清楚了, 至于说是缓存的原理机制, 在之前`Engine.load()`的方法内, 删除缓存的方法进去可以看到一个`LruCache`的类文件, 从名字可以推断是Glide自己实现的`Lru算法`作为缓存的处理, 关于Lru的算法原理, 在本篇内就不再做赘述了, 而`ActiveCache`用到了`引用计数`算法.\nGlide用到了大量的抽象工厂类, 另外方法内经常是包括了十来个参数, 在阅读的经过上还是有点困难(对我而言).\n相应的代码注释可看[Github上我补充的注释](https://github.com/YuTianTina/glide)\n","slug":"Glide源码解析1","published":1,"updated":"2018-05-07T02:01:54.186Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh7fldnc00168os66wenr26j","content":"<p>基于v4最新版本的Glide解析, 从最开始的简单加载开始看源码, 仅作个人记录.<br><a id=\"more\"></a><br>一个Glide加载图片的核心用法如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlideApp.with(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">                .load(uri)</span><br><span class=\"line\">                .into(imageViewLookup);</span><br></pre></td></tr></table></figure></p>\n<p>我们通过一步步链式调用进去查看</p>\n<h2 id=\"Glide-with-同步生命周期\"><a href=\"#Glide-with-同步生命周期\" class=\"headerlink\" title=\"Glide.with : 同步生命周期\"></a>Glide.with : 同步生命周期</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> RequestManager <span class=\"title\">supportFragmentGet</span><span class=\"params\">(@NonNull Context context, @NonNull FragmentManager fm,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      @Nullable Fragment parentHint)</span> </span>&#123;</span><br><span class=\"line\">    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);</span><br><span class=\"line\">    RequestManager requestManager = current.getRequestManager();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (requestManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      Glide glide = Glide.get(context);</span><br><span class=\"line\">      requestManager =</span><br><span class=\"line\">          factory.build(</span><br><span class=\"line\">              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class=\"line\">      current.setRequestManager(requestManager);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> requestManager;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>通过<code>getSupportRequestManagerFragment(final FragmentManager fm, Fragment parentHint)</code>方法调用, 在<code>Glide.with(context)</code>中传入的组件中,<br>新增一个子Fragment, 这个Fragment类根据传入的是<code>support.fragment</code>或者是<code>fragment</code>来决定是<code>RequestManagerFragment</code>还是<code>SupportRequestManagerFragment</code>,然后通过<code>current.SupportRequestManagerFragment()</code> 将Glide的生命周期与这个子fragment的声明周期绑定, 实现了组件与Glide加载同步的功能</p>\n<h2 id=\"图片的加载\"><a href=\"#图片的加载\" class=\"headerlink\" title=\"图片的加载\"></a>图片的加载</h2><p>我们通过暴露的into的API跳进去, 最终到了<code>RequestBuilder.into(@NonNull Y target, @Nullable RequestListener&lt;TranscodeType&gt; targetListener, @NonNull RequestOptions options)</code>, 详细代码如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class=\"function\">Y <span class=\"title\">into</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      @NonNull Y target,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      @NonNull RequestOptions options)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否在主线程</span></span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    <span class=\"comment\">// target是否为空判断</span></span><br><span class=\"line\">    Preconditions.checkNotNull(target);</span><br><span class=\"line\">    <span class=\"comment\">// load()方法是否已经被调用, 如果没被调用, 则将抛出异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isModelSet) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"You must call #load() before calling #into()\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    options = options.autoClone();</span><br><span class=\"line\">    <span class=\"comment\">// 创建请求</span></span><br><span class=\"line\">    Request request = buildRequest(target, targetListener, options);</span><br><span class=\"line\">    <span class=\"comment\">// 获取target当前的请求</span></span><br><span class=\"line\">    Request previous = target.getRequest();</span><br><span class=\"line\">    <span class=\"comment\">// 如果请求相同, 而且当前请求设置可以使用内存缓存</span></span><br><span class=\"line\">    <span class=\"comment\">// 则请求回收</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (request.isEquivalentTo(previous)</span><br><span class=\"line\">        &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class=\"line\">      request.recycle();</span><br><span class=\"line\">      <span class=\"comment\">// If the request is completed, beginning again will ensure the result is re-delivered,</span></span><br><span class=\"line\">      <span class=\"comment\">// triggering RequestListeners and Targets. If the request is failed, beginning again will</span></span><br><span class=\"line\">      <span class=\"comment\">// restart the request, giving it another chance to complete. If the request is already</span></span><br><span class=\"line\">      <span class=\"comment\">// running, we can let it continue running without interruption.</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果当前请求不在执行, 则会重新开始请求</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Use the previous request rather than the new one to allow for optimizations like skipping</span></span><br><span class=\"line\">        <span class=\"comment\">// setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions</span></span><br><span class=\"line\">        <span class=\"comment\">// that are done in the individual Request.</span></span><br><span class=\"line\">        previous.begin();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    requestManager.clear(target);</span><br><span class=\"line\">    target.setRequest(request);</span><br><span class=\"line\">    <span class=\"comment\">// 请求追踪</span></span><br><span class=\"line\">    requestManager.track(target, request);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后通过<code>requestManager.track()</code>发起Request执行, 如果当前状态(<code>status</code>)既不是<code>RUNNING</code>也不是<code>COMPLETE</code>, 则会执行<code>onSizeReady</code>, 到这里直到<code>Engine.load()</code>才开始资源的加载, 相关的代码及注释如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;R&gt; <span class=\"function\">LoadStatus <span class=\"title\">load</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      GlideContext glideContext,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Object model,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Key signature,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">int</span> width,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">int</span> height,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Class&lt;?&gt; resourceClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Class&lt;R&gt; transcodeClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Priority priority,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      DiskCacheStrategy diskCacheStrategy,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> isTransformationRequired,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> isScaleOnlyOrNoTransform,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Options options,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> isMemoryCacheable,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> useUnlimitedSourceExecutorPool,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> useAnimationPool,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> onlyRetrieveFromCache,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      ResourceCallback cb)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"comment\">// 创建缓存key</span></span><br><span class=\"line\">    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</span><br><span class=\"line\">        resourceClass, transcodeClass, options);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从存活资源内读取数据, 内部缓存由value为弱引用对象的map做管理, 做手动的计数管理</span></span><br><span class=\"line\">    <span class=\"comment\">// 当资源计数为0时, 则回收</span></span><br><span class=\"line\">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (active != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果命中, 则回调加载</span></span><br><span class=\"line\">      cb.onResourceReady(active, DataSource.MEMORY_CACHE);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logWithTimeAndKey(<span class=\"string\">\"Loaded resource from active resources\"</span>, startTime, key);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取内存缓存数据</span></span><br><span class=\"line\">    <span class=\"comment\">// 当内存缓存中有命中, 则删除Cache, 并将目标资源加到activeResources中</span></span><br><span class=\"line\">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cached != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果命中, 则回调加载</span></span><br><span class=\"line\">      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logWithTimeAndKey(<span class=\"string\">\"Loaded resource from cache\"</span>, startTime, key);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//  EngineJob : 调度DecodeJob，添加，移除资源回调，并notify回调</span></span><br><span class=\"line\">    EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class=\"line\">    <span class=\"comment\">// 当前存活的资源和内存缓存都没有的情况下</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. 先判断是否有资源(resouce什么时候回调true 不明), 如果有, 则回调加载</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 如果加载失败, 则加载抛出异常</span></span><br><span class=\"line\">    <span class=\"comment\">// 3. 否则, 在资源回调中添加</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      current.addCallback(cb);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logWithTimeAndKey(<span class=\"string\">\"Added to existing load\"</span>, startTime, key);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 返回当前的LoadStatus</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, current);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当资源回调中都没有的情况</span></span><br><span class=\"line\">    EngineJob&lt;R&gt; engineJob =</span><br><span class=\"line\">        engineJobFactory.build(</span><br><span class=\"line\">            key,</span><br><span class=\"line\">            isMemoryCacheable,</span><br><span class=\"line\">            useUnlimitedSourceExecutorPool,</span><br><span class=\"line\">            useAnimationPool,</span><br><span class=\"line\">            onlyRetrieveFromCache);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现了Runnable接口，调度任务的核心类，整个请求的繁重工作都在这里完成：处理来自缓存或者原始的资源，应用转换动画以及transcode。</span></span><br><span class=\"line\">    <span class=\"comment\">// 负责根据缓存类型获取不同的Generator加载数据，数据加载成功后回调DecodeJob的onDataFetcherReady方法对资源进行处理</span></span><br><span class=\"line\">    DecodeJob&lt;R&gt; decodeJob =</span><br><span class=\"line\">        decodeJobFactory.build(</span><br><span class=\"line\">            glideContext,</span><br><span class=\"line\">            model,</span><br><span class=\"line\">            key,</span><br><span class=\"line\">            signature,</span><br><span class=\"line\">            width,</span><br><span class=\"line\">            height,</span><br><span class=\"line\">            resourceClass,</span><br><span class=\"line\">            transcodeClass,</span><br><span class=\"line\">            priority,</span><br><span class=\"line\">            diskCacheStrategy,</span><br><span class=\"line\">            transformations,</span><br><span class=\"line\">            isTransformationRequired,</span><br><span class=\"line\">            isScaleOnlyOrNoTransform,</span><br><span class=\"line\">            onlyRetrieveFromCache,</span><br><span class=\"line\">            options,</span><br><span class=\"line\">            engineJob);</span><br><span class=\"line\"></span><br><span class=\"line\">    jobs.put(key, engineJob);</span><br><span class=\"line\"></span><br><span class=\"line\">    engineJob.addCallback(cb);</span><br><span class=\"line\">    engineJob.start(decodeJob);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">      logWithTimeAndKey(<span class=\"string\">\"Started new load\"</span>, startTime, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, engineJob);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的流程图可以看下图:<br><img src=\"Glide源码解析1/glide_load时序图.png\" alt=\"Engine.load()流程图\"></p>\n<h2 id=\"资源图片的缓存\"><a href=\"#资源图片的缓存\" class=\"headerlink\" title=\"资源图片的缓存\"></a>资源图片的缓存</h2><p>当无法再当前存活的资源以及缓存内找到对应key的资源时, 会通过<code>engineJob</code>开始执行<code>decodeJob</code>, 所以我们可以直接看<code>decodeJob</code>的<code>run()</code>.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 根据不同的runReason执行不同任务</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">runWrapped</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">switch</span> (runReason) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 首次请求时</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> INITIALIZE:</span><br><span class=\"line\">        stage = getNextStage(Stage.INITIALIZE);</span><br><span class=\"line\">        currentGenerator = getNextGenerator();</span><br><span class=\"line\">        <span class=\"comment\">// load数据</span></span><br><span class=\"line\">        runGenerators();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> SWITCH_TO_SOURCE_SERVICE:</span><br><span class=\"line\">        <span class=\"comment\">// load数据</span></span><br><span class=\"line\">        runGenerators();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> DECODE_DATA:</span><br><span class=\"line\">        <span class=\"comment\">// 数据处理</span></span><br><span class=\"line\">        decodeFromRetrievedData();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Unrecognized run reason: \"</span> + runReason);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>核心的执行流程如下代码:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 执行Generators</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">runGenerators</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前线程</span></span><br><span class=\"line\">    currentThread = Thread.currentThread();</span><br><span class=\"line\">    startFetchTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// currentGenerator.startNext() : 从当前策略对应的Generator获取数据，数据获取成功则回调DecodeJob的onDataFetcherReady对资源进行处理。否则尝试从下一个策略的Generator获取数据</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isCancelled &amp;&amp; currentGenerator != <span class=\"keyword\">null</span></span><br><span class=\"line\">        &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;</span><br><span class=\"line\">      stage = getNextStage(stage);</span><br><span class=\"line\">      <span class=\"comment\">// 根据Stage获取到相应的Generator后会执行currentGenerator.startNext()，如果中途startNext返回true，则直接回调，否则最终会得到SOURCE的stage，重新调度任务</span></span><br><span class=\"line\">      currentGenerator = getNextGenerator();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (stage == Stage.SOURCE) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 重新调度当前任务</span></span><br><span class=\"line\">        reschedule();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// We've run out of stages and generators, give up.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) &#123;</span><br><span class=\"line\">      notifyFailed();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Otherwise a generator started a new load and we expect to be called back in</span></span><br><span class=\"line\">    <span class=\"comment\">// onDataFetcherReady.</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们看下DecodeJob的执行流程<br><img src=\"Glide源码解析1/decodeJob流程图.png\" alt=\"decodeJob执行流程\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>到这里, 整体的流程大致是搞清楚了, 至于说是缓存的原理机制, 在之前<code>Engine.load()</code>的方法内, 删除缓存的方法进去可以看到一个<code>LruCache</code>的类文件, 从名字可以推断是Glide自己实现的<code>Lru算法</code>作为缓存的处理, 关于Lru的算法原理, 在本篇内就不再做赘述了, 而<code>ActiveCache</code>用到了<code>引用计数</code>算法.<br>Glide用到了大量的抽象工厂类, 另外方法内经常是包括了十来个参数, 在阅读的经过上还是有点困难(对我而言).<br>相应的代码注释可看<a href=\"https://github.com/YuTianTina/glide\" target=\"_blank\" rel=\"noopener\">Github上我补充的注释</a></p>\n","site":{"data":{}},"excerpt":"<p>基于v4最新版本的Glide解析, 从最开始的简单加载开始看源码, 仅作个人记录.<br>","more":"<br>一个Glide加载图片的核心用法如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlideApp.with(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">                .load(uri)</span><br><span class=\"line\">                .into(imageViewLookup);</span><br></pre></td></tr></table></figure></p>\n<p>我们通过一步步链式调用进去查看</p>\n<h2 id=\"Glide-with-同步生命周期\"><a href=\"#Glide-with-同步生命周期\" class=\"headerlink\" title=\"Glide.with : 同步生命周期\"></a>Glide.with : 同步生命周期</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> RequestManager <span class=\"title\">supportFragmentGet</span><span class=\"params\">(@NonNull Context context, @NonNull FragmentManager fm,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      @Nullable Fragment parentHint)</span> </span>&#123;</span><br><span class=\"line\">    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);</span><br><span class=\"line\">    RequestManager requestManager = current.getRequestManager();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (requestManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      Glide glide = Glide.get(context);</span><br><span class=\"line\">      requestManager =</span><br><span class=\"line\">          factory.build(</span><br><span class=\"line\">              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class=\"line\">      current.setRequestManager(requestManager);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> requestManager;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>通过<code>getSupportRequestManagerFragment(final FragmentManager fm, Fragment parentHint)</code>方法调用, 在<code>Glide.with(context)</code>中传入的组件中,<br>新增一个子Fragment, 这个Fragment类根据传入的是<code>support.fragment</code>或者是<code>fragment</code>来决定是<code>RequestManagerFragment</code>还是<code>SupportRequestManagerFragment</code>,然后通过<code>current.SupportRequestManagerFragment()</code> 将Glide的生命周期与这个子fragment的声明周期绑定, 实现了组件与Glide加载同步的功能</p>\n<h2 id=\"图片的加载\"><a href=\"#图片的加载\" class=\"headerlink\" title=\"图片的加载\"></a>图片的加载</h2><p>我们通过暴露的into的API跳进去, 最终到了<code>RequestBuilder.into(@NonNull Y target, @Nullable RequestListener&lt;TranscodeType&gt; targetListener, @NonNull RequestOptions options)</code>, 详细代码如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class=\"function\">Y <span class=\"title\">into</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      @NonNull Y target,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      @NonNull RequestOptions options)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否在主线程</span></span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    <span class=\"comment\">// target是否为空判断</span></span><br><span class=\"line\">    Preconditions.checkNotNull(target);</span><br><span class=\"line\">    <span class=\"comment\">// load()方法是否已经被调用, 如果没被调用, 则将抛出异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isModelSet) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"You must call #load() before calling #into()\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    options = options.autoClone();</span><br><span class=\"line\">    <span class=\"comment\">// 创建请求</span></span><br><span class=\"line\">    Request request = buildRequest(target, targetListener, options);</span><br><span class=\"line\">    <span class=\"comment\">// 获取target当前的请求</span></span><br><span class=\"line\">    Request previous = target.getRequest();</span><br><span class=\"line\">    <span class=\"comment\">// 如果请求相同, 而且当前请求设置可以使用内存缓存</span></span><br><span class=\"line\">    <span class=\"comment\">// 则请求回收</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (request.isEquivalentTo(previous)</span><br><span class=\"line\">        &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class=\"line\">      request.recycle();</span><br><span class=\"line\">      <span class=\"comment\">// If the request is completed, beginning again will ensure the result is re-delivered,</span></span><br><span class=\"line\">      <span class=\"comment\">// triggering RequestListeners and Targets. If the request is failed, beginning again will</span></span><br><span class=\"line\">      <span class=\"comment\">// restart the request, giving it another chance to complete. If the request is already</span></span><br><span class=\"line\">      <span class=\"comment\">// running, we can let it continue running without interruption.</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果当前请求不在执行, 则会重新开始请求</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Use the previous request rather than the new one to allow for optimizations like skipping</span></span><br><span class=\"line\">        <span class=\"comment\">// setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions</span></span><br><span class=\"line\">        <span class=\"comment\">// that are done in the individual Request.</span></span><br><span class=\"line\">        previous.begin();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    requestManager.clear(target);</span><br><span class=\"line\">    target.setRequest(request);</span><br><span class=\"line\">    <span class=\"comment\">// 请求追踪</span></span><br><span class=\"line\">    requestManager.track(target, request);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后通过<code>requestManager.track()</code>发起Request执行, 如果当前状态(<code>status</code>)既不是<code>RUNNING</code>也不是<code>COMPLETE</code>, 则会执行<code>onSizeReady</code>, 到这里直到<code>Engine.load()</code>才开始资源的加载, 相关的代码及注释如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;R&gt; <span class=\"function\">LoadStatus <span class=\"title\">load</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      GlideContext glideContext,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Object model,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Key signature,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">int</span> width,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">int</span> height,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Class&lt;?&gt; resourceClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Class&lt;R&gt; transcodeClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Priority priority,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      DiskCacheStrategy diskCacheStrategy,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> isTransformationRequired,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> isScaleOnlyOrNoTransform,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Options options,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> isMemoryCacheable,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> useUnlimitedSourceExecutorPool,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> useAnimationPool,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> onlyRetrieveFromCache,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      ResourceCallback cb)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"comment\">// 创建缓存key</span></span><br><span class=\"line\">    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</span><br><span class=\"line\">        resourceClass, transcodeClass, options);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从存活资源内读取数据, 内部缓存由value为弱引用对象的map做管理, 做手动的计数管理</span></span><br><span class=\"line\">    <span class=\"comment\">// 当资源计数为0时, 则回收</span></span><br><span class=\"line\">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (active != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果命中, 则回调加载</span></span><br><span class=\"line\">      cb.onResourceReady(active, DataSource.MEMORY_CACHE);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logWithTimeAndKey(<span class=\"string\">\"Loaded resource from active resources\"</span>, startTime, key);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取内存缓存数据</span></span><br><span class=\"line\">    <span class=\"comment\">// 当内存缓存中有命中, 则删除Cache, 并将目标资源加到activeResources中</span></span><br><span class=\"line\">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cached != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果命中, 则回调加载</span></span><br><span class=\"line\">      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logWithTimeAndKey(<span class=\"string\">\"Loaded resource from cache\"</span>, startTime, key);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//  EngineJob : 调度DecodeJob，添加，移除资源回调，并notify回调</span></span><br><span class=\"line\">    EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class=\"line\">    <span class=\"comment\">// 当前存活的资源和内存缓存都没有的情况下</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. 先判断是否有资源(resouce什么时候回调true 不明), 如果有, 则回调加载</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 如果加载失败, 则加载抛出异常</span></span><br><span class=\"line\">    <span class=\"comment\">// 3. 否则, 在资源回调中添加</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      current.addCallback(cb);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logWithTimeAndKey(<span class=\"string\">\"Added to existing load\"</span>, startTime, key);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 返回当前的LoadStatus</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, current);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当资源回调中都没有的情况</span></span><br><span class=\"line\">    EngineJob&lt;R&gt; engineJob =</span><br><span class=\"line\">        engineJobFactory.build(</span><br><span class=\"line\">            key,</span><br><span class=\"line\">            isMemoryCacheable,</span><br><span class=\"line\">            useUnlimitedSourceExecutorPool,</span><br><span class=\"line\">            useAnimationPool,</span><br><span class=\"line\">            onlyRetrieveFromCache);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现了Runnable接口，调度任务的核心类，整个请求的繁重工作都在这里完成：处理来自缓存或者原始的资源，应用转换动画以及transcode。</span></span><br><span class=\"line\">    <span class=\"comment\">// 负责根据缓存类型获取不同的Generator加载数据，数据加载成功后回调DecodeJob的onDataFetcherReady方法对资源进行处理</span></span><br><span class=\"line\">    DecodeJob&lt;R&gt; decodeJob =</span><br><span class=\"line\">        decodeJobFactory.build(</span><br><span class=\"line\">            glideContext,</span><br><span class=\"line\">            model,</span><br><span class=\"line\">            key,</span><br><span class=\"line\">            signature,</span><br><span class=\"line\">            width,</span><br><span class=\"line\">            height,</span><br><span class=\"line\">            resourceClass,</span><br><span class=\"line\">            transcodeClass,</span><br><span class=\"line\">            priority,</span><br><span class=\"line\">            diskCacheStrategy,</span><br><span class=\"line\">            transformations,</span><br><span class=\"line\">            isTransformationRequired,</span><br><span class=\"line\">            isScaleOnlyOrNoTransform,</span><br><span class=\"line\">            onlyRetrieveFromCache,</span><br><span class=\"line\">            options,</span><br><span class=\"line\">            engineJob);</span><br><span class=\"line\"></span><br><span class=\"line\">    jobs.put(key, engineJob);</span><br><span class=\"line\"></span><br><span class=\"line\">    engineJob.addCallback(cb);</span><br><span class=\"line\">    engineJob.start(decodeJob);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">      logWithTimeAndKey(<span class=\"string\">\"Started new load\"</span>, startTime, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, engineJob);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的流程图可以看下图:<br><img src=\"Glide源码解析1/glide_load时序图.png\" alt=\"Engine.load()流程图\"></p>\n<h2 id=\"资源图片的缓存\"><a href=\"#资源图片的缓存\" class=\"headerlink\" title=\"资源图片的缓存\"></a>资源图片的缓存</h2><p>当无法再当前存活的资源以及缓存内找到对应key的资源时, 会通过<code>engineJob</code>开始执行<code>decodeJob</code>, 所以我们可以直接看<code>decodeJob</code>的<code>run()</code>.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 根据不同的runReason执行不同任务</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">runWrapped</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">switch</span> (runReason) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 首次请求时</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> INITIALIZE:</span><br><span class=\"line\">        stage = getNextStage(Stage.INITIALIZE);</span><br><span class=\"line\">        currentGenerator = getNextGenerator();</span><br><span class=\"line\">        <span class=\"comment\">// load数据</span></span><br><span class=\"line\">        runGenerators();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> SWITCH_TO_SOURCE_SERVICE:</span><br><span class=\"line\">        <span class=\"comment\">// load数据</span></span><br><span class=\"line\">        runGenerators();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> DECODE_DATA:</span><br><span class=\"line\">        <span class=\"comment\">// 数据处理</span></span><br><span class=\"line\">        decodeFromRetrievedData();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Unrecognized run reason: \"</span> + runReason);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>核心的执行流程如下代码:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 执行Generators</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">runGenerators</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前线程</span></span><br><span class=\"line\">    currentThread = Thread.currentThread();</span><br><span class=\"line\">    startFetchTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// currentGenerator.startNext() : 从当前策略对应的Generator获取数据，数据获取成功则回调DecodeJob的onDataFetcherReady对资源进行处理。否则尝试从下一个策略的Generator获取数据</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isCancelled &amp;&amp; currentGenerator != <span class=\"keyword\">null</span></span><br><span class=\"line\">        &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;</span><br><span class=\"line\">      stage = getNextStage(stage);</span><br><span class=\"line\">      <span class=\"comment\">// 根据Stage获取到相应的Generator后会执行currentGenerator.startNext()，如果中途startNext返回true，则直接回调，否则最终会得到SOURCE的stage，重新调度任务</span></span><br><span class=\"line\">      currentGenerator = getNextGenerator();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (stage == Stage.SOURCE) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 重新调度当前任务</span></span><br><span class=\"line\">        reschedule();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// We've run out of stages and generators, give up.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) &#123;</span><br><span class=\"line\">      notifyFailed();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Otherwise a generator started a new load and we expect to be called back in</span></span><br><span class=\"line\">    <span class=\"comment\">// onDataFetcherReady.</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们看下DecodeJob的执行流程<br><img src=\"Glide源码解析1/decodeJob流程图.png\" alt=\"decodeJob执行流程\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>到这里, 整体的流程大致是搞清楚了, 至于说是缓存的原理机制, 在之前<code>Engine.load()</code>的方法内, 删除缓存的方法进去可以看到一个<code>LruCache</code>的类文件, 从名字可以推断是Glide自己实现的<code>Lru算法</code>作为缓存的处理, 关于Lru的算法原理, 在本篇内就不再做赘述了, 而<code>ActiveCache</code>用到了<code>引用计数</code>算法.<br>Glide用到了大量的抽象工厂类, 另外方法内经常是包括了十来个参数, 在阅读的经过上还是有点困难(对我而言).<br>相应的代码注释可看<a href=\"https://github.com/YuTianTina/glide\" target=\"_blank\" rel=\"noopener\">Github上我补充的注释</a></p>"},{"title":"HashMap源码解析(一)","date":"2018-02-01T16:00:00.000Z","_content":"\n## 前言\n本篇主要了解下`HashMap`的源码, 以便了解其常用方法的实现原理.本篇以android SDK API26内的Java源码为准\n## HashMap是什么\n`HashMap`是基于实现`Map`接口的哈希表, 但是他和`HashTable`有一定的区别, 主要区分在`HashMap`可以传`null`的键值对, 而且他`不是线程安全`的, 如果需要支持同步, 则需要调用`Collections.synchronizedMap(Map<K,V> m) `方法. 同时, `HashMap`不能保证时间推移下map内顺序不变.\n<!-- more -->\n## 构造函数\n国际惯例, 我们先看下他的构造函数, 他需要两个参数, 分别是初始容量`initialCapacity`(默认为 16)和负载因子`loadFactor`(默认为0.75f),\n奇怪的是, threshold的注释说明它应该是等于初始容量 * 负载因子, 而在`tableSizeFor()`方法的计算中, 我们获取到的是初始容量的两倍数据, 这点我们先压下疑问往后看\n``` java\npublic HashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity < 0)\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n        this.loadFactor = loadFactor;\n        // threshold 表示下次需要扩容时的容纳最大值(初始容量 * 负载因子), 如果超出这个值, 则会进行扩容\n        this.threshold = tableSizeFor(initialCapacity);\n    }\n```\n这里threshold的计算方法, 我们姑且看下, `MAXIMUM_CAPACITY`为`1<<30`, 位移运算后值为$2^{29}$\n``` java\n    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n```\n这段代码的意思就是会获取等于或大于`cap`最小的2的幂次,我们以默认值默认值$2^4$为例尝试计算一下, 得到的结果是$2^5$.\n## get(Object key)\n我们首先看下如果对`HashMap`进行查找.\n``` java\npublic V get(Object key) {\n        Node<K,V> e;\n        return (e = getNode(hash(key), key)) == null ? null : e.value;\n    }\n```\n这里`getNode`才是真正用来实现`Map.get`的方法.要注意的是, 这里的定位哈希桶数组的位置的算法, 由于`tab.length`永远是2的幂次, 这里的`(n - 1) & hash`就相当于`hash % n`的操作, 而&比%具有更高的效率, 所以这里的位运算相当于是一个小的优化\n``` java\n    /**\n     * 实现map的get方法\n     * Implements Map.get and related methods\n     *\n     * @param hash hash for key key的hash值\n     * @param key the key key\n     * @return the node, or null if none 返回目标节点, 如果没有则返回\n     */\n    final Node<K,V> getNode(int hash, Object key) {\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n        // tab为空, 并且获取到的目标节点不为空\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) {\n            // 如果hash和key相同\n            if (first.hash == hash && // always check first node\n                ((k = first.key) == key || (key != null && key.equals(k))))\n                // 返回目标节点\n                return first;\n            if ((e = first.next) != null) {\n                // 红黑树情况\n                if (first instanceof TreeNode)\n                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n                // 链表情况\n                do {\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;\n    }\n```\n## put\n同样, put的实际实现是以下方法\n``` java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        // 如果tab为空, 则调用resize分配内存\n        if ((tab = table) == null || (n = tab.length) == 0){\n            n = (tab = resize()).length;\n        }\n        // 通过(n - 1) & hash]获取存入位置, 得到插入位置中的节点p\n        if ((p = tab[i = (n - 1) & hash]) == null)\n            // 节点p为空, 则直接插入\n            tab[i] = newNode(hash, key, value, null);\n        else { // 节点p不为空, 插入位置冲突\n            Node<K,V> e; K k;\n            // 与当前节点第一个节点相同(hash和key都相同)\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k)))){\n                // 节点赋值tab[i]\n                e = p;\n            }\n            // 与第一个节点不相同\n            // 红黑树情况\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            // 链表情况\n            else {\n                // p从表头向后移动\n                for (int binCount = 0; ; ++binCount) {\n                    // 如果移动到链表尾部\n                    if ((e = p.next) == null) {\n                        // 插入到尾部\n                        p.next = newNode(hash, key, value, null);\n                        // 如果达到链->树阈值\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            // 替换红黑树\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    // 找到目标相同节点(hash&&key)\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    // p后移 p = p.next\n                    p = e;\n                }\n            }\n            // 处理hash和key相同的情况\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        // 如果size > threshold时, 进行扩容\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n`put`具体的流程图可以看下图\n\n![put流程图](HashMap源码解析/put.jpg)\n## 扩容resize\n该方法主要作用就是针对map进行容量初始化或者扩容双倍容量, 另外, 扩容之后, 需要重新计算键值对的位置, 并移动到目标位置上.\n``` java\nfinal Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        if (oldCap > 0) {\n            // 超过最大容量, 无法扩容, 只能改变阈值\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n            // 容量加倍\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                // 阈值加倍\n                newThr = oldThr << 1; // double threshold\n        }\n        // 用阈值初始值新的容量\n        else if (oldThr > 0) // initial capacity was placed in threshold\n            newCap = oldThr;\n        // 当阈值==0的时候\n        else {               // zero initial threshold signifies using defaults\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n        if (newThr == 0) {\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr;\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        // 将旧tab中的Node转移到新tab中, 分链表和红黑树两种情况\n        table = newTab;\n        if (oldTab != null) {\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { // preserve order\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n```\n`resize`做了两步工作, 一步是计算新的阈值和容量, 一步是键值对重新映射.\n之前我们有个疑问, 就是`threshold`的注释明明标注它说是等于初始容量*负载因子, 而在我们的`tableSizeFor`内并没有看到相关的逻辑代码, 这个问题就可以在这里得到解决.\n方法的前段逻辑如下:\n1. 判断当前哈希桶数组(`oldCap`)是否有值, 即哈希桶数组已经被初始化\n  1.  有且长度超过最大值, 则不做扩容\n  2. 有且没有超过最大值, 如果扩容后仍然小于最大值, 则做扩容处理\n2. 但是, 当哈希桶数组没有数据\n  1. 初始阈值(`oldThr`)有值且大于0 , 哈希桶数组容量长度直接沿用老的阈值大小\n  2. 初始阈值没有设置时, 阈值就会设为 加载因子 * 容量\n3. 如果新设置的阈值等于0, 则会赋值为加载因子 * 新的容量大小\n\n## removeNode\n删除的动作与上面的比较来说, 就容易理解了.\n主要可以分为三个动作:\n1. 寻找定位哈希桶数组索引位置\n2. 遍历链表找到键值相等的节点\n3. 删除目标节点\n\n``` java\nfinal Node<K,V> removeNode(int hash, Object key, Object value,\n                               boolean matchValue, boolean movable) {\n        Node<K,V>[] tab; Node<K,V> p; int n, index;\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (p = tab[index = (n - 1) & hash]) != null) {\n            Node<K,V> node = null, e; K k; V v;\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                node = p;\n            else if ((e = p.next) != null) {\n                if (p instanceof TreeNode)\n                    node = ((TreeNode<K,V>)p).getTreeNode(hash, key);\n                else {\n                    do {\n                        if (e.hash == hash &&\n                            ((k = e.key) == key ||\n                             (key != null && key.equals(k)))) {\n                            node = e;\n                            break;\n                        }\n                        p = e;\n                    } while ((e = e.next) != null);\n                }\n            }\n            if (node != null && (!matchValue || (v = node.value) == value ||\n                                 (value != null && value.equals(v)))) {\n                if (node instanceof TreeNode)\n                    ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);\n                else if (node == p)\n                    tab[index] = node.next;\n                else\n                    p.next = node.next;\n                ++modCount;\n                --size;\n                afterNodeRemoval(node);\n                return node;\n            }\n        }\n        return null;\n    }\n```\n## 总结\n本篇主要解释了几个常用方法的实现原理, 在此做下记录. 不过关于红黑树的相关知识, 就不在这里多加说明了.\n","source":"_posts/HashMap源码解析1.md","raw":"title: HashMap源码解析(一)\ndate: 2018-02-02 00:00:00\ncategories:\n- 源码解析\ntags:\n- 源码解析\n---\n\n## 前言\n本篇主要了解下`HashMap`的源码, 以便了解其常用方法的实现原理.本篇以android SDK API26内的Java源码为准\n## HashMap是什么\n`HashMap`是基于实现`Map`接口的哈希表, 但是他和`HashTable`有一定的区别, 主要区分在`HashMap`可以传`null`的键值对, 而且他`不是线程安全`的, 如果需要支持同步, 则需要调用`Collections.synchronizedMap(Map<K,V> m) `方法. 同时, `HashMap`不能保证时间推移下map内顺序不变.\n<!-- more -->\n## 构造函数\n国际惯例, 我们先看下他的构造函数, 他需要两个参数, 分别是初始容量`initialCapacity`(默认为 16)和负载因子`loadFactor`(默认为0.75f),\n奇怪的是, threshold的注释说明它应该是等于初始容量 * 负载因子, 而在`tableSizeFor()`方法的计算中, 我们获取到的是初始容量的两倍数据, 这点我们先压下疑问往后看\n``` java\npublic HashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity < 0)\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n        this.loadFactor = loadFactor;\n        // threshold 表示下次需要扩容时的容纳最大值(初始容量 * 负载因子), 如果超出这个值, 则会进行扩容\n        this.threshold = tableSizeFor(initialCapacity);\n    }\n```\n这里threshold的计算方法, 我们姑且看下, `MAXIMUM_CAPACITY`为`1<<30`, 位移运算后值为$2^{29}$\n``` java\n    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n```\n这段代码的意思就是会获取等于或大于`cap`最小的2的幂次,我们以默认值默认值$2^4$为例尝试计算一下, 得到的结果是$2^5$.\n## get(Object key)\n我们首先看下如果对`HashMap`进行查找.\n``` java\npublic V get(Object key) {\n        Node<K,V> e;\n        return (e = getNode(hash(key), key)) == null ? null : e.value;\n    }\n```\n这里`getNode`才是真正用来实现`Map.get`的方法.要注意的是, 这里的定位哈希桶数组的位置的算法, 由于`tab.length`永远是2的幂次, 这里的`(n - 1) & hash`就相当于`hash % n`的操作, 而&比%具有更高的效率, 所以这里的位运算相当于是一个小的优化\n``` java\n    /**\n     * 实现map的get方法\n     * Implements Map.get and related methods\n     *\n     * @param hash hash for key key的hash值\n     * @param key the key key\n     * @return the node, or null if none 返回目标节点, 如果没有则返回\n     */\n    final Node<K,V> getNode(int hash, Object key) {\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n        // tab为空, 并且获取到的目标节点不为空\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) {\n            // 如果hash和key相同\n            if (first.hash == hash && // always check first node\n                ((k = first.key) == key || (key != null && key.equals(k))))\n                // 返回目标节点\n                return first;\n            if ((e = first.next) != null) {\n                // 红黑树情况\n                if (first instanceof TreeNode)\n                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n                // 链表情况\n                do {\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;\n    }\n```\n## put\n同样, put的实际实现是以下方法\n``` java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        // 如果tab为空, 则调用resize分配内存\n        if ((tab = table) == null || (n = tab.length) == 0){\n            n = (tab = resize()).length;\n        }\n        // 通过(n - 1) & hash]获取存入位置, 得到插入位置中的节点p\n        if ((p = tab[i = (n - 1) & hash]) == null)\n            // 节点p为空, 则直接插入\n            tab[i] = newNode(hash, key, value, null);\n        else { // 节点p不为空, 插入位置冲突\n            Node<K,V> e; K k;\n            // 与当前节点第一个节点相同(hash和key都相同)\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k)))){\n                // 节点赋值tab[i]\n                e = p;\n            }\n            // 与第一个节点不相同\n            // 红黑树情况\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            // 链表情况\n            else {\n                // p从表头向后移动\n                for (int binCount = 0; ; ++binCount) {\n                    // 如果移动到链表尾部\n                    if ((e = p.next) == null) {\n                        // 插入到尾部\n                        p.next = newNode(hash, key, value, null);\n                        // 如果达到链->树阈值\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            // 替换红黑树\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    // 找到目标相同节点(hash&&key)\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    // p后移 p = p.next\n                    p = e;\n                }\n            }\n            // 处理hash和key相同的情况\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        // 如果size > threshold时, 进行扩容\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n`put`具体的流程图可以看下图\n\n![put流程图](HashMap源码解析/put.jpg)\n## 扩容resize\n该方法主要作用就是针对map进行容量初始化或者扩容双倍容量, 另外, 扩容之后, 需要重新计算键值对的位置, 并移动到目标位置上.\n``` java\nfinal Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        if (oldCap > 0) {\n            // 超过最大容量, 无法扩容, 只能改变阈值\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n            // 容量加倍\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                // 阈值加倍\n                newThr = oldThr << 1; // double threshold\n        }\n        // 用阈值初始值新的容量\n        else if (oldThr > 0) // initial capacity was placed in threshold\n            newCap = oldThr;\n        // 当阈值==0的时候\n        else {               // zero initial threshold signifies using defaults\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n        if (newThr == 0) {\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr;\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        // 将旧tab中的Node转移到新tab中, 分链表和红黑树两种情况\n        table = newTab;\n        if (oldTab != null) {\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { // preserve order\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n```\n`resize`做了两步工作, 一步是计算新的阈值和容量, 一步是键值对重新映射.\n之前我们有个疑问, 就是`threshold`的注释明明标注它说是等于初始容量*负载因子, 而在我们的`tableSizeFor`内并没有看到相关的逻辑代码, 这个问题就可以在这里得到解决.\n方法的前段逻辑如下:\n1. 判断当前哈希桶数组(`oldCap`)是否有值, 即哈希桶数组已经被初始化\n  1.  有且长度超过最大值, 则不做扩容\n  2. 有且没有超过最大值, 如果扩容后仍然小于最大值, 则做扩容处理\n2. 但是, 当哈希桶数组没有数据\n  1. 初始阈值(`oldThr`)有值且大于0 , 哈希桶数组容量长度直接沿用老的阈值大小\n  2. 初始阈值没有设置时, 阈值就会设为 加载因子 * 容量\n3. 如果新设置的阈值等于0, 则会赋值为加载因子 * 新的容量大小\n\n## removeNode\n删除的动作与上面的比较来说, 就容易理解了.\n主要可以分为三个动作:\n1. 寻找定位哈希桶数组索引位置\n2. 遍历链表找到键值相等的节点\n3. 删除目标节点\n\n``` java\nfinal Node<K,V> removeNode(int hash, Object key, Object value,\n                               boolean matchValue, boolean movable) {\n        Node<K,V>[] tab; Node<K,V> p; int n, index;\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (p = tab[index = (n - 1) & hash]) != null) {\n            Node<K,V> node = null, e; K k; V v;\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                node = p;\n            else if ((e = p.next) != null) {\n                if (p instanceof TreeNode)\n                    node = ((TreeNode<K,V>)p).getTreeNode(hash, key);\n                else {\n                    do {\n                        if (e.hash == hash &&\n                            ((k = e.key) == key ||\n                             (key != null && key.equals(k)))) {\n                            node = e;\n                            break;\n                        }\n                        p = e;\n                    } while ((e = e.next) != null);\n                }\n            }\n            if (node != null && (!matchValue || (v = node.value) == value ||\n                                 (value != null && value.equals(v)))) {\n                if (node instanceof TreeNode)\n                    ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);\n                else if (node == p)\n                    tab[index] = node.next;\n                else\n                    p.next = node.next;\n                ++modCount;\n                --size;\n                afterNodeRemoval(node);\n                return node;\n            }\n        }\n        return null;\n    }\n```\n## 总结\n本篇主要解释了几个常用方法的实现原理, 在此做下记录. 不过关于红黑树的相关知识, 就不在这里多加说明了.\n","slug":"HashMap源码解析1","published":1,"updated":"2018-05-07T02:03:10.546Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh7fldnf00188os6vib7ej5c","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本篇主要了解下<code>HashMap</code>的源码, 以便了解其常用方法的实现原理.本篇以android SDK API26内的Java源码为准</p>\n<h2 id=\"HashMap是什么\"><a href=\"#HashMap是什么\" class=\"headerlink\" title=\"HashMap是什么\"></a>HashMap是什么</h2><p><code>HashMap</code>是基于实现<code>Map</code>接口的哈希表, 但是他和<code>HashTable</code>有一定的区别, 主要区分在<code>HashMap</code>可以传<code>null</code>的键值对, 而且他<code>不是线程安全</code>的, 如果需要支持同步, 则需要调用<code>Collections.synchronizedMap(Map&lt;K,V&gt; m)</code>方法. 同时, <code>HashMap</code>不能保证时间推移下map内顺序不变.<br><a id=\"more\"></a></p>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>国际惯例, 我们先看下他的构造函数, 他需要两个参数, 分别是初始容量<code>initialCapacity</code>(默认为 16)和负载因子<code>loadFactor</code>(默认为0.75f),<br>奇怪的是, threshold的注释说明它应该是等于初始容量 * 负载因子, 而在<code>tableSizeFor()</code>方法的计算中, 我们获取到的是初始容量的两倍数据, 这点我们先压下疑问往后看<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span> +</span><br><span class=\"line\">                                               initialCapacity);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span> +</span><br><span class=\"line\">                                               loadFactor);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">        <span class=\"comment\">// threshold 表示下次需要扩容时的容纳最大值(初始容量 * 负载因子), 如果超出这个值, 则会进行扩容</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里threshold的计算方法, 我们姑且看下, <code>MAXIMUM_CAPACITY</code>为<code>1&lt;&lt;30</code>, 位移运算后值为$2^{29}$<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码的意思就是会获取等于或大于<code>cap</code>最小的2的幂次,我们以默认值默认值$2^4$为例尝试计算一下, 得到的结果是$2^5$.</p>\n<h2 id=\"get-Object-key\"><a href=\"#get-Object-key\" class=\"headerlink\" title=\"get(Object key)\"></a>get(Object key)</h2><p>我们首先看下如果对<code>HashMap</code>进行查找.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里<code>getNode</code>才是真正用来实现<code>Map.get</code>的方法.要注意的是, 这里的定位哈希桶数组的位置的算法, 由于<code>tab.length</code>永远是2的幂次, 这里的<code>(n - 1) &amp; hash</code>就相当于<code>hash % n</code>的操作, 而&amp;比%具有更高的效率, 所以这里的位运算相当于是一个小的优化<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现map的get方法</span></span><br><span class=\"line\"><span class=\"comment\"> * Implements Map.get and related methods</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> hash hash for key key的hash值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key the key key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the node, or null if none 返回目标节点, 如果没有则返回</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</span><br><span class=\"line\">    <span class=\"comment\">// tab为空, 并且获取到的目标节点不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果hash和key相同</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">            ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            <span class=\"comment\">// 返回目标节点</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 红黑树情况</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">            <span class=\"comment\">// 链表情况</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put\"></a>put</h2><p>同样, put的实际实现是以下方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">        <span class=\"comment\">// 如果tab为空, 则调用resize分配内存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            n = (tab = resize()).length;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 通过(n - 1) &amp; hash]获取存入位置, 得到插入位置中的节点p</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"comment\">// 节点p为空, 则直接插入</span></span><br><span class=\"line\">            tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 节点p不为空, 插入位置冲突</span></span><br><span class=\"line\">            Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">            <span class=\"comment\">// 与当前节点第一个节点相同(hash和key都相同)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">                ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 节点赋值tab[i]</span></span><br><span class=\"line\">                e = p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 与第一个节点不相同</span></span><br><span class=\"line\">            <span class=\"comment\">// 红黑树情况</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">            <span class=\"comment\">// 链表情况</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// p从表头向后移动</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果移动到链表尾部</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 插入到尾部</span></span><br><span class=\"line\">                        p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                        <span class=\"comment\">// 如果达到链-&gt;树阈值</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                            <span class=\"comment\">// 替换红黑树</span></span><br><span class=\"line\">                            treeifyBin(tab, hash);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// 找到目标相同节点(hash&amp;&amp;key)</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                        ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// p后移 p = p.next</span></span><br><span class=\"line\">                    p = e;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 处理hash和key相同的情况</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">                V oldValue = e.value;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    e.value = value;</span><br><span class=\"line\">                afterNodeAccess(e);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ++modCount;</span><br><span class=\"line\">        <span class=\"comment\">// 如果size &gt; threshold时, 进行扩容</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        afterNodeInsertion(evict);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>put</code>具体的流程图可以看下图</p>\n<p><img src=\"HashMap源码解析/put.jpg\" alt=\"put流程图\"></p>\n<h2 id=\"扩容resize\"><a href=\"#扩容resize\" class=\"headerlink\" title=\"扩容resize\"></a>扩容resize</h2><p>该方法主要作用就是针对map进行容量初始化或者扩容双倍容量, 另外, 扩容之后, 需要重新计算键值对的位置, 并移动到目标位置上.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 超过最大容量, 无法扩容, 只能改变阈值</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">                threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 容量加倍</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">                <span class=\"comment\">// 阈值加倍</span></span><br><span class=\"line\">                newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 用阈值初始值新的容量</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">            newCap = oldThr;</span><br><span class=\"line\">        <span class=\"comment\">// 当阈值==0的时候</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">            newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                      (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        threshold = newThr;</span><br><span class=\"line\">        <span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"rawtypes\"</span>,<span class=\"string\">\"unchecked\"</span>&#125;)</span><br><span class=\"line\">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">        <span class=\"comment\">// 将旧tab中的Node转移到新tab中, 分链表和红黑树两种情况</span></span><br><span class=\"line\">        table = newTab;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">                Node&lt;K,V&gt; e;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                        ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">                        Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        Node&lt;K,V&gt; next;</span><br><span class=\"line\">                        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                            next = e.next;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                    loHead = e;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span></span><br><span class=\"line\">                                    loTail.next = e;</span><br><span class=\"line\">                                loTail = e;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                    hiHead = e;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span></span><br><span class=\"line\">                                    hiTail.next = e;</span><br><span class=\"line\">                                hiTail = e;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                            newTab[j] = loHead;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                            newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>resize</code>做了两步工作, 一步是计算新的阈值和容量, 一步是键值对重新映射.<br>之前我们有个疑问, 就是<code>threshold</code>的注释明明标注它说是等于初始容量*负载因子, 而在我们的<code>tableSizeFor</code>内并没有看到相关的逻辑代码, 这个问题就可以在这里得到解决.<br>方法的前段逻辑如下:</p>\n<ol>\n<li>判断当前哈希桶数组(<code>oldCap</code>)是否有值, 即哈希桶数组已经被初始化<ol>\n<li>有且长度超过最大值, 则不做扩容</li>\n<li>有且没有超过最大值, 如果扩容后仍然小于最大值, 则做扩容处理</li>\n</ol>\n</li>\n<li>但是, 当哈希桶数组没有数据<ol>\n<li>初始阈值(<code>oldThr</code>)有值且大于0 , 哈希桶数组容量长度直接沿用老的阈值大小</li>\n<li>初始阈值没有设置时, 阈值就会设为 加载因子 * 容量</li>\n</ol>\n</li>\n<li>如果新设置的阈值等于0, 则会赋值为加载因子 * 新的容量大小</li>\n</ol>\n<h2 id=\"removeNode\"><a href=\"#removeNode\" class=\"headerlink\" title=\"removeNode\"></a>removeNode</h2><p>删除的动作与上面的比较来说, 就容易理解了.<br>主要可以分为三个动作:</p>\n<ol>\n<li>寻找定位哈希桶数组索引位置</li>\n<li>遍历链表找到键值相等的节点</li>\n<li>删除目标节点</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">removeNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key, Object value,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                               <span class=\"keyword\">boolean</span> matchValue, <span class=\"keyword\">boolean</span> movable)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, index;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">            (p = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; node = <span class=\"keyword\">null</span>, e; K k; V v;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">                ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                node = p;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = p.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                            ((k = e.key) == key ||</span><br><span class=\"line\">                             (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class=\"line\">                            node = e;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        p = e;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node != <span class=\"keyword\">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class=\"line\">                                 (value != <span class=\"keyword\">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class=\"keyword\">this</span>, tab, movable);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node == p)</span><br><span class=\"line\">                    tab[index] = node.next;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    p.next = node.next;</span><br><span class=\"line\">                ++modCount;</span><br><span class=\"line\">                --size;</span><br><span class=\"line\">                afterNodeRemoval(node);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本篇主要解释了几个常用方法的实现原理, 在此做下记录. 不过关于红黑树的相关知识, 就不在这里多加说明了.</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本篇主要了解下<code>HashMap</code>的源码, 以便了解其常用方法的实现原理.本篇以android SDK API26内的Java源码为准</p>\n<h2 id=\"HashMap是什么\"><a href=\"#HashMap是什么\" class=\"headerlink\" title=\"HashMap是什么\"></a>HashMap是什么</h2><p><code>HashMap</code>是基于实现<code>Map</code>接口的哈希表, 但是他和<code>HashTable</code>有一定的区别, 主要区分在<code>HashMap</code>可以传<code>null</code>的键值对, 而且他<code>不是线程安全</code>的, 如果需要支持同步, 则需要调用<code>Collections.synchronizedMap(Map&lt;K,V&gt; m)</code>方法. 同时, <code>HashMap</code>不能保证时间推移下map内顺序不变.<br>","more":"</p>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>国际惯例, 我们先看下他的构造函数, 他需要两个参数, 分别是初始容量<code>initialCapacity</code>(默认为 16)和负载因子<code>loadFactor</code>(默认为0.75f),<br>奇怪的是, threshold的注释说明它应该是等于初始容量 * 负载因子, 而在<code>tableSizeFor()</code>方法的计算中, 我们获取到的是初始容量的两倍数据, 这点我们先压下疑问往后看<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span> +</span><br><span class=\"line\">                                               initialCapacity);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span> +</span><br><span class=\"line\">                                               loadFactor);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">        <span class=\"comment\">// threshold 表示下次需要扩容时的容纳最大值(初始容量 * 负载因子), 如果超出这个值, 则会进行扩容</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里threshold的计算方法, 我们姑且看下, <code>MAXIMUM_CAPACITY</code>为<code>1&lt;&lt;30</code>, 位移运算后值为$2^{29}$<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码的意思就是会获取等于或大于<code>cap</code>最小的2的幂次,我们以默认值默认值$2^4$为例尝试计算一下, 得到的结果是$2^5$.</p>\n<h2 id=\"get-Object-key\"><a href=\"#get-Object-key\" class=\"headerlink\" title=\"get(Object key)\"></a>get(Object key)</h2><p>我们首先看下如果对<code>HashMap</code>进行查找.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里<code>getNode</code>才是真正用来实现<code>Map.get</code>的方法.要注意的是, 这里的定位哈希桶数组的位置的算法, 由于<code>tab.length</code>永远是2的幂次, 这里的<code>(n - 1) &amp; hash</code>就相当于<code>hash % n</code>的操作, 而&amp;比%具有更高的效率, 所以这里的位运算相当于是一个小的优化<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现map的get方法</span></span><br><span class=\"line\"><span class=\"comment\"> * Implements Map.get and related methods</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> hash hash for key key的hash值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key the key key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the node, or null if none 返回目标节点, 如果没有则返回</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</span><br><span class=\"line\">    <span class=\"comment\">// tab为空, 并且获取到的目标节点不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果hash和key相同</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">            ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            <span class=\"comment\">// 返回目标节点</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 红黑树情况</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">            <span class=\"comment\">// 链表情况</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put\"></a>put</h2><p>同样, put的实际实现是以下方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">        <span class=\"comment\">// 如果tab为空, 则调用resize分配内存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            n = (tab = resize()).length;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 通过(n - 1) &amp; hash]获取存入位置, 得到插入位置中的节点p</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"comment\">// 节点p为空, 则直接插入</span></span><br><span class=\"line\">            tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 节点p不为空, 插入位置冲突</span></span><br><span class=\"line\">            Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">            <span class=\"comment\">// 与当前节点第一个节点相同(hash和key都相同)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">                ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 节点赋值tab[i]</span></span><br><span class=\"line\">                e = p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 与第一个节点不相同</span></span><br><span class=\"line\">            <span class=\"comment\">// 红黑树情况</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">            <span class=\"comment\">// 链表情况</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// p从表头向后移动</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果移动到链表尾部</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 插入到尾部</span></span><br><span class=\"line\">                        p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                        <span class=\"comment\">// 如果达到链-&gt;树阈值</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                            <span class=\"comment\">// 替换红黑树</span></span><br><span class=\"line\">                            treeifyBin(tab, hash);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// 找到目标相同节点(hash&amp;&amp;key)</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                        ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// p后移 p = p.next</span></span><br><span class=\"line\">                    p = e;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 处理hash和key相同的情况</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">                V oldValue = e.value;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    e.value = value;</span><br><span class=\"line\">                afterNodeAccess(e);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ++modCount;</span><br><span class=\"line\">        <span class=\"comment\">// 如果size &gt; threshold时, 进行扩容</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        afterNodeInsertion(evict);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>put</code>具体的流程图可以看下图</p>\n<p><img src=\"HashMap源码解析/put.jpg\" alt=\"put流程图\"></p>\n<h2 id=\"扩容resize\"><a href=\"#扩容resize\" class=\"headerlink\" title=\"扩容resize\"></a>扩容resize</h2><p>该方法主要作用就是针对map进行容量初始化或者扩容双倍容量, 另外, 扩容之后, 需要重新计算键值对的位置, 并移动到目标位置上.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 超过最大容量, 无法扩容, 只能改变阈值</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">                threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 容量加倍</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">                <span class=\"comment\">// 阈值加倍</span></span><br><span class=\"line\">                newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 用阈值初始值新的容量</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">            newCap = oldThr;</span><br><span class=\"line\">        <span class=\"comment\">// 当阈值==0的时候</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">            newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                      (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        threshold = newThr;</span><br><span class=\"line\">        <span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"rawtypes\"</span>,<span class=\"string\">\"unchecked\"</span>&#125;)</span><br><span class=\"line\">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">        <span class=\"comment\">// 将旧tab中的Node转移到新tab中, 分链表和红黑树两种情况</span></span><br><span class=\"line\">        table = newTab;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">                Node&lt;K,V&gt; e;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                        ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">                        Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        Node&lt;K,V&gt; next;</span><br><span class=\"line\">                        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                            next = e.next;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                    loHead = e;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span></span><br><span class=\"line\">                                    loTail.next = e;</span><br><span class=\"line\">                                loTail = e;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                    hiHead = e;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span></span><br><span class=\"line\">                                    hiTail.next = e;</span><br><span class=\"line\">                                hiTail = e;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                            newTab[j] = loHead;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                            newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>resize</code>做了两步工作, 一步是计算新的阈值和容量, 一步是键值对重新映射.<br>之前我们有个疑问, 就是<code>threshold</code>的注释明明标注它说是等于初始容量*负载因子, 而在我们的<code>tableSizeFor</code>内并没有看到相关的逻辑代码, 这个问题就可以在这里得到解决.<br>方法的前段逻辑如下:</p>\n<ol>\n<li>判断当前哈希桶数组(<code>oldCap</code>)是否有值, 即哈希桶数组已经被初始化<ol>\n<li>有且长度超过最大值, 则不做扩容</li>\n<li>有且没有超过最大值, 如果扩容后仍然小于最大值, 则做扩容处理</li>\n</ol>\n</li>\n<li>但是, 当哈希桶数组没有数据<ol>\n<li>初始阈值(<code>oldThr</code>)有值且大于0 , 哈希桶数组容量长度直接沿用老的阈值大小</li>\n<li>初始阈值没有设置时, 阈值就会设为 加载因子 * 容量</li>\n</ol>\n</li>\n<li>如果新设置的阈值等于0, 则会赋值为加载因子 * 新的容量大小</li>\n</ol>\n<h2 id=\"removeNode\"><a href=\"#removeNode\" class=\"headerlink\" title=\"removeNode\"></a>removeNode</h2><p>删除的动作与上面的比较来说, 就容易理解了.<br>主要可以分为三个动作:</p>\n<ol>\n<li>寻找定位哈希桶数组索引位置</li>\n<li>遍历链表找到键值相等的节点</li>\n<li>删除目标节点</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">removeNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key, Object value,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                               <span class=\"keyword\">boolean</span> matchValue, <span class=\"keyword\">boolean</span> movable)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, index;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">            (p = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; node = <span class=\"keyword\">null</span>, e; K k; V v;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">                ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                node = p;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = p.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                            ((k = e.key) == key ||</span><br><span class=\"line\">                             (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class=\"line\">                            node = e;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        p = e;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node != <span class=\"keyword\">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class=\"line\">                                 (value != <span class=\"keyword\">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class=\"keyword\">this</span>, tab, movable);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node == p)</span><br><span class=\"line\">                    tab[index] = node.next;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    p.next = node.next;</span><br><span class=\"line\">                ++modCount;</span><br><span class=\"line\">                --size;</span><br><span class=\"line\">                afterNodeRemoval(node);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本篇主要解释了几个常用方法的实现原理, 在此做下记录. 不过关于红黑树的相关知识, 就不在这里多加说明了.</p>"},{"title":"RxJava2源码解析(一)","date":"2018-02-06T16:00:00.000Z","_content":"## 前言\n最近组内大佬打算分享RxJava2的源码, 赶紧先预习一波, 防止技术分享会上有听没懂.大概个人准备了几天的时间, 打算先整理以下自己的源码阅读记录.RxJava2的源码解析系列打算分别从以下三面来阐述:\n1. 数据源的订阅和响应原理\n2. 线程切换的原理\n3. 背压的实现(Flowable)\n\n本篇主要尝试阐明**数据源的订阅和响应原理**\n<!-- more -->\n## 基础使用的Demo\n抛开线程切换和背压, 我们来写一个单纯的发送数据, 订阅响应的Demo,为了便于理解, 我们抛开链式调用来写\n``` java\n// 被观察者\nObservable<Integer> observable = Observable.create(new ObservableOnSubscribe<Integer>() {\n    @Override\n    public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {\n        Log.e(TAG, \"subscribe\");\n        emitter.onNext(123);\n        emitter.onComplete();\n    }\n});\n// 观察者\nObserver<Integer> observer = new Observer<Integer>() {\n    @Override\n    public void onSubscribe(Disposable d) {\n        Log.e(TAG, \"onSubscribe\");\n    }\n\n    @Override\n    public void onNext(Integer integer) {\n        Log.e(TAG, \"onNext\" + integer);\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        Log.e(TAG, \"onError\");\n    }\n\n    @Override\n    public void onComplete() {\n        Log.e(TAG, \"onComplete\");\n    }\n};\n// 订阅\nobservable.subscribe(observer);\n```\n## ObservableSource\n我们首先来看当我们创建一个`Observable`(被观察者)的时候, 实际上他做了什么\n``` java\npublic static <T> Observable<T> create(ObservableOnSubscribe<T> source) {\n        // npe校验\n        ObjectHelper.requireNonNull(source, \"source is null\");\n        return RxJavaPlugins.onAssembly(new ObservableCreate<T>(source));\n    }\n\npublic static <T> Observable<T> onAssembly(@NonNull Observable<T> source) {\n    Function<? super Observable, ? extends Observable> f = onObservableAssembly;\n    if (f != null) {\n        return apply(f, source);\n    }\n    return source;\n}\n```\n`RxJavaPlugins.onAssembly()`这个方法主要是为了hook使用, 本篇暂且不表. 所以这里`Observable.create()`返回的是一个`ObervableCreate`对象.它继承于`Observable`, 是`ObservableSource`的实现类\n## observable.subscribe(observer)\n我们主要看订阅的时候做了什么, 先上源码\n``` java\npublic final void subscribe(Observer<? super T> observer) {\n        // npe校验\n        ObjectHelper.requireNonNull(observer, \"observer is null\");\n        try {\n            // hook, 主要返回的就是我们的observer\n            observer = RxJavaPlugins.onSubscribe(this, observer);\n            // npe校验\n            ObjectHelper.requireNonNull(observer, \"Plugin returned null Observer\");\n\n            subscribeActual(observer);\n        } catch (NullPointerException e) { // NOPMD\n            throw e;\n        } catch (Throwable e) {\n            Exceptions.throwIfFatal(e);\n            // can't call onError because no way to know if a Disposable has been set or not\n            // can't call onSubscribe because the call might have set a Subscription already\n            RxJavaPlugins.onError(e);\n\n            NullPointerException npe = new NullPointerException(\"Actually not, but can't throw other exceptions due to RS\");\n            npe.initCause(e);\n            throw npe;\n        }\n    }\n```\n可以看到这里实际执行的是`subscribeActual(observer)`这个方法, 这里调用是个抽象接口, 我们在`ObervableCreate`找具体的实现\n``` java\n@Override\nprotected void subscribeActual(Observer<? super T> observer) {\n        // 包装数据发射器\n        CreateEmitter<T> parent = new CreateEmitter<T>(observer);\n        // 订阅监听\n        observer.onSubscribe(parent);\n\n        try {\n            // 上游的执行\n            source.subscribe(parent);\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            parent.onError(ex);\n        }\n    }\n```\n``` java\nemitter.onNext(123);\nemitter.onComplete();\n```\n从`source.subscribe(parent);`我们就会走到以下我们自己写的数据发送事件.这里的`emitter`通过源码我们可以看到是将`observer`包装后的`CreateEmitter`类对象, 我们在往里面看.\n``` java\nstatic final class CreateEmitter<T> extends AtomicReference<Disposable> implements ObservableEmitter<T>, Disposable {\n\n\n        private static final long serialVersionUID = -3434801548987643227L;\n\n        final Observer<? super T> observer;\n\n        CreateEmitter(Observer<? super T> observer) {\n            this.observer = observer;\n        }\n\n        @Override\n        public void onNext(T t) {\n            if (t == null) {\n                onError(new NullPointerException(\"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\"));\n                return;\n            }\n            if (!isDisposed()) {\n                observer.onNext(t);\n            }\n        }\n\n        @Override\n        public void onError(Throwable t) {\n            if (!tryOnError(t)) {\n                RxJavaPlugins.onError(t);\n            }\n        }\n\n        @Override\n        public boolean tryOnError(Throwable t) {\n            if (t == null) {\n                t = new NullPointerException(\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\");\n            }\n            if (!isDisposed()) {\n                try {\n                    observer.onError(t);\n                } finally {\n                    dispose();\n                }\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public void onComplete() {\n            if (!isDisposed()) {\n                try {\n                    observer.onComplete();\n                } finally {\n                    dispose();\n                }\n            }\n        }\n\n        @Override\n        public void setDisposable(Disposable d) {\n            DisposableHelper.set(this, d);\n        }\n\n        @Override\n        public void setCancellable(Cancellable c) {\n            setDisposable(new CancellableDisposable(c));\n        }\n\n        @Override\n        public ObservableEmitter<T> serialize() {\n            return new SerializedEmitter<T>(this);\n        }\n\n        @Override\n        public void dispose() {\n            DisposableHelper.dispose(this);\n        }\n\n        @Override\n        public boolean isDisposed() {\n            return DisposableHelper.isDisposed(get());\n        }\n    }\n```\n通过之前将`observer`传入`CreateEmitter`, 调用`emitter.onNext`最终调用走到了`observer.onNext`.\n整体的流程非常的清晰. 下面我们看下, 如果中间有多重数据转换, 是什么样的流程\n## 数据转换实现流程\n以第一个基础demo为例, 我们改造下`Observable`(被观察者), 将他进行一次数据转换, 并且做一次筛除.这个demo的意思就是发送123, 中间做+1处理, 然后筛选出大于122的数据发送给观察者.这个很容易理解.\n``` java\nObservable<Integer> observable =\n                Observable\n                        .create(new ObservableOnSubscribe<Integer>() {\n                            @Override\n                            public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {\n                                Log.e(TAG, \"subscribe\");\n                                emitter.onNext(123);\n                                emitter.onComplete();\n                            }\n                        })\n                        .map(new Function<Integer, Integer>() {\n                            @Override\n                            public Integer apply(Integer integer) throws Exception {\n                                Log.e(TAG, \"map\");\n                                return integer + 1;\n                            }\n                        })\n                        .filter(new Predicate<Integer>() {\n                            @Override\n                            public boolean test(Integer integer) throws Exception {\n                                Log.e(TAG, \"filter\");\n                                return integer > 122;\n                            }\n                        });\n```\n我们依旧来看下`map`操作符的源码\n``` java\npublic final <R> Observable<R> map(Function<? super T, ? extends R> mapper) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        return RxJavaPlugins.onAssembly(new ObservableMap<T, R>(this, mapper));\n    }\n```\n是不是很眼熟? 忽略掉hook, 这里返回的是`ObservableMap`对象.同样, `filter`操作符返回的是一个`ObservableFilter`\n``` java\npublic final Observable<T> filter(Predicate<? super T> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n        return RxJavaPlugins.onAssembly(new ObservableFilter<T>(this, predicate));\n    }\n```\n不论是`ObservableMap`还是`ObservableFilter`他们都继承于`AbstractObservableWithUpstream`抽象类, 它继承于`Observable`, 带有上游的`Observable`\n``` java\nabstract class AbstractObservableWithUpstream<T, U> extends Observable<U> implements HasUpstreamObservableSource<T> {\n\n    /** The source consumable Observable. */\n    // 上游Obervable\n    protected final ObservableSource<T> source;\n\n    /**\n     * Constructs the ObservableSource with the given consumable.\n     * @param source the consumable Observable\n     */\n    AbstractObservableWithUpstream(ObservableSource<T> source) {\n        this.source = source;\n    }\n\n    @Override\n    public final ObservableSource<T> source() {\n        return source;\n    }\n\n}\n```\n这时候, 我们重新看下订阅的处理, 当我们执行`observable.subscribe(observer)`的时候, `observable`最终返回的是`ObservableFilter`对象, 所以我们需要看这个类对象的`subscribeActual(observer)`方法.他的代码很简洁, 实际就是将我们的`observer`和`filter`操作符的具体操作方法包装成一个`FilterObserver`对象, 然后由上游`ObservableMap`对象来subscribe(订阅)它.\n``` java\n@Override\n    public void subscribeActual(Observer<? super T> s) {\n        source.subscribe(new FilterObserver<T>(s, predicate));\n    }\n```\n我们已经知道`Observable.subscribe(observer)`方法实际调用的是对应实现类的`subscribeActual(observer)`方法, 所以我们直接去看`ObservableMap.subscribeActual(observer)`方法就可以了, 他的方法与`FilterObserver`内的类似, 这时候是将前面传进来的`FilterObserver`对象和我们`map`操作符做的操作包装成一个`MapObserver`对象, 交给上游.\n``` java\n@Override\n    public void subscribeActual(Observer<? super U> t) {\n        source.subscribe(new MapObserver<T, U>(t, function));\n    }\n```\n这时候我们的上游是`ObservableCreate`对象,它的`subscribeActual(observer)`方法上文有提到, 他将`MapObserver`对象包装进`CreateEmitter`对象, 这个时候, 才开始执行订阅动作, 然后我们走到`CreateEmitter`的`onNext()`方法,实际会执行到下游观察者的`onNext`方法, 在这层, 我们的观察者是`MapObserver`.它继承于`BasicFuseableObserver`, 表示一个流程执行中间的观察者对象. 现在我们看`MapObserver`的`onNext`的执行, 这里我们主要关注主流程的执行逻辑, 忽略掉其他代码, 可以看到它最终调用的是`actual.onNext(v)`, 首先将我们`map`操作符的逻辑处理返回的数据赋值给`v`, 这里的`actual`指的是我们下游的`observer`(观察者), 那么这个时候是我们的`FilterObserver`对象, 将`v`对象通过`onNext`传递下去.\n``` java\nstatic final class MapObserver<T, U> extends BasicFuseableObserver<T, U> {\n        final Function<? super T, ? extends U> mapper;\n\n        MapObserver(Observer<? super U> actual, Function<? super T, ? extends U> mapper) {\n            super(actual);\n            this.mapper = mapper;\n        }\n\n        @Override\n        public void onNext(T t) {\n            if (done) {\n                return;\n            }\n\n            if (sourceMode != NONE) {\n                actual.onNext(null);\n                return;\n            }\n\n            U v;\n\n            try {\n                v = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper function returned a null value.\");\n            } catch (Throwable ex) {\n                fail(ex);\n                return;\n            }\n            actual.onNext(v);\n        }\n\n        @Override\n        public int requestFusion(int mode) {\n            return transitiveBoundaryFusion(mode);\n        }\n\n        @Nullable\n        @Override\n        public U poll() throws Exception {\n            T t = qs.poll();\n            return t != null ? ObjectHelper.<U>requireNonNull(mapper.apply(t), \"The mapper function returned a null value.\") : null;\n        }\n    }\n```\n然后我们看`FilterObserver`的源码, 他的`onNext`逻辑就是会执行我们传进去的`Predicate`对象的`test`方法, 如果符合筛选逻辑, 就会通过调用下游的`onNext`将数据传下去, 这个时候的下游是我们new的`Observer`, 这时候的执行,我们应该就清楚了.\n``` java\nstatic final class FilterObserver<T> extends BasicFuseableObserver<T, T> {\n        final Predicate<? super T> filter;\n\n        FilterObserver(Observer<? super T> actual, Predicate<? super T> filter) {\n            super(actual);\n            this.filter = filter;\n        }\n\n        @Override\n        public void onNext(T t) {\n            if (sourceMode == NONE) {\n                boolean b;\n                try {\n                    b = filter.test(t);\n                } catch (Throwable e) {\n                    fail(e);\n                    return;\n                }\n                if (b) {\n                    actual.onNext(t);\n                }\n            } else {\n                actual.onNext(null);\n            }\n        }\n\n        @Override\n        public int requestFusion(int mode) {\n            return transitiveBoundaryFusion(mode);\n        }\n\n        @Nullable\n        @Override\n        public T poll() throws Exception {\n            for (;;) {\n                T v = qs.poll();\n                if (v == null || filter.test(v)) {\n                    return v;\n                }\n            }\n        }\n    }\n```\n## 总结\n订阅和数据的传输的原理就是如此. 我们用流程图来总结下上面的整个流程.\n![流程图](RxJava2源码解析/rxjava实现原理.jpg)\n总的来说, 订阅的动作是层层递归上传到最开始的`Observable`, 然后从最开始的`Observable`将数据一层层往下传.\n当然, 从`装饰模式`来讲, 他这里的实际动作就是将`Observable`做了层层装饰来传递订阅, 对设计模式有兴趣的同学可以看看相关的书籍, 对于理解这段代码有点睛之用\n","source":"_posts/RxJava2源码解析1.md","raw":"title: RxJava2源码解析(一)\ndate: 2018-02-07 00:00:00\ncategories:\n- 源码解析\ntags:\n- 源码解析\n- RxJava2\n---\n## 前言\n最近组内大佬打算分享RxJava2的源码, 赶紧先预习一波, 防止技术分享会上有听没懂.大概个人准备了几天的时间, 打算先整理以下自己的源码阅读记录.RxJava2的源码解析系列打算分别从以下三面来阐述:\n1. 数据源的订阅和响应原理\n2. 线程切换的原理\n3. 背压的实现(Flowable)\n\n本篇主要尝试阐明**数据源的订阅和响应原理**\n<!-- more -->\n## 基础使用的Demo\n抛开线程切换和背压, 我们来写一个单纯的发送数据, 订阅响应的Demo,为了便于理解, 我们抛开链式调用来写\n``` java\n// 被观察者\nObservable<Integer> observable = Observable.create(new ObservableOnSubscribe<Integer>() {\n    @Override\n    public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {\n        Log.e(TAG, \"subscribe\");\n        emitter.onNext(123);\n        emitter.onComplete();\n    }\n});\n// 观察者\nObserver<Integer> observer = new Observer<Integer>() {\n    @Override\n    public void onSubscribe(Disposable d) {\n        Log.e(TAG, \"onSubscribe\");\n    }\n\n    @Override\n    public void onNext(Integer integer) {\n        Log.e(TAG, \"onNext\" + integer);\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        Log.e(TAG, \"onError\");\n    }\n\n    @Override\n    public void onComplete() {\n        Log.e(TAG, \"onComplete\");\n    }\n};\n// 订阅\nobservable.subscribe(observer);\n```\n## ObservableSource\n我们首先来看当我们创建一个`Observable`(被观察者)的时候, 实际上他做了什么\n``` java\npublic static <T> Observable<T> create(ObservableOnSubscribe<T> source) {\n        // npe校验\n        ObjectHelper.requireNonNull(source, \"source is null\");\n        return RxJavaPlugins.onAssembly(new ObservableCreate<T>(source));\n    }\n\npublic static <T> Observable<T> onAssembly(@NonNull Observable<T> source) {\n    Function<? super Observable, ? extends Observable> f = onObservableAssembly;\n    if (f != null) {\n        return apply(f, source);\n    }\n    return source;\n}\n```\n`RxJavaPlugins.onAssembly()`这个方法主要是为了hook使用, 本篇暂且不表. 所以这里`Observable.create()`返回的是一个`ObervableCreate`对象.它继承于`Observable`, 是`ObservableSource`的实现类\n## observable.subscribe(observer)\n我们主要看订阅的时候做了什么, 先上源码\n``` java\npublic final void subscribe(Observer<? super T> observer) {\n        // npe校验\n        ObjectHelper.requireNonNull(observer, \"observer is null\");\n        try {\n            // hook, 主要返回的就是我们的observer\n            observer = RxJavaPlugins.onSubscribe(this, observer);\n            // npe校验\n            ObjectHelper.requireNonNull(observer, \"Plugin returned null Observer\");\n\n            subscribeActual(observer);\n        } catch (NullPointerException e) { // NOPMD\n            throw e;\n        } catch (Throwable e) {\n            Exceptions.throwIfFatal(e);\n            // can't call onError because no way to know if a Disposable has been set or not\n            // can't call onSubscribe because the call might have set a Subscription already\n            RxJavaPlugins.onError(e);\n\n            NullPointerException npe = new NullPointerException(\"Actually not, but can't throw other exceptions due to RS\");\n            npe.initCause(e);\n            throw npe;\n        }\n    }\n```\n可以看到这里实际执行的是`subscribeActual(observer)`这个方法, 这里调用是个抽象接口, 我们在`ObervableCreate`找具体的实现\n``` java\n@Override\nprotected void subscribeActual(Observer<? super T> observer) {\n        // 包装数据发射器\n        CreateEmitter<T> parent = new CreateEmitter<T>(observer);\n        // 订阅监听\n        observer.onSubscribe(parent);\n\n        try {\n            // 上游的执行\n            source.subscribe(parent);\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            parent.onError(ex);\n        }\n    }\n```\n``` java\nemitter.onNext(123);\nemitter.onComplete();\n```\n从`source.subscribe(parent);`我们就会走到以下我们自己写的数据发送事件.这里的`emitter`通过源码我们可以看到是将`observer`包装后的`CreateEmitter`类对象, 我们在往里面看.\n``` java\nstatic final class CreateEmitter<T> extends AtomicReference<Disposable> implements ObservableEmitter<T>, Disposable {\n\n\n        private static final long serialVersionUID = -3434801548987643227L;\n\n        final Observer<? super T> observer;\n\n        CreateEmitter(Observer<? super T> observer) {\n            this.observer = observer;\n        }\n\n        @Override\n        public void onNext(T t) {\n            if (t == null) {\n                onError(new NullPointerException(\"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\"));\n                return;\n            }\n            if (!isDisposed()) {\n                observer.onNext(t);\n            }\n        }\n\n        @Override\n        public void onError(Throwable t) {\n            if (!tryOnError(t)) {\n                RxJavaPlugins.onError(t);\n            }\n        }\n\n        @Override\n        public boolean tryOnError(Throwable t) {\n            if (t == null) {\n                t = new NullPointerException(\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\");\n            }\n            if (!isDisposed()) {\n                try {\n                    observer.onError(t);\n                } finally {\n                    dispose();\n                }\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public void onComplete() {\n            if (!isDisposed()) {\n                try {\n                    observer.onComplete();\n                } finally {\n                    dispose();\n                }\n            }\n        }\n\n        @Override\n        public void setDisposable(Disposable d) {\n            DisposableHelper.set(this, d);\n        }\n\n        @Override\n        public void setCancellable(Cancellable c) {\n            setDisposable(new CancellableDisposable(c));\n        }\n\n        @Override\n        public ObservableEmitter<T> serialize() {\n            return new SerializedEmitter<T>(this);\n        }\n\n        @Override\n        public void dispose() {\n            DisposableHelper.dispose(this);\n        }\n\n        @Override\n        public boolean isDisposed() {\n            return DisposableHelper.isDisposed(get());\n        }\n    }\n```\n通过之前将`observer`传入`CreateEmitter`, 调用`emitter.onNext`最终调用走到了`observer.onNext`.\n整体的流程非常的清晰. 下面我们看下, 如果中间有多重数据转换, 是什么样的流程\n## 数据转换实现流程\n以第一个基础demo为例, 我们改造下`Observable`(被观察者), 将他进行一次数据转换, 并且做一次筛除.这个demo的意思就是发送123, 中间做+1处理, 然后筛选出大于122的数据发送给观察者.这个很容易理解.\n``` java\nObservable<Integer> observable =\n                Observable\n                        .create(new ObservableOnSubscribe<Integer>() {\n                            @Override\n                            public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {\n                                Log.e(TAG, \"subscribe\");\n                                emitter.onNext(123);\n                                emitter.onComplete();\n                            }\n                        })\n                        .map(new Function<Integer, Integer>() {\n                            @Override\n                            public Integer apply(Integer integer) throws Exception {\n                                Log.e(TAG, \"map\");\n                                return integer + 1;\n                            }\n                        })\n                        .filter(new Predicate<Integer>() {\n                            @Override\n                            public boolean test(Integer integer) throws Exception {\n                                Log.e(TAG, \"filter\");\n                                return integer > 122;\n                            }\n                        });\n```\n我们依旧来看下`map`操作符的源码\n``` java\npublic final <R> Observable<R> map(Function<? super T, ? extends R> mapper) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        return RxJavaPlugins.onAssembly(new ObservableMap<T, R>(this, mapper));\n    }\n```\n是不是很眼熟? 忽略掉hook, 这里返回的是`ObservableMap`对象.同样, `filter`操作符返回的是一个`ObservableFilter`\n``` java\npublic final Observable<T> filter(Predicate<? super T> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n        return RxJavaPlugins.onAssembly(new ObservableFilter<T>(this, predicate));\n    }\n```\n不论是`ObservableMap`还是`ObservableFilter`他们都继承于`AbstractObservableWithUpstream`抽象类, 它继承于`Observable`, 带有上游的`Observable`\n``` java\nabstract class AbstractObservableWithUpstream<T, U> extends Observable<U> implements HasUpstreamObservableSource<T> {\n\n    /** The source consumable Observable. */\n    // 上游Obervable\n    protected final ObservableSource<T> source;\n\n    /**\n     * Constructs the ObservableSource with the given consumable.\n     * @param source the consumable Observable\n     */\n    AbstractObservableWithUpstream(ObservableSource<T> source) {\n        this.source = source;\n    }\n\n    @Override\n    public final ObservableSource<T> source() {\n        return source;\n    }\n\n}\n```\n这时候, 我们重新看下订阅的处理, 当我们执行`observable.subscribe(observer)`的时候, `observable`最终返回的是`ObservableFilter`对象, 所以我们需要看这个类对象的`subscribeActual(observer)`方法.他的代码很简洁, 实际就是将我们的`observer`和`filter`操作符的具体操作方法包装成一个`FilterObserver`对象, 然后由上游`ObservableMap`对象来subscribe(订阅)它.\n``` java\n@Override\n    public void subscribeActual(Observer<? super T> s) {\n        source.subscribe(new FilterObserver<T>(s, predicate));\n    }\n```\n我们已经知道`Observable.subscribe(observer)`方法实际调用的是对应实现类的`subscribeActual(observer)`方法, 所以我们直接去看`ObservableMap.subscribeActual(observer)`方法就可以了, 他的方法与`FilterObserver`内的类似, 这时候是将前面传进来的`FilterObserver`对象和我们`map`操作符做的操作包装成一个`MapObserver`对象, 交给上游.\n``` java\n@Override\n    public void subscribeActual(Observer<? super U> t) {\n        source.subscribe(new MapObserver<T, U>(t, function));\n    }\n```\n这时候我们的上游是`ObservableCreate`对象,它的`subscribeActual(observer)`方法上文有提到, 他将`MapObserver`对象包装进`CreateEmitter`对象, 这个时候, 才开始执行订阅动作, 然后我们走到`CreateEmitter`的`onNext()`方法,实际会执行到下游观察者的`onNext`方法, 在这层, 我们的观察者是`MapObserver`.它继承于`BasicFuseableObserver`, 表示一个流程执行中间的观察者对象. 现在我们看`MapObserver`的`onNext`的执行, 这里我们主要关注主流程的执行逻辑, 忽略掉其他代码, 可以看到它最终调用的是`actual.onNext(v)`, 首先将我们`map`操作符的逻辑处理返回的数据赋值给`v`, 这里的`actual`指的是我们下游的`observer`(观察者), 那么这个时候是我们的`FilterObserver`对象, 将`v`对象通过`onNext`传递下去.\n``` java\nstatic final class MapObserver<T, U> extends BasicFuseableObserver<T, U> {\n        final Function<? super T, ? extends U> mapper;\n\n        MapObserver(Observer<? super U> actual, Function<? super T, ? extends U> mapper) {\n            super(actual);\n            this.mapper = mapper;\n        }\n\n        @Override\n        public void onNext(T t) {\n            if (done) {\n                return;\n            }\n\n            if (sourceMode != NONE) {\n                actual.onNext(null);\n                return;\n            }\n\n            U v;\n\n            try {\n                v = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper function returned a null value.\");\n            } catch (Throwable ex) {\n                fail(ex);\n                return;\n            }\n            actual.onNext(v);\n        }\n\n        @Override\n        public int requestFusion(int mode) {\n            return transitiveBoundaryFusion(mode);\n        }\n\n        @Nullable\n        @Override\n        public U poll() throws Exception {\n            T t = qs.poll();\n            return t != null ? ObjectHelper.<U>requireNonNull(mapper.apply(t), \"The mapper function returned a null value.\") : null;\n        }\n    }\n```\n然后我们看`FilterObserver`的源码, 他的`onNext`逻辑就是会执行我们传进去的`Predicate`对象的`test`方法, 如果符合筛选逻辑, 就会通过调用下游的`onNext`将数据传下去, 这个时候的下游是我们new的`Observer`, 这时候的执行,我们应该就清楚了.\n``` java\nstatic final class FilterObserver<T> extends BasicFuseableObserver<T, T> {\n        final Predicate<? super T> filter;\n\n        FilterObserver(Observer<? super T> actual, Predicate<? super T> filter) {\n            super(actual);\n            this.filter = filter;\n        }\n\n        @Override\n        public void onNext(T t) {\n            if (sourceMode == NONE) {\n                boolean b;\n                try {\n                    b = filter.test(t);\n                } catch (Throwable e) {\n                    fail(e);\n                    return;\n                }\n                if (b) {\n                    actual.onNext(t);\n                }\n            } else {\n                actual.onNext(null);\n            }\n        }\n\n        @Override\n        public int requestFusion(int mode) {\n            return transitiveBoundaryFusion(mode);\n        }\n\n        @Nullable\n        @Override\n        public T poll() throws Exception {\n            for (;;) {\n                T v = qs.poll();\n                if (v == null || filter.test(v)) {\n                    return v;\n                }\n            }\n        }\n    }\n```\n## 总结\n订阅和数据的传输的原理就是如此. 我们用流程图来总结下上面的整个流程.\n![流程图](RxJava2源码解析/rxjava实现原理.jpg)\n总的来说, 订阅的动作是层层递归上传到最开始的`Observable`, 然后从最开始的`Observable`将数据一层层往下传.\n当然, 从`装饰模式`来讲, 他这里的实际动作就是将`Observable`做了层层装饰来传递订阅, 对设计模式有兴趣的同学可以看看相关的书籍, 对于理解这段代码有点睛之用\n","slug":"RxJava2源码解析1","published":1,"updated":"2018-05-07T02:03:22.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh7fldng00198os6qkhf0alb","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近组内大佬打算分享RxJava2的源码, 赶紧先预习一波, 防止技术分享会上有听没懂.大概个人准备了几天的时间, 打算先整理以下自己的源码阅读记录.RxJava2的源码解析系列打算分别从以下三面来阐述:</p>\n<ol>\n<li>数据源的订阅和响应原理</li>\n<li>线程切换的原理</li>\n<li>背压的实现(Flowable)</li>\n</ol>\n<p>本篇主要尝试阐明<strong>数据源的订阅和响应原理</strong><br><a id=\"more\"></a></p>\n<h2 id=\"基础使用的Demo\"><a href=\"#基础使用的Demo\" class=\"headerlink\" title=\"基础使用的Demo\"></a>基础使用的Demo</h2><p>抛开线程切换和背压, 我们来写一个单纯的发送数据, 订阅响应的Demo,为了便于理解, 我们抛开链式调用来写<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 被观察者</span></span><br><span class=\"line\">Observable&lt;Integer&gt; observable = Observable.create(<span class=\"keyword\">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">\"subscribe\"</span>);</span><br><span class=\"line\">        emitter.onNext(<span class=\"number\">123</span>);</span><br><span class=\"line\">        emitter.onComplete();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 观察者</span></span><br><span class=\"line\">Observer&lt;Integer&gt; observer = <span class=\"keyword\">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSubscribe</span><span class=\"params\">(Disposable d)</span> </span>&#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">\"onSubscribe\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(Integer integer)</span> </span>&#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">\"onNext\"</span> + integer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">\"onError\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">\"onComplete\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 订阅</span></span><br><span class=\"line\">observable.subscribe(observer);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"ObservableSource\"><a href=\"#ObservableSource\" class=\"headerlink\" title=\"ObservableSource\"></a>ObservableSource</h2><p>我们首先来看当我们创建一个<code>Observable</code>(被观察者)的时候, 实际上他做了什么<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Observable&lt;T&gt; <span class=\"title\">create</span><span class=\"params\">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// npe校验</span></span><br><span class=\"line\">        ObjectHelper.requireNonNull(source, <span class=\"string\">\"source is null\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RxJavaPlugins.onAssembly(<span class=\"keyword\">new</span> ObservableCreate&lt;T&gt;(source));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Observable&lt;T&gt; <span class=\"title\">onAssembly</span><span class=\"params\">(@NonNull Observable&lt;T&gt; source)</span> </span>&#123;</span><br><span class=\"line\">    Function&lt;? <span class=\"keyword\">super</span> Observable, ? extends Observable&gt; f = onObservableAssembly;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> apply(f, source);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> source;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>RxJavaPlugins.onAssembly()</code>这个方法主要是为了hook使用, 本篇暂且不表. 所以这里<code>Observable.create()</code>返回的是一个<code>ObervableCreate</code>对象.它继承于<code>Observable</code>, 是<code>ObservableSource</code>的实现类</p>\n<h2 id=\"observable-subscribe-observer\"><a href=\"#observable-subscribe-observer\" class=\"headerlink\" title=\"observable.subscribe(observer)\"></a>observable.subscribe(observer)</h2><p>我们主要看订阅的时候做了什么, 先上源码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// npe校验</span></span><br><span class=\"line\">        ObjectHelper.requireNonNull(observer, <span class=\"string\">\"observer is null\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// hook, 主要返回的就是我们的observer</span></span><br><span class=\"line\">            observer = RxJavaPlugins.onSubscribe(<span class=\"keyword\">this</span>, observer);</span><br><span class=\"line\">            <span class=\"comment\">// npe校验</span></span><br><span class=\"line\">            ObjectHelper.requireNonNull(observer, <span class=\"string\">\"Plugin returned null Observer\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            subscribeActual(observer);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NullPointerException e) &#123; <span class=\"comment\">// NOPMD</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            Exceptions.throwIfFatal(e);</span><br><span class=\"line\">            <span class=\"comment\">// can't call onError because no way to know if a Disposable has been set or not</span></span><br><span class=\"line\">            <span class=\"comment\">// can't call onSubscribe because the call might have set a Subscription already</span></span><br><span class=\"line\">            RxJavaPlugins.onError(e);</span><br><span class=\"line\"></span><br><span class=\"line\">            NullPointerException npe = <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"Actually not, but can't throw other exceptions due to RS\"</span>);</span><br><span class=\"line\">            npe.initCause(e);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> npe;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到这里实际执行的是<code>subscribeActual(observer)</code>这个方法, 这里调用是个抽象接口, 我们在<code>ObervableCreate</code>找具体的实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribeActual</span><span class=\"params\">(Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 包装数据发射器</span></span><br><span class=\"line\">        CreateEmitter&lt;T&gt; parent = <span class=\"keyword\">new</span> CreateEmitter&lt;T&gt;(observer);</span><br><span class=\"line\">        <span class=\"comment\">// 订阅监听</span></span><br><span class=\"line\">        observer.onSubscribe(parent);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 上游的执行</span></span><br><span class=\"line\">            source.subscribe(parent);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">            Exceptions.throwIfFatal(ex);</span><br><span class=\"line\">            parent.onError(ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">emitter.onNext(<span class=\"number\">123</span>);</span><br><span class=\"line\">emitter.onComplete();</span><br></pre></td></tr></table></figure>\n<p>从<code>source.subscribe(parent);</code>我们就会走到以下我们自己写的数据发送事件.这里的<code>emitter</code>通过源码我们可以看到是将<code>observer</code>包装后的<code>CreateEmitter</code>类对象, 我们在往里面看.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CreateEmitter</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AtomicReference</span>&lt;<span class=\"title\">Disposable</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">ObservableEmitter</span>&lt;<span class=\"title\">T</span>&gt;, <span class=\"title\">Disposable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">3434801548987643227L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer;</span><br><span class=\"line\"></span><br><span class=\"line\">        CreateEmitter(Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.observer = observer;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                onError(<span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\"</span>));</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!isDisposed()) &#123;</span><br><span class=\"line\">                observer.onNext(t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable t)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!tryOnError(t)) &#123;</span><br><span class=\"line\">                RxJavaPlugins.onError(t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryOnError</span><span class=\"params\">(Throwable t)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                t = <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!isDisposed()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    observer.onError(t);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    dispose();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!isDisposed()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    observer.onComplete();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    dispose();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDisposable</span><span class=\"params\">(Disposable d)</span> </span>&#123;</span><br><span class=\"line\">            DisposableHelper.set(<span class=\"keyword\">this</span>, d);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCancellable</span><span class=\"params\">(Cancellable c)</span> </span>&#123;</span><br><span class=\"line\">            setDisposable(<span class=\"keyword\">new</span> CancellableDisposable(c));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> ObservableEmitter&lt;T&gt; <span class=\"title\">serialize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SerializedEmitter&lt;T&gt;(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispose</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            DisposableHelper.dispose(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isDisposed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> DisposableHelper.isDisposed(get());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过之前将<code>observer</code>传入<code>CreateEmitter</code>, 调用<code>emitter.onNext</code>最终调用走到了<code>observer.onNext</code>.<br>整体的流程非常的清晰. 下面我们看下, 如果中间有多重数据转换, 是什么样的流程</p>\n<h2 id=\"数据转换实现流程\"><a href=\"#数据转换实现流程\" class=\"headerlink\" title=\"数据转换实现流程\"></a>数据转换实现流程</h2><p>以第一个基础demo为例, 我们改造下<code>Observable</code>(被观察者), 将他进行一次数据转换, 并且做一次筛除.这个demo的意思就是发送123, 中间做+1处理, 然后筛选出大于122的数据发送给观察者.这个很容易理解.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable&lt;Integer&gt; observable =</span><br><span class=\"line\">                Observable</span><br><span class=\"line\">                        .create(<span class=\"keyword\">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class=\"line\">                            <span class=\"meta\">@Override</span></span><br><span class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                                Log.e(TAG, <span class=\"string\">\"subscribe\"</span>);</span><br><span class=\"line\">                                emitter.onNext(<span class=\"number\">123</span>);</span><br><span class=\"line\">                                emitter.onComplete();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;)</span><br><span class=\"line\">                        .map(<span class=\"keyword\">new</span> Function&lt;Integer, Integer&gt;() &#123;</span><br><span class=\"line\">                            <span class=\"meta\">@Override</span></span><br><span class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">apply</span><span class=\"params\">(Integer integer)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                                Log.e(TAG, <span class=\"string\">\"map\"</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">return</span> integer + <span class=\"number\">1</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;)</span><br><span class=\"line\">                        .filter(<span class=\"keyword\">new</span> Predicate&lt;Integer&gt;() &#123;</span><br><span class=\"line\">                            <span class=\"meta\">@Override</span></span><br><span class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">test</span><span class=\"params\">(Integer integer)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                                Log.e(TAG, <span class=\"string\">\"filter\"</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">return</span> integer &gt; <span class=\"number\">122</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>我们依旧来看下<code>map</code>操作符的源码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> &lt;R&gt; <span class=\"function\">Observable&lt;R&gt; <span class=\"title\">map</span><span class=\"params\">(Function&lt;? <span class=\"keyword\">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class=\"line\">        ObjectHelper.requireNonNull(mapper, <span class=\"string\">\"mapper is null\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RxJavaPlugins.onAssembly(<span class=\"keyword\">new</span> ObservableMap&lt;T, R&gt;(<span class=\"keyword\">this</span>, mapper));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>是不是很眼熟? 忽略掉hook, 这里返回的是<code>ObservableMap</code>对象.同样, <code>filter</code>操作符返回的是一个<code>ObservableFilter</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Observable&lt;T&gt; <span class=\"title\">filter</span><span class=\"params\">(Predicate&lt;? <span class=\"keyword\">super</span> T&gt; predicate)</span> </span>&#123;</span><br><span class=\"line\">        ObjectHelper.requireNonNull(predicate, <span class=\"string\">\"predicate is null\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RxJavaPlugins.onAssembly(<span class=\"keyword\">new</span> ObservableFilter&lt;T&gt;(<span class=\"keyword\">this</span>, predicate));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>不论是<code>ObservableMap</code>还是<code>ObservableFilter</code>他们都继承于<code>AbstractObservableWithUpstream</code>抽象类, 它继承于<code>Observable</code>, 带有上游的<code>Observable</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractObservableWithUpstream</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">U</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Observable</span>&lt;<span class=\"title\">U</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">HasUpstreamObservableSource</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** The source consumable Observable. */</span></span><br><span class=\"line\">    <span class=\"comment\">// 上游Obervable</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> ObservableSource&lt;T&gt; source;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructs the ObservableSource with the given consumable.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> source the consumable Observable</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    AbstractObservableWithUpstream(ObservableSource&lt;T&gt; source) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.source = source;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ObservableSource&lt;T&gt; <span class=\"title\">source</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> source;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这时候, 我们重新看下订阅的处理, 当我们执行<code>observable.subscribe(observer)</code>的时候, <code>observable</code>最终返回的是<code>ObservableFilter</code>对象, 所以我们需要看这个类对象的<code>subscribeActual(observer)</code>方法.他的代码很简洁, 实际就是将我们的<code>observer</code>和<code>filter</code>操作符的具体操作方法包装成一个<code>FilterObserver</code>对象, 然后由上游<code>ObservableMap</code>对象来subscribe(订阅)它.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribeActual</span><span class=\"params\">(Observer&lt;? <span class=\"keyword\">super</span> T&gt; s)</span> </span>&#123;</span><br><span class=\"line\">        source.subscribe(<span class=\"keyword\">new</span> FilterObserver&lt;T&gt;(s, predicate));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们已经知道<code>Observable.subscribe(observer)</code>方法实际调用的是对应实现类的<code>subscribeActual(observer)</code>方法, 所以我们直接去看<code>ObservableMap.subscribeActual(observer)</code>方法就可以了, 他的方法与<code>FilterObserver</code>内的类似, 这时候是将前面传进来的<code>FilterObserver</code>对象和我们<code>map</code>操作符做的操作包装成一个<code>MapObserver</code>对象, 交给上游.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribeActual</span><span class=\"params\">(Observer&lt;? <span class=\"keyword\">super</span> U&gt; t)</span> </span>&#123;</span><br><span class=\"line\">        source.subscribe(<span class=\"keyword\">new</span> MapObserver&lt;T, U&gt;(t, function));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这时候我们的上游是<code>ObservableCreate</code>对象,它的<code>subscribeActual(observer)</code>方法上文有提到, 他将<code>MapObserver</code>对象包装进<code>CreateEmitter</code>对象, 这个时候, 才开始执行订阅动作, 然后我们走到<code>CreateEmitter</code>的<code>onNext()</code>方法,实际会执行到下游观察者的<code>onNext</code>方法, 在这层, 我们的观察者是<code>MapObserver</code>.它继承于<code>BasicFuseableObserver</code>, 表示一个流程执行中间的观察者对象. 现在我们看<code>MapObserver</code>的<code>onNext</code>的执行, 这里我们主要关注主流程的执行逻辑, 忽略掉其他代码, 可以看到它最终调用的是<code>actual.onNext(v)</code>, 首先将我们<code>map</code>操作符的逻辑处理返回的数据赋值给<code>v</code>, 这里的<code>actual</code>指的是我们下游的<code>observer</code>(观察者), 那么这个时候是我们的<code>FilterObserver</code>对象, 将<code>v</code>对象通过<code>onNext</code>传递下去.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapObserver</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">U</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">BasicFuseableObserver</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">U</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Function&lt;? <span class=\"keyword\">super</span> T, ? extends U&gt; mapper;</span><br><span class=\"line\"></span><br><span class=\"line\">        MapObserver(Observer&lt;? <span class=\"keyword\">super</span> U&gt; actual, Function&lt;? <span class=\"keyword\">super</span> T, ? extends U&gt; mapper) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(actual);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.mapper = mapper;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (done) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sourceMode != NONE) &#123;</span><br><span class=\"line\">                actual.onNext(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            U v;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                v = ObjectHelper.requireNonNull(mapper.apply(t), <span class=\"string\">\"The mapper function returned a null value.\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                fail(ex);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            actual.onNext(v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">requestFusion</span><span class=\"params\">(<span class=\"keyword\">int</span> mode)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> transitiveBoundaryFusion(mode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> U <span class=\"title\">poll</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            T t = qs.poll();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t != <span class=\"keyword\">null</span> ? ObjectHelper.&lt;U&gt;requireNonNull(mapper.apply(t), <span class=\"string\">\"The mapper function returned a null value.\"</span>) : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后我们看<code>FilterObserver</code>的源码, 他的<code>onNext</code>逻辑就是会执行我们传进去的<code>Predicate</code>对象的<code>test</code>方法, 如果符合筛选逻辑, 就会通过调用下游的<code>onNext</code>将数据传下去, 这个时候的下游是我们new的<code>Observer</code>, 这时候的执行,我们应该就清楚了.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FilterObserver</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">BasicFuseableObserver</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Predicate&lt;? <span class=\"keyword\">super</span> T&gt; filter;</span><br><span class=\"line\"></span><br><span class=\"line\">        FilterObserver(Observer&lt;? <span class=\"keyword\">super</span> T&gt; actual, Predicate&lt;? <span class=\"keyword\">super</span> T&gt; filter) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(actual);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.filter = filter;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sourceMode == NONE) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> b;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    b = filter.test(t);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">                    fail(e);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (b) &#123;</span><br><span class=\"line\">                    actual.onNext(t);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                actual.onNext(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">requestFusion</span><span class=\"params\">(<span class=\"keyword\">int</span> mode)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> transitiveBoundaryFusion(mode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">poll</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                T v = qs.poll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (v == <span class=\"keyword\">null</span> || filter.test(v)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>订阅和数据的传输的原理就是如此. 我们用流程图来总结下上面的整个流程.<br><img src=\"RxJava2源码解析/rxjava实现原理.jpg\" alt=\"流程图\"><br>总的来说, 订阅的动作是层层递归上传到最开始的<code>Observable</code>, 然后从最开始的<code>Observable</code>将数据一层层往下传.<br>当然, 从<code>装饰模式</code>来讲, 他这里的实际动作就是将<code>Observable</code>做了层层装饰来传递订阅, 对设计模式有兴趣的同学可以看看相关的书籍, 对于理解这段代码有点睛之用</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近组内大佬打算分享RxJava2的源码, 赶紧先预习一波, 防止技术分享会上有听没懂.大概个人准备了几天的时间, 打算先整理以下自己的源码阅读记录.RxJava2的源码解析系列打算分别从以下三面来阐述:</p>\n<ol>\n<li>数据源的订阅和响应原理</li>\n<li>线程切换的原理</li>\n<li>背压的实现(Flowable)</li>\n</ol>\n<p>本篇主要尝试阐明<strong>数据源的订阅和响应原理</strong><br>","more":"</p>\n<h2 id=\"基础使用的Demo\"><a href=\"#基础使用的Demo\" class=\"headerlink\" title=\"基础使用的Demo\"></a>基础使用的Demo</h2><p>抛开线程切换和背压, 我们来写一个单纯的发送数据, 订阅响应的Demo,为了便于理解, 我们抛开链式调用来写<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 被观察者</span></span><br><span class=\"line\">Observable&lt;Integer&gt; observable = Observable.create(<span class=\"keyword\">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">\"subscribe\"</span>);</span><br><span class=\"line\">        emitter.onNext(<span class=\"number\">123</span>);</span><br><span class=\"line\">        emitter.onComplete();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 观察者</span></span><br><span class=\"line\">Observer&lt;Integer&gt; observer = <span class=\"keyword\">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSubscribe</span><span class=\"params\">(Disposable d)</span> </span>&#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">\"onSubscribe\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(Integer integer)</span> </span>&#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">\"onNext\"</span> + integer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">\"onError\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">\"onComplete\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 订阅</span></span><br><span class=\"line\">observable.subscribe(observer);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"ObservableSource\"><a href=\"#ObservableSource\" class=\"headerlink\" title=\"ObservableSource\"></a>ObservableSource</h2><p>我们首先来看当我们创建一个<code>Observable</code>(被观察者)的时候, 实际上他做了什么<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Observable&lt;T&gt; <span class=\"title\">create</span><span class=\"params\">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// npe校验</span></span><br><span class=\"line\">        ObjectHelper.requireNonNull(source, <span class=\"string\">\"source is null\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RxJavaPlugins.onAssembly(<span class=\"keyword\">new</span> ObservableCreate&lt;T&gt;(source));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Observable&lt;T&gt; <span class=\"title\">onAssembly</span><span class=\"params\">(@NonNull Observable&lt;T&gt; source)</span> </span>&#123;</span><br><span class=\"line\">    Function&lt;? <span class=\"keyword\">super</span> Observable, ? extends Observable&gt; f = onObservableAssembly;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> apply(f, source);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> source;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>RxJavaPlugins.onAssembly()</code>这个方法主要是为了hook使用, 本篇暂且不表. 所以这里<code>Observable.create()</code>返回的是一个<code>ObervableCreate</code>对象.它继承于<code>Observable</code>, 是<code>ObservableSource</code>的实现类</p>\n<h2 id=\"observable-subscribe-observer\"><a href=\"#observable-subscribe-observer\" class=\"headerlink\" title=\"observable.subscribe(observer)\"></a>observable.subscribe(observer)</h2><p>我们主要看订阅的时候做了什么, 先上源码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// npe校验</span></span><br><span class=\"line\">        ObjectHelper.requireNonNull(observer, <span class=\"string\">\"observer is null\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// hook, 主要返回的就是我们的observer</span></span><br><span class=\"line\">            observer = RxJavaPlugins.onSubscribe(<span class=\"keyword\">this</span>, observer);</span><br><span class=\"line\">            <span class=\"comment\">// npe校验</span></span><br><span class=\"line\">            ObjectHelper.requireNonNull(observer, <span class=\"string\">\"Plugin returned null Observer\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            subscribeActual(observer);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NullPointerException e) &#123; <span class=\"comment\">// NOPMD</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            Exceptions.throwIfFatal(e);</span><br><span class=\"line\">            <span class=\"comment\">// can't call onError because no way to know if a Disposable has been set or not</span></span><br><span class=\"line\">            <span class=\"comment\">// can't call onSubscribe because the call might have set a Subscription already</span></span><br><span class=\"line\">            RxJavaPlugins.onError(e);</span><br><span class=\"line\"></span><br><span class=\"line\">            NullPointerException npe = <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"Actually not, but can't throw other exceptions due to RS\"</span>);</span><br><span class=\"line\">            npe.initCause(e);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> npe;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到这里实际执行的是<code>subscribeActual(observer)</code>这个方法, 这里调用是个抽象接口, 我们在<code>ObervableCreate</code>找具体的实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribeActual</span><span class=\"params\">(Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 包装数据发射器</span></span><br><span class=\"line\">        CreateEmitter&lt;T&gt; parent = <span class=\"keyword\">new</span> CreateEmitter&lt;T&gt;(observer);</span><br><span class=\"line\">        <span class=\"comment\">// 订阅监听</span></span><br><span class=\"line\">        observer.onSubscribe(parent);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 上游的执行</span></span><br><span class=\"line\">            source.subscribe(parent);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">            Exceptions.throwIfFatal(ex);</span><br><span class=\"line\">            parent.onError(ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">emitter.onNext(<span class=\"number\">123</span>);</span><br><span class=\"line\">emitter.onComplete();</span><br></pre></td></tr></table></figure>\n<p>从<code>source.subscribe(parent);</code>我们就会走到以下我们自己写的数据发送事件.这里的<code>emitter</code>通过源码我们可以看到是将<code>observer</code>包装后的<code>CreateEmitter</code>类对象, 我们在往里面看.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CreateEmitter</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AtomicReference</span>&lt;<span class=\"title\">Disposable</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">ObservableEmitter</span>&lt;<span class=\"title\">T</span>&gt;, <span class=\"title\">Disposable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">3434801548987643227L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer;</span><br><span class=\"line\"></span><br><span class=\"line\">        CreateEmitter(Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.observer = observer;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                onError(<span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\"</span>));</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!isDisposed()) &#123;</span><br><span class=\"line\">                observer.onNext(t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable t)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!tryOnError(t)) &#123;</span><br><span class=\"line\">                RxJavaPlugins.onError(t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryOnError</span><span class=\"params\">(Throwable t)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                t = <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!isDisposed()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    observer.onError(t);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    dispose();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!isDisposed()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    observer.onComplete();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    dispose();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDisposable</span><span class=\"params\">(Disposable d)</span> </span>&#123;</span><br><span class=\"line\">            DisposableHelper.set(<span class=\"keyword\">this</span>, d);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCancellable</span><span class=\"params\">(Cancellable c)</span> </span>&#123;</span><br><span class=\"line\">            setDisposable(<span class=\"keyword\">new</span> CancellableDisposable(c));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> ObservableEmitter&lt;T&gt; <span class=\"title\">serialize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SerializedEmitter&lt;T&gt;(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispose</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            DisposableHelper.dispose(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isDisposed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> DisposableHelper.isDisposed(get());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过之前将<code>observer</code>传入<code>CreateEmitter</code>, 调用<code>emitter.onNext</code>最终调用走到了<code>observer.onNext</code>.<br>整体的流程非常的清晰. 下面我们看下, 如果中间有多重数据转换, 是什么样的流程</p>\n<h2 id=\"数据转换实现流程\"><a href=\"#数据转换实现流程\" class=\"headerlink\" title=\"数据转换实现流程\"></a>数据转换实现流程</h2><p>以第一个基础demo为例, 我们改造下<code>Observable</code>(被观察者), 将他进行一次数据转换, 并且做一次筛除.这个demo的意思就是发送123, 中间做+1处理, 然后筛选出大于122的数据发送给观察者.这个很容易理解.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable&lt;Integer&gt; observable =</span><br><span class=\"line\">                Observable</span><br><span class=\"line\">                        .create(<span class=\"keyword\">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class=\"line\">                            <span class=\"meta\">@Override</span></span><br><span class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                                Log.e(TAG, <span class=\"string\">\"subscribe\"</span>);</span><br><span class=\"line\">                                emitter.onNext(<span class=\"number\">123</span>);</span><br><span class=\"line\">                                emitter.onComplete();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;)</span><br><span class=\"line\">                        .map(<span class=\"keyword\">new</span> Function&lt;Integer, Integer&gt;() &#123;</span><br><span class=\"line\">                            <span class=\"meta\">@Override</span></span><br><span class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">apply</span><span class=\"params\">(Integer integer)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                                Log.e(TAG, <span class=\"string\">\"map\"</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">return</span> integer + <span class=\"number\">1</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;)</span><br><span class=\"line\">                        .filter(<span class=\"keyword\">new</span> Predicate&lt;Integer&gt;() &#123;</span><br><span class=\"line\">                            <span class=\"meta\">@Override</span></span><br><span class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">test</span><span class=\"params\">(Integer integer)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                                Log.e(TAG, <span class=\"string\">\"filter\"</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">return</span> integer &gt; <span class=\"number\">122</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>我们依旧来看下<code>map</code>操作符的源码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> &lt;R&gt; <span class=\"function\">Observable&lt;R&gt; <span class=\"title\">map</span><span class=\"params\">(Function&lt;? <span class=\"keyword\">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class=\"line\">        ObjectHelper.requireNonNull(mapper, <span class=\"string\">\"mapper is null\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RxJavaPlugins.onAssembly(<span class=\"keyword\">new</span> ObservableMap&lt;T, R&gt;(<span class=\"keyword\">this</span>, mapper));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>是不是很眼熟? 忽略掉hook, 这里返回的是<code>ObservableMap</code>对象.同样, <code>filter</code>操作符返回的是一个<code>ObservableFilter</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Observable&lt;T&gt; <span class=\"title\">filter</span><span class=\"params\">(Predicate&lt;? <span class=\"keyword\">super</span> T&gt; predicate)</span> </span>&#123;</span><br><span class=\"line\">        ObjectHelper.requireNonNull(predicate, <span class=\"string\">\"predicate is null\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RxJavaPlugins.onAssembly(<span class=\"keyword\">new</span> ObservableFilter&lt;T&gt;(<span class=\"keyword\">this</span>, predicate));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>不论是<code>ObservableMap</code>还是<code>ObservableFilter</code>他们都继承于<code>AbstractObservableWithUpstream</code>抽象类, 它继承于<code>Observable</code>, 带有上游的<code>Observable</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractObservableWithUpstream</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">U</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Observable</span>&lt;<span class=\"title\">U</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">HasUpstreamObservableSource</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** The source consumable Observable. */</span></span><br><span class=\"line\">    <span class=\"comment\">// 上游Obervable</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> ObservableSource&lt;T&gt; source;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructs the ObservableSource with the given consumable.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> source the consumable Observable</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    AbstractObservableWithUpstream(ObservableSource&lt;T&gt; source) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.source = source;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ObservableSource&lt;T&gt; <span class=\"title\">source</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> source;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这时候, 我们重新看下订阅的处理, 当我们执行<code>observable.subscribe(observer)</code>的时候, <code>observable</code>最终返回的是<code>ObservableFilter</code>对象, 所以我们需要看这个类对象的<code>subscribeActual(observer)</code>方法.他的代码很简洁, 实际就是将我们的<code>observer</code>和<code>filter</code>操作符的具体操作方法包装成一个<code>FilterObserver</code>对象, 然后由上游<code>ObservableMap</code>对象来subscribe(订阅)它.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribeActual</span><span class=\"params\">(Observer&lt;? <span class=\"keyword\">super</span> T&gt; s)</span> </span>&#123;</span><br><span class=\"line\">        source.subscribe(<span class=\"keyword\">new</span> FilterObserver&lt;T&gt;(s, predicate));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们已经知道<code>Observable.subscribe(observer)</code>方法实际调用的是对应实现类的<code>subscribeActual(observer)</code>方法, 所以我们直接去看<code>ObservableMap.subscribeActual(observer)</code>方法就可以了, 他的方法与<code>FilterObserver</code>内的类似, 这时候是将前面传进来的<code>FilterObserver</code>对象和我们<code>map</code>操作符做的操作包装成一个<code>MapObserver</code>对象, 交给上游.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribeActual</span><span class=\"params\">(Observer&lt;? <span class=\"keyword\">super</span> U&gt; t)</span> </span>&#123;</span><br><span class=\"line\">        source.subscribe(<span class=\"keyword\">new</span> MapObserver&lt;T, U&gt;(t, function));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这时候我们的上游是<code>ObservableCreate</code>对象,它的<code>subscribeActual(observer)</code>方法上文有提到, 他将<code>MapObserver</code>对象包装进<code>CreateEmitter</code>对象, 这个时候, 才开始执行订阅动作, 然后我们走到<code>CreateEmitter</code>的<code>onNext()</code>方法,实际会执行到下游观察者的<code>onNext</code>方法, 在这层, 我们的观察者是<code>MapObserver</code>.它继承于<code>BasicFuseableObserver</code>, 表示一个流程执行中间的观察者对象. 现在我们看<code>MapObserver</code>的<code>onNext</code>的执行, 这里我们主要关注主流程的执行逻辑, 忽略掉其他代码, 可以看到它最终调用的是<code>actual.onNext(v)</code>, 首先将我们<code>map</code>操作符的逻辑处理返回的数据赋值给<code>v</code>, 这里的<code>actual</code>指的是我们下游的<code>observer</code>(观察者), 那么这个时候是我们的<code>FilterObserver</code>对象, 将<code>v</code>对象通过<code>onNext</code>传递下去.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapObserver</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">U</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">BasicFuseableObserver</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">U</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Function&lt;? <span class=\"keyword\">super</span> T, ? extends U&gt; mapper;</span><br><span class=\"line\"></span><br><span class=\"line\">        MapObserver(Observer&lt;? <span class=\"keyword\">super</span> U&gt; actual, Function&lt;? <span class=\"keyword\">super</span> T, ? extends U&gt; mapper) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(actual);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.mapper = mapper;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (done) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sourceMode != NONE) &#123;</span><br><span class=\"line\">                actual.onNext(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            U v;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                v = ObjectHelper.requireNonNull(mapper.apply(t), <span class=\"string\">\"The mapper function returned a null value.\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                fail(ex);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            actual.onNext(v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">requestFusion</span><span class=\"params\">(<span class=\"keyword\">int</span> mode)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> transitiveBoundaryFusion(mode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> U <span class=\"title\">poll</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            T t = qs.poll();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t != <span class=\"keyword\">null</span> ? ObjectHelper.&lt;U&gt;requireNonNull(mapper.apply(t), <span class=\"string\">\"The mapper function returned a null value.\"</span>) : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后我们看<code>FilterObserver</code>的源码, 他的<code>onNext</code>逻辑就是会执行我们传进去的<code>Predicate</code>对象的<code>test</code>方法, 如果符合筛选逻辑, 就会通过调用下游的<code>onNext</code>将数据传下去, 这个时候的下游是我们new的<code>Observer</code>, 这时候的执行,我们应该就清楚了.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FilterObserver</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">BasicFuseableObserver</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Predicate&lt;? <span class=\"keyword\">super</span> T&gt; filter;</span><br><span class=\"line\"></span><br><span class=\"line\">        FilterObserver(Observer&lt;? <span class=\"keyword\">super</span> T&gt; actual, Predicate&lt;? <span class=\"keyword\">super</span> T&gt; filter) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(actual);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.filter = filter;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sourceMode == NONE) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> b;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    b = filter.test(t);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">                    fail(e);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (b) &#123;</span><br><span class=\"line\">                    actual.onNext(t);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                actual.onNext(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">requestFusion</span><span class=\"params\">(<span class=\"keyword\">int</span> mode)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> transitiveBoundaryFusion(mode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">poll</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                T v = qs.poll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (v == <span class=\"keyword\">null</span> || filter.test(v)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>订阅和数据的传输的原理就是如此. 我们用流程图来总结下上面的整个流程.<br><img src=\"RxJava2源码解析/rxjava实现原理.jpg\" alt=\"流程图\"><br>总的来说, 订阅的动作是层层递归上传到最开始的<code>Observable</code>, 然后从最开始的<code>Observable</code>将数据一层层往下传.<br>当然, 从<code>装饰模式</code>来讲, 他这里的实际动作就是将<code>Observable</code>做了层层装饰来传递订阅, 对设计模式有兴趣的同学可以看看相关的书籍, 对于理解这段代码有点睛之用</p>"},{"title":"RxJava2源码解析(二)","date":"2018-02-07T16:00:00.000Z","_content":"## 前言\n本篇主要解析RxJava的线程切换的原理实现\n<!-- more -->\n## subscribeOn\n首先, 我们先看下`subscribeOn()`方法, 老样子, 先上Demo\n``` java\nObservable<Integer> observable =\n                Observable\n                .create(new ObservableOnSubscribe<Integer>() {\n                    @Override\n                    public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {\n                        emitter.onNext(123);\n                        emitter.onComplete();\n                    }\n                });\n\nobservable\n        .subscribeOn(Schedulers.io())\n        .subscribe(getObserver());\n```\n`subscribeOn`操作符源码里其实是返回了一个`ObservableSubscribeOn`对象, 而从[上篇](https://yutiantina.github.io/2018/02/07/RxJava2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%901/)我们已经知道, 订阅的动作其实在每个`Observable`的`subscribeActual(observer)`中执行, 所以我们直接去看`ObservableSubscribeOn`中的对应重载方法就行了.\n``` java\n@Override\n    public void subscribeActual(final Observer<? super T> s) {\n        final SubscribeOnObserver<T> parent = new SubscribeOnObserver<T>(s);\n\n        s.onSubscribe(parent);\n\n        parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));\n    }\n```\n``` java\nfinal class SubscribeTask implements Runnable {\n        private final SubscribeOnObserver<T> parent;\n\n        SubscribeTask(SubscribeOnObserver<T> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void run() {\n            source.subscribe(parent);\n        }\n    }\n```\n`SubscribeTask`是一个Runnable的实现类, 执行内容就是修饰后的`Observer`订阅上游的动作, 我们先看`scheduler.scheduleDirect(runable)`方法\n``` java\n@NonNull\npublic Disposable scheduleDirect(@NonNull Runnable run) {\n    return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);\n}\n\n@NonNull\npublic Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) {\n    final Worker w = createWorker();\n\n    final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);\n\n    DisposeTask task = new DisposeTask(decoratedRun, w);\n\n    w.schedule(task, delay, unit);\n\n    return task;\n}\n```\n这里`createWorker`是个抽象方法, 我们需要找到对应的修饰类, 我们返回去看`Schedulers.io()`, `IO`是`IoScheduler`的实例, 它的重载方法代码如下\n``` java\nfinal AtomicReference<CachedWorkerPool> pool;\npublic Worker createWorker() {\n        return new EventLoopWorker(pool.get());\n    }\n```\n可以看到IO线程实际使用的是一个有线程缓存的线程调度器.它内部通过`ScheduledExecutorService`实例来尝试重用之前`worker`开始使用的实例, 由于本篇着重在流程实现原理, 所以略过细节处.\n在`EventLoopWorker`中, 我们看下对应的重载方法\n``` java\npublic Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) {\n            if (tasks.isDisposed()) {\n                // don't schedule, we are unsubscribed\n                return EmptyDisposable.INSTANCE;\n            }\n\n            return threadWorker.scheduleActual(action, delayTime, unit, tasks);\n        }\n```\n继续往下, 其实这个时候已经是在线程池目标线程执行相关的工作了. 再深入就是线程池的操作了, 所以这里我们不再赘述\n``` java\npublic ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) {\n        Runnable decoratedRun = RxJavaPlugins.onSchedule(run);\n\n        ScheduledRunnable sr = new ScheduledRunnable(decoratedRun, parent);\n\n        if (parent != null) {\n            if (!parent.add(sr)) {\n                return sr;\n            }\n        }\n\n        Future<?> f;\n        try {\n            if (delayTime <= 0) {\n                f = executor.submit((Callable<Object>)sr);\n            } else {\n                f = executor.schedule((Callable<Object>)sr, delayTime, unit);\n            }\n            sr.setFuture(f);\n        } catch (RejectedExecutionException ex) {\n            if (parent != null) {\n                parent.remove(sr);\n            }\n            RxJavaPlugins.onError(ex);\n        }\n\n        return sr;\n    }\n```\n由此我们可以看出来, 每次每个`subscribeOn`操作符执行的时候, 其实在`source.subscribe(parent);`订阅动作就做了线程切换, 所以在多次调`subscribeOn`的时候, 就会一直切换线程, 直到离`ObservableSource`最近的`subscribeOn`线程切换生效.\n## observeOn\n废话不说, 我们直接看`ObservableObserveOn.subscribeActual(observer)`\n``` java\nprotected void subscribeActual(Observer<? super T> observer) {\n        if (scheduler instanceof TrampolineScheduler) {\n            source.subscribe(observer);\n        } else {\n            Scheduler.Worker w = scheduler.createWorker();\n\n            source.subscribe(new ObserveOnObserver<T>(observer, w, delayError, bufferSize));\n        }\n    }\n```\n熟悉的配方, 当相同想成的时候, 直接订阅, 而当不同线程的时候, 可以看到我们获取目标切换线程对应的worker实例以及装饰对应的`Observer`成`ObserveOnOberver`,后面的流程我们心知肚明, 就是`Observer`层层订阅上去, 然后我们看当碰到最上流的`ObservableSource`往下执行的时候, 做什么操作.具体我们看`ObserveOnOberver`代码, 我们这里着重看下`onSubscribe`和`onNext`方法\n``` java\n@Override\npublic void onSubscribe(Disposable s) {\n    if (DisposableHelper.validate(this.s, s)) {\n        this.s = s;\n        // 发送的数据是集合队列形式的时候\n        if (s instanceof QueueDisposable) {\n            @SuppressWarnings(\"unchecked\")\n            QueueDisposable<T> qd = (QueueDisposable<T>) s;\n\n            int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);\n            //是同步模式的时候\n            if (m == QueueDisposable.SYNC) {\n                sourceMode = m;\n                queue = qd;\n                done = true;\n                actual.onSubscribe(this);\n                // 线程调度\n                schedule();\n                return;\n            }\n            // 异步模式\n            if (m == QueueDisposable.ASYNC) {\n                sourceMode = m;\n                queue = qd;\n                actual.onSubscribe(this);\n                return;\n            }\n        }\n\n        queue = new SpscLinkedArrayQueue<T>(bufferSize);\n\n        actual.onSubscribe(this);\n    }\n}\n\n@Override\npublic void onNext(T t) {\n    // 是否已经调用到onComplete 或者 onError, 如果是, 则不再执行后面的onNext\n    if (done) {\n        return;\n    }\n    // 如果是非异步操作, 将数据添加到队列中\n    if (sourceMode != QueueDisposable.ASYNC) {\n        queue.offer(t);\n    }\n    // 线程调度\n    schedule();\n}\n```\n大概的注释都加在代码上了, 我们再补充看下看`onSubscribe`方法, 首先判断发送的数据是否属于`QueueDisposable`, 如果不是, 直接执行下游的`onSubscribe`,这里我卡了一下, 看不到他的线程切换是在哪里做, 后来往回看, 发现在我们执行`ObservableSubscribeOn.subscribeActual(observer)`的时候, `onSubscribe()`方法本身的确不是在切换后的线程内执行的. 但是, 当我们发送的是集合数据, 那么我们需要判断是哪种线程模式进行线程调度.\n\n我们来看具体的`schedule()`方法代码\n``` java\nvoid schedule() {\n            // 判断当前自增值是否为0, 原子性保证worker.schedule(this);不会在调用结束前被重复调用\n            if (getAndIncrement() == 0) {\n                worker.schedule(this);\n            }\n        }\n```\n这个时候就是在指定线程内run了, `Disposable schedule(@NonNull Runnable run)`传入的是个`Runnable`的实现类, 我们来找重载的`run`方法\n``` java\n@Override\npublic void run() {\n    if (outputFused) {\n        drainFused();\n    } else {\n        drainNormal();\n    }\n}\n\nvoid drainNormal() {\n    int missed = 1;\n\n    final SimpleQueue<T> q = queue;\n    final Observer<? super T> a = actual;\n    // 无限循环\n    for (;;) {\n        // 判断是否被取消, 或者调用onError 或者调用onComplete则退出循环\n        if (checkTerminated(done, q.isEmpty(), a)) {\n            return;\n        }\n        // 无限循环\n        for (;;) {\n            boolean d = done;\n            T v;\n\n            try {\n                // 队列数据分发\n                v = q.poll();\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                s.dispose();\n                q.clear();\n                a.onError(ex);\n                worker.dispose();\n                return;\n            }\n            boolean empty = v == null;\n            // 判断是否应该被终止\n            if (checkTerminated(d, empty, a)) {\n                return;\n            }\n\n            if (empty) {\n                break;\n            }\n            a.onNext(v);\n        }\n        // 原子性保证worker.schedule(this)的调用\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n\n// 判断循环是否终止\nboolean checkTerminated(boolean d, boolean empty, Observer<? super T> a) {\n    // 如果订阅已经被取消, 则清除队列, 终止\n    if (cancelled) {\n        queue.clear();\n        return true;\n    }\n    // 如果调用过onError 或者 onComplete\n    if (d) {\n        Throwable e = error;\n        // 默认false\n        if (delayError) {\n            // 等到队列为空的时候再调用onError或者onComplete\n            if (empty) {\n                if (e != null) {\n                    a.onError(e);\n                } else {\n                    a.onComplete();\n                }\n                worker.dispose();\n                return true;\n            }\n        } else {\n            // 如果有抛出异常, 走下游的onError\n            // 线程任务停止\n            if (e != null) {\n                queue.clear();\n                a.onError(e);\n                worker.dispose();\n                return true;\n            }\n            // 没有, 走下游的onComplete\n            // 线程任务停止\n            else if (empty) {\n                a.onComplete();\n                worker.dispose();\n                return true;\n            }\n        }\n    }\n    // 否则不结束\n    return false;\n}\n```\n由此我们可以得出结论, `observeOn`的操作符可以保证我们下流操作线程切换生效\n## 总结\n到这里, 我们线程切换的原理大体流程就基本分析完毕了, 可以看出`subscribeOn`操作符只对上游生效, 而且因为他是在订阅的时候进行线程切换, 而我们每个操作符中间都有订阅动作, 所以越接近我们的`ObservableSource`的订阅的`subscribeOn`越是最后生效的. 而`observeOn`生效在我们的`onNext`,`onComplete`, `onError`方法内, 所以每次的`observeOn`针对它的下游都可以生效.\n","source":"_posts/RxJava2源码解析2.md","raw":"title: RxJava2源码解析(二)\ndate: 2018-02-08 00:00:00\ncategories:\n- 源码解析\ntags:\n- 源码解析\n- rxJava2\n---\n## 前言\n本篇主要解析RxJava的线程切换的原理实现\n<!-- more -->\n## subscribeOn\n首先, 我们先看下`subscribeOn()`方法, 老样子, 先上Demo\n``` java\nObservable<Integer> observable =\n                Observable\n                .create(new ObservableOnSubscribe<Integer>() {\n                    @Override\n                    public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {\n                        emitter.onNext(123);\n                        emitter.onComplete();\n                    }\n                });\n\nobservable\n        .subscribeOn(Schedulers.io())\n        .subscribe(getObserver());\n```\n`subscribeOn`操作符源码里其实是返回了一个`ObservableSubscribeOn`对象, 而从[上篇](https://yutiantina.github.io/2018/02/07/RxJava2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%901/)我们已经知道, 订阅的动作其实在每个`Observable`的`subscribeActual(observer)`中执行, 所以我们直接去看`ObservableSubscribeOn`中的对应重载方法就行了.\n``` java\n@Override\n    public void subscribeActual(final Observer<? super T> s) {\n        final SubscribeOnObserver<T> parent = new SubscribeOnObserver<T>(s);\n\n        s.onSubscribe(parent);\n\n        parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));\n    }\n```\n``` java\nfinal class SubscribeTask implements Runnable {\n        private final SubscribeOnObserver<T> parent;\n\n        SubscribeTask(SubscribeOnObserver<T> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void run() {\n            source.subscribe(parent);\n        }\n    }\n```\n`SubscribeTask`是一个Runnable的实现类, 执行内容就是修饰后的`Observer`订阅上游的动作, 我们先看`scheduler.scheduleDirect(runable)`方法\n``` java\n@NonNull\npublic Disposable scheduleDirect(@NonNull Runnable run) {\n    return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);\n}\n\n@NonNull\npublic Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) {\n    final Worker w = createWorker();\n\n    final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);\n\n    DisposeTask task = new DisposeTask(decoratedRun, w);\n\n    w.schedule(task, delay, unit);\n\n    return task;\n}\n```\n这里`createWorker`是个抽象方法, 我们需要找到对应的修饰类, 我们返回去看`Schedulers.io()`, `IO`是`IoScheduler`的实例, 它的重载方法代码如下\n``` java\nfinal AtomicReference<CachedWorkerPool> pool;\npublic Worker createWorker() {\n        return new EventLoopWorker(pool.get());\n    }\n```\n可以看到IO线程实际使用的是一个有线程缓存的线程调度器.它内部通过`ScheduledExecutorService`实例来尝试重用之前`worker`开始使用的实例, 由于本篇着重在流程实现原理, 所以略过细节处.\n在`EventLoopWorker`中, 我们看下对应的重载方法\n``` java\npublic Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) {\n            if (tasks.isDisposed()) {\n                // don't schedule, we are unsubscribed\n                return EmptyDisposable.INSTANCE;\n            }\n\n            return threadWorker.scheduleActual(action, delayTime, unit, tasks);\n        }\n```\n继续往下, 其实这个时候已经是在线程池目标线程执行相关的工作了. 再深入就是线程池的操作了, 所以这里我们不再赘述\n``` java\npublic ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) {\n        Runnable decoratedRun = RxJavaPlugins.onSchedule(run);\n\n        ScheduledRunnable sr = new ScheduledRunnable(decoratedRun, parent);\n\n        if (parent != null) {\n            if (!parent.add(sr)) {\n                return sr;\n            }\n        }\n\n        Future<?> f;\n        try {\n            if (delayTime <= 0) {\n                f = executor.submit((Callable<Object>)sr);\n            } else {\n                f = executor.schedule((Callable<Object>)sr, delayTime, unit);\n            }\n            sr.setFuture(f);\n        } catch (RejectedExecutionException ex) {\n            if (parent != null) {\n                parent.remove(sr);\n            }\n            RxJavaPlugins.onError(ex);\n        }\n\n        return sr;\n    }\n```\n由此我们可以看出来, 每次每个`subscribeOn`操作符执行的时候, 其实在`source.subscribe(parent);`订阅动作就做了线程切换, 所以在多次调`subscribeOn`的时候, 就会一直切换线程, 直到离`ObservableSource`最近的`subscribeOn`线程切换生效.\n## observeOn\n废话不说, 我们直接看`ObservableObserveOn.subscribeActual(observer)`\n``` java\nprotected void subscribeActual(Observer<? super T> observer) {\n        if (scheduler instanceof TrampolineScheduler) {\n            source.subscribe(observer);\n        } else {\n            Scheduler.Worker w = scheduler.createWorker();\n\n            source.subscribe(new ObserveOnObserver<T>(observer, w, delayError, bufferSize));\n        }\n    }\n```\n熟悉的配方, 当相同想成的时候, 直接订阅, 而当不同线程的时候, 可以看到我们获取目标切换线程对应的worker实例以及装饰对应的`Observer`成`ObserveOnOberver`,后面的流程我们心知肚明, 就是`Observer`层层订阅上去, 然后我们看当碰到最上流的`ObservableSource`往下执行的时候, 做什么操作.具体我们看`ObserveOnOberver`代码, 我们这里着重看下`onSubscribe`和`onNext`方法\n``` java\n@Override\npublic void onSubscribe(Disposable s) {\n    if (DisposableHelper.validate(this.s, s)) {\n        this.s = s;\n        // 发送的数据是集合队列形式的时候\n        if (s instanceof QueueDisposable) {\n            @SuppressWarnings(\"unchecked\")\n            QueueDisposable<T> qd = (QueueDisposable<T>) s;\n\n            int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);\n            //是同步模式的时候\n            if (m == QueueDisposable.SYNC) {\n                sourceMode = m;\n                queue = qd;\n                done = true;\n                actual.onSubscribe(this);\n                // 线程调度\n                schedule();\n                return;\n            }\n            // 异步模式\n            if (m == QueueDisposable.ASYNC) {\n                sourceMode = m;\n                queue = qd;\n                actual.onSubscribe(this);\n                return;\n            }\n        }\n\n        queue = new SpscLinkedArrayQueue<T>(bufferSize);\n\n        actual.onSubscribe(this);\n    }\n}\n\n@Override\npublic void onNext(T t) {\n    // 是否已经调用到onComplete 或者 onError, 如果是, 则不再执行后面的onNext\n    if (done) {\n        return;\n    }\n    // 如果是非异步操作, 将数据添加到队列中\n    if (sourceMode != QueueDisposable.ASYNC) {\n        queue.offer(t);\n    }\n    // 线程调度\n    schedule();\n}\n```\n大概的注释都加在代码上了, 我们再补充看下看`onSubscribe`方法, 首先判断发送的数据是否属于`QueueDisposable`, 如果不是, 直接执行下游的`onSubscribe`,这里我卡了一下, 看不到他的线程切换是在哪里做, 后来往回看, 发现在我们执行`ObservableSubscribeOn.subscribeActual(observer)`的时候, `onSubscribe()`方法本身的确不是在切换后的线程内执行的. 但是, 当我们发送的是集合数据, 那么我们需要判断是哪种线程模式进行线程调度.\n\n我们来看具体的`schedule()`方法代码\n``` java\nvoid schedule() {\n            // 判断当前自增值是否为0, 原子性保证worker.schedule(this);不会在调用结束前被重复调用\n            if (getAndIncrement() == 0) {\n                worker.schedule(this);\n            }\n        }\n```\n这个时候就是在指定线程内run了, `Disposable schedule(@NonNull Runnable run)`传入的是个`Runnable`的实现类, 我们来找重载的`run`方法\n``` java\n@Override\npublic void run() {\n    if (outputFused) {\n        drainFused();\n    } else {\n        drainNormal();\n    }\n}\n\nvoid drainNormal() {\n    int missed = 1;\n\n    final SimpleQueue<T> q = queue;\n    final Observer<? super T> a = actual;\n    // 无限循环\n    for (;;) {\n        // 判断是否被取消, 或者调用onError 或者调用onComplete则退出循环\n        if (checkTerminated(done, q.isEmpty(), a)) {\n            return;\n        }\n        // 无限循环\n        for (;;) {\n            boolean d = done;\n            T v;\n\n            try {\n                // 队列数据分发\n                v = q.poll();\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                s.dispose();\n                q.clear();\n                a.onError(ex);\n                worker.dispose();\n                return;\n            }\n            boolean empty = v == null;\n            // 判断是否应该被终止\n            if (checkTerminated(d, empty, a)) {\n                return;\n            }\n\n            if (empty) {\n                break;\n            }\n            a.onNext(v);\n        }\n        // 原子性保证worker.schedule(this)的调用\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n\n// 判断循环是否终止\nboolean checkTerminated(boolean d, boolean empty, Observer<? super T> a) {\n    // 如果订阅已经被取消, 则清除队列, 终止\n    if (cancelled) {\n        queue.clear();\n        return true;\n    }\n    // 如果调用过onError 或者 onComplete\n    if (d) {\n        Throwable e = error;\n        // 默认false\n        if (delayError) {\n            // 等到队列为空的时候再调用onError或者onComplete\n            if (empty) {\n                if (e != null) {\n                    a.onError(e);\n                } else {\n                    a.onComplete();\n                }\n                worker.dispose();\n                return true;\n            }\n        } else {\n            // 如果有抛出异常, 走下游的onError\n            // 线程任务停止\n            if (e != null) {\n                queue.clear();\n                a.onError(e);\n                worker.dispose();\n                return true;\n            }\n            // 没有, 走下游的onComplete\n            // 线程任务停止\n            else if (empty) {\n                a.onComplete();\n                worker.dispose();\n                return true;\n            }\n        }\n    }\n    // 否则不结束\n    return false;\n}\n```\n由此我们可以得出结论, `observeOn`的操作符可以保证我们下流操作线程切换生效\n## 总结\n到这里, 我们线程切换的原理大体流程就基本分析完毕了, 可以看出`subscribeOn`操作符只对上游生效, 而且因为他是在订阅的时候进行线程切换, 而我们每个操作符中间都有订阅动作, 所以越接近我们的`ObservableSource`的订阅的`subscribeOn`越是最后生效的. 而`observeOn`生效在我们的`onNext`,`onComplete`, `onError`方法内, 所以每次的`observeOn`针对它的下游都可以生效.\n","slug":"RxJava2源码解析2","published":1,"updated":"2018-05-07T02:03:35.090Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh7fldni001d8os6dgp9rgqh","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本篇主要解析RxJava的线程切换的原理实现<br><a id=\"more\"></a></p>\n<h2 id=\"subscribeOn\"><a href=\"#subscribeOn\" class=\"headerlink\" title=\"subscribeOn\"></a>subscribeOn</h2><p>首先, 我们先看下<code>subscribeOn()</code>方法, 老样子, 先上Demo<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable&lt;Integer&gt; observable =</span><br><span class=\"line\">                Observable</span><br><span class=\"line\">                .create(<span class=\"keyword\">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                        emitter.onNext(<span class=\"number\">123</span>);</span><br><span class=\"line\">                        emitter.onComplete();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">observable</span><br><span class=\"line\">        .subscribeOn(Schedulers.io())</span><br><span class=\"line\">        .subscribe(getObserver());</span><br></pre></td></tr></table></figure></p>\n<p><code>subscribeOn</code>操作符源码里其实是返回了一个<code>ObservableSubscribeOn</code>对象, 而从<a href=\"https://yutiantina.github.io/2018/02/07/RxJava2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%901/\" target=\"_blank\" rel=\"noopener\">上篇</a>我们已经知道, 订阅的动作其实在每个<code>Observable</code>的<code>subscribeActual(observer)</code>中执行, 所以我们直接去看<code>ObservableSubscribeOn</code>中的对应重载方法就行了.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribeActual</span><span class=\"params\">(<span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class=\"keyword\">new</span> SubscribeOnObserver&lt;T&gt;(s);</span><br><span class=\"line\"></span><br><span class=\"line\">        s.onSubscribe(parent);</span><br><span class=\"line\"></span><br><span class=\"line\">        parent.setDisposable(scheduler.scheduleDirect(<span class=\"keyword\">new</span> SubscribeTask(parent)));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubscribeTask</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SubscribeOnObserver&lt;T&gt; parent;</span><br><span class=\"line\"></span><br><span class=\"line\">        SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.parent = parent;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            source.subscribe(parent);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><code>SubscribeTask</code>是一个Runnable的实现类, 执行内容就是修饰后的<code>Observer</code>订阅上游的动作, 我们先看<code>scheduler.scheduleDirect(runable)</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Disposable <span class=\"title\">scheduleDirect</span><span class=\"params\">(@NonNull Runnable run)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> scheduleDirect(run, <span class=\"number\">0L</span>, TimeUnit.NANOSECONDS);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Disposable <span class=\"title\">scheduleDirect</span><span class=\"params\">(@NonNull Runnable run, <span class=\"keyword\">long</span> delay, @NonNull TimeUnit unit)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Worker w = createWorker();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class=\"line\"></span><br><span class=\"line\">    DisposeTask task = <span class=\"keyword\">new</span> DisposeTask(decoratedRun, w);</span><br><span class=\"line\"></span><br><span class=\"line\">    w.schedule(task, delay, unit);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> task;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里<code>createWorker</code>是个抽象方法, 我们需要找到对应的修饰类, 我们返回去看<code>Schedulers.io()</code>, <code>IO</code>是<code>IoScheduler</code>的实例, 它的重载方法代码如下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> AtomicReference&lt;CachedWorkerPool&gt; pool;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Worker <span class=\"title\">createWorker</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EventLoopWorker(pool.get());</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到IO线程实际使用的是一个有线程缓存的线程调度器.它内部通过<code>ScheduledExecutorService</code>实例来尝试重用之前<code>worker</code>开始使用的实例, 由于本篇着重在流程实现原理, 所以略过细节处.<br>在<code>EventLoopWorker</code>中, 我们看下对应的重载方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Disposable <span class=\"title\">schedule</span><span class=\"params\">(@NonNull Runnable action, <span class=\"keyword\">long</span> delayTime, @NonNull TimeUnit unit)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tasks.isDisposed()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// don't schedule, we are unsubscribed</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> EmptyDisposable.INSTANCE;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> threadWorker.scheduleActual(action, delayTime, unit, tasks);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>继续往下, 其实这个时候已经是在线程池目标线程执行相关的工作了. 再深入就是线程池的操作了, 所以这里我们不再赘述<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ScheduledRunnable <span class=\"title\">scheduleActual</span><span class=\"params\">(<span class=\"keyword\">final</span> Runnable run, <span class=\"keyword\">long</span> delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent)</span> </span>&#123;</span><br><span class=\"line\">        Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class=\"line\"></span><br><span class=\"line\">        ScheduledRunnable sr = <span class=\"keyword\">new</span> ScheduledRunnable(decoratedRun, parent);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!parent.add(sr)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> sr;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Future&lt;?&gt; f;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (delayTime &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                f = executor.submit((Callable&lt;Object&gt;)sr);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sr.setFuture(f);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                parent.remove(sr);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            RxJavaPlugins.onError(ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sr;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>由此我们可以看出来, 每次每个<code>subscribeOn</code>操作符执行的时候, 其实在<code>source.subscribe(parent);</code>订阅动作就做了线程切换, 所以在多次调<code>subscribeOn</code>的时候, 就会一直切换线程, 直到离<code>ObservableSource</code>最近的<code>subscribeOn</code>线程切换生效.</p>\n<h2 id=\"observeOn\"><a href=\"#observeOn\" class=\"headerlink\" title=\"observeOn\"></a>observeOn</h2><p>废话不说, 我们直接看<code>ObservableObserveOn.subscribeActual(observer)</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribeActual</span><span class=\"params\">(Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (scheduler <span class=\"keyword\">instanceof</span> TrampolineScheduler) &#123;</span><br><span class=\"line\">            source.subscribe(observer);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Scheduler.Worker w = scheduler.createWorker();</span><br><span class=\"line\"></span><br><span class=\"line\">            source.subscribe(<span class=\"keyword\">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>熟悉的配方, 当相同想成的时候, 直接订阅, 而当不同线程的时候, 可以看到我们获取目标切换线程对应的worker实例以及装饰对应的<code>Observer</code>成<code>ObserveOnOberver</code>,后面的流程我们心知肚明, 就是<code>Observer</code>层层订阅上去, 然后我们看当碰到最上流的<code>ObservableSource</code>往下执行的时候, 做什么操作.具体我们看<code>ObserveOnOberver</code>代码, 我们这里着重看下<code>onSubscribe</code>和<code>onNext</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSubscribe</span><span class=\"params\">(Disposable s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DisposableHelper.validate(<span class=\"keyword\">this</span>.s, s)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.s = s;</span><br><span class=\"line\">        <span class=\"comment\">// 发送的数据是集合队列形式的时候</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s <span class=\"keyword\">instanceof</span> QueueDisposable) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            QueueDisposable&lt;T&gt; qd = (QueueDisposable&lt;T&gt;) s;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">int</span> m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);</span><br><span class=\"line\">            <span class=\"comment\">//是同步模式的时候</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m == QueueDisposable.SYNC) &#123;</span><br><span class=\"line\">                sourceMode = m;</span><br><span class=\"line\">                queue = qd;</span><br><span class=\"line\">                done = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                actual.onSubscribe(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 线程调度</span></span><br><span class=\"line\">                schedule();</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 异步模式</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m == QueueDisposable.ASYNC) &#123;</span><br><span class=\"line\">                sourceMode = m;</span><br><span class=\"line\">                queue = qd;</span><br><span class=\"line\">                actual.onSubscribe(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        queue = <span class=\"keyword\">new</span> SpscLinkedArrayQueue&lt;T&gt;(bufferSize);</span><br><span class=\"line\"></span><br><span class=\"line\">        actual.onSubscribe(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 是否已经调用到onComplete 或者 onError, 如果是, 则不再执行后面的onNext</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (done) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是非异步操作, 将数据添加到队列中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sourceMode != QueueDisposable.ASYNC) &#123;</span><br><span class=\"line\">        queue.offer(t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 线程调度</span></span><br><span class=\"line\">    schedule();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>大概的注释都加在代码上了, 我们再补充看下看<code>onSubscribe</code>方法, 首先判断发送的数据是否属于<code>QueueDisposable</code>, 如果不是, 直接执行下游的<code>onSubscribe</code>,这里我卡了一下, 看不到他的线程切换是在哪里做, 后来往回看, 发现在我们执行<code>ObservableSubscribeOn.subscribeActual(observer)</code>的时候, <code>onSubscribe()</code>方法本身的确不是在切换后的线程内执行的. 但是, 当我们发送的是集合数据, 那么我们需要判断是哪种线程模式进行线程调度.</p>\n<p>我们来看具体的<code>schedule()</code>方法代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">schedule</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断当前自增值是否为0, 原子性保证worker.schedule(this);不会在调用结束前被重复调用</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (getAndIncrement() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                worker.schedule(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个时候就是在指定线程内run了, <code>Disposable schedule(@NonNull Runnable run)</code>传入的是个<code>Runnable</code>的实现类, 我们来找重载的<code>run</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (outputFused) &#123;</span><br><span class=\"line\">        drainFused();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        drainNormal();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">drainNormal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> missed = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> SimpleQueue&lt;T&gt; q = queue;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; a = actual;</span><br><span class=\"line\">    <span class=\"comment\">// 无限循环</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断是否被取消, 或者调用onError 或者调用onComplete则退出循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (checkTerminated(done, q.isEmpty(), a)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 无限循环</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> d = done;</span><br><span class=\"line\">            T v;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 队列数据分发</span></span><br><span class=\"line\">                v = q.poll();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                Exceptions.throwIfFatal(ex);</span><br><span class=\"line\">                s.dispose();</span><br><span class=\"line\">                q.clear();</span><br><span class=\"line\">                a.onError(ex);</span><br><span class=\"line\">                worker.dispose();</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> empty = v == <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 判断是否应该被终止</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (checkTerminated(d, empty, a)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (empty) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            a.onNext(v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 原子性保证worker.schedule(this)的调用</span></span><br><span class=\"line\">        missed = addAndGet(-missed);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (missed == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断循环是否终止</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">checkTerminated</span><span class=\"params\">(<span class=\"keyword\">boolean</span> d, <span class=\"keyword\">boolean</span> empty, Observer&lt;? <span class=\"keyword\">super</span> T&gt; a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果订阅已经被取消, 则清除队列, 终止</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cancelled) &#123;</span><br><span class=\"line\">        queue.clear();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果调用过onError 或者 onComplete</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (d) &#123;</span><br><span class=\"line\">        Throwable e = error;</span><br><span class=\"line\">        <span class=\"comment\">// 默认false</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (delayError) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 等到队列为空的时候再调用onError或者onComplete</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (empty) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    a.onError(e);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    a.onComplete();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                worker.dispose();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果有抛出异常, 走下游的onError</span></span><br><span class=\"line\">            <span class=\"comment\">// 线程任务停止</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                queue.clear();</span><br><span class=\"line\">                a.onError(e);</span><br><span class=\"line\">                worker.dispose();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 没有, 走下游的onComplete</span></span><br><span class=\"line\">            <span class=\"comment\">// 线程任务停止</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (empty) &#123;</span><br><span class=\"line\">                a.onComplete();</span><br><span class=\"line\">                worker.dispose();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 否则不结束</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由此我们可以得出结论, <code>observeOn</code>的操作符可以保证我们下流操作线程切换生效</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>到这里, 我们线程切换的原理大体流程就基本分析完毕了, 可以看出<code>subscribeOn</code>操作符只对上游生效, 而且因为他是在订阅的时候进行线程切换, 而我们每个操作符中间都有订阅动作, 所以越接近我们的<code>ObservableSource</code>的订阅的<code>subscribeOn</code>越是最后生效的. 而<code>observeOn</code>生效在我们的<code>onNext</code>,<code>onComplete</code>, <code>onError</code>方法内, 所以每次的<code>observeOn</code>针对它的下游都可以生效.</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本篇主要解析RxJava的线程切换的原理实现<br>","more":"</p>\n<h2 id=\"subscribeOn\"><a href=\"#subscribeOn\" class=\"headerlink\" title=\"subscribeOn\"></a>subscribeOn</h2><p>首先, 我们先看下<code>subscribeOn()</code>方法, 老样子, 先上Demo<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable&lt;Integer&gt; observable =</span><br><span class=\"line\">                Observable</span><br><span class=\"line\">                .create(<span class=\"keyword\">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                        emitter.onNext(<span class=\"number\">123</span>);</span><br><span class=\"line\">                        emitter.onComplete();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">observable</span><br><span class=\"line\">        .subscribeOn(Schedulers.io())</span><br><span class=\"line\">        .subscribe(getObserver());</span><br></pre></td></tr></table></figure></p>\n<p><code>subscribeOn</code>操作符源码里其实是返回了一个<code>ObservableSubscribeOn</code>对象, 而从<a href=\"https://yutiantina.github.io/2018/02/07/RxJava2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%901/\" target=\"_blank\" rel=\"noopener\">上篇</a>我们已经知道, 订阅的动作其实在每个<code>Observable</code>的<code>subscribeActual(observer)</code>中执行, 所以我们直接去看<code>ObservableSubscribeOn</code>中的对应重载方法就行了.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribeActual</span><span class=\"params\">(<span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class=\"keyword\">new</span> SubscribeOnObserver&lt;T&gt;(s);</span><br><span class=\"line\"></span><br><span class=\"line\">        s.onSubscribe(parent);</span><br><span class=\"line\"></span><br><span class=\"line\">        parent.setDisposable(scheduler.scheduleDirect(<span class=\"keyword\">new</span> SubscribeTask(parent)));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubscribeTask</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SubscribeOnObserver&lt;T&gt; parent;</span><br><span class=\"line\"></span><br><span class=\"line\">        SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.parent = parent;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            source.subscribe(parent);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><code>SubscribeTask</code>是一个Runnable的实现类, 执行内容就是修饰后的<code>Observer</code>订阅上游的动作, 我们先看<code>scheduler.scheduleDirect(runable)</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Disposable <span class=\"title\">scheduleDirect</span><span class=\"params\">(@NonNull Runnable run)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> scheduleDirect(run, <span class=\"number\">0L</span>, TimeUnit.NANOSECONDS);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Disposable <span class=\"title\">scheduleDirect</span><span class=\"params\">(@NonNull Runnable run, <span class=\"keyword\">long</span> delay, @NonNull TimeUnit unit)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Worker w = createWorker();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class=\"line\"></span><br><span class=\"line\">    DisposeTask task = <span class=\"keyword\">new</span> DisposeTask(decoratedRun, w);</span><br><span class=\"line\"></span><br><span class=\"line\">    w.schedule(task, delay, unit);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> task;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里<code>createWorker</code>是个抽象方法, 我们需要找到对应的修饰类, 我们返回去看<code>Schedulers.io()</code>, <code>IO</code>是<code>IoScheduler</code>的实例, 它的重载方法代码如下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> AtomicReference&lt;CachedWorkerPool&gt; pool;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Worker <span class=\"title\">createWorker</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EventLoopWorker(pool.get());</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到IO线程实际使用的是一个有线程缓存的线程调度器.它内部通过<code>ScheduledExecutorService</code>实例来尝试重用之前<code>worker</code>开始使用的实例, 由于本篇着重在流程实现原理, 所以略过细节处.<br>在<code>EventLoopWorker</code>中, 我们看下对应的重载方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Disposable <span class=\"title\">schedule</span><span class=\"params\">(@NonNull Runnable action, <span class=\"keyword\">long</span> delayTime, @NonNull TimeUnit unit)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tasks.isDisposed()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// don't schedule, we are unsubscribed</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> EmptyDisposable.INSTANCE;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> threadWorker.scheduleActual(action, delayTime, unit, tasks);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>继续往下, 其实这个时候已经是在线程池目标线程执行相关的工作了. 再深入就是线程池的操作了, 所以这里我们不再赘述<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ScheduledRunnable <span class=\"title\">scheduleActual</span><span class=\"params\">(<span class=\"keyword\">final</span> Runnable run, <span class=\"keyword\">long</span> delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent)</span> </span>&#123;</span><br><span class=\"line\">        Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class=\"line\"></span><br><span class=\"line\">        ScheduledRunnable sr = <span class=\"keyword\">new</span> ScheduledRunnable(decoratedRun, parent);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!parent.add(sr)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> sr;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Future&lt;?&gt; f;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (delayTime &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                f = executor.submit((Callable&lt;Object&gt;)sr);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sr.setFuture(f);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                parent.remove(sr);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            RxJavaPlugins.onError(ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sr;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>由此我们可以看出来, 每次每个<code>subscribeOn</code>操作符执行的时候, 其实在<code>source.subscribe(parent);</code>订阅动作就做了线程切换, 所以在多次调<code>subscribeOn</code>的时候, 就会一直切换线程, 直到离<code>ObservableSource</code>最近的<code>subscribeOn</code>线程切换生效.</p>\n<h2 id=\"observeOn\"><a href=\"#observeOn\" class=\"headerlink\" title=\"observeOn\"></a>observeOn</h2><p>废话不说, 我们直接看<code>ObservableObserveOn.subscribeActual(observer)</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribeActual</span><span class=\"params\">(Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (scheduler <span class=\"keyword\">instanceof</span> TrampolineScheduler) &#123;</span><br><span class=\"line\">            source.subscribe(observer);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Scheduler.Worker w = scheduler.createWorker();</span><br><span class=\"line\"></span><br><span class=\"line\">            source.subscribe(<span class=\"keyword\">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>熟悉的配方, 当相同想成的时候, 直接订阅, 而当不同线程的时候, 可以看到我们获取目标切换线程对应的worker实例以及装饰对应的<code>Observer</code>成<code>ObserveOnOberver</code>,后面的流程我们心知肚明, 就是<code>Observer</code>层层订阅上去, 然后我们看当碰到最上流的<code>ObservableSource</code>往下执行的时候, 做什么操作.具体我们看<code>ObserveOnOberver</code>代码, 我们这里着重看下<code>onSubscribe</code>和<code>onNext</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSubscribe</span><span class=\"params\">(Disposable s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DisposableHelper.validate(<span class=\"keyword\">this</span>.s, s)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.s = s;</span><br><span class=\"line\">        <span class=\"comment\">// 发送的数据是集合队列形式的时候</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s <span class=\"keyword\">instanceof</span> QueueDisposable) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            QueueDisposable&lt;T&gt; qd = (QueueDisposable&lt;T&gt;) s;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">int</span> m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);</span><br><span class=\"line\">            <span class=\"comment\">//是同步模式的时候</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m == QueueDisposable.SYNC) &#123;</span><br><span class=\"line\">                sourceMode = m;</span><br><span class=\"line\">                queue = qd;</span><br><span class=\"line\">                done = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                actual.onSubscribe(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 线程调度</span></span><br><span class=\"line\">                schedule();</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 异步模式</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m == QueueDisposable.ASYNC) &#123;</span><br><span class=\"line\">                sourceMode = m;</span><br><span class=\"line\">                queue = qd;</span><br><span class=\"line\">                actual.onSubscribe(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        queue = <span class=\"keyword\">new</span> SpscLinkedArrayQueue&lt;T&gt;(bufferSize);</span><br><span class=\"line\"></span><br><span class=\"line\">        actual.onSubscribe(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 是否已经调用到onComplete 或者 onError, 如果是, 则不再执行后面的onNext</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (done) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是非异步操作, 将数据添加到队列中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sourceMode != QueueDisposable.ASYNC) &#123;</span><br><span class=\"line\">        queue.offer(t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 线程调度</span></span><br><span class=\"line\">    schedule();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>大概的注释都加在代码上了, 我们再补充看下看<code>onSubscribe</code>方法, 首先判断发送的数据是否属于<code>QueueDisposable</code>, 如果不是, 直接执行下游的<code>onSubscribe</code>,这里我卡了一下, 看不到他的线程切换是在哪里做, 后来往回看, 发现在我们执行<code>ObservableSubscribeOn.subscribeActual(observer)</code>的时候, <code>onSubscribe()</code>方法本身的确不是在切换后的线程内执行的. 但是, 当我们发送的是集合数据, 那么我们需要判断是哪种线程模式进行线程调度.</p>\n<p>我们来看具体的<code>schedule()</code>方法代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">schedule</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断当前自增值是否为0, 原子性保证worker.schedule(this);不会在调用结束前被重复调用</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (getAndIncrement() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                worker.schedule(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个时候就是在指定线程内run了, <code>Disposable schedule(@NonNull Runnable run)</code>传入的是个<code>Runnable</code>的实现类, 我们来找重载的<code>run</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (outputFused) &#123;</span><br><span class=\"line\">        drainFused();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        drainNormal();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">drainNormal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> missed = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> SimpleQueue&lt;T&gt; q = queue;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; a = actual;</span><br><span class=\"line\">    <span class=\"comment\">// 无限循环</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断是否被取消, 或者调用onError 或者调用onComplete则退出循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (checkTerminated(done, q.isEmpty(), a)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 无限循环</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> d = done;</span><br><span class=\"line\">            T v;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 队列数据分发</span></span><br><span class=\"line\">                v = q.poll();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                Exceptions.throwIfFatal(ex);</span><br><span class=\"line\">                s.dispose();</span><br><span class=\"line\">                q.clear();</span><br><span class=\"line\">                a.onError(ex);</span><br><span class=\"line\">                worker.dispose();</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> empty = v == <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 判断是否应该被终止</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (checkTerminated(d, empty, a)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (empty) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            a.onNext(v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 原子性保证worker.schedule(this)的调用</span></span><br><span class=\"line\">        missed = addAndGet(-missed);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (missed == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断循环是否终止</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">checkTerminated</span><span class=\"params\">(<span class=\"keyword\">boolean</span> d, <span class=\"keyword\">boolean</span> empty, Observer&lt;? <span class=\"keyword\">super</span> T&gt; a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果订阅已经被取消, 则清除队列, 终止</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cancelled) &#123;</span><br><span class=\"line\">        queue.clear();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果调用过onError 或者 onComplete</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (d) &#123;</span><br><span class=\"line\">        Throwable e = error;</span><br><span class=\"line\">        <span class=\"comment\">// 默认false</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (delayError) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 等到队列为空的时候再调用onError或者onComplete</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (empty) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    a.onError(e);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    a.onComplete();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                worker.dispose();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果有抛出异常, 走下游的onError</span></span><br><span class=\"line\">            <span class=\"comment\">// 线程任务停止</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                queue.clear();</span><br><span class=\"line\">                a.onError(e);</span><br><span class=\"line\">                worker.dispose();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 没有, 走下游的onComplete</span></span><br><span class=\"line\">            <span class=\"comment\">// 线程任务停止</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (empty) &#123;</span><br><span class=\"line\">                a.onComplete();</span><br><span class=\"line\">                worker.dispose();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 否则不结束</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由此我们可以得出结论, <code>observeOn</code>的操作符可以保证我们下流操作线程切换生效</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>到这里, 我们线程切换的原理大体流程就基本分析完毕了, 可以看出<code>subscribeOn</code>操作符只对上游生效, 而且因为他是在订阅的时候进行线程切换, 而我们每个操作符中间都有订阅动作, 所以越接近我们的<code>ObservableSource</code>的订阅的<code>subscribeOn</code>越是最后生效的. 而<code>observeOn</code>生效在我们的<code>onNext</code>,<code>onComplete</code>, <code>onError</code>方法内, 所以每次的<code>observeOn</code>针对它的下游都可以生效.</p>"},{"title":"EventBus源码解析","date":"2018-03-29T16:00:00.000Z","_content":"### 前言\n前期加班加点赶项目, 趁着刚上线空两天,赶紧看下`EventBus`做个\"思维复健\"\n### 使用\n`EventBus`的使用非常简单, 如果使用默认的`EventBus`, 我们一般只会使用到以下三个API\n1. 绑定\n``` java\nEventBus.getDefault().regisiter(this);\n```\n2. 发送信息\n``` java\nEventBus.getDefault().post(new Event());\n```\n3. 解绑\n``` java\nEventBus.getDefault().unregisiter(this);\n```\n<!-- more -->\n### EventBus.getDefault()\n`EventBus`内部维护了一个单例, 通过`getDefault`我们可以获取默认单例来进行绑定和发送动作, 但是当我们需要进行一些关于log, 是否未有订阅者情况的响应处理时, 我们可以通过`EventBusBuilder`通过构建者模式来进行配置处理,本篇解析仅分析默认情况下的流程代码\n### 绑定\n老规矩, 我们先上代码\n``` java\npublic void register(Object subscriber) {\n        Class<?> subscriberClass = subscriber.getClass();\n        // 获取对应subscriber类的订阅方法\n        List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);\n        synchronized (this) {\n            // 遍历执行订阅\n            for (SubscriberMethod subscriberMethod : subscriberMethods) {\n                subscribe(subscriber, subscriberMethod);\n            }\n        }\n    }\n```\n我们根据传递的订阅者来获取相关的订阅方法, 然后遍历执行订阅的动作. 我们首先看下如果查找订阅者的所有订阅方法\n``` java\nList<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {\n        // 从缓存中查找订阅方法\n        List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);\n        // 缓存中有, 直接返回\n        if (subscriberMethods != null) {\n            return subscriberMethods;\n        }\n        // 查找注册方法, 默认false\n        if (ignoreGeneratedIndex) {\n            // 使用反射查找\n            subscriberMethods = findUsingReflection(subscriberClass);\n        } else {\n            // 使用注解器生成的类查找\n            subscriberMethods = findUsingInfo(subscriberClass);\n        }\n        // 如果没有订阅方法, 则抛出异常\n        if (subscriberMethods.isEmpty()) {\n            throw new EventBusException(\"Subscriber \" + subscriberClass\n                    + \" and its super classes have no public methods with the @Subscribe annotation\");\n        } else {\n            // 否则加入缓存中\n            METHOD_CACHE.put(subscriberClass, subscriberMethods);\n            return subscriberMethods;\n        }\n    }\n```\n我们知道`EventBus`3.0版本后通过`@Subscribe`注解来标注对应的订阅方法, 可以看到通过`findUsingInfo`方法查询订阅方法, 如果没有订阅方法, 会抛出异常, 而如果找到了, 则会加入缓存`METHOD_CACHE`进行内部维护, 这个方法可以优化部分性能, 减少反射带来的性能问题.\n我们在往`findUsingInfo`里看, 会发现如果找不到相关订阅者信息的时候, 仍会通过反射来寻找.\n``` java\nprivate List<SubscriberMethod> findUsingInfo(Class<?> subscriberClass) {\n        FindState findState = prepareFindState();\n        findState.initForSubscriber(subscriberClass);\n        while (findState.clazz != null) {\n            findState.subscriberInfo = getSubscriberInfo(findState);\n            if (findState.subscriberInfo != null) {\n                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();\n                // 遍历订阅者方法\n                for (SubscriberMethod subscriberMethod : array) {\n                    if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {\n                        findState.subscriberMethods.add(subscriberMethod);\n                    }\n                }\n            } else {\n                // 没有订阅信息, 从反射来找\n                findUsingReflectionInSingleClass(findState);\n            }\n            findState.moveToSuperclass();\n        }\n        return getMethodsAndRelease(findState);\n    }\n```\n我们回头去看`subscribe`订阅动作的执行代码\n``` java\n/**\n     * 订阅动作\n     * @param subscriber         订阅者(类似订阅的Activity之类)\n     * @param subscriberMethod   订阅事件方法, 比如加了@Subscribe注解的方法\n     */\n    private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {\n        // 订阅事件的类, 比如平常传递的自己写的EventLogin等等..\n        Class<?> eventType = subscriberMethod.eventType;\n        Subscription newSubscription = new Subscription(subscriber, subscriberMethod);\n        // 获取与eventType有关的订阅事件的队列\n        CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);\n        // 如果为空\n        if (subscriptions == null) {\n            // 初始队列\n            subscriptions = new CopyOnWriteArrayList<>();\n            subscriptionsByEventType.put(eventType, subscriptions);\n        } else {\n            // 如果管理的订阅队列存在新的订阅事件, 则抛出已注册事件的异常\n            if (subscriptions.contains(newSubscription)) {\n                throw new EventBusException(\"Subscriber \" + subscriber.getClass() + \" already registered to event \"\n                        + eventType);\n            }\n        }\n        int size = subscriptions.size();\n        // 遍历订阅的事件\n        for (int i = 0; i <= size; i++) {\n            // 根据优先级, 插入订阅事件\n            if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {\n                subscriptions.add(i, newSubscription);\n                break;\n            }\n        }\n        // 以订阅者为key, value为订阅事件的类的队列\n        List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);\n        if (subscribedEvents == null) {\n            subscribedEvents = new ArrayList<>();\n            typesBySubscriber.put(subscriber, subscribedEvents);\n        }\n        subscribedEvents.add(eventType);\n        // 是否粘性事件\n        if (subscriberMethod.sticky) {\n            // 是否分发订阅了响应事件类父类事件的方法, 默认为true\n            if (eventInheritance) {\n                // Existing sticky events of all subclasses of eventType have to be considered.\n                // Note: Iterating over all events may be inefficient with lots of sticky events,\n                // thus data structure should be changed to allow a more efficient lookup\n                // (e.g. an additional map storing sub classes of super classes: Class -> List<Class>).\n                // stickyEvents 粘性事件集合, key为eventType的类, value是eventType对象\n                Set<Map.Entry<Class<?>, Object>> entries = stickyEvents.entrySet();\n                for (Map.Entry<Class<?>, Object> entry : entries) {\n                    // 获取候选eventType\n                    Class<?> candidateEventType = entry.getKey();\n                    // native方法, 应该是判断当前注册eventType与候选缓存的eventType是否匹配\n                    if (eventType.isAssignableFrom(candidateEventType)) {\n                        // 如果匹配, 校验并发送订阅\n                        Object stickyEvent = entry.getValue();\n                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);\n                    }\n                }\n            } else {\n                Object stickyEvent = stickyEvents.get(eventType);\n                checkPostStickyEventToSubscription(newSubscription, stickyEvent);\n            }\n        }\n    }\n```\n相关注释都在代码里, 这块的流程我们可以梳理成以下步骤:\n1. 获取我们订阅时间传输的类`EventType`, 初始化内部维护的两个集合, 分别是`subscriptionsByEventType`和`typesBySubscriber`, 根据命名我们也可以理解, 一个是根据`eventType`区分的订阅者队列, 一个是根据`subscriber`(订阅者)区分的`eventType`队列, 分别向对应的集合内添加对应新的订阅者和订阅事件\n2. 根据是否粘性事件判断是否需要调用`checkPostStickyEventToSubscription`直接发送信息给订阅者\n3. `checkPostStickyEventToSubscription`内部判断事件是否被中断来判断是否会调用到`postToSubscription`, 就是发送信息给订阅者\n\n## 发送信息\n``` java\n/**\n     * 事件发送\n     */\n    /** Posts the given event to the event bus. */\n    public void post(Object event) {\n        // currentPostingThreadState 为ThreadLocal对象\n        // 获取当前线程的发送状态\n        PostingThreadState postingState = currentPostingThreadState.get();\n        // 获取当前线程的事件发送队列\n        List<Object> eventQueue = postingState.eventQueue;\n        // 添加事件\n        eventQueue.add(event);\n        // 如果不在发送中\n        if (!postingState.isPosting) {\n            // 判断是否在主线程\n            postingState.isMainThread = isMainThread();\n            // 修改发送中状态\n            postingState.isPosting = true;\n            if (postingState.canceled) {\n                throw new EventBusException(\"Internal error. Abort state was not reset\");\n            }\n            try {\n                // 遍历发送队列事件\n                while (!eventQueue.isEmpty()) {\n                    // 从队头开始发送, 同时移除队列中的对应事件\n                    postSingleEvent(eventQueue.remove(0), postingState);\n                }\n            } finally {\n                // 修改发送中状态, 修改主线程判断\n                postingState.isPosting = false;\n                postingState.isMainThread = false;\n            }\n        }\n    }\n```\n由于在业务场景中, 无法判断发送信息在什么线程下执行的, 所以内部维护的`currentPostingThreadState`是一个`ThreadLocal`对象, 它可以保证当前线程的数据不会被其他线程共享.在`post`中, 我们就能看到`EventBus`会根据当前线程, 将事件发送给当前线程的队列中, 然后遍历执行`postSingleEvent`进行单个事件的发送, 同时移除掉队列中已发送的事件\n``` java\n/**\n     * 发送单个事件\n     * @param event\n     * @param postingState\n     * @throws Error\n     */\n    private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {\n        // event 是对应eventType的实例\n        Class<?> eventClass = event.getClass();\n        // 默认没有找到订阅者\n        boolean subscriptionFound = false;\n        // 默认true, 判断是否触发eventType的父类或接口的订阅\n        if (eventInheritance) {\n            // 查找获取所有eventType的父类和接口\n            List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);\n            int countTypes = eventTypes.size();\n            // 循环发送\n            for (int h = 0; h < countTypes; h++) {\n                Class<?> clazz = eventTypes.get(h);\n                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);\n            }\n        } else {\n            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);\n        }\n        // 如果没有找到订阅者\n        if (!subscriptionFound) {\n            if (logNoSubscriberMessages) {\n                logger.log(Level.FINE, \"No subscribers registered for event \" + eventClass);\n            }\n            // 如果我们的builder配置了sendNoSubscriberEvent(默认为true)\n            if (sendNoSubscriberEvent && eventClass != NoSubscriberEvent.class &&\n                    eventClass != SubscriberExceptionEvent.class) {\n                // 会发送一个NoSubscriberEvent的事件, 如果需要判断无订阅者时候的触发情况, 可以接收这个事件做处理\n                post(new NoSubscriberEvent(this, event));\n            }\n        }\n    }\n```\n这里的流程我们可以分成两步:\n1. 通过`postSingleEventForEventType`根据`eventType`查找对应的订阅者, 如果找到, 则发送事件\n2. 如果没有找到订阅者, 根据构造器内我们通过`sendNoSubscriberEvent`的配置, 来判断是否需要发送一个无订阅者响应事件\n\n``` java\nprivate boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {\n        CopyOnWriteArrayList<Subscription> subscriptions;\n        synchronized (this) {\n            // 根据eventType获取订阅者\n            subscriptions = subscriptionsByEventType.get(eventClass);\n        }\n        if (subscriptions != null && !subscriptions.isEmpty()) {\n            for (Subscription subscription : subscriptions) {\n                postingState.event = event;\n                postingState.subscription = subscription;\n                boolean aborted = false;\n                try {\n                    // 发送给订阅者\n                    postToSubscription(subscription, event, postingState.isMainThread);\n                    aborted = postingState.canceled;\n                } finally {\n                    postingState.event = null;\n                    postingState.subscription = null;\n                    postingState.canceled = false;\n                }\n                if (aborted) {\n                    break;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n```\n`postSingleEventForEventType`方法就执行了上面的第一步动作, 如果找到了订阅者, 就会返回true; 否则, 返回false.最终我们通过调用`postToSubscription`将事件发送给订阅者.\n咱们继续往下走.\n``` java\n/**\n     * 订阅发布\n     * @param subscription 新注册的订阅者\n     * @param event eventType\n     * @param isMainThread 是否主线程\n     */\n    private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {\n        // 订阅方法的指定线程\n        switch (subscription.subscriberMethod.threadMode) {\n            // 相同线程内\n            case POSTING:\n                invokeSubscriber(subscription, event);\n                break;\n            // 主线程内, 不阻塞\n            case MAIN:\n                if (isMainThread) {\n                    // 订阅者的调用\n                    invokeSubscriber(subscription, event);\n                } else {\n                    // 通过handler处理\n                    mainThreadPoster.enqueue(subscription, event);\n                }\n                break;\n            // 主线程, 阻塞\n            case MAIN_ORDERED:\n                if (mainThreadPoster != null) {\n                    mainThreadPoster.enqueue(subscription, event);\n                } else {\n                    // temporary: technically not correct as poster not decoupled from subscriber\n                    invokeSubscriber(subscription, event);\n                }\n                break;\n            // 后台线程,\n            case BACKGROUND:\n                if (isMainThread) {\n                    // 实现了Runnable\n                    backgroundPoster.enqueue(subscription, event);\n                } else {\n                    invokeSubscriber(subscription, event);\n                }\n                break;\n            // 异步线程\n            case ASYNC:\n                asyncPoster.enqueue(subscription, event);\n                break;\n            default:\n                throw new IllegalStateException(\"Unknown thread mode: \" + subscription.subscriberMethod.threadMode);\n        }\n    }\n```\n默认的线程模式一般是`POSTING`会走发送信息时所在的线程, 这样避免了线程切换所存在的可能开销.我们首先看下`invokeSubscriber`方法, 它的作用就是做到了订阅者的调用\n``` java\nvoid invokeSubscriber(Subscription subscription, Object event) {\n        try {\n            // 订阅方法的调用\n            subscription.subscriberMethod.method.invoke(subscription.subscriber, event);\n        } catch (InvocationTargetException e) {\n            handleSubscriberException(subscription, event, e.getCause());\n        } catch (IllegalAccessException e) {\n            throw new IllegalStateException(\"Unexpected exception\", e);\n        }\n    }\n```\n其实可以看出, 这里就是获取订阅方法, 通过反射将事件作为参数调用.\n\n我们看下走UI线程的流程, 在判断当前线程非主线程的情况下, 我们会调用到`mainThreadPoster.enqueue(subscription, event);`,\n首先, 我们回到`EventBus`的构造函数中, 找到`mainThreadPoster`的相关申明\n``` java\nmainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null;\n```\n\n``` java\npublic interface MainThreadSupport {\n\n    boolean isMainThread();\n\n    Poster createPoster(EventBus eventBus);\n\n    class AndroidHandlerMainThreadSupport implements MainThreadSupport {\n\n        private final Looper looper;\n\n        public AndroidHandlerMainThreadSupport(Looper looper) {\n            this.looper = looper;\n        }\n\n        @Override\n        public boolean isMainThread() {\n            return looper == Looper.myLooper();\n        }\n\n        @Override\n        public Poster createPoster(EventBus eventBus) {\n            return new HandlerPoster(eventBus, looper, 10);\n        }\n    }\n\n}\n```\n可以看到他是个`HandlerPoster`对象, 然后再回来看`HandlerPoster.enqueue`对应的代码\n``` java\npublic void enqueue(Subscription subscription, Object event) {\n        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);\n        synchronized (this) {\n            queue.enqueue(pendingPost);\n            if (!handlerActive) {\n                handlerActive = true;\n                if (!sendMessage(obtainMessage())) {\n                    throw new EventBusException(\"Could not send handler message\");\n                }\n            }\n        }\n    }\n```\n这里首先维护了内部的`PendingPost`, 并且将对应的`pendingPost`加入执行队列中.`HandlerPoster`继承于`Handler`, 根据他前面传入的Looper可以判定保证信息的执行是在主线程中做处理的, 现在我们看下`handleMessage`的处理\n``` java\n@Override\n    public void handleMessage(Message msg) {\n        boolean rescheduled = false;\n        try {\n            long started = SystemClock.uptimeMillis();\n            while (true) {\n                PendingPost pendingPost = queue.poll();\n                if (pendingPost == null) {\n                    synchronized (this) {\n                        // Check again, this time in synchronized\n                        pendingPost = queue.poll();\n                        if (pendingPost == null) {\n                            handlerActive = false;\n                            return;\n                        }\n                    }\n                }\n                // 调用订阅者\n                eventBus.invokeSubscriber(pendingPost);\n                long timeInMethod = SystemClock.uptimeMillis() - started;\n                if (timeInMethod >= maxMillisInsideHandleMessage) {\n                    if (!sendMessage(obtainMessage())) {\n                        throw new EventBusException(\"Could not send handler message\");\n                    }\n                    rescheduled = true;\n                    return;\n                }\n            }\n        } finally {\n            handlerActive = rescheduled;\n        }\n    }\n```\n这里做的处理, 主要就是调用了`EventBus`对象的`invokeSubscriber`方法, 最终走到了订阅者的方法的执行.\n至于其他的几个线程模式, 查看对应的`POST`也可以大致知道他的原理, 这里就暂且不表了.\n### 解绑\n相对前面的, 其实解绑的逻辑就非常简单了, 我们先看代码\n``` java\n/**\n     * 解绑\n     */\n    /** Unregisters the given subscriber from all event classes. */\n    public synchronized void unregister(Object subscriber) {\n        // 根据订阅者获取对应的eventType\n        List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);\n        // 如果不为空\n        if (subscribedTypes != null) {\n            // 遍历解绑\n            for (Class<?> eventType : subscribedTypes) {\n                unsubscribeByEventType(subscriber, eventType);\n            }\n            // 移除相关的eventType\n            typesBySubscriber.remove(subscriber);\n        } else {\n            logger.log(Level.WARNING, \"Subscriber to unregister was not registered before: \" + subscriber.getClass());\n        }\n    }\n```\n我们在绑定相关的解析中, 已经知道其实内部管理订阅事件和订阅者是通过`typesBySubscriber`和`subscriptionsByEventType`来实现的, 而这里就是移除掉与对应订阅者相关的对象即可.\n","source":"_posts/EventBus源码解析.md","raw":"title: EventBus源码解析\ndate: 2018-03-30 00:00:00\ncategories:\n- 源码解析\ntags:\n- android\n- 源码解析\n---\n### 前言\n前期加班加点赶项目, 趁着刚上线空两天,赶紧看下`EventBus`做个\"思维复健\"\n### 使用\n`EventBus`的使用非常简单, 如果使用默认的`EventBus`, 我们一般只会使用到以下三个API\n1. 绑定\n``` java\nEventBus.getDefault().regisiter(this);\n```\n2. 发送信息\n``` java\nEventBus.getDefault().post(new Event());\n```\n3. 解绑\n``` java\nEventBus.getDefault().unregisiter(this);\n```\n<!-- more -->\n### EventBus.getDefault()\n`EventBus`内部维护了一个单例, 通过`getDefault`我们可以获取默认单例来进行绑定和发送动作, 但是当我们需要进行一些关于log, 是否未有订阅者情况的响应处理时, 我们可以通过`EventBusBuilder`通过构建者模式来进行配置处理,本篇解析仅分析默认情况下的流程代码\n### 绑定\n老规矩, 我们先上代码\n``` java\npublic void register(Object subscriber) {\n        Class<?> subscriberClass = subscriber.getClass();\n        // 获取对应subscriber类的订阅方法\n        List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);\n        synchronized (this) {\n            // 遍历执行订阅\n            for (SubscriberMethod subscriberMethod : subscriberMethods) {\n                subscribe(subscriber, subscriberMethod);\n            }\n        }\n    }\n```\n我们根据传递的订阅者来获取相关的订阅方法, 然后遍历执行订阅的动作. 我们首先看下如果查找订阅者的所有订阅方法\n``` java\nList<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {\n        // 从缓存中查找订阅方法\n        List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);\n        // 缓存中有, 直接返回\n        if (subscriberMethods != null) {\n            return subscriberMethods;\n        }\n        // 查找注册方法, 默认false\n        if (ignoreGeneratedIndex) {\n            // 使用反射查找\n            subscriberMethods = findUsingReflection(subscriberClass);\n        } else {\n            // 使用注解器生成的类查找\n            subscriberMethods = findUsingInfo(subscriberClass);\n        }\n        // 如果没有订阅方法, 则抛出异常\n        if (subscriberMethods.isEmpty()) {\n            throw new EventBusException(\"Subscriber \" + subscriberClass\n                    + \" and its super classes have no public methods with the @Subscribe annotation\");\n        } else {\n            // 否则加入缓存中\n            METHOD_CACHE.put(subscriberClass, subscriberMethods);\n            return subscriberMethods;\n        }\n    }\n```\n我们知道`EventBus`3.0版本后通过`@Subscribe`注解来标注对应的订阅方法, 可以看到通过`findUsingInfo`方法查询订阅方法, 如果没有订阅方法, 会抛出异常, 而如果找到了, 则会加入缓存`METHOD_CACHE`进行内部维护, 这个方法可以优化部分性能, 减少反射带来的性能问题.\n我们在往`findUsingInfo`里看, 会发现如果找不到相关订阅者信息的时候, 仍会通过反射来寻找.\n``` java\nprivate List<SubscriberMethod> findUsingInfo(Class<?> subscriberClass) {\n        FindState findState = prepareFindState();\n        findState.initForSubscriber(subscriberClass);\n        while (findState.clazz != null) {\n            findState.subscriberInfo = getSubscriberInfo(findState);\n            if (findState.subscriberInfo != null) {\n                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();\n                // 遍历订阅者方法\n                for (SubscriberMethod subscriberMethod : array) {\n                    if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {\n                        findState.subscriberMethods.add(subscriberMethod);\n                    }\n                }\n            } else {\n                // 没有订阅信息, 从反射来找\n                findUsingReflectionInSingleClass(findState);\n            }\n            findState.moveToSuperclass();\n        }\n        return getMethodsAndRelease(findState);\n    }\n```\n我们回头去看`subscribe`订阅动作的执行代码\n``` java\n/**\n     * 订阅动作\n     * @param subscriber         订阅者(类似订阅的Activity之类)\n     * @param subscriberMethod   订阅事件方法, 比如加了@Subscribe注解的方法\n     */\n    private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {\n        // 订阅事件的类, 比如平常传递的自己写的EventLogin等等..\n        Class<?> eventType = subscriberMethod.eventType;\n        Subscription newSubscription = new Subscription(subscriber, subscriberMethod);\n        // 获取与eventType有关的订阅事件的队列\n        CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);\n        // 如果为空\n        if (subscriptions == null) {\n            // 初始队列\n            subscriptions = new CopyOnWriteArrayList<>();\n            subscriptionsByEventType.put(eventType, subscriptions);\n        } else {\n            // 如果管理的订阅队列存在新的订阅事件, 则抛出已注册事件的异常\n            if (subscriptions.contains(newSubscription)) {\n                throw new EventBusException(\"Subscriber \" + subscriber.getClass() + \" already registered to event \"\n                        + eventType);\n            }\n        }\n        int size = subscriptions.size();\n        // 遍历订阅的事件\n        for (int i = 0; i <= size; i++) {\n            // 根据优先级, 插入订阅事件\n            if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {\n                subscriptions.add(i, newSubscription);\n                break;\n            }\n        }\n        // 以订阅者为key, value为订阅事件的类的队列\n        List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);\n        if (subscribedEvents == null) {\n            subscribedEvents = new ArrayList<>();\n            typesBySubscriber.put(subscriber, subscribedEvents);\n        }\n        subscribedEvents.add(eventType);\n        // 是否粘性事件\n        if (subscriberMethod.sticky) {\n            // 是否分发订阅了响应事件类父类事件的方法, 默认为true\n            if (eventInheritance) {\n                // Existing sticky events of all subclasses of eventType have to be considered.\n                // Note: Iterating over all events may be inefficient with lots of sticky events,\n                // thus data structure should be changed to allow a more efficient lookup\n                // (e.g. an additional map storing sub classes of super classes: Class -> List<Class>).\n                // stickyEvents 粘性事件集合, key为eventType的类, value是eventType对象\n                Set<Map.Entry<Class<?>, Object>> entries = stickyEvents.entrySet();\n                for (Map.Entry<Class<?>, Object> entry : entries) {\n                    // 获取候选eventType\n                    Class<?> candidateEventType = entry.getKey();\n                    // native方法, 应该是判断当前注册eventType与候选缓存的eventType是否匹配\n                    if (eventType.isAssignableFrom(candidateEventType)) {\n                        // 如果匹配, 校验并发送订阅\n                        Object stickyEvent = entry.getValue();\n                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);\n                    }\n                }\n            } else {\n                Object stickyEvent = stickyEvents.get(eventType);\n                checkPostStickyEventToSubscription(newSubscription, stickyEvent);\n            }\n        }\n    }\n```\n相关注释都在代码里, 这块的流程我们可以梳理成以下步骤:\n1. 获取我们订阅时间传输的类`EventType`, 初始化内部维护的两个集合, 分别是`subscriptionsByEventType`和`typesBySubscriber`, 根据命名我们也可以理解, 一个是根据`eventType`区分的订阅者队列, 一个是根据`subscriber`(订阅者)区分的`eventType`队列, 分别向对应的集合内添加对应新的订阅者和订阅事件\n2. 根据是否粘性事件判断是否需要调用`checkPostStickyEventToSubscription`直接发送信息给订阅者\n3. `checkPostStickyEventToSubscription`内部判断事件是否被中断来判断是否会调用到`postToSubscription`, 就是发送信息给订阅者\n\n## 发送信息\n``` java\n/**\n     * 事件发送\n     */\n    /** Posts the given event to the event bus. */\n    public void post(Object event) {\n        // currentPostingThreadState 为ThreadLocal对象\n        // 获取当前线程的发送状态\n        PostingThreadState postingState = currentPostingThreadState.get();\n        // 获取当前线程的事件发送队列\n        List<Object> eventQueue = postingState.eventQueue;\n        // 添加事件\n        eventQueue.add(event);\n        // 如果不在发送中\n        if (!postingState.isPosting) {\n            // 判断是否在主线程\n            postingState.isMainThread = isMainThread();\n            // 修改发送中状态\n            postingState.isPosting = true;\n            if (postingState.canceled) {\n                throw new EventBusException(\"Internal error. Abort state was not reset\");\n            }\n            try {\n                // 遍历发送队列事件\n                while (!eventQueue.isEmpty()) {\n                    // 从队头开始发送, 同时移除队列中的对应事件\n                    postSingleEvent(eventQueue.remove(0), postingState);\n                }\n            } finally {\n                // 修改发送中状态, 修改主线程判断\n                postingState.isPosting = false;\n                postingState.isMainThread = false;\n            }\n        }\n    }\n```\n由于在业务场景中, 无法判断发送信息在什么线程下执行的, 所以内部维护的`currentPostingThreadState`是一个`ThreadLocal`对象, 它可以保证当前线程的数据不会被其他线程共享.在`post`中, 我们就能看到`EventBus`会根据当前线程, 将事件发送给当前线程的队列中, 然后遍历执行`postSingleEvent`进行单个事件的发送, 同时移除掉队列中已发送的事件\n``` java\n/**\n     * 发送单个事件\n     * @param event\n     * @param postingState\n     * @throws Error\n     */\n    private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {\n        // event 是对应eventType的实例\n        Class<?> eventClass = event.getClass();\n        // 默认没有找到订阅者\n        boolean subscriptionFound = false;\n        // 默认true, 判断是否触发eventType的父类或接口的订阅\n        if (eventInheritance) {\n            // 查找获取所有eventType的父类和接口\n            List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);\n            int countTypes = eventTypes.size();\n            // 循环发送\n            for (int h = 0; h < countTypes; h++) {\n                Class<?> clazz = eventTypes.get(h);\n                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);\n            }\n        } else {\n            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);\n        }\n        // 如果没有找到订阅者\n        if (!subscriptionFound) {\n            if (logNoSubscriberMessages) {\n                logger.log(Level.FINE, \"No subscribers registered for event \" + eventClass);\n            }\n            // 如果我们的builder配置了sendNoSubscriberEvent(默认为true)\n            if (sendNoSubscriberEvent && eventClass != NoSubscriberEvent.class &&\n                    eventClass != SubscriberExceptionEvent.class) {\n                // 会发送一个NoSubscriberEvent的事件, 如果需要判断无订阅者时候的触发情况, 可以接收这个事件做处理\n                post(new NoSubscriberEvent(this, event));\n            }\n        }\n    }\n```\n这里的流程我们可以分成两步:\n1. 通过`postSingleEventForEventType`根据`eventType`查找对应的订阅者, 如果找到, 则发送事件\n2. 如果没有找到订阅者, 根据构造器内我们通过`sendNoSubscriberEvent`的配置, 来判断是否需要发送一个无订阅者响应事件\n\n``` java\nprivate boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {\n        CopyOnWriteArrayList<Subscription> subscriptions;\n        synchronized (this) {\n            // 根据eventType获取订阅者\n            subscriptions = subscriptionsByEventType.get(eventClass);\n        }\n        if (subscriptions != null && !subscriptions.isEmpty()) {\n            for (Subscription subscription : subscriptions) {\n                postingState.event = event;\n                postingState.subscription = subscription;\n                boolean aborted = false;\n                try {\n                    // 发送给订阅者\n                    postToSubscription(subscription, event, postingState.isMainThread);\n                    aborted = postingState.canceled;\n                } finally {\n                    postingState.event = null;\n                    postingState.subscription = null;\n                    postingState.canceled = false;\n                }\n                if (aborted) {\n                    break;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n```\n`postSingleEventForEventType`方法就执行了上面的第一步动作, 如果找到了订阅者, 就会返回true; 否则, 返回false.最终我们通过调用`postToSubscription`将事件发送给订阅者.\n咱们继续往下走.\n``` java\n/**\n     * 订阅发布\n     * @param subscription 新注册的订阅者\n     * @param event eventType\n     * @param isMainThread 是否主线程\n     */\n    private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {\n        // 订阅方法的指定线程\n        switch (subscription.subscriberMethod.threadMode) {\n            // 相同线程内\n            case POSTING:\n                invokeSubscriber(subscription, event);\n                break;\n            // 主线程内, 不阻塞\n            case MAIN:\n                if (isMainThread) {\n                    // 订阅者的调用\n                    invokeSubscriber(subscription, event);\n                } else {\n                    // 通过handler处理\n                    mainThreadPoster.enqueue(subscription, event);\n                }\n                break;\n            // 主线程, 阻塞\n            case MAIN_ORDERED:\n                if (mainThreadPoster != null) {\n                    mainThreadPoster.enqueue(subscription, event);\n                } else {\n                    // temporary: technically not correct as poster not decoupled from subscriber\n                    invokeSubscriber(subscription, event);\n                }\n                break;\n            // 后台线程,\n            case BACKGROUND:\n                if (isMainThread) {\n                    // 实现了Runnable\n                    backgroundPoster.enqueue(subscription, event);\n                } else {\n                    invokeSubscriber(subscription, event);\n                }\n                break;\n            // 异步线程\n            case ASYNC:\n                asyncPoster.enqueue(subscription, event);\n                break;\n            default:\n                throw new IllegalStateException(\"Unknown thread mode: \" + subscription.subscriberMethod.threadMode);\n        }\n    }\n```\n默认的线程模式一般是`POSTING`会走发送信息时所在的线程, 这样避免了线程切换所存在的可能开销.我们首先看下`invokeSubscriber`方法, 它的作用就是做到了订阅者的调用\n``` java\nvoid invokeSubscriber(Subscription subscription, Object event) {\n        try {\n            // 订阅方法的调用\n            subscription.subscriberMethod.method.invoke(subscription.subscriber, event);\n        } catch (InvocationTargetException e) {\n            handleSubscriberException(subscription, event, e.getCause());\n        } catch (IllegalAccessException e) {\n            throw new IllegalStateException(\"Unexpected exception\", e);\n        }\n    }\n```\n其实可以看出, 这里就是获取订阅方法, 通过反射将事件作为参数调用.\n\n我们看下走UI线程的流程, 在判断当前线程非主线程的情况下, 我们会调用到`mainThreadPoster.enqueue(subscription, event);`,\n首先, 我们回到`EventBus`的构造函数中, 找到`mainThreadPoster`的相关申明\n``` java\nmainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null;\n```\n\n``` java\npublic interface MainThreadSupport {\n\n    boolean isMainThread();\n\n    Poster createPoster(EventBus eventBus);\n\n    class AndroidHandlerMainThreadSupport implements MainThreadSupport {\n\n        private final Looper looper;\n\n        public AndroidHandlerMainThreadSupport(Looper looper) {\n            this.looper = looper;\n        }\n\n        @Override\n        public boolean isMainThread() {\n            return looper == Looper.myLooper();\n        }\n\n        @Override\n        public Poster createPoster(EventBus eventBus) {\n            return new HandlerPoster(eventBus, looper, 10);\n        }\n    }\n\n}\n```\n可以看到他是个`HandlerPoster`对象, 然后再回来看`HandlerPoster.enqueue`对应的代码\n``` java\npublic void enqueue(Subscription subscription, Object event) {\n        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);\n        synchronized (this) {\n            queue.enqueue(pendingPost);\n            if (!handlerActive) {\n                handlerActive = true;\n                if (!sendMessage(obtainMessage())) {\n                    throw new EventBusException(\"Could not send handler message\");\n                }\n            }\n        }\n    }\n```\n这里首先维护了内部的`PendingPost`, 并且将对应的`pendingPost`加入执行队列中.`HandlerPoster`继承于`Handler`, 根据他前面传入的Looper可以判定保证信息的执行是在主线程中做处理的, 现在我们看下`handleMessage`的处理\n``` java\n@Override\n    public void handleMessage(Message msg) {\n        boolean rescheduled = false;\n        try {\n            long started = SystemClock.uptimeMillis();\n            while (true) {\n                PendingPost pendingPost = queue.poll();\n                if (pendingPost == null) {\n                    synchronized (this) {\n                        // Check again, this time in synchronized\n                        pendingPost = queue.poll();\n                        if (pendingPost == null) {\n                            handlerActive = false;\n                            return;\n                        }\n                    }\n                }\n                // 调用订阅者\n                eventBus.invokeSubscriber(pendingPost);\n                long timeInMethod = SystemClock.uptimeMillis() - started;\n                if (timeInMethod >= maxMillisInsideHandleMessage) {\n                    if (!sendMessage(obtainMessage())) {\n                        throw new EventBusException(\"Could not send handler message\");\n                    }\n                    rescheduled = true;\n                    return;\n                }\n            }\n        } finally {\n            handlerActive = rescheduled;\n        }\n    }\n```\n这里做的处理, 主要就是调用了`EventBus`对象的`invokeSubscriber`方法, 最终走到了订阅者的方法的执行.\n至于其他的几个线程模式, 查看对应的`POST`也可以大致知道他的原理, 这里就暂且不表了.\n### 解绑\n相对前面的, 其实解绑的逻辑就非常简单了, 我们先看代码\n``` java\n/**\n     * 解绑\n     */\n    /** Unregisters the given subscriber from all event classes. */\n    public synchronized void unregister(Object subscriber) {\n        // 根据订阅者获取对应的eventType\n        List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);\n        // 如果不为空\n        if (subscribedTypes != null) {\n            // 遍历解绑\n            for (Class<?> eventType : subscribedTypes) {\n                unsubscribeByEventType(subscriber, eventType);\n            }\n            // 移除相关的eventType\n            typesBySubscriber.remove(subscriber);\n        } else {\n            logger.log(Level.WARNING, \"Subscriber to unregister was not registered before: \" + subscriber.getClass());\n        }\n    }\n```\n我们在绑定相关的解析中, 已经知道其实内部管理订阅事件和订阅者是通过`typesBySubscriber`和`subscriptionsByEventType`来实现的, 而这里就是移除掉与对应订阅者相关的对象即可.\n","slug":"EventBus源码解析","published":1,"updated":"2018-05-07T02:03:50.325Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh7fldoo001v8os6tz9k5nn7","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>前期加班加点赶项目, 趁着刚上线空两天,赶紧看下<code>EventBus</code>做个”思维复健”</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p><code>EventBus</code>的使用非常简单, 如果使用默认的<code>EventBus</code>, 我们一般只会使用到以下三个API</p>\n<ol>\n<li><p>绑定</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBus.getDefault().regisiter(<span class=\"keyword\">this</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>发送信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBus.getDefault().post(<span class=\"keyword\">new</span> Event());</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解绑</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBus.getDefault().unregisiter(<span class=\"keyword\">this</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<a id=\"more\"></a>\n<h3 id=\"EventBus-getDefault\"><a href=\"#EventBus-getDefault\" class=\"headerlink\" title=\"EventBus.getDefault()\"></a>EventBus.getDefault()</h3><p><code>EventBus</code>内部维护了一个单例, 通过<code>getDefault</code>我们可以获取默认单例来进行绑定和发送动作, 但是当我们需要进行一些关于log, 是否未有订阅者情况的响应处理时, 我们可以通过<code>EventBusBuilder</code>通过构建者模式来进行配置处理,本篇解析仅分析默认情况下的流程代码</p>\n<h3 id=\"绑定\"><a href=\"#绑定\" class=\"headerlink\" title=\"绑定\"></a>绑定</h3><p>老规矩, 我们先上代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(Object subscriber)</span> </span>&#123;</span><br><span class=\"line\">        Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class=\"line\">        <span class=\"comment\">// 获取对应subscriber类的订阅方法</span></span><br><span class=\"line\">        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 遍历执行订阅</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class=\"line\">                subscribe(subscriber, subscriberMethod);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们根据传递的订阅者来获取相关的订阅方法, 然后遍历执行订阅的动作. 我们首先看下如果查找订阅者的所有订阅方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">List&lt;SubscriberMethod&gt; <span class=\"title\">findSubscriberMethods</span><span class=\"params\">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从缓存中查找订阅方法</span></span><br><span class=\"line\">        List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class=\"line\">        <span class=\"comment\">// 缓存中有, 直接返回</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscriberMethods != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> subscriberMethods;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 查找注册方法, 默认false</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用反射查找</span></span><br><span class=\"line\">            subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用注解器生成的类查找</span></span><br><span class=\"line\">            subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果没有订阅方法, 则抛出异常</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(<span class=\"string\">\"Subscriber \"</span> + subscriberClass</span><br><span class=\"line\">                    + <span class=\"string\">\" and its super classes have no public methods with the @Subscribe annotation\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 否则加入缓存中</span></span><br><span class=\"line\">            METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> subscriberMethods;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们知道<code>EventBus</code>3.0版本后通过<code>@Subscribe</code>注解来标注对应的订阅方法, 可以看到通过<code>findUsingInfo</code>方法查询订阅方法, 如果没有订阅方法, 会抛出异常, 而如果找到了, 则会加入缓存<code>METHOD_CACHE</code>进行内部维护, 这个方法可以优化部分性能, 减少反射带来的性能问题.<br>我们在往<code>findUsingInfo</code>里看, 会发现如果找不到相关订阅者信息的时候, 仍会通过反射来寻找.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> List&lt;SubscriberMethod&gt; <span class=\"title\">findUsingInfo</span><span class=\"params\">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class=\"line\">        FindState findState = prepareFindState();</span><br><span class=\"line\">        findState.initForSubscriber(subscriberClass);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (findState.clazz != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (findState.subscriberInfo != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class=\"line\">                <span class=\"comment\">// 遍历订阅者方法</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class=\"line\">                        findState.subscriberMethods.add(subscriberMethod);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 没有订阅信息, 从反射来找</span></span><br><span class=\"line\">                findUsingReflectionInSingleClass(findState);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            findState.moveToSuperclass();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getMethodsAndRelease(findState);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们回头去看<code>subscribe</code>订阅动作的执行代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 订阅动作</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> subscriber         订阅者(类似订阅的Activity之类)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> subscriberMethod   订阅事件方法, 比如加了<span class=\"doctag\">@Subscribe</span>注解的方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 订阅事件的类, 比如平常传递的自己写的EventLogin等等..</span></span><br><span class=\"line\">        Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class=\"line\">        Subscription newSubscription = <span class=\"keyword\">new</span> Subscription(subscriber, subscriberMethod);</span><br><span class=\"line\">        <span class=\"comment\">// 获取与eventType有关的订阅事件的队列</span></span><br><span class=\"line\">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class=\"line\">        <span class=\"comment\">// 如果为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscriptions == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 初始队列</span></span><br><span class=\"line\">            subscriptions = <span class=\"keyword\">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class=\"line\">            subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果管理的订阅队列存在新的订阅事件, 则抛出已注册事件的异常</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(<span class=\"string\">\"Subscriber \"</span> + subscriber.getClass() + <span class=\"string\">\" already registered to event \"</span></span><br><span class=\"line\">                        + eventType);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> size = subscriptions.size();</span><br><span class=\"line\">        <span class=\"comment\">// 遍历订阅的事件</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= size; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 根据优先级, 插入订阅事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class=\"line\">                subscriptions.add(i, newSubscription);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 以订阅者为key, value为订阅事件的类的队列</span></span><br><span class=\"line\">        List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscribedEvents == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            subscribedEvents = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">            typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        subscribedEvents.add(eventType);</span><br><span class=\"line\">        <span class=\"comment\">// 是否粘性事件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscriberMethod.sticky) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 是否分发订阅了响应事件类父类事件的方法, 默认为true</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (eventInheritance) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Existing sticky events of all subclasses of eventType have to be considered.</span></span><br><span class=\"line\">                <span class=\"comment\">// Note: Iterating over all events may be inefficient with lots of sticky events,</span></span><br><span class=\"line\">                <span class=\"comment\">// thus data structure should be changed to allow a more efficient lookup</span></span><br><span class=\"line\">                <span class=\"comment\">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></span><br><span class=\"line\">                <span class=\"comment\">// stickyEvents 粘性事件集合, key为eventType的类, value是eventType对象</span></span><br><span class=\"line\">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 获取候选eventType</span></span><br><span class=\"line\">                    Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class=\"line\">                    <span class=\"comment\">// native方法, 应该是判断当前注册eventType与候选缓存的eventType是否匹配</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 如果匹配, 校验并发送订阅</span></span><br><span class=\"line\">                        Object stickyEvent = entry.getValue();</span><br><span class=\"line\">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                Object stickyEvent = stickyEvents.get(eventType);</span><br><span class=\"line\">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>相关注释都在代码里, 这块的流程我们可以梳理成以下步骤:</p>\n<ol>\n<li>获取我们订阅时间传输的类<code>EventType</code>, 初始化内部维护的两个集合, 分别是<code>subscriptionsByEventType</code>和<code>typesBySubscriber</code>, 根据命名我们也可以理解, 一个是根据<code>eventType</code>区分的订阅者队列, 一个是根据<code>subscriber</code>(订阅者)区分的<code>eventType</code>队列, 分别向对应的集合内添加对应新的订阅者和订阅事件</li>\n<li>根据是否粘性事件判断是否需要调用<code>checkPostStickyEventToSubscription</code>直接发送信息给订阅者</li>\n<li><code>checkPostStickyEventToSubscription</code>内部判断事件是否被中断来判断是否会调用到<code>postToSubscription</code>, 就是发送信息给订阅者</li>\n</ol>\n<h2 id=\"发送信息\"><a href=\"#发送信息\" class=\"headerlink\" title=\"发送信息\"></a>发送信息</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 事件发送</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"comment\">/** Posts the given event to the event bus. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">post</span><span class=\"params\">(Object event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// currentPostingThreadState 为ThreadLocal对象</span></span><br><span class=\"line\">        <span class=\"comment\">// 获取当前线程的发送状态</span></span><br><span class=\"line\">        PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前线程的事件发送队列</span></span><br><span class=\"line\">        List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class=\"line\">        <span class=\"comment\">// 添加事件</span></span><br><span class=\"line\">        eventQueue.add(event);</span><br><span class=\"line\">        <span class=\"comment\">// 如果不在发送中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!postingState.isPosting) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断是否在主线程</span></span><br><span class=\"line\">            postingState.isMainThread = isMainThread();</span><br><span class=\"line\">            <span class=\"comment\">// 修改发送中状态</span></span><br><span class=\"line\">            postingState.isPosting = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (postingState.canceled) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(<span class=\"string\">\"Internal error. Abort state was not reset\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 遍历发送队列事件</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 从队头开始发送, 同时移除队列中的对应事件</span></span><br><span class=\"line\">                    postSingleEvent(eventQueue.remove(<span class=\"number\">0</span>), postingState);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 修改发送中状态, 修改主线程判断</span></span><br><span class=\"line\">                postingState.isPosting = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                postingState.isMainThread = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>由于在业务场景中, 无法判断发送信息在什么线程下执行的, 所以内部维护的<code>currentPostingThreadState</code>是一个<code>ThreadLocal</code>对象, 它可以保证当前线程的数据不会被其他线程共享.在<code>post</code>中, 我们就能看到<code>EventBus</code>会根据当前线程, 将事件发送给当前线程的队列中, 然后遍历执行<code>postSingleEvent</code>进行单个事件的发送, 同时移除掉队列中已发送的事件<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 发送单个事件</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> event</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> postingState</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Error</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">postSingleEvent</span><span class=\"params\">(Object event, PostingThreadState postingState)</span> <span class=\"keyword\">throws</span> Error </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// event 是对应eventType的实例</span></span><br><span class=\"line\">        Class&lt;?&gt; eventClass = event.getClass();</span><br><span class=\"line\">        <span class=\"comment\">// 默认没有找到订阅者</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> subscriptionFound = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 默认true, 判断是否触发eventType的父类或接口的订阅</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (eventInheritance) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 查找获取所有eventType的父类和接口</span></span><br><span class=\"line\">            List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> countTypes = eventTypes.size();</span><br><span class=\"line\">            <span class=\"comment\">// 循环发送</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> h = <span class=\"number\">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class=\"line\">                Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class=\"line\">                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果没有找到订阅者</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!subscriptionFound) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (logNoSubscriberMessages) &#123;</span><br><span class=\"line\">                logger.log(Level.FINE, <span class=\"string\">\"No subscribers registered for event \"</span> + eventClass);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果我们的builder配置了sendNoSubscriberEvent(默认为true)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class=\"line\">                    eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 会发送一个NoSubscriberEvent的事件, 如果需要判断无订阅者时候的触发情况, 可以接收这个事件做处理</span></span><br><span class=\"line\">                post(<span class=\"keyword\">new</span> NoSubscriberEvent(<span class=\"keyword\">this</span>, event));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的流程我们可以分成两步:</p>\n<ol>\n<li>通过<code>postSingleEventForEventType</code>根据<code>eventType</code>查找对应的订阅者, 如果找到, 则发送事件</li>\n<li>如果没有找到订阅者, 根据构造器内我们通过<code>sendNoSubscriberEvent</code>的配置, 来判断是否需要发送一个无订阅者响应事件</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">postSingleEventForEventType</span><span class=\"params\">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class=\"line\">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 根据eventType获取订阅者</span></span><br><span class=\"line\">            subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscriptions != <span class=\"keyword\">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class=\"line\">                postingState.event = event;</span><br><span class=\"line\">                postingState.subscription = subscription;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> aborted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 发送给订阅者</span></span><br><span class=\"line\">                    postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class=\"line\">                    aborted = postingState.canceled;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    postingState.event = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    postingState.subscription = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    postingState.canceled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (aborted) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><code>postSingleEventForEventType</code>方法就执行了上面的第一步动作, 如果找到了订阅者, 就会返回true; 否则, 返回false.最终我们通过调用<code>postToSubscription</code>将事件发送给订阅者.<br>咱们继续往下走.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 订阅发布</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> subscription 新注册的订阅者</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> event eventType</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> isMainThread 是否主线程</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">postToSubscription</span><span class=\"params\">(Subscription subscription, Object event, <span class=\"keyword\">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 订阅方法的指定线程</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 相同线程内</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> POSTING:</span><br><span class=\"line\">                invokeSubscriber(subscription, event);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 主线程内, 不阻塞</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> MAIN:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isMainThread) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 订阅者的调用</span></span><br><span class=\"line\">                    invokeSubscriber(subscription, event);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 通过handler处理</span></span><br><span class=\"line\">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 主线程, 阻塞</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> MAIN_ORDERED:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mainThreadPoster != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// temporary: technically not correct as poster not decoupled from subscriber</span></span><br><span class=\"line\">                    invokeSubscriber(subscription, event);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 后台线程,</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> BACKGROUND:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isMainThread) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 实现了Runnable</span></span><br><span class=\"line\">                    backgroundPoster.enqueue(subscription, event);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    invokeSubscriber(subscription, event);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 异步线程</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> ASYNC:</span><br><span class=\"line\">                asyncPoster.enqueue(subscription, event);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Unknown thread mode: \"</span> + subscription.subscriberMethod.threadMode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>默认的线程模式一般是<code>POSTING</code>会走发送信息时所在的线程, 这样避免了线程切换所存在的可能开销.我们首先看下<code>invokeSubscriber</code>方法, 它的作用就是做到了订阅者的调用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">invokeSubscriber</span><span class=\"params\">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 订阅方法的调用</span></span><br><span class=\"line\">            subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InvocationTargetException e) &#123;</span><br><span class=\"line\">            handleSubscriberException(subscription, event, e.getCause());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Unexpected exception\"</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>其实可以看出, 这里就是获取订阅方法, 通过反射将事件作为参数调用.</p>\n<p>我们看下走UI线程的流程, 在判断当前线程非主线程的情况下, 我们会调用到<code>mainThreadPoster.enqueue(subscription, event);</code>,<br>首先, 我们回到<code>EventBus</code>的构造函数中, 找到<code>mainThreadPoster</code>的相关申明<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mainThreadPoster = mainThreadSupport != <span class=\"keyword\">null</span> ? mainThreadSupport.createPoster(<span class=\"keyword\">this</span>) : <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MainThreadSupport</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isMainThread</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Poster <span class=\"title\">createPoster</span><span class=\"params\">(EventBus eventBus)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AndroidHandlerMainThreadSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">MainThreadSupport</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Looper looper;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AndroidHandlerMainThreadSupport</span><span class=\"params\">(Looper looper)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.looper = looper;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMainThread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> looper == Looper.myLooper();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Poster <span class=\"title\">createPoster</span><span class=\"params\">(EventBus eventBus)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> HandlerPoster(eventBus, looper, <span class=\"number\">10</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到他是个<code>HandlerPoster</code>对象, 然后再回来看<code>HandlerPoster.enqueue</code>对应的代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class=\"line\">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            queue.enqueue(pendingPost);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!handlerActive) &#123;</span><br><span class=\"line\">                handlerActive = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(<span class=\"string\">\"Could not send handler message\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里首先维护了内部的<code>PendingPost</code>, 并且将对应的<code>pendingPost</code>加入执行队列中.<code>HandlerPoster</code>继承于<code>Handler</code>, 根据他前面传入的Looper可以判定保证信息的执行是在主线程中做处理的, 现在我们看下<code>handleMessage</code>的处理<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> rescheduled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> started = SystemClock.uptimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                PendingPost pendingPost = queue.poll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (pendingPost == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// Check again, this time in synchronized</span></span><br><span class=\"line\">                        pendingPost = queue.poll();</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (pendingPost == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            handlerActive = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 调用订阅者</span></span><br><span class=\"line\">                eventBus.invokeSubscriber(pendingPost);</span><br><span class=\"line\">                <span class=\"keyword\">long</span> timeInMethod = SystemClock.uptimeMillis() - started;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(<span class=\"string\">\"Could not send handler message\"</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    rescheduled = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            handlerActive = rescheduled;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里做的处理, 主要就是调用了<code>EventBus</code>对象的<code>invokeSubscriber</code>方法, 最终走到了订阅者的方法的执行.<br>至于其他的几个线程模式, 查看对应的<code>POST</code>也可以大致知道他的原理, 这里就暂且不表了.</p>\n<h3 id=\"解绑\"><a href=\"#解绑\" class=\"headerlink\" title=\"解绑\"></a>解绑</h3><p>相对前面的, 其实解绑的逻辑就非常简单了, 我们先看代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 解绑</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"comment\">/** Unregisters the given subscriber from all event classes. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">unregister</span><span class=\"params\">(Object subscriber)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据订阅者获取对应的eventType</span></span><br><span class=\"line\">        List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class=\"line\">        <span class=\"comment\">// 如果不为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscribedTypes != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 遍历解绑</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class=\"line\">                unsubscribeByEventType(subscriber, eventType);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 移除相关的eventType</span></span><br><span class=\"line\">            typesBySubscriber.remove(subscriber);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            logger.log(Level.WARNING, <span class=\"string\">\"Subscriber to unregister was not registered before: \"</span> + subscriber.getClass());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们在绑定相关的解析中, 已经知道其实内部管理订阅事件和订阅者是通过<code>typesBySubscriber</code>和<code>subscriptionsByEventType</code>来实现的, 而这里就是移除掉与对应订阅者相关的对象即可.</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>前期加班加点赶项目, 趁着刚上线空两天,赶紧看下<code>EventBus</code>做个”思维复健”</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p><code>EventBus</code>的使用非常简单, 如果使用默认的<code>EventBus</code>, 我们一般只会使用到以下三个API</p>\n<ol>\n<li><p>绑定</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBus.getDefault().regisiter(<span class=\"keyword\">this</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>发送信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBus.getDefault().post(<span class=\"keyword\">new</span> Event());</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解绑</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBus.getDefault().unregisiter(<span class=\"keyword\">this</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>","more":"<h3 id=\"EventBus-getDefault\"><a href=\"#EventBus-getDefault\" class=\"headerlink\" title=\"EventBus.getDefault()\"></a>EventBus.getDefault()</h3><p><code>EventBus</code>内部维护了一个单例, 通过<code>getDefault</code>我们可以获取默认单例来进行绑定和发送动作, 但是当我们需要进行一些关于log, 是否未有订阅者情况的响应处理时, 我们可以通过<code>EventBusBuilder</code>通过构建者模式来进行配置处理,本篇解析仅分析默认情况下的流程代码</p>\n<h3 id=\"绑定\"><a href=\"#绑定\" class=\"headerlink\" title=\"绑定\"></a>绑定</h3><p>老规矩, 我们先上代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(Object subscriber)</span> </span>&#123;</span><br><span class=\"line\">        Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class=\"line\">        <span class=\"comment\">// 获取对应subscriber类的订阅方法</span></span><br><span class=\"line\">        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 遍历执行订阅</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class=\"line\">                subscribe(subscriber, subscriberMethod);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们根据传递的订阅者来获取相关的订阅方法, 然后遍历执行订阅的动作. 我们首先看下如果查找订阅者的所有订阅方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">List&lt;SubscriberMethod&gt; <span class=\"title\">findSubscriberMethods</span><span class=\"params\">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从缓存中查找订阅方法</span></span><br><span class=\"line\">        List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class=\"line\">        <span class=\"comment\">// 缓存中有, 直接返回</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscriberMethods != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> subscriberMethods;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 查找注册方法, 默认false</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用反射查找</span></span><br><span class=\"line\">            subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用注解器生成的类查找</span></span><br><span class=\"line\">            subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果没有订阅方法, 则抛出异常</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(<span class=\"string\">\"Subscriber \"</span> + subscriberClass</span><br><span class=\"line\">                    + <span class=\"string\">\" and its super classes have no public methods with the @Subscribe annotation\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 否则加入缓存中</span></span><br><span class=\"line\">            METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> subscriberMethods;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们知道<code>EventBus</code>3.0版本后通过<code>@Subscribe</code>注解来标注对应的订阅方法, 可以看到通过<code>findUsingInfo</code>方法查询订阅方法, 如果没有订阅方法, 会抛出异常, 而如果找到了, 则会加入缓存<code>METHOD_CACHE</code>进行内部维护, 这个方法可以优化部分性能, 减少反射带来的性能问题.<br>我们在往<code>findUsingInfo</code>里看, 会发现如果找不到相关订阅者信息的时候, 仍会通过反射来寻找.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> List&lt;SubscriberMethod&gt; <span class=\"title\">findUsingInfo</span><span class=\"params\">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class=\"line\">        FindState findState = prepareFindState();</span><br><span class=\"line\">        findState.initForSubscriber(subscriberClass);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (findState.clazz != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (findState.subscriberInfo != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class=\"line\">                <span class=\"comment\">// 遍历订阅者方法</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class=\"line\">                        findState.subscriberMethods.add(subscriberMethod);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 没有订阅信息, 从反射来找</span></span><br><span class=\"line\">                findUsingReflectionInSingleClass(findState);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            findState.moveToSuperclass();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getMethodsAndRelease(findState);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们回头去看<code>subscribe</code>订阅动作的执行代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 订阅动作</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> subscriber         订阅者(类似订阅的Activity之类)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> subscriberMethod   订阅事件方法, 比如加了<span class=\"doctag\">@Subscribe</span>注解的方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 订阅事件的类, 比如平常传递的自己写的EventLogin等等..</span></span><br><span class=\"line\">        Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class=\"line\">        Subscription newSubscription = <span class=\"keyword\">new</span> Subscription(subscriber, subscriberMethod);</span><br><span class=\"line\">        <span class=\"comment\">// 获取与eventType有关的订阅事件的队列</span></span><br><span class=\"line\">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class=\"line\">        <span class=\"comment\">// 如果为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscriptions == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 初始队列</span></span><br><span class=\"line\">            subscriptions = <span class=\"keyword\">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class=\"line\">            subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果管理的订阅队列存在新的订阅事件, 则抛出已注册事件的异常</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(<span class=\"string\">\"Subscriber \"</span> + subscriber.getClass() + <span class=\"string\">\" already registered to event \"</span></span><br><span class=\"line\">                        + eventType);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> size = subscriptions.size();</span><br><span class=\"line\">        <span class=\"comment\">// 遍历订阅的事件</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= size; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 根据优先级, 插入订阅事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class=\"line\">                subscriptions.add(i, newSubscription);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 以订阅者为key, value为订阅事件的类的队列</span></span><br><span class=\"line\">        List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscribedEvents == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            subscribedEvents = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">            typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        subscribedEvents.add(eventType);</span><br><span class=\"line\">        <span class=\"comment\">// 是否粘性事件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscriberMethod.sticky) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 是否分发订阅了响应事件类父类事件的方法, 默认为true</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (eventInheritance) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Existing sticky events of all subclasses of eventType have to be considered.</span></span><br><span class=\"line\">                <span class=\"comment\">// Note: Iterating over all events may be inefficient with lots of sticky events,</span></span><br><span class=\"line\">                <span class=\"comment\">// thus data structure should be changed to allow a more efficient lookup</span></span><br><span class=\"line\">                <span class=\"comment\">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></span><br><span class=\"line\">                <span class=\"comment\">// stickyEvents 粘性事件集合, key为eventType的类, value是eventType对象</span></span><br><span class=\"line\">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 获取候选eventType</span></span><br><span class=\"line\">                    Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class=\"line\">                    <span class=\"comment\">// native方法, 应该是判断当前注册eventType与候选缓存的eventType是否匹配</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 如果匹配, 校验并发送订阅</span></span><br><span class=\"line\">                        Object stickyEvent = entry.getValue();</span><br><span class=\"line\">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                Object stickyEvent = stickyEvents.get(eventType);</span><br><span class=\"line\">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>相关注释都在代码里, 这块的流程我们可以梳理成以下步骤:</p>\n<ol>\n<li>获取我们订阅时间传输的类<code>EventType</code>, 初始化内部维护的两个集合, 分别是<code>subscriptionsByEventType</code>和<code>typesBySubscriber</code>, 根据命名我们也可以理解, 一个是根据<code>eventType</code>区分的订阅者队列, 一个是根据<code>subscriber</code>(订阅者)区分的<code>eventType</code>队列, 分别向对应的集合内添加对应新的订阅者和订阅事件</li>\n<li>根据是否粘性事件判断是否需要调用<code>checkPostStickyEventToSubscription</code>直接发送信息给订阅者</li>\n<li><code>checkPostStickyEventToSubscription</code>内部判断事件是否被中断来判断是否会调用到<code>postToSubscription</code>, 就是发送信息给订阅者</li>\n</ol>\n<h2 id=\"发送信息\"><a href=\"#发送信息\" class=\"headerlink\" title=\"发送信息\"></a>发送信息</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 事件发送</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"comment\">/** Posts the given event to the event bus. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">post</span><span class=\"params\">(Object event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// currentPostingThreadState 为ThreadLocal对象</span></span><br><span class=\"line\">        <span class=\"comment\">// 获取当前线程的发送状态</span></span><br><span class=\"line\">        PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前线程的事件发送队列</span></span><br><span class=\"line\">        List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class=\"line\">        <span class=\"comment\">// 添加事件</span></span><br><span class=\"line\">        eventQueue.add(event);</span><br><span class=\"line\">        <span class=\"comment\">// 如果不在发送中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!postingState.isPosting) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断是否在主线程</span></span><br><span class=\"line\">            postingState.isMainThread = isMainThread();</span><br><span class=\"line\">            <span class=\"comment\">// 修改发送中状态</span></span><br><span class=\"line\">            postingState.isPosting = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (postingState.canceled) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(<span class=\"string\">\"Internal error. Abort state was not reset\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 遍历发送队列事件</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 从队头开始发送, 同时移除队列中的对应事件</span></span><br><span class=\"line\">                    postSingleEvent(eventQueue.remove(<span class=\"number\">0</span>), postingState);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 修改发送中状态, 修改主线程判断</span></span><br><span class=\"line\">                postingState.isPosting = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                postingState.isMainThread = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>由于在业务场景中, 无法判断发送信息在什么线程下执行的, 所以内部维护的<code>currentPostingThreadState</code>是一个<code>ThreadLocal</code>对象, 它可以保证当前线程的数据不会被其他线程共享.在<code>post</code>中, 我们就能看到<code>EventBus</code>会根据当前线程, 将事件发送给当前线程的队列中, 然后遍历执行<code>postSingleEvent</code>进行单个事件的发送, 同时移除掉队列中已发送的事件<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 发送单个事件</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> event</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> postingState</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Error</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">postSingleEvent</span><span class=\"params\">(Object event, PostingThreadState postingState)</span> <span class=\"keyword\">throws</span> Error </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// event 是对应eventType的实例</span></span><br><span class=\"line\">        Class&lt;?&gt; eventClass = event.getClass();</span><br><span class=\"line\">        <span class=\"comment\">// 默认没有找到订阅者</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> subscriptionFound = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 默认true, 判断是否触发eventType的父类或接口的订阅</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (eventInheritance) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 查找获取所有eventType的父类和接口</span></span><br><span class=\"line\">            List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> countTypes = eventTypes.size();</span><br><span class=\"line\">            <span class=\"comment\">// 循环发送</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> h = <span class=\"number\">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class=\"line\">                Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class=\"line\">                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果没有找到订阅者</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!subscriptionFound) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (logNoSubscriberMessages) &#123;</span><br><span class=\"line\">                logger.log(Level.FINE, <span class=\"string\">\"No subscribers registered for event \"</span> + eventClass);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果我们的builder配置了sendNoSubscriberEvent(默认为true)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class=\"line\">                    eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 会发送一个NoSubscriberEvent的事件, 如果需要判断无订阅者时候的触发情况, 可以接收这个事件做处理</span></span><br><span class=\"line\">                post(<span class=\"keyword\">new</span> NoSubscriberEvent(<span class=\"keyword\">this</span>, event));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的流程我们可以分成两步:</p>\n<ol>\n<li>通过<code>postSingleEventForEventType</code>根据<code>eventType</code>查找对应的订阅者, 如果找到, 则发送事件</li>\n<li>如果没有找到订阅者, 根据构造器内我们通过<code>sendNoSubscriberEvent</code>的配置, 来判断是否需要发送一个无订阅者响应事件</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">postSingleEventForEventType</span><span class=\"params\">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class=\"line\">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 根据eventType获取订阅者</span></span><br><span class=\"line\">            subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscriptions != <span class=\"keyword\">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class=\"line\">                postingState.event = event;</span><br><span class=\"line\">                postingState.subscription = subscription;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> aborted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 发送给订阅者</span></span><br><span class=\"line\">                    postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class=\"line\">                    aborted = postingState.canceled;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    postingState.event = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    postingState.subscription = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    postingState.canceled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (aborted) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><code>postSingleEventForEventType</code>方法就执行了上面的第一步动作, 如果找到了订阅者, 就会返回true; 否则, 返回false.最终我们通过调用<code>postToSubscription</code>将事件发送给订阅者.<br>咱们继续往下走.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 订阅发布</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> subscription 新注册的订阅者</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> event eventType</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> isMainThread 是否主线程</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">postToSubscription</span><span class=\"params\">(Subscription subscription, Object event, <span class=\"keyword\">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 订阅方法的指定线程</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 相同线程内</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> POSTING:</span><br><span class=\"line\">                invokeSubscriber(subscription, event);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 主线程内, 不阻塞</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> MAIN:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isMainThread) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 订阅者的调用</span></span><br><span class=\"line\">                    invokeSubscriber(subscription, event);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 通过handler处理</span></span><br><span class=\"line\">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 主线程, 阻塞</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> MAIN_ORDERED:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mainThreadPoster != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// temporary: technically not correct as poster not decoupled from subscriber</span></span><br><span class=\"line\">                    invokeSubscriber(subscription, event);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 后台线程,</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> BACKGROUND:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isMainThread) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 实现了Runnable</span></span><br><span class=\"line\">                    backgroundPoster.enqueue(subscription, event);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    invokeSubscriber(subscription, event);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 异步线程</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> ASYNC:</span><br><span class=\"line\">                asyncPoster.enqueue(subscription, event);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Unknown thread mode: \"</span> + subscription.subscriberMethod.threadMode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>默认的线程模式一般是<code>POSTING</code>会走发送信息时所在的线程, 这样避免了线程切换所存在的可能开销.我们首先看下<code>invokeSubscriber</code>方法, 它的作用就是做到了订阅者的调用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">invokeSubscriber</span><span class=\"params\">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 订阅方法的调用</span></span><br><span class=\"line\">            subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InvocationTargetException e) &#123;</span><br><span class=\"line\">            handleSubscriberException(subscription, event, e.getCause());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Unexpected exception\"</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>其实可以看出, 这里就是获取订阅方法, 通过反射将事件作为参数调用.</p>\n<p>我们看下走UI线程的流程, 在判断当前线程非主线程的情况下, 我们会调用到<code>mainThreadPoster.enqueue(subscription, event);</code>,<br>首先, 我们回到<code>EventBus</code>的构造函数中, 找到<code>mainThreadPoster</code>的相关申明<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mainThreadPoster = mainThreadSupport != <span class=\"keyword\">null</span> ? mainThreadSupport.createPoster(<span class=\"keyword\">this</span>) : <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MainThreadSupport</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isMainThread</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Poster <span class=\"title\">createPoster</span><span class=\"params\">(EventBus eventBus)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AndroidHandlerMainThreadSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">MainThreadSupport</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Looper looper;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AndroidHandlerMainThreadSupport</span><span class=\"params\">(Looper looper)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.looper = looper;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMainThread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> looper == Looper.myLooper();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Poster <span class=\"title\">createPoster</span><span class=\"params\">(EventBus eventBus)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> HandlerPoster(eventBus, looper, <span class=\"number\">10</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到他是个<code>HandlerPoster</code>对象, 然后再回来看<code>HandlerPoster.enqueue</code>对应的代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class=\"line\">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            queue.enqueue(pendingPost);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!handlerActive) &#123;</span><br><span class=\"line\">                handlerActive = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(<span class=\"string\">\"Could not send handler message\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里首先维护了内部的<code>PendingPost</code>, 并且将对应的<code>pendingPost</code>加入执行队列中.<code>HandlerPoster</code>继承于<code>Handler</code>, 根据他前面传入的Looper可以判定保证信息的执行是在主线程中做处理的, 现在我们看下<code>handleMessage</code>的处理<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> rescheduled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> started = SystemClock.uptimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                PendingPost pendingPost = queue.poll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (pendingPost == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// Check again, this time in synchronized</span></span><br><span class=\"line\">                        pendingPost = queue.poll();</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (pendingPost == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            handlerActive = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 调用订阅者</span></span><br><span class=\"line\">                eventBus.invokeSubscriber(pendingPost);</span><br><span class=\"line\">                <span class=\"keyword\">long</span> timeInMethod = SystemClock.uptimeMillis() - started;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(<span class=\"string\">\"Could not send handler message\"</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    rescheduled = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            handlerActive = rescheduled;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里做的处理, 主要就是调用了<code>EventBus</code>对象的<code>invokeSubscriber</code>方法, 最终走到了订阅者的方法的执行.<br>至于其他的几个线程模式, 查看对应的<code>POST</code>也可以大致知道他的原理, 这里就暂且不表了.</p>\n<h3 id=\"解绑\"><a href=\"#解绑\" class=\"headerlink\" title=\"解绑\"></a>解绑</h3><p>相对前面的, 其实解绑的逻辑就非常简单了, 我们先看代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 解绑</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"comment\">/** Unregisters the given subscriber from all event classes. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">unregister</span><span class=\"params\">(Object subscriber)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据订阅者获取对应的eventType</span></span><br><span class=\"line\">        List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class=\"line\">        <span class=\"comment\">// 如果不为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscribedTypes != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 遍历解绑</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class=\"line\">                unsubscribeByEventType(subscriber, eventType);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 移除相关的eventType</span></span><br><span class=\"line\">            typesBySubscriber.remove(subscriber);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            logger.log(Level.WARNING, <span class=\"string\">\"Subscriber to unregister was not registered before: \"</span> + subscriber.getClass());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们在绑定相关的解析中, 已经知道其实内部管理订阅事件和订阅者是通过<code>typesBySubscriber</code>和<code>subscriptionsByEventType</code>来实现的, 而这里就是移除掉与对应订阅者相关的对象即可.</p>"}],"PostAsset":[{"_id":"source/_posts/基于as3.0 多aar打包发布/demopic.png","slug":"demopic.png","post":"cjh7fldi700088os6z4iqergd","modified":0,"renderable":0},{"_id":"source/_posts/记录一次Gradle的踩坑/Gradle执行时序.png","slug":"Gradle执行时序.png","post":"cjh7fldi800098os6jb1259mf","modified":0,"renderable":0},{"_id":"source/_posts/谈谈GC和引用/gc.png","slug":"gc.png","post":"cjh7fldib000d8os6vj4y3erv","modified":0,"renderable":0},{"_id":"source/_posts/HashMap源码解析1/put.jpg","slug":"put.jpg","post":"cjh7fldnf00188os6vib7ej5c","modified":0,"renderable":0},{"_id":"source/_posts/RxJava2源码解析1/rxjava实现原理.jpg","slug":"rxjava实现原理.jpg","post":"cjh7fldng00198os6qkhf0alb","modified":0,"renderable":0},{"_id":"source/_posts/Glide源码解析1/decodeJob流程图.png","slug":"decodeJob流程图.png","post":"cjh7fldnc00168os66wenr26j","modified":0,"renderable":0},{"_id":"source/_posts/Glide源码解析1/glide_load时序图.png","slug":"glide_load时序图.png","post":"cjh7fldnc00168os66wenr26j","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjh7fldi700088os6z4iqergd","category_id":"cjh7fldi200048os6ehph868y","_id":"cjh7fldie000e8os604bj1ct0"},{"post_id":"cjh7fldhs00008os6cgwhvl8a","category_id":"cjh7fldi200048os6ehph868y","_id":"cjh7fldig000h8os699i011i5"},{"post_id":"cjh7fldhy00028os6cld9qaiu","category_id":"cjh7fldi9000a8os6a0avslaj","_id":"cjh7fldig000j8os6a7zd9kla"},{"post_id":"cjh7fldi400068os6gyku7acv","category_id":"cjh7fldi200048os6ehph868y","_id":"cjh7fldih000n8os63xr3a13f"},{"post_id":"cjh7fldi800098os6jb1259mf","category_id":"cjh7fldig000i8os6lt3w1zhz","_id":"cjh7fldii000q8os6dpmy07jf"},{"post_id":"cjh7fldib000d8os6vj4y3erv","category_id":"cjh7fldii000p8os6o3d0j9ei","_id":"cjh7fldij000u8os6x7b9sxjd"},{"post_id":"cjh7fldn900148os6tr0uvmbk","category_id":"cjh7fldi9000a8os6a0avslaj","_id":"cjh7fldni001b8os6sww6u1x3"},{"post_id":"cjh7fldnf00188os6vib7ej5c","category_id":"cjh7fldi9000a8os6a0avslaj","_id":"cjh7fldnk001g8os6095s25r3"},{"post_id":"cjh7fldng00198os6qkhf0alb","category_id":"cjh7fldi9000a8os6a0avslaj","_id":"cjh7fldnl001i8os63gr6t182"},{"post_id":"cjh7fldni001d8os6dgp9rgqh","category_id":"cjh7fldi9000a8os6a0avslaj","_id":"cjh7fldnm001k8os6kxwo5b8e"},{"post_id":"cjh7fldnc00168os66wenr26j","category_id":"cjh7fldi200048os6ehph868y","_id":"cjh7fldnm001m8os6dcowdabx"},{"post_id":"cjh7fldnc00168os66wenr26j","category_id":"cjh7fldnh001a8os6xyzldvde","_id":"cjh7fldnn001p8os61g6of42y"},{"post_id":"cjh7fldoo001v8os6tz9k5nn7","category_id":"cjh7fldi9000a8os6a0avslaj","_id":"cjh7fldoq001y8os69wxe57u5"}],"PostTag":[{"post_id":"cjh7fldhs00008os6cgwhvl8a","tag_id":"cjh7fldi300058os61u3hzpyd","_id":"cjh7fldib000c8os6brx0oklr"},{"post_id":"cjh7fldhy00028os6cld9qaiu","tag_id":"cjh7fldi300058os61u3hzpyd","_id":"cjh7fldih000l8os6wgaqsrf6"},{"post_id":"cjh7fldhy00028os6cld9qaiu","tag_id":"cjh7fldie000f8os6puizqsrd","_id":"cjh7fldih000m8os6vtkxgitq"},{"post_id":"cjh7fldi400068os6gyku7acv","tag_id":"cjh7fldi300058os61u3hzpyd","_id":"cjh7fldii000s8os6wzf4pt67"},{"post_id":"cjh7fldi400068os6gyku7acv","tag_id":"cjh7fldih000o8os66c0kcir5","_id":"cjh7fldij000t8os6sqdfu0v1"},{"post_id":"cjh7fldi700088os6z4iqergd","tag_id":"cjh7fldi300058os61u3hzpyd","_id":"cjh7fldik000w8os6emkdah71"},{"post_id":"cjh7fldi700088os6z4iqergd","tag_id":"cjh7fldii000r8os6muvbm0d0","_id":"cjh7fldil000x8os6cp9speop"},{"post_id":"cjh7fldi800098os6jb1259mf","tag_id":"cjh7fldi300058os61u3hzpyd","_id":"cjh7fldil000z8os6cntw88qw"},{"post_id":"cjh7fldi800098os6jb1259mf","tag_id":"cjh7fldii000r8os6muvbm0d0","_id":"cjh7fldil00108os6raaams43"},{"post_id":"cjh7fldib000d8os6vj4y3erv","tag_id":"cjh7fldil000y8os6mvg7kvy4","_id":"cjh7fldim00128os61yrfzcrg"},{"post_id":"cjh7fldib000d8os6vj4y3erv","tag_id":"cjh7fldil00118os6r6t1r2ya","_id":"cjh7fldim00138os6ktjnbo79"},{"post_id":"cjh7fldnf00188os6vib7ej5c","tag_id":"cjh7fldie000f8os6puizqsrd","_id":"cjh7fldni001c8os6peam30fl"},{"post_id":"cjh7fldn900148os6tr0uvmbk","tag_id":"cjh7fldne00178os6i6joteej","_id":"cjh7fldnk001f8os69tzr8v8h"},{"post_id":"cjh7fldn900148os6tr0uvmbk","tag_id":"cjh7fldie000f8os6puizqsrd","_id":"cjh7fldnl001h8os6mu0ds0xr"},{"post_id":"cjh7fldnc00168os66wenr26j","tag_id":"cjh7fldi300058os61u3hzpyd","_id":"cjh7fldnm001l8os6rt2zlr18"},{"post_id":"cjh7fldnc00168os66wenr26j","tag_id":"cjh7fldnj001e8os62dnpem9u","_id":"cjh7fldnm001n8os6io8rr174"},{"post_id":"cjh7fldnc00168os66wenr26j","tag_id":"cjh7fldie000f8os6puizqsrd","_id":"cjh7fldnn001q8os6zugpto9l"},{"post_id":"cjh7fldng00198os6qkhf0alb","tag_id":"cjh7fldie000f8os6puizqsrd","_id":"cjh7fldnn001r8os6lckdpqmt"},{"post_id":"cjh7fldng00198os6qkhf0alb","tag_id":"cjh7fldnl001j8os6o094j6fl","_id":"cjh7fldno001s8os6xla0u5fp"},{"post_id":"cjh7fldni001d8os6dgp9rgqh","tag_id":"cjh7fldie000f8os6puizqsrd","_id":"cjh7fldno001t8os61six1vvr"},{"post_id":"cjh7fldni001d8os6dgp9rgqh","tag_id":"cjh7fldnn001o8os6pmzlvc0m","_id":"cjh7fldno001u8os6i02zd2hi"},{"post_id":"cjh7fldoo001v8os6tz9k5nn7","tag_id":"cjh7fldi300058os61u3hzpyd","_id":"cjh7fldoq001w8os6sdac2uo4"},{"post_id":"cjh7fldoo001v8os6tz9k5nn7","tag_id":"cjh7fldie000f8os6puizqsrd","_id":"cjh7fldoq001x8os64w3emk3o"}],"Tag":[{"name":"android","_id":"cjh7fldi300058os61u3hzpyd"},{"name":"源码解析","_id":"cjh7fldie000f8os6puizqsrd"},{"name":"ObjectBox","_id":"cjh7fldih000o8os66c0kcir5"},{"name":"gradle","_id":"cjh7fldii000r8os6muvbm0d0"},{"name":"java","_id":"cjh7fldil000y8os6mvg7kvy4"},{"name":"JVM","_id":"cjh7fldil00118os6r6t1r2ya"},{"name":"Java","_id":"cjh7fldne00178os6i6joteej"},{"name":"Glide","_id":"cjh7fldnj001e8os62dnpem9u"},{"name":"RxJava2","_id":"cjh7fldnl001j8os6o094j6fl"},{"name":"rxJava2","_id":"cjh7fldnn001o8os6pmzlvc0m"}]}}