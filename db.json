{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"16816ad4d1a74e135669b20478b1971efcfab922","modified":1527730659415},{"_id":"themes/hexo-theme-next/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1525656449838},{"_id":"themes/hexo-theme-next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1525656044178},{"_id":"themes/hexo-theme-next/_config.yml","hash":"1736fcffb01473fc2ca0612c4dd25ef88d2becd8","modified":1526374396432},{"_id":"themes/hexo-theme-next/README.en.md","hash":"32d6cdfec1447f54aae1d7f1365ce6733dfcec8f","modified":1525656044178},{"_id":"themes/hexo-theme-next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1525656044178},{"_id":"themes/hexo-theme-next/bower.json","hash":"7d7938f9da896fe710aa0e9120140e528bf058df","modified":1525656044179},{"_id":"themes/hexo-theme-next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1525656044179},{"_id":"themes/hexo-theme-next/package.json","hash":"193dad6f59a588908fac082cc46fe067dac1b84d","modified":1525656044195},{"_id":"source/articles/index.md","hash":"85864ee480a5d845c4df9799d8f3224eda9bc9c0","modified":1525339458000},{"_id":"source/about/index.md","hash":"bec84ac07b18c2396cfe6a3f0eea6415fbe6a520","modified":1525339458000},{"_id":"source/_posts/.DS_Store","hash":"f4a0c7eda2e85192254e1a1c966e58ac2b1fe85d","modified":1535512866360},{"_id":"source/_posts/ARouter源码解析.md","hash":"025c21dfa775da4fa02e8eeb71b6b7b6017362a8","modified":1526629819860},{"_id":"source/_posts/AppPlugin源码解析.md","hash":"518b2094c98e307eaef4ceec097d75cbd8d731ec","modified":1531100216709},{"_id":"source/_posts/ArrayList源码解析.md","hash":"9b9a3097ddb99c5052513f923638dcef9c5d4d0f","modified":1525658660166},{"_id":"source/_posts/Enum的正确使用方式.md","hash":"58747020573c049c3bf80e357dd2f7eb04977977","modified":1525658527486},{"_id":"source/_posts/EventBus源码解析.md","hash":"1905b7f4ee18eb1f247712768e34cb120b018910","modified":1525658630325},{"_id":"source/_posts/Glide源码解析1.md","hash":"2c6d13b63117b18a940e64d09d7783e0cf4af7a6","modified":1526375093843},{"_id":"source/_posts/HashMap源码解析1.md","hash":"e4cdd8f61ab18aa77e2aa8c28e9929fd38753d8f","modified":1526375149049},{"_id":"source/_posts/Kotlin零散二三点.md","hash":"76b87b257cfe7baf519d7ad63a32619f3a787d76","modified":1527471747896},{"_id":"source/_posts/LruCache解析.md","hash":"17c6d33451e65118aac4007495cd12c45f57b371","modified":1525658575247},{"_id":"source/_posts/ObjectBox使用说明.md","hash":"430d7259f06b86754b405d1c616b85d6b53e77ba","modified":1525658488287},{"_id":"source/_posts/RxJava2源码解析1.md","hash":"eda3f628d9147d7382399f2d1d4b0ac4618c6605","modified":1526375177061},{"_id":"source/_posts/RxJava2源码解析2.md","hash":"ee4fd211dc56689ad22f760127ab181d479bd639","modified":1525658615090},{"_id":"source/_posts/okHttp源码解析(一).md","hash":"8b75d10d905c9963cb2f17bf2c40df1f15dabde9","modified":1534752550679},{"_id":"source/_posts/androidAPT.md","hash":"6db9aca89868c3d0a8a50b034496bc4cb268423a","modified":1526539830129},{"_id":"source/_posts/okHttp源码解析(二)-ConnectInterceptor.md","hash":"bde05ad8e7d685e5479fa5b28220bc616446adf4","modified":1535117833854},{"_id":"source/_posts/rxJabaObservableUML.gliffy","hash":"06888a960a2581a8a41bfb5956fa50a898597038","modified":1525339458000},{"_id":"source/_posts/基于as3.0 多aar打包发布.md","hash":"636ce54485c4294f6841a268948c0fef1f516e29","modified":1526375118715},{"_id":"source/_posts/记录一次Gradle的踩坑.md","hash":"2f6d36b393dcbf5a9e2600fe7fda1f1cf2c03bd9","modified":1526375273023},{"_id":"source/_posts/谈谈GC和引用.md","hash":"ed0cab824d306a9b7df1818653e1fc4b83b76e1a","modified":1526375132477},{"_id":"source/categories/index.md","hash":"6f83e5cdbd7bef76e96c7e540a316d94fc700a81","modified":1525339458000},{"_id":"source/tags/index.md","hash":"74c49f4cbdea1dbb28802eb8178c5cfff08c7f58","modified":1525339458000},{"_id":"themes/hexo-theme-next/scripts/merge-configs.js","hash":"13c8b3a2d9fce06c2488820d9248d190c8100e0a","modified":1525656044195},{"_id":"themes/hexo-theme-next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1525656044196},{"_id":"themes/hexo-theme-next/layout/_layout.swig","hash":"06b1eab2e00273e0b94bd32dc682bd92c1e0a747","modified":1525656044182},{"_id":"themes/hexo-theme-next/layout/archive.swig","hash":"383f64deab105724fd5512371963bd9e9aafbffd","modified":1525656044194},{"_id":"themes/hexo-theme-next/layout/index.swig","hash":"03e8a2cda03bad42ac0cb827025eb81f95d496a2","modified":1525656044194},{"_id":"themes/hexo-theme-next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1525656044194},{"_id":"themes/hexo-theme-next/layout/page.swig","hash":"37c874cd720acf0eda8d26e063278f2b6ae8d3a6","modified":1525656044194},{"_id":"themes/hexo-theme-next/layout/post.swig","hash":"2d5f8d7f0a96b611e2d5a5e4d111fc17726a990f","modified":1525656044195},{"_id":"themes/hexo-theme-next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1525656044195},{"_id":"themes/hexo-theme-next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1525656044195},{"_id":"themes/hexo-theme-next/languages/de.yml","hash":"306db8c865630f32c6b6260ade9d3209fbec8011","modified":1525656044179},{"_id":"themes/hexo-theme-next/languages/default.yml","hash":"4cc6aeb1ac09a58330e494c8771773758ab354af","modified":1525656044179},{"_id":"themes/hexo-theme-next/languages/en.yml","hash":"e7def07a709ef55684490b700a06998c67f35f39","modified":1525656044179},{"_id":"themes/hexo-theme-next/languages/fr-FR.yml","hash":"24180322c83587a153cea110e74e96eacc3355ad","modified":1525656044180},{"_id":"themes/hexo-theme-next/languages/id.yml","hash":"2835ea80dadf093fcf47edd957680973f1fb6b85","modified":1525656044180},{"_id":"themes/hexo-theme-next/languages/ja.yml","hash":"1c3a05ab80a6f8be63268b66da6f19da7aa2c638","modified":1525656044180},{"_id":"themes/hexo-theme-next/languages/ko.yml","hash":"be150543379150f78329815af427bf152c0e9431","modified":1525656044180},{"_id":"themes/hexo-theme-next/languages/pt-BR.yml","hash":"958e49571818a34fdf4af3232a07a024050f8f4e","modified":1525656044180},{"_id":"themes/hexo-theme-next/languages/pt.yml","hash":"36c8f60dacbe5d27d84d0e0d6974d7679f928da0","modified":1525656044181},{"_id":"themes/hexo-theme-next/languages/ru.yml","hash":"1549a7c2fe23caa7cbedcd0aa2b77c46e57caf27","modified":1525656044181},{"_id":"themes/hexo-theme-next/languages/zh-Hans.yml","hash":"3c0c7dfd0256457ee24df9e9879226c58cb084b5","modified":1525656044181},{"_id":"themes/hexo-theme-next/languages/zh-tw.yml","hash":"0b2c18aa76570364003c8d1cd429fa158ae89022","modified":1525656044181},{"_id":"themes/hexo-theme-next/languages/zh-hk.yml","hash":"1c917997413bf566cb79e0975789f3c9c9128ccd","modified":1525656044181},{"_id":"themes/hexo-theme-next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1525656044265},{"_id":"themes/hexo-theme-next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1525656044266},{"_id":"themes/hexo-theme-next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1525656044266},{"_id":"themes/hexo-theme-next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525656044219},{"_id":"source/_posts/Glide源码解析1/decodeJob流程图.png","hash":"94e8007884a6c7665346a2b4ce8d3f337ed25643","modified":1525339458000},{"_id":"source/_posts/Kotlin零散二三点/let.png","hash":"f1ccd285fde122c2f7263db00ffd41fb0fc56c3a","modified":1527235595433},{"_id":"source/_posts/Kotlin零散二三点/Kotlin.png","hash":"7d54c92b163cf5bae58f2f5d7f6d99d070831504","modified":1527221167916},{"_id":"source/_posts/RxJava2源码解析1/rxjava实现原理.jpg","hash":"5704e8dbad45c042049d4da9dc04177858b06c1e","modified":1525339458000},{"_id":"source/_posts/okHttp源码解析(一)/requestbuilder.png","hash":"4c33b2655e5425ef6a950766d1b04086ed9dd7d7","modified":1534490177918},{"_id":"source/_posts/基于as3.0 多aar打包发布/demopic.png","hash":"e4c624d006f5175998336f58677f815a12a665d4","modified":1525339458000},{"_id":"source/_posts/谈谈GC和引用/gc.png","hash":"61470a0acc9eda5281d68579701600200e7171a6","modified":1525339458000},{"_id":"themes/hexo-theme-next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1525656044196},{"_id":"themes/hexo-theme-next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1525656044196},{"_id":"themes/hexo-theme-next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1525656044196},{"_id":"themes/hexo-theme-next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1525656044196},{"_id":"themes/hexo-theme-next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1525656044197},{"_id":"themes/hexo-theme-next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1525656044197},{"_id":"themes/hexo-theme-next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1525656044197},{"_id":"themes/hexo-theme-next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1525656044197},{"_id":"themes/hexo-theme-next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1525656044197},{"_id":"themes/hexo-theme-next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1525656044182},{"_id":"themes/hexo-theme-next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1525656044182},{"_id":"themes/hexo-theme-next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1525656044182},{"_id":"themes/hexo-theme-next/layout/_macro/post-copyright.swig","hash":"53d4f83b2b7fb4387dfc9fe81519abd56fbce4ae","modified":1525656044182},{"_id":"themes/hexo-theme-next/layout/_macro/reward.swig","hash":"5d5f70deb6074cb4dd0438463e14ccf89213c282","modified":1525656044183},{"_id":"themes/hexo-theme-next/layout/_macro/sidebar.swig","hash":"faa7886ccf986890cd776f4e9d70cb89fe9fda5f","modified":1525656044183},{"_id":"themes/hexo-theme-next/layout/_macro/post.swig","hash":"911363776867d9523a3e322cdf591d49cd166403","modified":1525656044183},{"_id":"themes/hexo-theme-next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1525656044184},{"_id":"themes/hexo-theme-next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1525656044187},{"_id":"themes/hexo-theme-next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1525656044187},{"_id":"themes/hexo-theme-next/layout/_scripts/vendors.swig","hash":"9baf90f7c40b3b10f288e9268c3191e895890cea","modified":1525656044188},{"_id":"themes/hexo-theme-next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1525656044192},{"_id":"themes/hexo-theme-next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1525656044192},{"_id":"themes/hexo-theme-next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1525656044192},{"_id":"themes/hexo-theme-next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1525656044192},{"_id":"themes/hexo-theme-next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1525656044192},{"_id":"themes/hexo-theme-next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1525656044192},{"_id":"themes/hexo-theme-next/layout/_partials/comments.swig","hash":"ce7094ee05878161e7568a6dfae5b56ff3fbd6e1","modified":1525656044184},{"_id":"themes/hexo-theme-next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1525656044184},{"_id":"themes/hexo-theme-next/layout/_partials/head.swig","hash":"1f14d3f494b2dbbcee802fd6f6d1abd5b7e2304c","modified":1525656044184},{"_id":"themes/hexo-theme-next/layout/_partials/header.swig","hash":"a1ffbb691dfad3eaf2832a11766e58a179003b8b","modified":1525656044185},{"_id":"themes/hexo-theme-next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1525656044185},{"_id":"themes/hexo-theme-next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1525656044185},{"_id":"themes/hexo-theme-next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1525656044185},{"_id":"themes/hexo-theme-next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1525656044219},{"_id":"themes/hexo-theme-next/source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1525660230435},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1525656044219},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1525656044220},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1525656044220},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1525656044220},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1525656044220},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1525656044221},{"_id":"themes/hexo-theme-next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1525656044221},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1525656044221},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1525656044221},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1525656044221},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1525656044221},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1525656044221},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1525656044222},{"_id":"source/_posts/Glide源码解析1/glide_load时序图.png","hash":"e8d305accaf9a949f5859ed55ef15212fc640c06","modified":1525339458000},{"_id":"source/_posts/HashMap源码解析1/put.jpg","hash":"9db130504f10a1da8867c3f48e95ef44d1529901","modified":1525339458000},{"_id":"source/_posts/记录一次Gradle的踩坑/Gradle执行时序.png","hash":"86d3af61eaf327aa2d0860abf7ee7b41b6a3ad9f","modified":1526366866281},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525656044188},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525656044188},{"_id":"themes/hexo-theme-next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525656044212},{"_id":"themes/hexo-theme-next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525656044212},{"_id":"themes/hexo-theme-next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525656044213},{"_id":"themes/hexo-theme-next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525656044218},{"_id":"themes/hexo-theme-next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525656044219},{"_id":"themes/hexo-theme-next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1525656044187},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1525656044188},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1525656044188},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1525656044189},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1525656044189},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1525656044189},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1525656044189},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1525656044189},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1525656044189},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/index.swig","hash":"3358d11b9a26185a2d36c96049e4340e701646e4","modified":1525656044190},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1525656044190},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1525656044190},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1525656044190},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1525656044190},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1525656044191},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1525656044191},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1525656044191},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1525656044191},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/index.swig","hash":"ee63aa2e49507b884a2d56778479cf01c723d751","modified":1525656044191},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1525656044191},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1525656044191},{"_id":"themes/hexo-theme-next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1525656044193},{"_id":"themes/hexo-theme-next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1525656044193},{"_id":"themes/hexo-theme-next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1525656044193},{"_id":"themes/hexo-theme-next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1525656044194},{"_id":"themes/hexo-theme-next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1525656044184},{"_id":"themes/hexo-theme-next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1525656044185},{"_id":"themes/hexo-theme-next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1525656044186},{"_id":"themes/hexo-theme-next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1525656044186},{"_id":"themes/hexo-theme-next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1525656044186},{"_id":"themes/hexo-theme-next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1525656044186},{"_id":"themes/hexo-theme-next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1525656044186},{"_id":"themes/hexo-theme-next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1525656044187},{"_id":"themes/hexo-theme-next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1525656044187},{"_id":"themes/hexo-theme-next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1525656044211},{"_id":"themes/hexo-theme-next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1525656044212},{"_id":"themes/hexo-theme-next/source/css/_mixins/Pisces.styl","hash":"eaedfaf06dae94ba77a8f4893e2e434bf8859bac","modified":1525656044212},{"_id":"themes/hexo-theme-next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1525656044212},{"_id":"themes/hexo-theme-next/source/css/_variables/Gemini.styl","hash":"49b5210fa62d6cbc6a98f57d89d5067a06ab3561","modified":1525656044218},{"_id":"themes/hexo-theme-next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1525656044218},{"_id":"themes/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"cfee25d790e4f9b7d57f0dc7e2ea9c1649f08f11","modified":1525656044218},{"_id":"themes/hexo-theme-next/source/css/_variables/base.styl","hash":"d477196c5699c8261b08e993a77ef67054d86166","modified":1525656044219},{"_id":"themes/hexo-theme-next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1525656044222},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","hash":"6117f97b4984b8e33f21c726132da64ba678e4ed","modified":1525656044222},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1525656044222},{"_id":"themes/hexo-theme-next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1525656044222},{"_id":"themes/hexo-theme-next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1525656044223},{"_id":"themes/hexo-theme-next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1525656044223},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","hash":"0693695a9512641daff63d99da772625a058ab18","modified":1525656044223},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","hash":"dc0365b2fb315a8b43d3ef19b59d3a82a366fcc1","modified":1525656044223},{"_id":"themes/hexo-theme-next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1525656044223},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1525656044224},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","hash":"2917c39c75b14b6dab7e1c46ab4d87b4df9fcd5d","modified":1525656044224},{"_id":"themes/hexo-theme-next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1525656044230},{"_id":"themes/hexo-theme-next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1525656044230},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1525656044227},{"_id":"themes/hexo-theme-next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1525656044230},{"_id":"themes/hexo-theme-next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1525656044230},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1525656044248},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1525656044248},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1525656044248},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1525656044248},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1525656044249},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1525656044248},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1525656044237},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1525656044237},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1525656044237},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1525656044237},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1525656044237},{"_id":"themes/hexo-theme-next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1525656044247},{"_id":"themes/hexo-theme-next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1525656044236},{"_id":"themes/hexo-theme-next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1525656044235},{"_id":"themes/hexo-theme-next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1525656044235},{"_id":"themes/hexo-theme-next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1525656044236},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1525656044253},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1525656044254},{"_id":"themes/hexo-theme-next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1525656044254},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1525656044249},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1525656044249},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1525656044250},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1525656044249},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1525656044249},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1525656044251},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1525656044250},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1525656044250},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1525656044251},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1525656044251},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1525656044252},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1525656044251},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1525656044252},{"_id":"themes/hexo-theme-next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1525656044252},{"_id":"themes/hexo-theme-next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1525656044260},{"_id":"themes/hexo-theme-next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1525656044261},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1525656044265},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1525656044264},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1525656044264},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1525656044247},{"_id":"themes/hexo-theme-next/source/images/avatar.png","hash":"e236f5447b379b018c625567084ce85658277e00","modified":1525657431411},{"_id":"themes/hexo-theme-next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1525656044193},{"_id":"themes/hexo-theme-next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1525656044193},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top-sidebar.styl","hash":"d026c8489f66ab6c12ad04bd37f1d5b6f2f3f0d1","modified":1525656044198},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1525656044198},{"_id":"themes/hexo-theme-next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1525656044198},{"_id":"themes/hexo-theme-next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1525656044198},{"_id":"themes/hexo-theme-next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1525656044198},{"_id":"themes/hexo-theme-next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1525656044201},{"_id":"themes/hexo-theme-next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1525656044206},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"2915df7152ea095a6290ef69157fd67669e0e793","modified":1525656044210},{"_id":"themes/hexo-theme-next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1525656044209},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1525656044210},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/mobile.styl","hash":"86b6fd7f1b1be3ae98f8af6b23a6b1299c670ce9","modified":1525656044210},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1525656044211},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1525656044211},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1525656044211},{"_id":"themes/hexo-theme-next/source/css/_schemes/Gemini/index.styl","hash":"bc8c388553bbcf95897459a466ba35bffd5ec5f0","modified":1525656044213},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1525656044213},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1525656044214},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1525656044214},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1525656044214},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1525656044214},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1525656044214},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1525656044215},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1525656044216},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1525656044216},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1525656044216},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1525656044216},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1525656044217},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1525656044217},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1525656044217},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1525656044217},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1525656044217},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e3e23751d4ad24e8714b425d768cf68e37de7ded","modified":1525656044218},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1525656044218},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1525656044223},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1525656044225},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1525656044227},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1525656044226},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1525656044230},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1525656044231},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1525656044231},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1525656044231},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1525656044231},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1525656044231},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1525656044233},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1525656044234},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1525656044235},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1525656044238},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1525656044238},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1525656044238},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1525656044236},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1525656044236},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1525656044260},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1525656044260},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1525656044226},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1525656044246},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1525656044246},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1525656044263},{"_id":"themes/hexo-theme-next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1525656044199},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1525656044200},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/highlight.styl","hash":"740d37f428b8f4574a76fc95cc25e50e0565f45e","modified":1525656044200},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1525656044200},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1525656044199},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1525656044199},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1525656044199},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1525656044199},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1525656044199},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1525656044201},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1525656044200},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1525656044200},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1525656044201},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1525656044201},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1525656044201},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1525656044202},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1525656044201},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-expand.styl","hash":"88c7d75646b66b168213190ee4cd874609afd5e3","modified":1525656044202},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1525656044202},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1525656044202},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-meta.styl","hash":"ed88c8b51d0517759c777e71a6bfbe2907bcd994","modified":1525656044202},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1525656044202},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"ee554b1031ef0070a5916477939021800e3c9d27","modified":1525656044203},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1525656044203},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1525656044203},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1525656044203},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1525656044203},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-widgets.styl","hash":"08a500b2984f109b751f3697ca33172d1340591a","modified":1525656044204},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-wordcount.styl","hash":"4fda5d38c6c8d910e3bf5c74a48a8d4a3f3dc73d","modified":1525656044204},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post.styl","hash":"51eca243220cf57133a4becae9b78514bcfdc723","modified":1525656044204},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"65a64d5662637b66e2f039a5f58217afe7a6e800","modified":1525656044204},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1525656044204},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1525656044205},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1525656044205},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"5f6ea57aabfa30a437059bf8352f1ad829dbd4ff","modified":1525656044204},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1525656044205},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"77c92a449ce84d558d26d052681f2e0dd77c70c9","modified":1525656044205},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1525656044205},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar.styl","hash":"57d2c8a060f5e4e1a0aef9aae11a0016cf7ac5ba","modified":1525656044206},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1525656044206},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1525656044206},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1525656044206},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1525656044206},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1525656044207},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1525656044207},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1525656044207},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note-modern.styl","hash":"45df0cf4c97b47e05573bcd41028ee50f3fdf432","modified":1525656044207},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1525656044207},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1525656044207},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1525656044208},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1525656044208},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1525656044208},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1525656044208},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1525656044209},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1525656044209},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1525656044209},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/third-party.styl","hash":"aeff0e6e23725e8baea27c890ccbbf466024f767","modified":1525656044209},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1525656044215},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1525656044215},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1525656044217},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1525656044224},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1525656044225},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1525656044225},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1525656044225},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1525656044232},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1525656044232},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1525656044232},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1525656044233},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1525656044233},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1525656044232},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1525656044239},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1525656044241},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1525656044246},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1525656044229},{"_id":"themes/hexo-theme-next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1525656044259},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1525656044244},{"_id":"public/atom.xml","hash":"d6b43bb14e33340d9cbdf4be2e897a92ae677e05","modified":1535546224168},{"_id":"public/sitemap.xml","hash":"b9d72b3a90c1416b6a2931988690e90941d277cb","modified":1535546224183},{"_id":"public/articles/index.html","hash":"ca343886e47dd525eb973be310652d721135e924","modified":1535546224256},{"_id":"public/about/index.html","hash":"0bd000d2494e2fd618fc9816c07dd20d171c1e2c","modified":1535546224256},{"_id":"public/categories/index.html","hash":"df172621662baa133e2cc6a377aca898d77d5361","modified":1535546224256},{"_id":"public/tags/index.html","hash":"bc83250957cbba8b2b15fcf721a7163b41f85625","modified":1535546224256},{"_id":"public/archives/2017/index.html","hash":"1bbdb1e12fe8d64fe2e5e742fbde4c976291d157","modified":1535546224257},{"_id":"public/archives/2017/12/index.html","hash":"88a56bc4189b04e4d15419f72173924336c30998","modified":1535546224257},{"_id":"public/archives/2018/01/index.html","hash":"475bb482bec110eb7d4e60ef3e9c93433b53fd87","modified":1535546224257},{"_id":"public/archives/2018/02/index.html","hash":"c44a0e6a870399e3264efcf2ea7217d7f458d5b0","modified":1535546224257},{"_id":"public/archives/2018/03/index.html","hash":"959c95510ba5e87311831cf70dfbf8cf698db566","modified":1535546224257},{"_id":"public/archives/2018/04/index.html","hash":"01aefc015006d8c4a4761d49987802a9c1e7c084","modified":1535546224257},{"_id":"public/archives/2018/05/index.html","hash":"d8aedb73499a83b90f921ffff8b55e40ec1ebf32","modified":1535546224258},{"_id":"public/archives/2018/07/index.html","hash":"978665e4827ea9d44cd20b47f580e7a2e2e4c664","modified":1535546224258},{"_id":"public/archives/2018/08/index.html","hash":"2e5b5ad09cafedbe3fde631d4fd3de6527a16bc7","modified":1535546224258},{"_id":"public/categories/android学习记录/index.html","hash":"a64dbfa164fc2f01a567eaf2f91b779b120c3a23","modified":1535546224256},{"_id":"public/categories/源码解析/page/2/index.html","hash":"13db8dae8ce0d427e5f68dd0307a0e74ec41798f","modified":1535546224256},{"_id":"public/categories/日常开发踩坑记录/index.html","hash":"da9be9c853f33e28ea415419a6e9189e5913b81b","modified":1535546224257},{"_id":"public/categories/java/index.html","hash":"dcab95157fd2bec9b9aa67638a19c517266fd807","modified":1535546224257},{"_id":"public/categories/android学习记录/源码解析/index.html","hash":"0b724743111bd9847a3a8fdf54d128784b8a5f58","modified":1535546224257},{"_id":"public/categories/kotlin/index.html","hash":"28a4e539e4dc3c2f84fc3b4eabb4df56e0b3f617","modified":1535546224257},{"_id":"public/tags/android/index.html","hash":"18d306227aff6a1de60f06a7b5908a5cc4171ef1","modified":1535546224258},{"_id":"public/tags/android/page/2/index.html","hash":"ca1a0443dd755ccf3b97a6fc745b08978fd34ed2","modified":1535546224258},{"_id":"public/tags/源码解析/page/2/index.html","hash":"c0552334b3dfeb176006a50a89aa94a8119c0133","modified":1535546224258},{"_id":"public/tags/objectbox/index.html","hash":"6c2460449d699f0fb4732d78658a1ab3bbb0f211","modified":1535546224258},{"_id":"public/tags/apt/index.html","hash":"033a79a38b692b978de0ccfc3ad90352f0a699b3","modified":1535546224258},{"_id":"public/tags/gradle/index.html","hash":"d886158f179e4ea412053a78edc9c238b9a127e5","modified":1535546224258},{"_id":"public/tags/java/index.html","hash":"8eefec8f880b92f60eeaaa1b65c29c9b7165f04f","modified":1535546224258},{"_id":"public/tags/jvm/index.html","hash":"db24fc669136935ab076168749dfedc922a86972","modified":1535546224258},{"_id":"public/tags/glide/index.html","hash":"594d32c0b5cbc1c276244311e44dc8911e41a276","modified":1535546224258},{"_id":"public/tags/kotlin/index.html","hash":"41bd5309901490a87539bd6eb06e384e6a75736d","modified":1535546224259},{"_id":"public/tags/rxjava2/index.html","hash":"c7e35d14f0de62dc6e3f391e7ac7cb4b3dcb285e","modified":1535546224259},{"_id":"public/tags/okhttp3/index.html","hash":"7f6d5d083c22dbb608f6e26405a4f5b923578b28","modified":1535546224259},{"_id":"public/2018/08/24/okHttp源码解析(二)-ConnectInterceptor/index.html","hash":"755e4bc8f51a96af433916d19f1499ddd86c8bba","modified":1535546224259},{"_id":"public/2018/08/20/okHttp源码解析(一)/index.html","hash":"821ef7c1c8e972953580a4a9443e0826bace4fc8","modified":1535546224259},{"_id":"public/2018/07/06/AppPlugin源码解析/index.html","hash":"455abc2fe0406ea103d93551bf8c507c40f6d389","modified":1535546224259},{"_id":"public/2018/05/25/Kotlin零散二三点/index.html","hash":"7875463d8d0e789bfb7a53ea9bcde6e557d04ff2","modified":1535546224259},{"_id":"public/2018/05/18/ARouter源码解析/index.html","hash":"e54437a30c88d8582ea0c1087cce155df7108a9b","modified":1535546224259},{"_id":"public/2018/05/17/androidAPT/index.html","hash":"75a7a7d15a4613b7ba3b738136c24098b3a87484","modified":1535546224259},{"_id":"public/2018/05/15/记录一次Gradle的踩坑/index.html","hash":"185e08ed00f0973c7106575eb48abe182a8ee1d3","modified":1535546224259},{"_id":"public/2018/04/26/ArrayList源码解析/index.html","hash":"dffd7a396b253d365e215953947c035091216596","modified":1535546224259},{"_id":"public/2018/03/30/EventBus源码解析/index.html","hash":"be379ec24dbaa50cf5912b5f5d375bff486e8e91","modified":1535546224260},{"_id":"public/2018/02/08/RxJava2源码解析2/index.html","hash":"ce568cf2ce8c939ba43a400aa2ea92d962306cb5","modified":1535546224260},{"_id":"public/2018/02/07/RxJava2源码解析1/index.html","hash":"f1f0100e9bdf9392162f6cd42be22f53899752bf","modified":1535546224260},{"_id":"public/2018/02/02/HashMap源码解析1/index.html","hash":"ef7de753776cd2414ce8f25a8ccb4d695adeb78f","modified":1535546224260},{"_id":"public/2018/01/31/LruCache解析/index.html","hash":"a74edc26ea029fb32f937430e549393386064eb8","modified":1535546224260},{"_id":"public/2018/01/12/谈谈GC和引用/index.html","hash":"142f63f2d8b7f4fedf1ce4b644aceb8971e08d24","modified":1535546224260},{"_id":"public/2017/12/26/Enum的正确使用方式/index.html","hash":"e410f8e87e0cfb9b735ed27243302248303a1f6f","modified":1535546224261},{"_id":"public/2017/12/22/Glide源码解析1/index.html","hash":"bebaa61a8152361efc728febb7620a3a4db07223","modified":1535546224261},{"_id":"public/2017/12/19/基于as3.0 多aar打包发布/index.html","hash":"bdb818c0b42e702ef0cad59e87919cc85da71b75","modified":1535546224261},{"_id":"public/2017/12/19/ObjectBox使用说明/index.html","hash":"7ed7bd23b71a2a0e11b2afdd31bd367c2316c54b","modified":1535546224261},{"_id":"public/archives/index.html","hash":"61f3bf73c96df425bc0b2ba3508deedaa695e96b","modified":1535546224261},{"_id":"public/archives/2018/index.html","hash":"35a8be78c6230d2689a546a529cab65654e17513","modified":1535546224261},{"_id":"public/categories/源码解析/index.html","hash":"873f9be1908eec24ab0414c0668e5c9d2b7cb9b5","modified":1535546224261},{"_id":"public/index.html","hash":"c5cd3df6d1a9ea6a3854ecf42c819f47df369951","modified":1535546224261},{"_id":"public/page/2/index.html","hash":"831e93da43ff546293c11155ba1651162b5d6437","modified":1535546224262},{"_id":"public/page/3/index.html","hash":"f8c07577f5590289100c1c71ac072b0e2241c99c","modified":1535546224262},{"_id":"public/tags/源码解析/index.html","hash":"d618855f6ff656b3ef35c54e512edc39c66c03f3","modified":1535546224262},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1535426497998},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1535426497998},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1535426497998},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1535426497999},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1535426497999},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1535426497999},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1535426497999},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1535426497999},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1535426497999},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1535426497999},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1535426497999},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1535426498000},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1535426498000},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1535426498000},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1535426498000},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1535426498000},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1535426498000},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1535426498000},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1535426498001},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1535426498001},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1535426498001},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1535426498001},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1535426498001},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1535426498001},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1535426498001},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1535426498002},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1535426498002},{"_id":"public/2017/12/19/基于as3.0 多aar打包发布/demopic.png","hash":"e4c624d006f5175998336f58677f815a12a665d4","modified":1535426498002},{"_id":"public/2018/01/12/谈谈GC和引用/gc.png","hash":"61470a0acc9eda5281d68579701600200e7171a6","modified":1535426498002},{"_id":"public/2018/02/07/RxJava2源码解析1/rxjava实现原理.jpg","hash":"5704e8dbad45c042049d4da9dc04177858b06c1e","modified":1535426498002},{"_id":"public/2018/08/20/okHttp源码解析(一)/requestbuilder.png","hash":"4c33b2655e5425ef6a950766d1b04086ed9dd7d7","modified":1535426498002},{"_id":"public/2017/12/22/Glide源码解析1/decodeJob流程图.png","hash":"94e8007884a6c7665346a2b4ce8d3f337ed25643","modified":1535426498002},{"_id":"public/2018/05/25/Kotlin零散二三点/let.png","hash":"f1ccd285fde122c2f7263db00ffd41fb0fc56c3a","modified":1535426498002},{"_id":"public/2018/05/25/Kotlin零散二三点/Kotlin.png","hash":"7d54c92b163cf5bae58f2f5d7f6d99d070831504","modified":1535426498003},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1535426498550},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1535426498578},{"_id":"public/2018/05/15/记录一次Gradle的踩坑/Gradle执行时序.png","hash":"86d3af61eaf327aa2d0860abf7ee7b41b6a3ad9f","modified":1535426498579},{"_id":"public/2018/02/02/HashMap源码解析1/put.jpg","hash":"9db130504f10a1da8867c3f48e95ef44d1529901","modified":1535426498579},{"_id":"public/2017/12/22/Glide源码解析1/glide_load时序图.png","hash":"e8d305accaf9a949f5859ed55ef15212fc640c06","modified":1535426498579},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1535426498665},{"_id":"public/js/src/bootstrap.js","hash":"6117f97b4984b8e33f21c726132da64ba678e4ed","modified":1535426498665},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1535426498675},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1535426498675},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1535426498676},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1535426498676},{"_id":"public/js/src/post-details.js","hash":"0693695a9512641daff63d99da772625a058ab18","modified":1535426498676},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1535426498677},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1535426498677},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1535426498677},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1535426498677},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1535426498677},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1535426498677},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1535426498677},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1535426498677},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1535426498677},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1535426498677},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1535426498677},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1535426498678},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1535426498678},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1535426498678},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1535426498678},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1535426498678},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1535426498678},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1535426498680},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1535426498680},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1535426498680},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1535426498681},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1535426498681},{"_id":"public/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1535426498681},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1535426498682},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1535426498689},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1535426498690},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1535426498690},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1535426498690},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1535426498690},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1535426498690},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1535426498690},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1535426498690},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1535426498691},{"_id":"public/css/main.css","hash":"0fcb4117413b228640ac0e3c9ad44416da498098","modified":1535426498691},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1535426498691},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1535426498692},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1535426498692},{"_id":"public/js/src/motion.js","hash":"dc0365b2fb315a8b43d3ef19b59d3a82a366fcc1","modified":1535426498833},{"_id":"public/js/src/utils.js","hash":"2917c39c75b14b6dab7e1c46ab4d87b4df9fcd5d","modified":1535426498834},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1535426498836},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1535426498836},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1535426498836},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1535426498836},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1535426498836},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1535426498837},{"_id":"public/images/avatar.png","hash":"e236f5447b379b018c625567084ce85658277e00","modified":1535426498837},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1535426498846},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1535426498861},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1535426498862},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1535426498909},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1535426498909},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1535426498910},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1535426498914},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1535426498914},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1535426498915},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1535426498915},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1535426498915},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1535426499004},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1535426499004},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1535426499026},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1535426499050},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1535426499057},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1535426499062},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1535426499076},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1535426499087},{"_id":"source/_posts/OkHttp源码解析(三)-CallServerInterceptor.md","hash":"e41d0abc621c345c443a204c200733bdc479f6c0","modified":1535546206418},{"_id":"public/2018/08/29/OkHttp源码解析(三)-CallServerInterceptor/index.html","hash":"1a1042cf09cd03f48c386e7d2fcb196d9afd99fe","modified":1535546224265}],"Category":[{"name":"android学习记录","_id":"cjld5agvb0004cqs6akdxw7zv"},{"name":"源码解析","_id":"cjld5agvj000bcqs6iiogr0xv"},{"name":"日常开发踩坑记录","_id":"cjld5agvu000lcqs6o398exjd"},{"name":"Java","_id":"cjld5agvx000scqs695xomylw"},{"name":"源码解析","parent":"cjld5agvb0004cqs6akdxw7zv","_id":"cjld5ah2v001fcqs6utybz8b4"},{"name":"kotlin","_id":"cjld5ah33001ncqs6uyv5510g"}],"Data":[],"Page":[{"title":"Articles","date":"2017-12-19T02:47:25.000Z","comments":0,"_content":"","source":"articles/index.md","raw":"---\ntitle: Articles\ndate: 2017-12-19 10:47:25\ncomments: false\n---\n","updated":"2018-05-03T09:24:18.000Z","path":"articles/index.html","layout":"page","_id":"cjld5aguw0000cqs6zo1euhdi","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于","date":"2017-12-19T02:49:32.000Z","comments":0,"_content":"","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2017-12-19 10:49:32\ncomments: false\n---\n","updated":"2018-05-03T09:24:18.000Z","path":"about/index.html","layout":"page","_id":"cjld5agv60002cqs6o2nizoq0","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分类","date":"2017-12-22T11:36:02.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2017-12-22 19:36:02\ntype: \"categories\"\ncomments: false\n---\n","updated":"2018-05-03T09:24:18.000Z","path":"categories/index.html","layout":"page","_id":"cjld5agvd0006cqs6pjcunbj3","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2017-12-19T08:10:18.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2017-12-19 16:10:18\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-05-03T09:24:18.000Z","path":"tags/index.html","layout":"page","_id":"cjld5agvf0008cqs63tsgjqeb","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Enum的正确使用方式","date":"2017-12-25T16:00:00.000Z","_content":"## 前言\n\n看到目前项目里用到蛮多枚举, 才有了这篇小文章分享\n\n## 为什么使用Enum\n\njava中的Enum是包含固定常量集的数据类型.当我们需要预定义一组代表某种数据的值时一般都会使用枚举, 而当要保证类型安全时, 我们经常会使用Enum。\n\n比如, 当我们要保证常量使用正常时, 我们经常使用Enum在编译时校验确保类型安全\n<!-- more -->\n\n## 使用Enum的缺点\n\n在[Android开发者官网](https://developer.android.com/topic/performance/memory.html?hl=zh-cn)上, 有这样一段话\n\n> enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.\n\nEnum中的每个值都是一个对象,每个声明都将使用一些运行时内存来简单引用该对象,所以Enum相较于static int会`占用更多的内存`.\n\n另外添加单个Enum将`增加最终DEX文件的大小`（是static int的**13**倍）.\n\n## 解决方案\n\nGoogle提供了[注解库](https://developer.android.com/studio/write/annotations.html#enum-annotations)通过`Typedef`协助我们解决了Enum的问题,它可以确保特定参数, 返回值或字段引用特定的常量集,还可以完成代码以自动提供允许的常量.\n\n我们可以通过使用`@IntDef`和`@StringDef`来帮助我们在编译时检查像Enum这项的变量赋值.\n\n## 使用姿势\n1. 首先我们需要依赖注解库\n``` groovy\ndependencies {compile 'com.android.support:support-annotations:24.2.0'}\n```\n2. 直接上代码了, 因为还是蛮简单的\n``` java\npublic class Person {\n        public static final int MALE = 0;\n        public static final int FEMALE = 1;\n        private  int sex;\n        public String getSexValue(){\n            if(MALE == sex){\n                return \"男\";\n            }else if(FEMALE == sex){\n                return \"女\";\n            }\n            return \"\";\n        }\n        public void setSex(@sexDef int sex) {\n            this.sex = sex;\n        }\n        //  定义该注解被保留的时间长短\n        //  RetentionPolicy.CLASS      注解被保留到class文件, 但jvm加载class文件时候被遗弃, 这是默认生命周期; 用于在编译时进行一些预处理操作, 比如生成一些辅助代码(ButterKnife)\n        //  RetentionPolicy.RUNTIME    注解不仅被保存到class文件中, jvm加载class文件之后, 仍然存在;用于在运行时去动态获取注解信息\n        //  RetentionPolicy.SOURCE      注解只保留在源文件, 当Java文件编译成class文件的时候, 注解被遗弃; 用于做一些检查性操作\n        @Retention(RetentionPolicy.SOURCE)\n        //  使用@IntDef定义声明常量作为枚举\n        @IntDef({MALE, FEMALE})\n        //  使用@interface声明新的枚举注解类型\n        public @interface sexDef{}\n    }\n```\n3. 当我们调用setSex设置性别的时候, 如果输入非指定类型, 则编译不会通过\n\n## 总结\n\n与普通static常量相比, Enum的使用至少为整个apk添加至少两倍以上的字节数，并且使用5到10倍的RAM内存。所以建议尽量避免使用Enum, 当需要使用上述特性时,建议以@IntDef 或 @StringDef 替代使用。\n\n更多的可以看看[The price of ENUMs][https://www.youtube.com/watch?v=Hzs6OBcvNQE&feature=youtu.be]视频, 需科学上网\n","source":"_posts/Enum的正确使用方式.md","raw":"title: Enum的正确使用方式\ndate: 2017-12-26 00:00:00\ncategories:\n- android学习记录\ntags:\n- android\n---\n## 前言\n\n看到目前项目里用到蛮多枚举, 才有了这篇小文章分享\n\n## 为什么使用Enum\n\njava中的Enum是包含固定常量集的数据类型.当我们需要预定义一组代表某种数据的值时一般都会使用枚举, 而当要保证类型安全时, 我们经常会使用Enum。\n\n比如, 当我们要保证常量使用正常时, 我们经常使用Enum在编译时校验确保类型安全\n<!-- more -->\n\n## 使用Enum的缺点\n\n在[Android开发者官网](https://developer.android.com/topic/performance/memory.html?hl=zh-cn)上, 有这样一段话\n\n> enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.\n\nEnum中的每个值都是一个对象,每个声明都将使用一些运行时内存来简单引用该对象,所以Enum相较于static int会`占用更多的内存`.\n\n另外添加单个Enum将`增加最终DEX文件的大小`（是static int的**13**倍）.\n\n## 解决方案\n\nGoogle提供了[注解库](https://developer.android.com/studio/write/annotations.html#enum-annotations)通过`Typedef`协助我们解决了Enum的问题,它可以确保特定参数, 返回值或字段引用特定的常量集,还可以完成代码以自动提供允许的常量.\n\n我们可以通过使用`@IntDef`和`@StringDef`来帮助我们在编译时检查像Enum这项的变量赋值.\n\n## 使用姿势\n1. 首先我们需要依赖注解库\n``` groovy\ndependencies {compile 'com.android.support:support-annotations:24.2.0'}\n```\n2. 直接上代码了, 因为还是蛮简单的\n``` java\npublic class Person {\n        public static final int MALE = 0;\n        public static final int FEMALE = 1;\n        private  int sex;\n        public String getSexValue(){\n            if(MALE == sex){\n                return \"男\";\n            }else if(FEMALE == sex){\n                return \"女\";\n            }\n            return \"\";\n        }\n        public void setSex(@sexDef int sex) {\n            this.sex = sex;\n        }\n        //  定义该注解被保留的时间长短\n        //  RetentionPolicy.CLASS      注解被保留到class文件, 但jvm加载class文件时候被遗弃, 这是默认生命周期; 用于在编译时进行一些预处理操作, 比如生成一些辅助代码(ButterKnife)\n        //  RetentionPolicy.RUNTIME    注解不仅被保存到class文件中, jvm加载class文件之后, 仍然存在;用于在运行时去动态获取注解信息\n        //  RetentionPolicy.SOURCE      注解只保留在源文件, 当Java文件编译成class文件的时候, 注解被遗弃; 用于做一些检查性操作\n        @Retention(RetentionPolicy.SOURCE)\n        //  使用@IntDef定义声明常量作为枚举\n        @IntDef({MALE, FEMALE})\n        //  使用@interface声明新的枚举注解类型\n        public @interface sexDef{}\n    }\n```\n3. 当我们调用setSex设置性别的时候, 如果输入非指定类型, 则编译不会通过\n\n## 总结\n\n与普通static常量相比, Enum的使用至少为整个apk添加至少两倍以上的字节数，并且使用5到10倍的RAM内存。所以建议尽量避免使用Enum, 当需要使用上述特性时,建议以@IntDef 或 @StringDef 替代使用。\n\n更多的可以看看[The price of ENUMs][https://www.youtube.com/watch?v=Hzs6OBcvNQE&feature=youtu.be]视频, 需科学上网\n","slug":"Enum的正确使用方式","published":1,"updated":"2018-05-07T02:02:07.486Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjld5agv10001cqs653z70aox","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>看到目前项目里用到蛮多枚举, 才有了这篇小文章分享</p>\n<h2 id=\"为什么使用Enum\"><a href=\"#为什么使用Enum\" class=\"headerlink\" title=\"为什么使用Enum\"></a>为什么使用Enum</h2><p>java中的Enum是包含固定常量集的数据类型.当我们需要预定义一组代表某种数据的值时一般都会使用枚举, 而当要保证类型安全时, 我们经常会使用Enum。</p>\n<p>比如, 当我们要保证常量使用正常时, 我们经常使用Enum在编译时校验确保类型安全<br><a id=\"more\"></a></p>\n<h2 id=\"使用Enum的缺点\"><a href=\"#使用Enum的缺点\" class=\"headerlink\" title=\"使用Enum的缺点\"></a>使用Enum的缺点</h2><p>在<a href=\"https://developer.android.com/topic/performance/memory.html?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">Android开发者官网</a>上, 有这样一段话</p>\n<blockquote>\n<p>enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.</p>\n</blockquote>\n<p>Enum中的每个值都是一个对象,每个声明都将使用一些运行时内存来简单引用该对象,所以Enum相较于static int会<code>占用更多的内存</code>.</p>\n<p>另外添加单个Enum将<code>增加最终DEX文件的大小</code>（是static int的<strong>13</strong>倍）.</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>Google提供了<a href=\"https://developer.android.com/studio/write/annotations.html#enum-annotations\" target=\"_blank\" rel=\"noopener\">注解库</a>通过<code>Typedef</code>协助我们解决了Enum的问题,它可以确保特定参数, 返回值或字段引用特定的常量集,还可以完成代码以自动提供允许的常量.</p>\n<p>我们可以通过使用<code>@IntDef</code>和<code>@StringDef</code>来帮助我们在编译时检查像Enum这项的变量赋值.</p>\n<h2 id=\"使用姿势\"><a href=\"#使用姿势\" class=\"headerlink\" title=\"使用姿势\"></a>使用姿势</h2><ol>\n<li><p>首先我们需要依赖注解库</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;compile <span class=\"string\">'com.android.support:support-annotations:24.2.0'</span>&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>直接上代码了, 因为还是蛮简单的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MALE = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FEMALE = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">private</span>  <span class=\"keyword\">int</span> sex;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getSexValue</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(MALE == sex)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"男\"</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(FEMALE == sex)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"女\"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSex</span><span class=\"params\">(@sexDef <span class=\"keyword\">int</span> sex)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.sex = sex;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//  定义该注解被保留的时间长短</span></span><br><span class=\"line\">        <span class=\"comment\">//  RetentionPolicy.CLASS      注解被保留到class文件, 但jvm加载class文件时候被遗弃, 这是默认生命周期; 用于在编译时进行一些预处理操作, 比如生成一些辅助代码(ButterKnife)</span></span><br><span class=\"line\">        <span class=\"comment\">//  RetentionPolicy.RUNTIME    注解不仅被保存到class文件中, jvm加载class文件之后, 仍然存在;用于在运行时去动态获取注解信息</span></span><br><span class=\"line\">        <span class=\"comment\">//  RetentionPolicy.SOURCE      注解只保留在源文件, 当Java文件编译成class文件的时候, 注解被遗弃; 用于做一些检查性操作</span></span><br><span class=\"line\">        <span class=\"meta\">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class=\"line\">        <span class=\"comment\">//  使用@IntDef定义声明常量作为枚举</span></span><br><span class=\"line\">        <span class=\"meta\">@IntDef</span>(&#123;MALE, FEMALE&#125;)</span><br><span class=\"line\">        <span class=\"comment\">//  使用@interface声明新的枚举注解类型</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> sexDef&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>当我们调用setSex设置性别的时候, 如果输入非指定类型, 则编译不会通过</p>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>与普通static常量相比, Enum的使用至少为整个apk添加至少两倍以上的字节数，并且使用5到10倍的RAM内存。所以建议尽量避免使用Enum, 当需要使用上述特性时,建议以@IntDef 或 @StringDef 替代使用。</p>\n<p>更多的可以看看[The price of ENUMs][<a href=\"https://www.youtube.com/watch?v=Hzs6OBcvNQE&amp;feature=youtu.be]视频\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=Hzs6OBcvNQE&amp;feature=youtu.be]视频</a>, 需科学上网</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>看到目前项目里用到蛮多枚举, 才有了这篇小文章分享</p>\n<h2 id=\"为什么使用Enum\"><a href=\"#为什么使用Enum\" class=\"headerlink\" title=\"为什么使用Enum\"></a>为什么使用Enum</h2><p>java中的Enum是包含固定常量集的数据类型.当我们需要预定义一组代表某种数据的值时一般都会使用枚举, 而当要保证类型安全时, 我们经常会使用Enum。</p>\n<p>比如, 当我们要保证常量使用正常时, 我们经常使用Enum在编译时校验确保类型安全<br>","more":"</p>\n<h2 id=\"使用Enum的缺点\"><a href=\"#使用Enum的缺点\" class=\"headerlink\" title=\"使用Enum的缺点\"></a>使用Enum的缺点</h2><p>在<a href=\"https://developer.android.com/topic/performance/memory.html?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">Android开发者官网</a>上, 有这样一段话</p>\n<blockquote>\n<p>enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.</p>\n</blockquote>\n<p>Enum中的每个值都是一个对象,每个声明都将使用一些运行时内存来简单引用该对象,所以Enum相较于static int会<code>占用更多的内存</code>.</p>\n<p>另外添加单个Enum将<code>增加最终DEX文件的大小</code>（是static int的<strong>13</strong>倍）.</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>Google提供了<a href=\"https://developer.android.com/studio/write/annotations.html#enum-annotations\" target=\"_blank\" rel=\"noopener\">注解库</a>通过<code>Typedef</code>协助我们解决了Enum的问题,它可以确保特定参数, 返回值或字段引用特定的常量集,还可以完成代码以自动提供允许的常量.</p>\n<p>我们可以通过使用<code>@IntDef</code>和<code>@StringDef</code>来帮助我们在编译时检查像Enum这项的变量赋值.</p>\n<h2 id=\"使用姿势\"><a href=\"#使用姿势\" class=\"headerlink\" title=\"使用姿势\"></a>使用姿势</h2><ol>\n<li><p>首先我们需要依赖注解库</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;compile <span class=\"string\">'com.android.support:support-annotations:24.2.0'</span>&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>直接上代码了, 因为还是蛮简单的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MALE = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FEMALE = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">private</span>  <span class=\"keyword\">int</span> sex;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getSexValue</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(MALE == sex)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"男\"</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(FEMALE == sex)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"女\"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSex</span><span class=\"params\">(@sexDef <span class=\"keyword\">int</span> sex)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.sex = sex;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//  定义该注解被保留的时间长短</span></span><br><span class=\"line\">        <span class=\"comment\">//  RetentionPolicy.CLASS      注解被保留到class文件, 但jvm加载class文件时候被遗弃, 这是默认生命周期; 用于在编译时进行一些预处理操作, 比如生成一些辅助代码(ButterKnife)</span></span><br><span class=\"line\">        <span class=\"comment\">//  RetentionPolicy.RUNTIME    注解不仅被保存到class文件中, jvm加载class文件之后, 仍然存在;用于在运行时去动态获取注解信息</span></span><br><span class=\"line\">        <span class=\"comment\">//  RetentionPolicy.SOURCE      注解只保留在源文件, 当Java文件编译成class文件的时候, 注解被遗弃; 用于做一些检查性操作</span></span><br><span class=\"line\">        <span class=\"meta\">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class=\"line\">        <span class=\"comment\">//  使用@IntDef定义声明常量作为枚举</span></span><br><span class=\"line\">        <span class=\"meta\">@IntDef</span>(&#123;MALE, FEMALE&#125;)</span><br><span class=\"line\">        <span class=\"comment\">//  使用@interface声明新的枚举注解类型</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> sexDef&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>当我们调用setSex设置性别的时候, 如果输入非指定类型, 则编译不会通过</p>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>与普通static常量相比, Enum的使用至少为整个apk添加至少两倍以上的字节数，并且使用5到10倍的RAM内存。所以建议尽量避免使用Enum, 当需要使用上述特性时,建议以@IntDef 或 @StringDef 替代使用。</p>\n<p>更多的可以看看[The price of ENUMs][<a href=\"https://www.youtube.com/watch?v=Hzs6OBcvNQE&amp;feature=youtu.be]视频\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=Hzs6OBcvNQE&amp;feature=youtu.be]视频</a>, 需科学上网</p>"},{"title":"LruCache解析","date":"2018-01-30T16:00:00.000Z","_content":"## 前言\n在学习`Glide`的时候, 我们会看到Glide的`二级缓存`, 分别分为`内存缓存`和`磁盘缓存`, 而不论哪种缓存都使用到了`Lru`算法, 本篇主要看一下Android里的`LruCache`的实现\n<!-- more -->\n## Lrucache实现原理\n以v4包的LruCahce类源码为准, 我们先看下他的构造函数\n``` java\npublic LruCache(int maxSize) {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize <= 0\");\n        }\n        this.maxSize = maxSize;\n        this.map = new LinkedHashMap<K, V>(0, 0.75f, true);\n    }\n```\n主要关注的是,LruCache内部通过`LinkedHashMap`用来管理缓存列表, `LinkedHashMap`是一个由数组+双向链表的数据结构实现的(我们以api26代码为准)\n``` java\n/**\n     * Constructs a new {@code LinkedHashMap} instance with the specified\n     * capacity, load factor and a flag specifying the ordering behavior.\n     *\n     * @param initialCapacity\n     *            the initial capacity of this hash map.\n     * @param loadFactor\n     *            the initial load factor.\n     * @param accessOrder\n     *            {@code true} if the ordering should be done based on the last\n     *            access (from least-recently accessed to most-recently\n     *            accessed), and {@code false} if the ordering should be the\n     *            order in which the entries were inserted.\n     * @throws IllegalArgumentException\n     *             when the capacity is less than zero or the load factor is\n     *             less or equal to zero.\n     */\n    public LinkedHashMap(\n            int initialCapacity, float loadFactor, boolean accessOrder) {\n        super(initialCapacity, loadFactor);\n        init();\n        this.accessOrder = accessOrder;\n    }\n```\n它的构造函数中的accessOrder表示的是如果为`true`,则为访问顺序; 否则, 为插入顺序排序, 我们可以看下`accessOrder`的相关的处理逻辑, 当我们调用`map.get(key)`和`map.put()`的使用, 都会调用到`afterNodeAccess()`方法, 该方法的作用就是将命中获取的引用对象, 放到链表的尾部, 就是说明, `LinkedHashMap`本身每次访问读取的时候, 都会把读取到的值放在尾部, 那么越不常用的对象越会在链表的头部\n``` java\npublic V get(Object key) {\n        Node<K,V> e;\n        if ((e = getNode(hash(key), key)) == null)\n            return null;\n        if (accessOrder)\n            afterNodeAccess(e);\n        return e.value;\n    }\n```\n这一段代码的处理就是判断目标节点的前后是否有对象, 摘除出目标节点, 将其放在last\n``` java\nvoid afterNodeAccess(Node<K,V> e) { // move node to last\n        LinkedHashMapEntry<K,V> last;\n        if (accessOrder && (last = tail) != e) {\n            LinkedHashMapEntry<K,V> p =\n                (LinkedHashMapEntry<K,V>)e, b = p.before, a = p.after;\n            p.after = null;\n            if (b == null)\n                head = a;\n            else\n                b.after = a;\n            if (a != null)\n                a.before = b;\n            else\n                last = b;\n            if (last == null)\n                head = p;\n            else {\n                p.before = last;\n                last.after = p;\n            }\n            tail = p;\n            ++modCount;\n        }\n    }\n```\n我们可以由此了解到`LruCache`类是通过`LinkedHashMap`来做缓存的`Lru`(Least Recently Used)管理, 我们在来看下`LruCache`的几个主要的方法\n### get()\n``` java\npublic final V get(K key) {\n        if (key == null) {\n            throw new NullPointerException(\"key == null\");\n        }\n\n        V mapValue;\n        synchronized (this) {\n            // LinkedHashMap 的get(key)方法会重新链接排序\n            mapValue = map.get(key);\n            if (mapValue != null) {\n                // 命中次数\n                hitCount++;\n                return mapValue;\n            }\n            // 非命中次数\n            missCount++;\n        }\n\n        // create是个空方法, 可以自己实现\n        V createdValue = create(key);\n        if (createdValue == null) {\n            return null;\n        }\n\n        synchronized (this) {\n            createCount++;\n            mapValue = map.put(key, createdValue);\n\n            // 如果对应的key之前是有值, 说明是有冲突的\n            if (mapValue != null) {\n                // 有冲突的情况, 则替换为旧值\n                // There was a conflict so undo that last put\n                map.put(key, mapValue);\n            } else {\n                size += safeSizeOf(key, createdValue);\n            }\n        }\n\n        // 冲突的情况下\n        if (mapValue != null) {\n            entryRemoved(false, key, createdValue, mapValue);\n            return mapValue;\n        } else {\n            trimToSize(maxSize);\n            return createdValue;\n        }\n    }\n```\n### put()\n``` java\npublic final V put(K key, V value) {\n        if (key == null || value == null) {\n            throw new NullPointerException(\"key == null || value == null\");\n        }\n\n        V previous;\n        synchronized (this) {\n            // 缓存次数添加\n            putCount++;\n            size += safeSizeOf(key, value);\n            previous = map.put(key, value);\n            // size是缓存大小数, 如果之前对应key有缓存的情况下, 缓存大小其实是不变的, 所以要减去原来的数\n            if (previous != null) {\n                size -= safeSizeOf(key, previous);\n            }\n        }\n\n        if (previous != null) {\n            // 缓存被替换, 调用到的方法\n            entryRemoved(false, key, previous, value);\n        }\n\n        trimToSize(maxSize);\n        return previous;\n    }\n```\n### trimToSize()\n不论是`get`还是`put`还是设置最大缓存大小`resize`,我们都会调用到`trimToSize`方法, 这个方法就是用来处理当超出缓存大小要求的时候, 删除最老的缓存, 直到缓存大小低于要求\n``` java\npublic void trimToSize(int maxSize) {\n        while (true) {\n            K key;\n            V value;\n            synchronized (this) {\n                if (size < 0 || (map.isEmpty() && size != 0)) {\n                    throw new IllegalStateException(getClass().getName()\n                            + \".sizeOf() is reporting inconsistent results!\");\n                }\n\n                if (size <= maxSize || map.isEmpty()) {\n                    break;\n                }\n\n                Map.Entry<K, V> toEvict = map.entrySet().iterator().next();\n                key = toEvict.getKey();\n                value = toEvict.getValue();\n                // LinkedHashMap构造函数中的accessOrder字段为true, 表示有读取排序\n                // 从最少使用顺序排序到最多排序\n                // 所以移除第一个value, 等于是移除最少使用的缓存\n                // map存储缓存, 直接移除第一个\n                map.remove(key);\n                size -= safeSizeOf(key, value);\n                evictionCount++;\n            }\n\n            entryRemoved(true, key, value, null);\n        }\n    }\n```\n## 总结\n现在, 我们可以了解到, 真正辅助`LruCache`实现它的算法的`LinkedHashMap`, 它会以读取的顺序来做顺序排序, 最近读取的在队尾, 当我们调用`LruCache.put`的时候, 将插入元素放在`map`队尾, 然后通过调用`trimToSize`判断是否超出缓存大小, 如果超出, 则移除`map`的队首对象.当我们调用`LruCache.get`的时候, 直接读取map对应`key`的`value`, 并由于`LinkedHashMap`的内部机制, 对读取顺序重排序, 将对应的元素更新到队尾\n","source":"_posts/LruCache解析.md","raw":"title: LruCache解析\ndate: 2018-01-31 00:00:00\ncategories:\n- 源码解析\ntags:\n- android\n- 源码解析\n---\n## 前言\n在学习`Glide`的时候, 我们会看到Glide的`二级缓存`, 分别分为`内存缓存`和`磁盘缓存`, 而不论哪种缓存都使用到了`Lru`算法, 本篇主要看一下Android里的`LruCache`的实现\n<!-- more -->\n## Lrucache实现原理\n以v4包的LruCahce类源码为准, 我们先看下他的构造函数\n``` java\npublic LruCache(int maxSize) {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize <= 0\");\n        }\n        this.maxSize = maxSize;\n        this.map = new LinkedHashMap<K, V>(0, 0.75f, true);\n    }\n```\n主要关注的是,LruCache内部通过`LinkedHashMap`用来管理缓存列表, `LinkedHashMap`是一个由数组+双向链表的数据结构实现的(我们以api26代码为准)\n``` java\n/**\n     * Constructs a new {@code LinkedHashMap} instance with the specified\n     * capacity, load factor and a flag specifying the ordering behavior.\n     *\n     * @param initialCapacity\n     *            the initial capacity of this hash map.\n     * @param loadFactor\n     *            the initial load factor.\n     * @param accessOrder\n     *            {@code true} if the ordering should be done based on the last\n     *            access (from least-recently accessed to most-recently\n     *            accessed), and {@code false} if the ordering should be the\n     *            order in which the entries were inserted.\n     * @throws IllegalArgumentException\n     *             when the capacity is less than zero or the load factor is\n     *             less or equal to zero.\n     */\n    public LinkedHashMap(\n            int initialCapacity, float loadFactor, boolean accessOrder) {\n        super(initialCapacity, loadFactor);\n        init();\n        this.accessOrder = accessOrder;\n    }\n```\n它的构造函数中的accessOrder表示的是如果为`true`,则为访问顺序; 否则, 为插入顺序排序, 我们可以看下`accessOrder`的相关的处理逻辑, 当我们调用`map.get(key)`和`map.put()`的使用, 都会调用到`afterNodeAccess()`方法, 该方法的作用就是将命中获取的引用对象, 放到链表的尾部, 就是说明, `LinkedHashMap`本身每次访问读取的时候, 都会把读取到的值放在尾部, 那么越不常用的对象越会在链表的头部\n``` java\npublic V get(Object key) {\n        Node<K,V> e;\n        if ((e = getNode(hash(key), key)) == null)\n            return null;\n        if (accessOrder)\n            afterNodeAccess(e);\n        return e.value;\n    }\n```\n这一段代码的处理就是判断目标节点的前后是否有对象, 摘除出目标节点, 将其放在last\n``` java\nvoid afterNodeAccess(Node<K,V> e) { // move node to last\n        LinkedHashMapEntry<K,V> last;\n        if (accessOrder && (last = tail) != e) {\n            LinkedHashMapEntry<K,V> p =\n                (LinkedHashMapEntry<K,V>)e, b = p.before, a = p.after;\n            p.after = null;\n            if (b == null)\n                head = a;\n            else\n                b.after = a;\n            if (a != null)\n                a.before = b;\n            else\n                last = b;\n            if (last == null)\n                head = p;\n            else {\n                p.before = last;\n                last.after = p;\n            }\n            tail = p;\n            ++modCount;\n        }\n    }\n```\n我们可以由此了解到`LruCache`类是通过`LinkedHashMap`来做缓存的`Lru`(Least Recently Used)管理, 我们在来看下`LruCache`的几个主要的方法\n### get()\n``` java\npublic final V get(K key) {\n        if (key == null) {\n            throw new NullPointerException(\"key == null\");\n        }\n\n        V mapValue;\n        synchronized (this) {\n            // LinkedHashMap 的get(key)方法会重新链接排序\n            mapValue = map.get(key);\n            if (mapValue != null) {\n                // 命中次数\n                hitCount++;\n                return mapValue;\n            }\n            // 非命中次数\n            missCount++;\n        }\n\n        // create是个空方法, 可以自己实现\n        V createdValue = create(key);\n        if (createdValue == null) {\n            return null;\n        }\n\n        synchronized (this) {\n            createCount++;\n            mapValue = map.put(key, createdValue);\n\n            // 如果对应的key之前是有值, 说明是有冲突的\n            if (mapValue != null) {\n                // 有冲突的情况, 则替换为旧值\n                // There was a conflict so undo that last put\n                map.put(key, mapValue);\n            } else {\n                size += safeSizeOf(key, createdValue);\n            }\n        }\n\n        // 冲突的情况下\n        if (mapValue != null) {\n            entryRemoved(false, key, createdValue, mapValue);\n            return mapValue;\n        } else {\n            trimToSize(maxSize);\n            return createdValue;\n        }\n    }\n```\n### put()\n``` java\npublic final V put(K key, V value) {\n        if (key == null || value == null) {\n            throw new NullPointerException(\"key == null || value == null\");\n        }\n\n        V previous;\n        synchronized (this) {\n            // 缓存次数添加\n            putCount++;\n            size += safeSizeOf(key, value);\n            previous = map.put(key, value);\n            // size是缓存大小数, 如果之前对应key有缓存的情况下, 缓存大小其实是不变的, 所以要减去原来的数\n            if (previous != null) {\n                size -= safeSizeOf(key, previous);\n            }\n        }\n\n        if (previous != null) {\n            // 缓存被替换, 调用到的方法\n            entryRemoved(false, key, previous, value);\n        }\n\n        trimToSize(maxSize);\n        return previous;\n    }\n```\n### trimToSize()\n不论是`get`还是`put`还是设置最大缓存大小`resize`,我们都会调用到`trimToSize`方法, 这个方法就是用来处理当超出缓存大小要求的时候, 删除最老的缓存, 直到缓存大小低于要求\n``` java\npublic void trimToSize(int maxSize) {\n        while (true) {\n            K key;\n            V value;\n            synchronized (this) {\n                if (size < 0 || (map.isEmpty() && size != 0)) {\n                    throw new IllegalStateException(getClass().getName()\n                            + \".sizeOf() is reporting inconsistent results!\");\n                }\n\n                if (size <= maxSize || map.isEmpty()) {\n                    break;\n                }\n\n                Map.Entry<K, V> toEvict = map.entrySet().iterator().next();\n                key = toEvict.getKey();\n                value = toEvict.getValue();\n                // LinkedHashMap构造函数中的accessOrder字段为true, 表示有读取排序\n                // 从最少使用顺序排序到最多排序\n                // 所以移除第一个value, 等于是移除最少使用的缓存\n                // map存储缓存, 直接移除第一个\n                map.remove(key);\n                size -= safeSizeOf(key, value);\n                evictionCount++;\n            }\n\n            entryRemoved(true, key, value, null);\n        }\n    }\n```\n## 总结\n现在, 我们可以了解到, 真正辅助`LruCache`实现它的算法的`LinkedHashMap`, 它会以读取的顺序来做顺序排序, 最近读取的在队尾, 当我们调用`LruCache.put`的时候, 将插入元素放在`map`队尾, 然后通过调用`trimToSize`判断是否超出缓存大小, 如果超出, 则移除`map`的队首对象.当我们调用`LruCache.get`的时候, 直接读取map对应`key`的`value`, 并由于`LinkedHashMap`的内部机制, 对读取顺序重排序, 将对应的元素更新到队尾\n","slug":"LruCache解析","published":1,"updated":"2018-05-07T02:02:55.247Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjld5agv70003cqs63issg43f","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在学习<code>Glide</code>的时候, 我们会看到Glide的<code>二级缓存</code>, 分别分为<code>内存缓存</code>和<code>磁盘缓存</code>, 而不论哪种缓存都使用到了<code>Lru</code>算法, 本篇主要看一下Android里的<code>LruCache</code>的实现<br><a id=\"more\"></a></p>\n<h2 id=\"Lrucache实现原理\"><a href=\"#Lrucache实现原理\" class=\"headerlink\" title=\"Lrucache实现原理\"></a>Lrucache实现原理</h2><p>以v4包的LruCahce类源码为准, 我们先看下他的构造函数<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LruCache</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (maxSize &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"maxSize &lt;= 0\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.maxSize = maxSize;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.map = <span class=\"keyword\">new</span> LinkedHashMap&lt;K, V&gt;(<span class=\"number\">0</span>, <span class=\"number\">0.75f</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>主要关注的是,LruCache内部通过<code>LinkedHashMap</code>用来管理缓存列表, <code>LinkedHashMap</code>是一个由数组+双向链表的数据结构实现的(我们以api26代码为准)<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructs a new &#123;<span class=\"doctag\">@code</span> LinkedHashMap&#125; instance with the specified</span></span><br><span class=\"line\"><span class=\"comment\">     * capacity, load factor and a flag specifying the ordering behavior.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> initialCapacity</span></span><br><span class=\"line\"><span class=\"comment\">     *            the initial capacity of this hash map.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> loadFactor</span></span><br><span class=\"line\"><span class=\"comment\">     *            the initial load factor.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> accessOrder</span></span><br><span class=\"line\"><span class=\"comment\">     *            &#123;<span class=\"doctag\">@code</span> true&#125; if the ordering should be done based on the last</span></span><br><span class=\"line\"><span class=\"comment\">     *            access (from least-recently accessed to most-recently</span></span><br><span class=\"line\"><span class=\"comment\">     *            accessed), and &#123;<span class=\"doctag\">@code</span> false&#125; if the ordering should be the</span></span><br><span class=\"line\"><span class=\"comment\">     *            order in which the entries were inserted.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> IllegalArgumentException</span></span><br><span class=\"line\"><span class=\"comment\">     *             when the capacity is less than zero or the load factor is</span></span><br><span class=\"line\"><span class=\"comment\">     *             less or equal to zero.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedHashMap</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor, <span class=\"keyword\">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(initialCapacity, loadFactor);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.accessOrder = accessOrder;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>它的构造函数中的accessOrder表示的是如果为<code>true</code>,则为访问顺序; 否则, 为插入顺序排序, 我们可以看下<code>accessOrder</code>的相关的处理逻辑, 当我们调用<code>map.get(key)</code>和<code>map.put()</code>的使用, 都会调用到<code>afterNodeAccess()</code>方法, 该方法的作用就是将命中获取的引用对象, 放到链表的尾部, 就是说明, <code>LinkedHashMap</code>本身每次访问读取的时候, 都会把读取到的值放在尾部, 那么越不常用的对象越会在链表的头部<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = getNode(hash(key), key)) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (accessOrder)</span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这一段代码的处理就是判断目标节点的前后是否有对象, 摘除出目标节点, 将其放在last<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">afterNodeAccess</span><span class=\"params\">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class=\"comment\">// move node to last</span></span><br><span class=\"line\">        LinkedHashMapEntry&lt;K,V&gt; last;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class=\"line\">            LinkedHashMapEntry&lt;K,V&gt; p =</span><br><span class=\"line\">                (LinkedHashMapEntry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class=\"line\">            p.after = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (b == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                head = a;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                b.after = a;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                a.before = b;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                last = b;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (last == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                head = p;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                p.before = last;</span><br><span class=\"line\">                last.after = p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tail = p;</span><br><span class=\"line\">            ++modCount;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以由此了解到<code>LruCache</code>类是通过<code>LinkedHashMap</code>来做缓存的<code>Lru</code>(Least Recently Used)管理, 我们在来看下<code>LruCache</code>的几个主要的方法</p>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">get</span><span class=\"params\">(K key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        V mapValue;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// LinkedHashMap 的get(key)方法会重新链接排序</span></span><br><span class=\"line\">            mapValue = map.get(key);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 命中次数</span></span><br><span class=\"line\">                hitCount++;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mapValue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 非命中次数</span></span><br><span class=\"line\">            missCount++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// create是个空方法, 可以自己实现</span></span><br><span class=\"line\">        V createdValue = create(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (createdValue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            createCount++;</span><br><span class=\"line\">            mapValue = map.put(key, createdValue);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 如果对应的key之前是有值, 说明是有冲突的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 有冲突的情况, 则替换为旧值</span></span><br><span class=\"line\">                <span class=\"comment\">// There was a conflict so undo that last put</span></span><br><span class=\"line\">                map.put(key, mapValue);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                size += safeSizeOf(key, createdValue);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 冲突的情况下</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            entryRemoved(<span class=\"keyword\">false</span>, key, createdValue, mapValue);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mapValue;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            trimToSize(maxSize);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> createdValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put()\"></a>put()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span> || value == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null || value == null\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        V previous;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 缓存次数添加</span></span><br><span class=\"line\">            putCount++;</span><br><span class=\"line\">            size += safeSizeOf(key, value);</span><br><span class=\"line\">            previous = map.put(key, value);</span><br><span class=\"line\">            <span class=\"comment\">// size是缓存大小数, 如果之前对应key有缓存的情况下, 缓存大小其实是不变的, 所以要减去原来的数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                size -= safeSizeOf(key, previous);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 缓存被替换, 调用到的方法</span></span><br><span class=\"line\">            entryRemoved(<span class=\"keyword\">false</span>, key, previous, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        trimToSize(maxSize);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> previous;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"trimToSize\"><a href=\"#trimToSize\" class=\"headerlink\" title=\"trimToSize()\"></a>trimToSize()</h3><p>不论是<code>get</code>还是<code>put</code>还是设置最大缓存大小<code>resize</code>,我们都会调用到<code>trimToSize</code>方法, 这个方法就是用来处理当超出缓存大小要求的时候, 删除最老的缓存, 直到缓存大小低于要求<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trimToSize</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            K key;</span><br><span class=\"line\">            V value;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (size &lt; <span class=\"number\">0</span> || (map.isEmpty() &amp;&amp; size != <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(getClass().getName()</span><br><span class=\"line\">                            + <span class=\"string\">\".sizeOf() is reporting inconsistent results!\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();</span><br><span class=\"line\">                key = toEvict.getKey();</span><br><span class=\"line\">                value = toEvict.getValue();</span><br><span class=\"line\">                <span class=\"comment\">// LinkedHashMap构造函数中的accessOrder字段为true, 表示有读取排序</span></span><br><span class=\"line\">                <span class=\"comment\">// 从最少使用顺序排序到最多排序</span></span><br><span class=\"line\">                <span class=\"comment\">// 所以移除第一个value, 等于是移除最少使用的缓存</span></span><br><span class=\"line\">                <span class=\"comment\">// map存储缓存, 直接移除第一个</span></span><br><span class=\"line\">                map.remove(key);</span><br><span class=\"line\">                size -= safeSizeOf(key, value);</span><br><span class=\"line\">                evictionCount++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            entryRemoved(<span class=\"keyword\">true</span>, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>现在, 我们可以了解到, 真正辅助<code>LruCache</code>实现它的算法的<code>LinkedHashMap</code>, 它会以读取的顺序来做顺序排序, 最近读取的在队尾, 当我们调用<code>LruCache.put</code>的时候, 将插入元素放在<code>map</code>队尾, 然后通过调用<code>trimToSize</code>判断是否超出缓存大小, 如果超出, 则移除<code>map</code>的队首对象.当我们调用<code>LruCache.get</code>的时候, 直接读取map对应<code>key</code>的<code>value</code>, 并由于<code>LinkedHashMap</code>的内部机制, 对读取顺序重排序, 将对应的元素更新到队尾</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在学习<code>Glide</code>的时候, 我们会看到Glide的<code>二级缓存</code>, 分别分为<code>内存缓存</code>和<code>磁盘缓存</code>, 而不论哪种缓存都使用到了<code>Lru</code>算法, 本篇主要看一下Android里的<code>LruCache</code>的实现<br>","more":"</p>\n<h2 id=\"Lrucache实现原理\"><a href=\"#Lrucache实现原理\" class=\"headerlink\" title=\"Lrucache实现原理\"></a>Lrucache实现原理</h2><p>以v4包的LruCahce类源码为准, 我们先看下他的构造函数<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LruCache</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (maxSize &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"maxSize &lt;= 0\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.maxSize = maxSize;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.map = <span class=\"keyword\">new</span> LinkedHashMap&lt;K, V&gt;(<span class=\"number\">0</span>, <span class=\"number\">0.75f</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>主要关注的是,LruCache内部通过<code>LinkedHashMap</code>用来管理缓存列表, <code>LinkedHashMap</code>是一个由数组+双向链表的数据结构实现的(我们以api26代码为准)<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructs a new &#123;<span class=\"doctag\">@code</span> LinkedHashMap&#125; instance with the specified</span></span><br><span class=\"line\"><span class=\"comment\">     * capacity, load factor and a flag specifying the ordering behavior.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> initialCapacity</span></span><br><span class=\"line\"><span class=\"comment\">     *            the initial capacity of this hash map.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> loadFactor</span></span><br><span class=\"line\"><span class=\"comment\">     *            the initial load factor.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> accessOrder</span></span><br><span class=\"line\"><span class=\"comment\">     *            &#123;<span class=\"doctag\">@code</span> true&#125; if the ordering should be done based on the last</span></span><br><span class=\"line\"><span class=\"comment\">     *            access (from least-recently accessed to most-recently</span></span><br><span class=\"line\"><span class=\"comment\">     *            accessed), and &#123;<span class=\"doctag\">@code</span> false&#125; if the ordering should be the</span></span><br><span class=\"line\"><span class=\"comment\">     *            order in which the entries were inserted.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> IllegalArgumentException</span></span><br><span class=\"line\"><span class=\"comment\">     *             when the capacity is less than zero or the load factor is</span></span><br><span class=\"line\"><span class=\"comment\">     *             less or equal to zero.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedHashMap</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor, <span class=\"keyword\">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(initialCapacity, loadFactor);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.accessOrder = accessOrder;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>它的构造函数中的accessOrder表示的是如果为<code>true</code>,则为访问顺序; 否则, 为插入顺序排序, 我们可以看下<code>accessOrder</code>的相关的处理逻辑, 当我们调用<code>map.get(key)</code>和<code>map.put()</code>的使用, 都会调用到<code>afterNodeAccess()</code>方法, 该方法的作用就是将命中获取的引用对象, 放到链表的尾部, 就是说明, <code>LinkedHashMap</code>本身每次访问读取的时候, 都会把读取到的值放在尾部, 那么越不常用的对象越会在链表的头部<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = getNode(hash(key), key)) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (accessOrder)</span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这一段代码的处理就是判断目标节点的前后是否有对象, 摘除出目标节点, 将其放在last<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">afterNodeAccess</span><span class=\"params\">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class=\"comment\">// move node to last</span></span><br><span class=\"line\">        LinkedHashMapEntry&lt;K,V&gt; last;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class=\"line\">            LinkedHashMapEntry&lt;K,V&gt; p =</span><br><span class=\"line\">                (LinkedHashMapEntry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class=\"line\">            p.after = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (b == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                head = a;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                b.after = a;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                a.before = b;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                last = b;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (last == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                head = p;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                p.before = last;</span><br><span class=\"line\">                last.after = p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tail = p;</span><br><span class=\"line\">            ++modCount;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以由此了解到<code>LruCache</code>类是通过<code>LinkedHashMap</code>来做缓存的<code>Lru</code>(Least Recently Used)管理, 我们在来看下<code>LruCache</code>的几个主要的方法</p>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">get</span><span class=\"params\">(K key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        V mapValue;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// LinkedHashMap 的get(key)方法会重新链接排序</span></span><br><span class=\"line\">            mapValue = map.get(key);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 命中次数</span></span><br><span class=\"line\">                hitCount++;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mapValue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 非命中次数</span></span><br><span class=\"line\">            missCount++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// create是个空方法, 可以自己实现</span></span><br><span class=\"line\">        V createdValue = create(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (createdValue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            createCount++;</span><br><span class=\"line\">            mapValue = map.put(key, createdValue);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 如果对应的key之前是有值, 说明是有冲突的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 有冲突的情况, 则替换为旧值</span></span><br><span class=\"line\">                <span class=\"comment\">// There was a conflict so undo that last put</span></span><br><span class=\"line\">                map.put(key, mapValue);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                size += safeSizeOf(key, createdValue);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 冲突的情况下</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            entryRemoved(<span class=\"keyword\">false</span>, key, createdValue, mapValue);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mapValue;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            trimToSize(maxSize);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> createdValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put()\"></a>put()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span> || value == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null || value == null\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        V previous;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 缓存次数添加</span></span><br><span class=\"line\">            putCount++;</span><br><span class=\"line\">            size += safeSizeOf(key, value);</span><br><span class=\"line\">            previous = map.put(key, value);</span><br><span class=\"line\">            <span class=\"comment\">// size是缓存大小数, 如果之前对应key有缓存的情况下, 缓存大小其实是不变的, 所以要减去原来的数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                size -= safeSizeOf(key, previous);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 缓存被替换, 调用到的方法</span></span><br><span class=\"line\">            entryRemoved(<span class=\"keyword\">false</span>, key, previous, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        trimToSize(maxSize);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> previous;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"trimToSize\"><a href=\"#trimToSize\" class=\"headerlink\" title=\"trimToSize()\"></a>trimToSize()</h3><p>不论是<code>get</code>还是<code>put</code>还是设置最大缓存大小<code>resize</code>,我们都会调用到<code>trimToSize</code>方法, 这个方法就是用来处理当超出缓存大小要求的时候, 删除最老的缓存, 直到缓存大小低于要求<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trimToSize</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            K key;</span><br><span class=\"line\">            V value;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (size &lt; <span class=\"number\">0</span> || (map.isEmpty() &amp;&amp; size != <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(getClass().getName()</span><br><span class=\"line\">                            + <span class=\"string\">\".sizeOf() is reporting inconsistent results!\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();</span><br><span class=\"line\">                key = toEvict.getKey();</span><br><span class=\"line\">                value = toEvict.getValue();</span><br><span class=\"line\">                <span class=\"comment\">// LinkedHashMap构造函数中的accessOrder字段为true, 表示有读取排序</span></span><br><span class=\"line\">                <span class=\"comment\">// 从最少使用顺序排序到最多排序</span></span><br><span class=\"line\">                <span class=\"comment\">// 所以移除第一个value, 等于是移除最少使用的缓存</span></span><br><span class=\"line\">                <span class=\"comment\">// map存储缓存, 直接移除第一个</span></span><br><span class=\"line\">                map.remove(key);</span><br><span class=\"line\">                size -= safeSizeOf(key, value);</span><br><span class=\"line\">                evictionCount++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            entryRemoved(<span class=\"keyword\">true</span>, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>现在, 我们可以了解到, 真正辅助<code>LruCache</code>实现它的算法的<code>LinkedHashMap</code>, 它会以读取的顺序来做顺序排序, 最近读取的在队尾, 当我们调用<code>LruCache.put</code>的时候, 将插入元素放在<code>map</code>队尾, 然后通过调用<code>trimToSize</code>判断是否超出缓存大小, 如果超出, 则移除<code>map</code>的队首对象.当我们调用<code>LruCache.get</code>的时候, 直接读取map对应<code>key</code>的<code>value</code>, 并由于<code>LinkedHashMap</code>的内部机制, 对读取顺序重排序, 将对应的元素更新到队尾</p>"},{"title":"ObjectBox-Java (android)使用手册","date":"2017-12-18T16:00:00.000Z","intro":"ObjectBox使用手册翻译","_content":"## 前前言\n本篇主要是方便自己记忆所写, 基本是撸完官方文档后的笔记\n## 前言\nObjectBox是一款由greenrobot出的基于noSql的ORM数据库, 但又支持表关系的定义以及事务的处理, 另外在性能上有着非常卓越的表现\n(关于性能比较, 可以看[这篇](1)),\n同时可以接入rxJava的扩展库, 并与google最新出的框架组件(Android Architecture Components)中的LiveData结合使用, 支持Kotlin.\n目前版本更新到1.2.1\n<!-- more -->\n## 依赖\n1. 在项目根目录的gradle添加它的依赖仓库地址\n``` groovy\nbuildscript {\n    ext.objectboxVersion = '1.2.1'\n    repositories {\n        jcenter()\n        maven { url \"http://objectbox.net/beta-repo/\" }\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:2.3.3'\n        classpath \"io.objectbox:objectbox-gradle-plugin:$objectboxVersion\"\n    }\n}\nallprojects {\n    repositories {\n        jcenter()\n        maven { url \"http://objectbox.net/beta-repo/\" }\n    }\n}\n```\n2. 在应用项目模块(app module)中添加插件\n``` groovy\napply plugin: 'com.android.application'\napply plugin: 'io.objectbox'\n```\n\n## 基本使用\n1. 准备`ObjectBox`对象单例并实例化, 可以放在application的`onCreate()`中\n``` java\n// MyObjectBox类文件这时候是引用不到, 它是根据实体类自动生成(build), 用来设置BoxStore对象\nboxStore = MyObjectBox.builder().androidContext(applicationContext).build();\n```\n2. 添加一个对象类, 添加`@Entity`注解, 进行表映射\n``` java\n@Entity\npublic class User{\n    // 主键, 必须有, 并且必须是long类型\n    @Id\n    private long id;\n\n    private String userName;\n    private int userAge;\n    // 必须有\n    public User(){}\n}\n```\nP.S 这时候记得build一下, MyObjectBox就自动生成了\n3. 这时候我们就可以通过`Box<User>`对象来针对这张表做增删改查工作了\n``` java\nBox<User> userBox = boxStore.boxFor(User.class).build();\n```\n\n## 增删改查\n`Box`分别有`put` 添加or修改, `query` 查找, `remove` 移除 等开放API可调用.\n在调用`put`时, 当Entity的Id不设置, 则会自动为其赋值, 并新增数据. 当有设置Id, 并在表内有对应Id, 则会被覆盖, 相当于更新对应数据.\n另外关于`@Id`,有几点需要注意:\n- `0`和`-1(0xFFFFFFFFFFFFFFFF)`不能作为Id的值使用\n- `0` 或者`null`(如果类型是Long, 但不建议使用Long, 使用long的速度会更快)会是通知永远新增一笔新数据\n- 如果`put`一个id比当前最大id大的对象, ObjectBox可能会抛出异常\n- 如果要自己分配id, 可以使用注解`@Id(assignable = true)`\n\n相关的方法, 可以参考[JavaDoc](2)中关于`Box`和`QueryBuilder`类中的方法\n## 注解\n除了本文其他地方已提到的注解, 补充几个比较大概率会用到的, 其他的建议大家可以看看[JavaDoc][2]中的`io.objectbox.annotation`包:\n``` java\n@Entity\npublic class User{\n    @Id\n    private long id;\n\n    @Index\n    private String uid;\n    @NameInDb(\"userName\")\n    private String name;\n    @Transient\n    private boolean country;\n}\n```\n- `@Index`: 因为在ObjectBox中主键是必须设置为long类型的id, 当我们业务上需要另外主键时, 可以再标注`@Index`, 在ObjectBox中查询时根据他标注的字段来查询, 会加快查询速度\n- `@NameInDb`: 字段在数据库中的命名\n- `@Transient`: 忽略字段, 不在表中生成\n\n## 数据迁移\nObjectBox可以实现大部分的数据迁移自动化, 当我们要删除或者新增一个字段的时候, 针对数据库我们是不需要做任何操作的.\n\n但是当我们需要重命名字段名或者表名, 或者需要更改字段类型时, 我们需要使用`@Uid`通知ObjectBox\n\n下面我们会分别举两个例子:\n1. 重命名操作, 实体类重命名或者字段重命名操作流程都一样, 区别只在于是在在哪里放`@Uid`, 以实体类重命名为例:\n  - 在类名上添加`@Uid`\n  ``` java\n  @Entity\n  @Uid\n  public class User{\n      @Id\n      private long id;\n\n      private String userName;\n      private int userAge;\n\n      public User(){}\n  }\n  ```\n  - `rebuild`一下, 在`Gradle Console`中会找到下面类似一段\n  ```\n  错误: [ObjectBox] UID operations for entity \"User2\":\n   [Rename] apply the current UID using @Uid(6966387148602341622L) - [Change/reset] apply a new UID using @Uid(2383770126231565339L)\n1 个错误\n  ```\n  - copy `[Rename]`的`@Uid`值6966387148602341622L, 并针对实体类进行重命名\n  ``` java\n  @Entity\n  @Uid(6966387148602341622L)\n  public class User2{\n      @Id\n      private long id;\n\n      private String userName;\n      private int userAge;\n\n      public User2(){}\n  }\n  ```\n  - 重新编译, 就已经迁移成功, 这时候`@Uid(6966387148602341622L)`这条代码就没有用了, 相关记录会在`objectbox-models/default.json`中体现\n\n2. 变更字段类型, 要注意的是, 会导致原类型字段Column的数据会被清空, 大体流程与重命名流程大致相同, 但是赋值的`@Uid` 需要使用的是`[Change/reset]`的值, 表示是一个`新字段`.\n\nP.S 前文提到了`objectbox-models/default.json`这个JSON文件, 这个文件相当于是我们做Migration时处理的文件记录, 所以是需要加入VCS控制\n## 关系\n- 以后补充\n\n##  事务\nObjectBox的所有操作都是在事务中运行的, 只是这个对我们来说是透明的, 我们不需要关注, 但是当我们需要进行多个操作的时候, 通过显示事务来控制, 可以大大提高app的效率和一致性.\n在`BoxStore`中, 提供了四个方法来执行显示事务:\n- `runInReadTx` : 在事务中运行给定的Runnable, 不可并发处理\n- `runIxTx` : 只读事务, 可以并发处理\n- `runInTxAsync` : 在单独的线程中运行, 事务完成后会回调callback(可能为空)\n- `callInTx` : 和`runIxTx`类似, 不过允许返回值并可以抛出一个异常\n\n要注意的是, 事务的提交开销较大, 所以在使用隐式事务时, 譬如大批量调用`put`时, 我们需要统一写到一个事务里去提交\n``` java\nfor(User user: userList){\n  user.plusAge();\n  box.put(user);\n}\n```\n以上的demo我们应该优化为下面这种:\n``` java\nfor(User user: userList){\n user.plusAge();\n}\nbox.put(userList);\n```\n\n## 数据库查看\n1. 在项目app gradle文件中, 必须在`'io.objectbox'`插件apply之前依赖一下代码\n``` groovy\ndebugCompile \"io.objectbox:objectbox-android-objectbrowser:1.2.1\"\nreleaseCompile \"io.objectbox:objectbox-android:1.2.1\"\n```\n2. 清单文件申请权限\n``` java\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n```\n3. 然后在BoxStore构建`之后`, 加入以下代码\n``` java\nif(BuildConfig.DEBUG){\n            new AndroidObjectBrowser(boxStore).start(this);\n  }\n```\n\n运行后, 就可以从设备的通知栏点击进入查看数据库, 也可以通过在cmd中输入`adb forward tcp:8090 tcp:8090`, 打开浏览器, 输入http://localhost:8090/index.html 网址查看\n\n## 后记\n关于它和rxJava如何使用, 如何做数据的观测, 以及和LiveData的搭配使用, 鉴于目前篇幅过长, 而且LiveData我目前还没有玩过, 所以暂时不写. 后续可能会新补一篇.\n\n具体可以看[Demo](https://github.com/YuTianTina/DatabaseChoice)\n\n[1]:https://notes.devlabs.bg/realm-objectbox-or-room-which-one-is-for-you-3a552234fd6e\n\n[2]:http://objectbox.io/files/objectbox-java/current/\n","source":"_posts/ObjectBox使用说明.md","raw":"title: ObjectBox-Java (android)使用手册\ndate: 2017-12-19 00:00:00\nintro: ObjectBox使用手册翻译\ncategories:  \n- android学习记录\ntags:\n- android\n- ObjectBox\n---\n## 前前言\n本篇主要是方便自己记忆所写, 基本是撸完官方文档后的笔记\n## 前言\nObjectBox是一款由greenrobot出的基于noSql的ORM数据库, 但又支持表关系的定义以及事务的处理, 另外在性能上有着非常卓越的表现\n(关于性能比较, 可以看[这篇](1)),\n同时可以接入rxJava的扩展库, 并与google最新出的框架组件(Android Architecture Components)中的LiveData结合使用, 支持Kotlin.\n目前版本更新到1.2.1\n<!-- more -->\n## 依赖\n1. 在项目根目录的gradle添加它的依赖仓库地址\n``` groovy\nbuildscript {\n    ext.objectboxVersion = '1.2.1'\n    repositories {\n        jcenter()\n        maven { url \"http://objectbox.net/beta-repo/\" }\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:2.3.3'\n        classpath \"io.objectbox:objectbox-gradle-plugin:$objectboxVersion\"\n    }\n}\nallprojects {\n    repositories {\n        jcenter()\n        maven { url \"http://objectbox.net/beta-repo/\" }\n    }\n}\n```\n2. 在应用项目模块(app module)中添加插件\n``` groovy\napply plugin: 'com.android.application'\napply plugin: 'io.objectbox'\n```\n\n## 基本使用\n1. 准备`ObjectBox`对象单例并实例化, 可以放在application的`onCreate()`中\n``` java\n// MyObjectBox类文件这时候是引用不到, 它是根据实体类自动生成(build), 用来设置BoxStore对象\nboxStore = MyObjectBox.builder().androidContext(applicationContext).build();\n```\n2. 添加一个对象类, 添加`@Entity`注解, 进行表映射\n``` java\n@Entity\npublic class User{\n    // 主键, 必须有, 并且必须是long类型\n    @Id\n    private long id;\n\n    private String userName;\n    private int userAge;\n    // 必须有\n    public User(){}\n}\n```\nP.S 这时候记得build一下, MyObjectBox就自动生成了\n3. 这时候我们就可以通过`Box<User>`对象来针对这张表做增删改查工作了\n``` java\nBox<User> userBox = boxStore.boxFor(User.class).build();\n```\n\n## 增删改查\n`Box`分别有`put` 添加or修改, `query` 查找, `remove` 移除 等开放API可调用.\n在调用`put`时, 当Entity的Id不设置, 则会自动为其赋值, 并新增数据. 当有设置Id, 并在表内有对应Id, 则会被覆盖, 相当于更新对应数据.\n另外关于`@Id`,有几点需要注意:\n- `0`和`-1(0xFFFFFFFFFFFFFFFF)`不能作为Id的值使用\n- `0` 或者`null`(如果类型是Long, 但不建议使用Long, 使用long的速度会更快)会是通知永远新增一笔新数据\n- 如果`put`一个id比当前最大id大的对象, ObjectBox可能会抛出异常\n- 如果要自己分配id, 可以使用注解`@Id(assignable = true)`\n\n相关的方法, 可以参考[JavaDoc](2)中关于`Box`和`QueryBuilder`类中的方法\n## 注解\n除了本文其他地方已提到的注解, 补充几个比较大概率会用到的, 其他的建议大家可以看看[JavaDoc][2]中的`io.objectbox.annotation`包:\n``` java\n@Entity\npublic class User{\n    @Id\n    private long id;\n\n    @Index\n    private String uid;\n    @NameInDb(\"userName\")\n    private String name;\n    @Transient\n    private boolean country;\n}\n```\n- `@Index`: 因为在ObjectBox中主键是必须设置为long类型的id, 当我们业务上需要另外主键时, 可以再标注`@Index`, 在ObjectBox中查询时根据他标注的字段来查询, 会加快查询速度\n- `@NameInDb`: 字段在数据库中的命名\n- `@Transient`: 忽略字段, 不在表中生成\n\n## 数据迁移\nObjectBox可以实现大部分的数据迁移自动化, 当我们要删除或者新增一个字段的时候, 针对数据库我们是不需要做任何操作的.\n\n但是当我们需要重命名字段名或者表名, 或者需要更改字段类型时, 我们需要使用`@Uid`通知ObjectBox\n\n下面我们会分别举两个例子:\n1. 重命名操作, 实体类重命名或者字段重命名操作流程都一样, 区别只在于是在在哪里放`@Uid`, 以实体类重命名为例:\n  - 在类名上添加`@Uid`\n  ``` java\n  @Entity\n  @Uid\n  public class User{\n      @Id\n      private long id;\n\n      private String userName;\n      private int userAge;\n\n      public User(){}\n  }\n  ```\n  - `rebuild`一下, 在`Gradle Console`中会找到下面类似一段\n  ```\n  错误: [ObjectBox] UID operations for entity \"User2\":\n   [Rename] apply the current UID using @Uid(6966387148602341622L) - [Change/reset] apply a new UID using @Uid(2383770126231565339L)\n1 个错误\n  ```\n  - copy `[Rename]`的`@Uid`值6966387148602341622L, 并针对实体类进行重命名\n  ``` java\n  @Entity\n  @Uid(6966387148602341622L)\n  public class User2{\n      @Id\n      private long id;\n\n      private String userName;\n      private int userAge;\n\n      public User2(){}\n  }\n  ```\n  - 重新编译, 就已经迁移成功, 这时候`@Uid(6966387148602341622L)`这条代码就没有用了, 相关记录会在`objectbox-models/default.json`中体现\n\n2. 变更字段类型, 要注意的是, 会导致原类型字段Column的数据会被清空, 大体流程与重命名流程大致相同, 但是赋值的`@Uid` 需要使用的是`[Change/reset]`的值, 表示是一个`新字段`.\n\nP.S 前文提到了`objectbox-models/default.json`这个JSON文件, 这个文件相当于是我们做Migration时处理的文件记录, 所以是需要加入VCS控制\n## 关系\n- 以后补充\n\n##  事务\nObjectBox的所有操作都是在事务中运行的, 只是这个对我们来说是透明的, 我们不需要关注, 但是当我们需要进行多个操作的时候, 通过显示事务来控制, 可以大大提高app的效率和一致性.\n在`BoxStore`中, 提供了四个方法来执行显示事务:\n- `runInReadTx` : 在事务中运行给定的Runnable, 不可并发处理\n- `runIxTx` : 只读事务, 可以并发处理\n- `runInTxAsync` : 在单独的线程中运行, 事务完成后会回调callback(可能为空)\n- `callInTx` : 和`runIxTx`类似, 不过允许返回值并可以抛出一个异常\n\n要注意的是, 事务的提交开销较大, 所以在使用隐式事务时, 譬如大批量调用`put`时, 我们需要统一写到一个事务里去提交\n``` java\nfor(User user: userList){\n  user.plusAge();\n  box.put(user);\n}\n```\n以上的demo我们应该优化为下面这种:\n``` java\nfor(User user: userList){\n user.plusAge();\n}\nbox.put(userList);\n```\n\n## 数据库查看\n1. 在项目app gradle文件中, 必须在`'io.objectbox'`插件apply之前依赖一下代码\n``` groovy\ndebugCompile \"io.objectbox:objectbox-android-objectbrowser:1.2.1\"\nreleaseCompile \"io.objectbox:objectbox-android:1.2.1\"\n```\n2. 清单文件申请权限\n``` java\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n```\n3. 然后在BoxStore构建`之后`, 加入以下代码\n``` java\nif(BuildConfig.DEBUG){\n            new AndroidObjectBrowser(boxStore).start(this);\n  }\n```\n\n运行后, 就可以从设备的通知栏点击进入查看数据库, 也可以通过在cmd中输入`adb forward tcp:8090 tcp:8090`, 打开浏览器, 输入http://localhost:8090/index.html 网址查看\n\n## 后记\n关于它和rxJava如何使用, 如何做数据的观测, 以及和LiveData的搭配使用, 鉴于目前篇幅过长, 而且LiveData我目前还没有玩过, 所以暂时不写. 后续可能会新补一篇.\n\n具体可以看[Demo](https://github.com/YuTianTina/DatabaseChoice)\n\n[1]:https://notes.devlabs.bg/realm-objectbox-or-room-which-one-is-for-you-3a552234fd6e\n\n[2]:http://objectbox.io/files/objectbox-java/current/\n","slug":"ObjectBox使用说明","published":1,"updated":"2018-05-07T02:01:28.287Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjld5agve0007cqs6o74enm3t","content":"<h2 id=\"前前言\"><a href=\"#前前言\" class=\"headerlink\" title=\"前前言\"></a>前前言</h2><p>本篇主要是方便自己记忆所写, 基本是撸完官方文档后的笔记</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>ObjectBox是一款由greenrobot出的基于noSql的ORM数据库, 但又支持表关系的定义以及事务的处理, 另外在性能上有着非常卓越的表现<br>(关于性能比较, 可以看<a href=\"1\">这篇</a>),<br>同时可以接入rxJava的扩展库, 并与google最新出的框架组件(Android Architecture Components)中的LiveData结合使用, 支持Kotlin.<br>目前版本更新到1.2.1<br><a id=\"more\"></a></p>\n<h2 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h2><ol>\n<li><p>在项目根目录的gradle添加它的依赖仓库地址</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    ext.objectboxVersion = <span class=\"string\">'1.2.1'</span></span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">        maven &#123; url <span class=\"string\">\"http://objectbox.net/beta-repo/\"</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath <span class=\"string\">'com.android.tools.build:gradle:2.3.3'</span></span><br><span class=\"line\">        classpath <span class=\"string\">\"io.objectbox:objectbox-gradle-plugin:$objectboxVersion\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">allprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">        maven &#123; url <span class=\"string\">\"http://objectbox.net/beta-repo/\"</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在应用项目模块(app module)中添加插件</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'io.objectbox'</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><ol>\n<li><p>准备<code>ObjectBox</code>对象单例并实例化, 可以放在application的<code>onCreate()</code>中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MyObjectBox类文件这时候是引用不到, 它是根据实体类自动生成(build), 用来设置BoxStore对象</span></span><br><span class=\"line\">boxStore = MyObjectBox.builder().androidContext(applicationContext).build();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加一个对象类, 添加<code>@Entity</code>注解, 进行表映射</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 主键, 必须有, 并且必须是long类型</span></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> userAge;</span><br><span class=\"line\">    <span class=\"comment\">// 必须有</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>P.S 这时候记得build一下, MyObjectBox就自动生成了</p>\n<ol>\n<li>这时候我们就可以通过<code>Box&lt;User&gt;</code>对象来针对这张表做增删改查工作了<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Box&lt;User&gt; userBox = boxStore.boxFor(User.class).build();</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"增删改查\"><a href=\"#增删改查\" class=\"headerlink\" title=\"增删改查\"></a>增删改查</h2><p><code>Box</code>分别有<code>put</code> 添加or修改, <code>query</code> 查找, <code>remove</code> 移除 等开放API可调用.<br>在调用<code>put</code>时, 当Entity的Id不设置, 则会自动为其赋值, 并新增数据. 当有设置Id, 并在表内有对应Id, 则会被覆盖, 相当于更新对应数据.<br>另外关于<code>@Id</code>,有几点需要注意:</p>\n<ul>\n<li><code>0</code>和<code>-1(0xFFFFFFFFFFFFFFFF)</code>不能作为Id的值使用</li>\n<li><code>0</code> 或者<code>null</code>(如果类型是Long, 但不建议使用Long, 使用long的速度会更快)会是通知永远新增一笔新数据</li>\n<li>如果<code>put</code>一个id比当前最大id大的对象, ObjectBox可能会抛出异常</li>\n<li>如果要自己分配id, 可以使用注解<code>@Id(assignable = true)</code></li>\n</ul>\n<p>相关的方法, 可以参考<a href=\"2\">JavaDoc</a>中关于<code>Box</code>和<code>QueryBuilder</code>类中的方法</p>\n<h2 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h2><p>除了本文其他地方已提到的注解, 补充几个比较大概率会用到的, 其他的建议大家可以看看<a href=\"http://objectbox.io/files/objectbox-java/current/\" target=\"_blank\" rel=\"noopener\">JavaDoc</a>中的<code>io.objectbox.annotation</code>包:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Index</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String uid;</span><br><span class=\"line\">    <span class=\"meta\">@NameInDb</span>(<span class=\"string\">\"userName\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"meta\">@Transient</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> country;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>@Index</code>: 因为在ObjectBox中主键是必须设置为long类型的id, 当我们业务上需要另外主键时, 可以再标注<code>@Index</code>, 在ObjectBox中查询时根据他标注的字段来查询, 会加快查询速度</li>\n<li><code>@NameInDb</code>: 字段在数据库中的命名</li>\n<li><code>@Transient</code>: 忽略字段, 不在表中生成</li>\n</ul>\n<h2 id=\"数据迁移\"><a href=\"#数据迁移\" class=\"headerlink\" title=\"数据迁移\"></a>数据迁移</h2><p>ObjectBox可以实现大部分的数据迁移自动化, 当我们要删除或者新增一个字段的时候, 针对数据库我们是不需要做任何操作的.</p>\n<p>但是当我们需要重命名字段名或者表名, 或者需要更改字段类型时, 我们需要使用<code>@Uid</code>通知ObjectBox</p>\n<p>下面我们会分别举两个例子:</p>\n<ol>\n<li><p>重命名操作, 实体类重命名或者字段重命名操作流程都一样, 区别只在于是在在哪里放<code>@Uid</code>, 以实体类重命名为例:</p>\n<ul>\n<li><p>在类名上添加<code>@Uid</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Uid</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> userAge;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>rebuild</code>一下, 在<code>Gradle Console</code>中会找到下面类似一段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  错误: [ObjectBox] UID operations for entity &quot;User2&quot;:</span><br><span class=\"line\">   [Rename] apply the current UID using @Uid(6966387148602341622L) - [Change/reset] apply a new UID using @Uid(2383770126231565339L)</span><br><span class=\"line\">1 个错误</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>copy <code>[Rename]</code>的<code>@Uid</code>值6966387148602341622L, 并针对实体类进行重命名</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Uid</span>(<span class=\"number\">6966387148602341622L</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User2</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> userAge;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User2</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重新编译, 就已经迁移成功, 这时候<code>@Uid(6966387148602341622L)</code>这条代码就没有用了, 相关记录会在<code>objectbox-models/default.json</code>中体现</p>\n</li>\n</ul>\n</li>\n<li><p>变更字段类型, 要注意的是, 会导致原类型字段Column的数据会被清空, 大体流程与重命名流程大致相同, 但是赋值的<code>@Uid</code> 需要使用的是<code>[Change/reset]</code>的值, 表示是一个<code>新字段</code>.</p>\n</li>\n</ol>\n<p>P.S 前文提到了<code>objectbox-models/default.json</code>这个JSON文件, 这个文件相当于是我们做Migration时处理的文件记录, 所以是需要加入VCS控制</p>\n<h2 id=\"关系\"><a href=\"#关系\" class=\"headerlink\" title=\"关系\"></a>关系</h2><ul>\n<li>以后补充</li>\n</ul>\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><p>ObjectBox的所有操作都是在事务中运行的, 只是这个对我们来说是透明的, 我们不需要关注, 但是当我们需要进行多个操作的时候, 通过显示事务来控制, 可以大大提高app的效率和一致性.<br>在<code>BoxStore</code>中, 提供了四个方法来执行显示事务:</p>\n<ul>\n<li><code>runInReadTx</code> : 在事务中运行给定的Runnable, 不可并发处理</li>\n<li><code>runIxTx</code> : 只读事务, 可以并发处理</li>\n<li><code>runInTxAsync</code> : 在单独的线程中运行, 事务完成后会回调callback(可能为空)</li>\n<li><code>callInTx</code> : 和<code>runIxTx</code>类似, 不过允许返回值并可以抛出一个异常</li>\n</ul>\n<p>要注意的是, 事务的提交开销较大, 所以在使用隐式事务时, 譬如大批量调用<code>put</code>时, 我们需要统一写到一个事务里去提交<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(User user: userList)&#123;</span><br><span class=\"line\">  user.plusAge();</span><br><span class=\"line\">  box.put(user);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上的demo我们应该优化为下面这种:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(User user: userList)&#123;</span><br><span class=\"line\"> user.plusAge();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">box.put(userList);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数据库查看\"><a href=\"#数据库查看\" class=\"headerlink\" title=\"数据库查看\"></a>数据库查看</h2><ol>\n<li><p>在项目app gradle文件中, 必须在<code>&#39;io.objectbox&#39;</code>插件apply之前依赖一下代码</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debugCompile <span class=\"string\">\"io.objectbox:objectbox-android-objectbrowser:1.2.1\"</span></span><br><span class=\"line\">releaseCompile <span class=\"string\">\"io.objectbox:objectbox-android:1.2.1\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>清单文件申请权限</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.INTERNET\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后在BoxStore构建<code>之后</code>, 加入以下代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(BuildConfig.DEBUG)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> AndroidObjectBrowser(boxStore).start(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>运行后, 就可以从设备的通知栏点击进入查看数据库, 也可以通过在cmd中输入<code>adb forward tcp:8090 tcp:8090</code>, 打开浏览器, 输入<a href=\"http://localhost:8090/index.html\" target=\"_blank\" rel=\"noopener\">http://localhost:8090/index.html</a> 网址查看</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>关于它和rxJava如何使用, 如何做数据的观测, 以及和LiveData的搭配使用, 鉴于目前篇幅过长, 而且LiveData我目前还没有玩过, 所以暂时不写. 后续可能会新补一篇.</p>\n<p>具体可以看<a href=\"https://github.com/YuTianTina/DatabaseChoice\" target=\"_blank\" rel=\"noopener\">Demo</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前前言\"><a href=\"#前前言\" class=\"headerlink\" title=\"前前言\"></a>前前言</h2><p>本篇主要是方便自己记忆所写, 基本是撸完官方文档后的笔记</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>ObjectBox是一款由greenrobot出的基于noSql的ORM数据库, 但又支持表关系的定义以及事务的处理, 另外在性能上有着非常卓越的表现<br>(关于性能比较, 可以看<a href=\"1\">这篇</a>),<br>同时可以接入rxJava的扩展库, 并与google最新出的框架组件(Android Architecture Components)中的LiveData结合使用, 支持Kotlin.<br>目前版本更新到1.2.1<br>","more":"</p>\n<h2 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h2><ol>\n<li><p>在项目根目录的gradle添加它的依赖仓库地址</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    ext.objectboxVersion = <span class=\"string\">'1.2.1'</span></span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">        maven &#123; url <span class=\"string\">\"http://objectbox.net/beta-repo/\"</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath <span class=\"string\">'com.android.tools.build:gradle:2.3.3'</span></span><br><span class=\"line\">        classpath <span class=\"string\">\"io.objectbox:objectbox-gradle-plugin:$objectboxVersion\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">allprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">        maven &#123; url <span class=\"string\">\"http://objectbox.net/beta-repo/\"</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在应用项目模块(app module)中添加插件</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'io.objectbox'</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><ol>\n<li><p>准备<code>ObjectBox</code>对象单例并实例化, 可以放在application的<code>onCreate()</code>中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MyObjectBox类文件这时候是引用不到, 它是根据实体类自动生成(build), 用来设置BoxStore对象</span></span><br><span class=\"line\">boxStore = MyObjectBox.builder().androidContext(applicationContext).build();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加一个对象类, 添加<code>@Entity</code>注解, 进行表映射</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 主键, 必须有, 并且必须是long类型</span></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> userAge;</span><br><span class=\"line\">    <span class=\"comment\">// 必须有</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>P.S 这时候记得build一下, MyObjectBox就自动生成了</p>\n<ol>\n<li>这时候我们就可以通过<code>Box&lt;User&gt;</code>对象来针对这张表做增删改查工作了<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Box&lt;User&gt; userBox = boxStore.boxFor(User.class).build();</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"增删改查\"><a href=\"#增删改查\" class=\"headerlink\" title=\"增删改查\"></a>增删改查</h2><p><code>Box</code>分别有<code>put</code> 添加or修改, <code>query</code> 查找, <code>remove</code> 移除 等开放API可调用.<br>在调用<code>put</code>时, 当Entity的Id不设置, 则会自动为其赋值, 并新增数据. 当有设置Id, 并在表内有对应Id, 则会被覆盖, 相当于更新对应数据.<br>另外关于<code>@Id</code>,有几点需要注意:</p>\n<ul>\n<li><code>0</code>和<code>-1(0xFFFFFFFFFFFFFFFF)</code>不能作为Id的值使用</li>\n<li><code>0</code> 或者<code>null</code>(如果类型是Long, 但不建议使用Long, 使用long的速度会更快)会是通知永远新增一笔新数据</li>\n<li>如果<code>put</code>一个id比当前最大id大的对象, ObjectBox可能会抛出异常</li>\n<li>如果要自己分配id, 可以使用注解<code>@Id(assignable = true)</code></li>\n</ul>\n<p>相关的方法, 可以参考<a href=\"2\">JavaDoc</a>中关于<code>Box</code>和<code>QueryBuilder</code>类中的方法</p>\n<h2 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h2><p>除了本文其他地方已提到的注解, 补充几个比较大概率会用到的, 其他的建议大家可以看看<a href=\"http://objectbox.io/files/objectbox-java/current/\" target=\"_blank\" rel=\"noopener\">JavaDoc</a>中的<code>io.objectbox.annotation</code>包:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Index</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String uid;</span><br><span class=\"line\">    <span class=\"meta\">@NameInDb</span>(<span class=\"string\">\"userName\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"meta\">@Transient</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> country;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>@Index</code>: 因为在ObjectBox中主键是必须设置为long类型的id, 当我们业务上需要另外主键时, 可以再标注<code>@Index</code>, 在ObjectBox中查询时根据他标注的字段来查询, 会加快查询速度</li>\n<li><code>@NameInDb</code>: 字段在数据库中的命名</li>\n<li><code>@Transient</code>: 忽略字段, 不在表中生成</li>\n</ul>\n<h2 id=\"数据迁移\"><a href=\"#数据迁移\" class=\"headerlink\" title=\"数据迁移\"></a>数据迁移</h2><p>ObjectBox可以实现大部分的数据迁移自动化, 当我们要删除或者新增一个字段的时候, 针对数据库我们是不需要做任何操作的.</p>\n<p>但是当我们需要重命名字段名或者表名, 或者需要更改字段类型时, 我们需要使用<code>@Uid</code>通知ObjectBox</p>\n<p>下面我们会分别举两个例子:</p>\n<ol>\n<li><p>重命名操作, 实体类重命名或者字段重命名操作流程都一样, 区别只在于是在在哪里放<code>@Uid</code>, 以实体类重命名为例:</p>\n<ul>\n<li><p>在类名上添加<code>@Uid</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Uid</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> userAge;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>rebuild</code>一下, 在<code>Gradle Console</code>中会找到下面类似一段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  错误: [ObjectBox] UID operations for entity &quot;User2&quot;:</span><br><span class=\"line\">   [Rename] apply the current UID using @Uid(6966387148602341622L) - [Change/reset] apply a new UID using @Uid(2383770126231565339L)</span><br><span class=\"line\">1 个错误</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>copy <code>[Rename]</code>的<code>@Uid</code>值6966387148602341622L, 并针对实体类进行重命名</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Uid</span>(<span class=\"number\">6966387148602341622L</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User2</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> userAge;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User2</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重新编译, 就已经迁移成功, 这时候<code>@Uid(6966387148602341622L)</code>这条代码就没有用了, 相关记录会在<code>objectbox-models/default.json</code>中体现</p>\n</li>\n</ul>\n</li>\n<li><p>变更字段类型, 要注意的是, 会导致原类型字段Column的数据会被清空, 大体流程与重命名流程大致相同, 但是赋值的<code>@Uid</code> 需要使用的是<code>[Change/reset]</code>的值, 表示是一个<code>新字段</code>.</p>\n</li>\n</ol>\n<p>P.S 前文提到了<code>objectbox-models/default.json</code>这个JSON文件, 这个文件相当于是我们做Migration时处理的文件记录, 所以是需要加入VCS控制</p>\n<h2 id=\"关系\"><a href=\"#关系\" class=\"headerlink\" title=\"关系\"></a>关系</h2><ul>\n<li>以后补充</li>\n</ul>\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><p>ObjectBox的所有操作都是在事务中运行的, 只是这个对我们来说是透明的, 我们不需要关注, 但是当我们需要进行多个操作的时候, 通过显示事务来控制, 可以大大提高app的效率和一致性.<br>在<code>BoxStore</code>中, 提供了四个方法来执行显示事务:</p>\n<ul>\n<li><code>runInReadTx</code> : 在事务中运行给定的Runnable, 不可并发处理</li>\n<li><code>runIxTx</code> : 只读事务, 可以并发处理</li>\n<li><code>runInTxAsync</code> : 在单独的线程中运行, 事务完成后会回调callback(可能为空)</li>\n<li><code>callInTx</code> : 和<code>runIxTx</code>类似, 不过允许返回值并可以抛出一个异常</li>\n</ul>\n<p>要注意的是, 事务的提交开销较大, 所以在使用隐式事务时, 譬如大批量调用<code>put</code>时, 我们需要统一写到一个事务里去提交<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(User user: userList)&#123;</span><br><span class=\"line\">  user.plusAge();</span><br><span class=\"line\">  box.put(user);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上的demo我们应该优化为下面这种:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(User user: userList)&#123;</span><br><span class=\"line\"> user.plusAge();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">box.put(userList);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数据库查看\"><a href=\"#数据库查看\" class=\"headerlink\" title=\"数据库查看\"></a>数据库查看</h2><ol>\n<li><p>在项目app gradle文件中, 必须在<code>&#39;io.objectbox&#39;</code>插件apply之前依赖一下代码</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debugCompile <span class=\"string\">\"io.objectbox:objectbox-android-objectbrowser:1.2.1\"</span></span><br><span class=\"line\">releaseCompile <span class=\"string\">\"io.objectbox:objectbox-android:1.2.1\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>清单文件申请权限</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.INTERNET\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后在BoxStore构建<code>之后</code>, 加入以下代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(BuildConfig.DEBUG)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> AndroidObjectBrowser(boxStore).start(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>运行后, 就可以从设备的通知栏点击进入查看数据库, 也可以通过在cmd中输入<code>adb forward tcp:8090 tcp:8090</code>, 打开浏览器, 输入<a href=\"http://localhost:8090/index.html\" target=\"_blank\" rel=\"noopener\">http://localhost:8090/index.html</a> 网址查看</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>关于它和rxJava如何使用, 如何做数据的观测, 以及和LiveData的搭配使用, 鉴于目前篇幅过长, 而且LiveData我目前还没有玩过, 所以暂时不写. 后续可能会新补一篇.</p>\n<p>具体可以看<a href=\"https://github.com/YuTianTina/DatabaseChoice\" target=\"_blank\" rel=\"noopener\">Demo</a></p>"},{"title":"androidAPT的使用","date":"2018-05-16T16:00:00.000Z","_content":"## 前言\n`APT`的概念大家应该不会陌生, 而且在很多第三方库中都有使用到, 最有名的应该就是`ButterKnife`了. 这里基础概念就略过了, 本篇主要是着重在怎么编写自己的注解处理器, 以及一些踩到的坑.\n<!-- more -->\n## 开始\n一般要实现编译器注解处理生成, 需要新建两个module, 分别存放自定义的`Annotation`和对应`Annotation`的处理器.\n### 自定义注解\n我们先新建存在自定义注解的module, ***注意, 这里建议新建java-library, 便于本地调试时给存放处理器的module依赖使用***, 对应gradle配置如下\n``` groovy\napply plugin: 'java-library'\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n}\n\nsourceCompatibility = \"1.8\"\ntargetCompatibility = \"1.8\"\n\n```\n自定义一个新的注解\n``` java\n@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\npublic @interface TestAnnotation {\n    String value();\n}\n```\n1. 这里`Retention`注解表示设置注解保留时机, 需要传递的是[`RetentionPolicy`](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/RetentionPolicy.html)枚举类型, 值分别有:\n  - `SOURCE`: 编译器时就会抛弃注解\n  - `CLASS`: 注解保留到编译器, 运行期会去除\n  - `RUNTIME`: 注解保留到运行期, 编译器时也会存在\n2. `Target`表示注解适用的上下文, 即他的目标修饰类型, 可以传数组,值应该为[ElementType](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html),枚举各个值的含义可以看官方文档, 我们主要用到比较多的应该是\n  - `TYPE`: 类, 接口(包括注解类型)或者枚举的声明\n  - `METHOD`: 方法声明\n  - `FIELD`: 字段声明, 包括枚举常量\n  - `LOCAL_VARIABLE`: 局部变量声明\n  - `CONSTRUCTOR`: 构造函数的声明\n\n### 注解处理器\n同样需要新建一个java-library, 对应gradle的配置如下\n``` groovy\napply plugin: 'java-library'\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n\n    // 协助我们生成类文件\n    implementation 'com.squareup:javapoet:1.11.0'\n    // 自定义注解的库\n    implementation project(':anno')\n    // 协助自动注册META-INF\n    implementation 'com.google.auto.service:auto-service:1.0-rc4'\n}\n```\n然后开始编写处理器, 关于如何使用[JavaPoet](https://github.com/square/javapoet), 建议看下官方文档, 在这里不再细说.最后通过`Filer`来进行文件的写入.\n``` java\n// AutoService注解协助自动生成META-INF服务, 提供项目识别自定义的注解处理器\n@AutoService(Processor.class)\npublic class TestProcessor extends AbstractProcessor {\n    private Filer mFiler;\n    private Messager messager;\n    /**\n     * init()方法可以初始化拿到一些使用的工具，比如文件相关的辅助类 Filer;元素相关的辅助类Elements;日志相关的辅助类Messager;\n     * @param processingEnv\n     */\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnv) {\n        super.init(processingEnv);\n        mFiler = processingEnv.getFiler();\n        messager = processingEnv.getMessager();\n    }\n\n    /**\n     * @return 返回Java版本\n     * 也可以通过@SupportedSourceVersion来指定, 如果没有设置默认返回的是JDK1.6版本\n     */\n    @Override\n    public SourceVersion getSupportedSourceVersion() {\n        return SourceVersion.latest();\n    }\n\n    /**\n     *\n     * @return 支持的注解类型\n     * 即是这个处理器是需要注册在哪几个注解上的, 也可以通过@SupportedAnnotationTypes来指定\n     */\n    @Override\n    public Set<String> getSupportedAnnotationTypes() {\n        LinkedHashSet<String> types = new LinkedHashSet<>();\n        types.add(TestAnnotation.class.getCanonicalName());\n        return types;\n    }\n\n    /**\n     * 一个Processor的main函数\n     * @param annotations 请求被处理的注解\n     * @param roundEnv 可以用来查询特定注解的被注解元素\n     * @return true 被当前处理器处理; false 可能被其他同样声明支持对应注解的处理器用来处理\n     */\n    @Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n        HashMap<String, String> nameMap = new HashMap<>();\n        Set<? extends Element> annotationElements = roundEnv.getElementsAnnotatedWith(TestAnnotation.class);\n        for (Element element: annotationElements\n             ) {\n            TestAnnotation annotation = element.getAnnotation(TestAnnotation.class);\n            String name = annotation.value();\n            nameMap.put(name, element.getSimpleName().toString());\n        }\n        generateJavaFile(nameMap);\n        return true;\n    }\n\n    private void generateJavaFile(Map<String, String> nameMap){\n        // 通过javaPoet生成java文件\n    }\n}\n```\n## 错误信息\n由于注解处理器是JVM在编译期进行运行, 所以普通的Log无法用来提示我们来打印一些日志或者用来提示错误信息.在`Processor`中, 当执行初始化的时候, 会传进来一个`ProcessingEnvironment`参数, 在上方代码注释内我也写了, 他会提供一些我们需要的参数, 比如`Messager`一个用来报告错误, 警报或者其他通知的工具, 它可以用来提醒第三方使用注解的开发者们来处理相关的错误.它有多个重载函数, 用于设置提醒到哪个地步, 具体可以自己尝试下.\n``` java\npublic interface Messager {\n    void printMessage(Diagnostic.Kind kind, CharSequence msg);\n\n    void printMessage(Diagnostic.Kind kind, CharSequence msg, Element e);\n\n    void printMessage(Diagnostic.Kind kind, CharSequence msg, Element e, AnnotationMirror a);\n\n    /**\n     * @param kind 通知类型\n     * @param msg  内容\n     * @param e    注解元素\n     * @param a    包含注解的值得注解\n     * @param v    提示到注解的值使用位置\n     */\n    void printMessage(Diagnostic.Kind kind,\n                      CharSequence msg,\n                      Element e,\n                      AnnotationMirror a,\n                      AnnotationValue v);\n}\n```\n## 使用自定义注解\n当我们需要使用的时候, 那么就跟常见的几个第三方库的使用(比如`Dagger`之类)是一样的.\n``` groovy\n// 依赖管理自定义注解的库\nimplementation project(':anno')\n// apt配置注解处理库\nannotationProcessor project(':aptlib')\n```\n值得注意的是如果你使用的是kotlin开发使用到对应的注解, 那么首先需要依赖kapt插件, 然后以`kapt`替换`annotationProcessor`添加注解处理库, 当项目里有Java文件使用到注解的时候, `kapt`也会兼顾到.\n``` groovy\napply plugin: 'kotlin-kapt'\ndependencies {\n    implementation fileTree(include: ['*.jar'], dir: 'libs')\n\n    implementation project(':anno')\n    kapt project(':aptlib')\n\n}\n```\n## Tips\n我们在开始的时候, 谈到注解的声明和处理器需要分别放在不同的module里, 原因是因为, 如果放在一个module里, 那么应用项目在依赖的时候, 就会变成\n``` groovy\nimplementation project(':aptlib')\nannotationProcessor project(':aptlib')\n```\n而不论是我们使用的`AbstractProcessor`还是`JavaPoet`库, 都是依赖于JDK进行编译的, 当应用项目依赖于(`implementation`)这个库的时候, AS就会默认用SDK来进行编译, 导致编译器提示部分类无法加载, 所以我们才需要分成两个module, 保证到进行逻辑处理的处理器可以不会通过`implementation`被依赖进项目中.相关可以看看相关的[issue](https://issuetracker.google.com/issues/37358824)的说明\n","source":"_posts/androidAPT.md","raw":"title: androidAPT的使用\ndate: 2018-05-17 00:00:00\ncategories:  \n- android学习记录\ntags:\n- APT\n- android\n---\n## 前言\n`APT`的概念大家应该不会陌生, 而且在很多第三方库中都有使用到, 最有名的应该就是`ButterKnife`了. 这里基础概念就略过了, 本篇主要是着重在怎么编写自己的注解处理器, 以及一些踩到的坑.\n<!-- more -->\n## 开始\n一般要实现编译器注解处理生成, 需要新建两个module, 分别存放自定义的`Annotation`和对应`Annotation`的处理器.\n### 自定义注解\n我们先新建存在自定义注解的module, ***注意, 这里建议新建java-library, 便于本地调试时给存放处理器的module依赖使用***, 对应gradle配置如下\n``` groovy\napply plugin: 'java-library'\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n}\n\nsourceCompatibility = \"1.8\"\ntargetCompatibility = \"1.8\"\n\n```\n自定义一个新的注解\n``` java\n@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\npublic @interface TestAnnotation {\n    String value();\n}\n```\n1. 这里`Retention`注解表示设置注解保留时机, 需要传递的是[`RetentionPolicy`](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/RetentionPolicy.html)枚举类型, 值分别有:\n  - `SOURCE`: 编译器时就会抛弃注解\n  - `CLASS`: 注解保留到编译器, 运行期会去除\n  - `RUNTIME`: 注解保留到运行期, 编译器时也会存在\n2. `Target`表示注解适用的上下文, 即他的目标修饰类型, 可以传数组,值应该为[ElementType](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html),枚举各个值的含义可以看官方文档, 我们主要用到比较多的应该是\n  - `TYPE`: 类, 接口(包括注解类型)或者枚举的声明\n  - `METHOD`: 方法声明\n  - `FIELD`: 字段声明, 包括枚举常量\n  - `LOCAL_VARIABLE`: 局部变量声明\n  - `CONSTRUCTOR`: 构造函数的声明\n\n### 注解处理器\n同样需要新建一个java-library, 对应gradle的配置如下\n``` groovy\napply plugin: 'java-library'\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n\n    // 协助我们生成类文件\n    implementation 'com.squareup:javapoet:1.11.0'\n    // 自定义注解的库\n    implementation project(':anno')\n    // 协助自动注册META-INF\n    implementation 'com.google.auto.service:auto-service:1.0-rc4'\n}\n```\n然后开始编写处理器, 关于如何使用[JavaPoet](https://github.com/square/javapoet), 建议看下官方文档, 在这里不再细说.最后通过`Filer`来进行文件的写入.\n``` java\n// AutoService注解协助自动生成META-INF服务, 提供项目识别自定义的注解处理器\n@AutoService(Processor.class)\npublic class TestProcessor extends AbstractProcessor {\n    private Filer mFiler;\n    private Messager messager;\n    /**\n     * init()方法可以初始化拿到一些使用的工具，比如文件相关的辅助类 Filer;元素相关的辅助类Elements;日志相关的辅助类Messager;\n     * @param processingEnv\n     */\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnv) {\n        super.init(processingEnv);\n        mFiler = processingEnv.getFiler();\n        messager = processingEnv.getMessager();\n    }\n\n    /**\n     * @return 返回Java版本\n     * 也可以通过@SupportedSourceVersion来指定, 如果没有设置默认返回的是JDK1.6版本\n     */\n    @Override\n    public SourceVersion getSupportedSourceVersion() {\n        return SourceVersion.latest();\n    }\n\n    /**\n     *\n     * @return 支持的注解类型\n     * 即是这个处理器是需要注册在哪几个注解上的, 也可以通过@SupportedAnnotationTypes来指定\n     */\n    @Override\n    public Set<String> getSupportedAnnotationTypes() {\n        LinkedHashSet<String> types = new LinkedHashSet<>();\n        types.add(TestAnnotation.class.getCanonicalName());\n        return types;\n    }\n\n    /**\n     * 一个Processor的main函数\n     * @param annotations 请求被处理的注解\n     * @param roundEnv 可以用来查询特定注解的被注解元素\n     * @return true 被当前处理器处理; false 可能被其他同样声明支持对应注解的处理器用来处理\n     */\n    @Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n        HashMap<String, String> nameMap = new HashMap<>();\n        Set<? extends Element> annotationElements = roundEnv.getElementsAnnotatedWith(TestAnnotation.class);\n        for (Element element: annotationElements\n             ) {\n            TestAnnotation annotation = element.getAnnotation(TestAnnotation.class);\n            String name = annotation.value();\n            nameMap.put(name, element.getSimpleName().toString());\n        }\n        generateJavaFile(nameMap);\n        return true;\n    }\n\n    private void generateJavaFile(Map<String, String> nameMap){\n        // 通过javaPoet生成java文件\n    }\n}\n```\n## 错误信息\n由于注解处理器是JVM在编译期进行运行, 所以普通的Log无法用来提示我们来打印一些日志或者用来提示错误信息.在`Processor`中, 当执行初始化的时候, 会传进来一个`ProcessingEnvironment`参数, 在上方代码注释内我也写了, 他会提供一些我们需要的参数, 比如`Messager`一个用来报告错误, 警报或者其他通知的工具, 它可以用来提醒第三方使用注解的开发者们来处理相关的错误.它有多个重载函数, 用于设置提醒到哪个地步, 具体可以自己尝试下.\n``` java\npublic interface Messager {\n    void printMessage(Diagnostic.Kind kind, CharSequence msg);\n\n    void printMessage(Diagnostic.Kind kind, CharSequence msg, Element e);\n\n    void printMessage(Diagnostic.Kind kind, CharSequence msg, Element e, AnnotationMirror a);\n\n    /**\n     * @param kind 通知类型\n     * @param msg  内容\n     * @param e    注解元素\n     * @param a    包含注解的值得注解\n     * @param v    提示到注解的值使用位置\n     */\n    void printMessage(Diagnostic.Kind kind,\n                      CharSequence msg,\n                      Element e,\n                      AnnotationMirror a,\n                      AnnotationValue v);\n}\n```\n## 使用自定义注解\n当我们需要使用的时候, 那么就跟常见的几个第三方库的使用(比如`Dagger`之类)是一样的.\n``` groovy\n// 依赖管理自定义注解的库\nimplementation project(':anno')\n// apt配置注解处理库\nannotationProcessor project(':aptlib')\n```\n值得注意的是如果你使用的是kotlin开发使用到对应的注解, 那么首先需要依赖kapt插件, 然后以`kapt`替换`annotationProcessor`添加注解处理库, 当项目里有Java文件使用到注解的时候, `kapt`也会兼顾到.\n``` groovy\napply plugin: 'kotlin-kapt'\ndependencies {\n    implementation fileTree(include: ['*.jar'], dir: 'libs')\n\n    implementation project(':anno')\n    kapt project(':aptlib')\n\n}\n```\n## Tips\n我们在开始的时候, 谈到注解的声明和处理器需要分别放在不同的module里, 原因是因为, 如果放在一个module里, 那么应用项目在依赖的时候, 就会变成\n``` groovy\nimplementation project(':aptlib')\nannotationProcessor project(':aptlib')\n```\n而不论是我们使用的`AbstractProcessor`还是`JavaPoet`库, 都是依赖于JDK进行编译的, 当应用项目依赖于(`implementation`)这个库的时候, AS就会默认用SDK来进行编译, 导致编译器提示部分类无法加载, 所以我们才需要分成两个module, 保证到进行逻辑处理的处理器可以不会通过`implementation`被依赖进项目中.相关可以看看相关的[issue](https://issuetracker.google.com/issues/37358824)的说明\n","slug":"androidAPT","published":1,"updated":"2018-05-17T06:50:30.129Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjld5agvg0009cqs6rkgvfaj1","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><code>APT</code>的概念大家应该不会陌生, 而且在很多第三方库中都有使用到, 最有名的应该就是<code>ButterKnife</code>了. 这里基础概念就略过了, 本篇主要是着重在怎么编写自己的注解处理器, 以及一些踩到的坑.<br><a id=\"more\"></a></p>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>一般要实现编译器注解处理生成, 需要新建两个module, 分别存放自定义的<code>Annotation</code>和对应<code>Annotation</code>的处理器.</p>\n<h3 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a>自定义注解</h3><p>我们先新建存在自定义注解的module, <strong><em>注意, 这里建议新建java-library, 便于本地调试时给存放处理器的module依赖使用</em></strong>, 对应gradle配置如下<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'java-library'</span></span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sourceCompatibility = <span class=\"string\">\"1.8\"</span></span><br><span class=\"line\">targetCompatibility = <span class=\"string\">\"1.8\"</span></span><br></pre></td></tr></table></figure></p>\n<p>自定义一个新的注解<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> TestAnnotation &#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>这里<code>Retention</code>注解表示设置注解保留时机, 需要传递的是<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/RetentionPolicy.html\" target=\"_blank\" rel=\"noopener\"><code>RetentionPolicy</code></a>枚举类型, 值分别有:<ul>\n<li><code>SOURCE</code>: 编译器时就会抛弃注解</li>\n<li><code>CLASS</code>: 注解保留到编译器, 运行期会去除</li>\n<li><code>RUNTIME</code>: 注解保留到运行期, 编译器时也会存在</li>\n</ul>\n</li>\n<li><code>Target</code>表示注解适用的上下文, 即他的目标修饰类型, 可以传数组,值应该为<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html\" target=\"_blank\" rel=\"noopener\">ElementType</a>,枚举各个值的含义可以看官方文档, 我们主要用到比较多的应该是<ul>\n<li><code>TYPE</code>: 类, 接口(包括注解类型)或者枚举的声明</li>\n<li><code>METHOD</code>: 方法声明</li>\n<li><code>FIELD</code>: 字段声明, 包括枚举常量</li>\n<li><code>LOCAL_VARIABLE</code>: 局部变量声明</li>\n<li><code>CONSTRUCTOR</code>: 构造函数的声明</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"注解处理器\"><a href=\"#注解处理器\" class=\"headerlink\" title=\"注解处理器\"></a>注解处理器</h3><p>同样需要新建一个java-library, 对应gradle的配置如下<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'java-library'</span></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 协助我们生成类文件</span></span><br><span class=\"line\">    implementation <span class=\"string\">'com.squareup:javapoet:1.11.0'</span></span><br><span class=\"line\">    <span class=\"comment\">// 自定义注解的库</span></span><br><span class=\"line\">    implementation project(<span class=\"string\">':anno'</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 协助自动注册META-INF</span></span><br><span class=\"line\">    implementation <span class=\"string\">'com.google.auto.service:auto-service:1.0-rc4'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后开始编写处理器, 关于如何使用<a href=\"https://github.com/square/javapoet\" target=\"_blank\" rel=\"noopener\">JavaPoet</a>, 建议看下官方文档, 在这里不再细说.最后通过<code>Filer</code>来进行文件的写入.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AutoService注解协助自动生成META-INF服务, 提供项目识别自定义的注解处理器</span></span><br><span class=\"line\"><span class=\"meta\">@AutoService</span>(Processor.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractProcessor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Filer mFiler;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Messager messager;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * init()方法可以初始化拿到一些使用的工具，比如文件相关的辅助类 Filer;元素相关的辅助类Elements;日志相关的辅助类Messager;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> processingEnv</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.init(processingEnv);</span><br><span class=\"line\">        mFiler = processingEnv.getFiler();</span><br><span class=\"line\">        messager = processingEnv.getMessager();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 返回Java版本</span></span><br><span class=\"line\"><span class=\"comment\">     * 也可以通过<span class=\"doctag\">@SupportedSourceVersion</span>来指定, 如果没有设置默认返回的是JDK1.6版本</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SourceVersion <span class=\"title\">getSupportedSourceVersion</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SourceVersion.latest();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 支持的注解类型</span></span><br><span class=\"line\"><span class=\"comment\">     * 即是这个处理器是需要注册在哪几个注解上的, 也可以通过<span class=\"doctag\">@SupportedAnnotationTypes</span>来指定</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title\">getSupportedAnnotationTypes</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        LinkedHashSet&lt;String&gt; types = <span class=\"keyword\">new</span> LinkedHashSet&lt;&gt;();</span><br><span class=\"line\">        types.add(TestAnnotation.class.getCanonicalName());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> types;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 一个Processor的main函数</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> annotations 请求被处理的注解</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> roundEnv 可以用来查询特定注解的被注解元素</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 被当前处理器处理; false 可能被其他同样声明支持对应注解的处理器用来处理</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">process</span><span class=\"params\">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class=\"line\">        HashMap&lt;String, String&gt; nameMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        Set&lt;? extends Element&gt; annotationElements = roundEnv.getElementsAnnotatedWith(TestAnnotation.class);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Element element: annotationElements</span><br><span class=\"line\">             ) &#123;</span><br><span class=\"line\">            TestAnnotation annotation = element.getAnnotation(TestAnnotation.class);</span><br><span class=\"line\">            String name = annotation.value();</span><br><span class=\"line\">            nameMap.put(name, element.getSimpleName().toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        generateJavaFile(nameMap);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">generateJavaFile</span><span class=\"params\">(Map&lt;String, String&gt; nameMap)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通过javaPoet生成java文件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"错误信息\"><a href=\"#错误信息\" class=\"headerlink\" title=\"错误信息\"></a>错误信息</h2><p>由于注解处理器是JVM在编译期进行运行, 所以普通的Log无法用来提示我们来打印一些日志或者用来提示错误信息.在<code>Processor</code>中, 当执行初始化的时候, 会传进来一个<code>ProcessingEnvironment</code>参数, 在上方代码注释内我也写了, 他会提供一些我们需要的参数, 比如<code>Messager</code>一个用来报告错误, 警报或者其他通知的工具, 它可以用来提醒第三方使用注解的开发者们来处理相关的错误.它有多个重载函数, 用于设置提醒到哪个地步, 具体可以自己尝试下.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Messager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printMessage</span><span class=\"params\">(Diagnostic.Kind kind, CharSequence msg)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printMessage</span><span class=\"params\">(Diagnostic.Kind kind, CharSequence msg, Element e)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printMessage</span><span class=\"params\">(Diagnostic.Kind kind, CharSequence msg, Element e, AnnotationMirror a)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> kind 通知类型</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> msg  内容</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> e    注解元素</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> a    包含注解的值得注解</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> v    提示到注解的值使用位置</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printMessage</span><span class=\"params\">(Diagnostic.Kind kind,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      CharSequence msg,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      Element e,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      AnnotationMirror a,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      AnnotationValue v)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用自定义注解\"><a href=\"#使用自定义注解\" class=\"headerlink\" title=\"使用自定义注解\"></a>使用自定义注解</h2><p>当我们需要使用的时候, 那么就跟常见的几个第三方库的使用(比如<code>Dagger</code>之类)是一样的.<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 依赖管理自定义注解的库</span></span><br><span class=\"line\">implementation project(<span class=\"string\">':anno'</span>)</span><br><span class=\"line\"><span class=\"comment\">// apt配置注解处理库</span></span><br><span class=\"line\">annotationProcessor project(<span class=\"string\">':aptlib'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>值得注意的是如果你使用的是kotlin开发使用到对应的注解, 那么首先需要依赖kapt插件, 然后以<code>kapt</code>替换<code>annotationProcessor</code>添加注解处理库, 当项目里有Java文件使用到注解的时候, <code>kapt</code>也会兼顾到.<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin-kapt'</span></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>], <span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    implementation project(<span class=\"string\">':anno'</span>)</span><br><span class=\"line\">    kapt project(<span class=\"string\">':aptlib'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h2><p>我们在开始的时候, 谈到注解的声明和处理器需要分别放在不同的module里, 原因是因为, 如果放在一个module里, 那么应用项目在依赖的时候, 就会变成<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation project(<span class=\"string\">':aptlib'</span>)</span><br><span class=\"line\">annotationProcessor project(<span class=\"string\">':aptlib'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>而不论是我们使用的<code>AbstractProcessor</code>还是<code>JavaPoet</code>库, 都是依赖于JDK进行编译的, 当应用项目依赖于(<code>implementation</code>)这个库的时候, AS就会默认用SDK来进行编译, 导致编译器提示部分类无法加载, 所以我们才需要分成两个module, 保证到进行逻辑处理的处理器可以不会通过<code>implementation</code>被依赖进项目中.相关可以看看相关的<a href=\"https://issuetracker.google.com/issues/37358824\" target=\"_blank\" rel=\"noopener\">issue</a>的说明</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><code>APT</code>的概念大家应该不会陌生, 而且在很多第三方库中都有使用到, 最有名的应该就是<code>ButterKnife</code>了. 这里基础概念就略过了, 本篇主要是着重在怎么编写自己的注解处理器, 以及一些踩到的坑.<br>","more":"</p>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>一般要实现编译器注解处理生成, 需要新建两个module, 分别存放自定义的<code>Annotation</code>和对应<code>Annotation</code>的处理器.</p>\n<h3 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a>自定义注解</h3><p>我们先新建存在自定义注解的module, <strong><em>注意, 这里建议新建java-library, 便于本地调试时给存放处理器的module依赖使用</em></strong>, 对应gradle配置如下<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'java-library'</span></span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sourceCompatibility = <span class=\"string\">\"1.8\"</span></span><br><span class=\"line\">targetCompatibility = <span class=\"string\">\"1.8\"</span></span><br></pre></td></tr></table></figure></p>\n<p>自定义一个新的注解<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> TestAnnotation &#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>这里<code>Retention</code>注解表示设置注解保留时机, 需要传递的是<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/RetentionPolicy.html\" target=\"_blank\" rel=\"noopener\"><code>RetentionPolicy</code></a>枚举类型, 值分别有:<ul>\n<li><code>SOURCE</code>: 编译器时就会抛弃注解</li>\n<li><code>CLASS</code>: 注解保留到编译器, 运行期会去除</li>\n<li><code>RUNTIME</code>: 注解保留到运行期, 编译器时也会存在</li>\n</ul>\n</li>\n<li><code>Target</code>表示注解适用的上下文, 即他的目标修饰类型, 可以传数组,值应该为<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html\" target=\"_blank\" rel=\"noopener\">ElementType</a>,枚举各个值的含义可以看官方文档, 我们主要用到比较多的应该是<ul>\n<li><code>TYPE</code>: 类, 接口(包括注解类型)或者枚举的声明</li>\n<li><code>METHOD</code>: 方法声明</li>\n<li><code>FIELD</code>: 字段声明, 包括枚举常量</li>\n<li><code>LOCAL_VARIABLE</code>: 局部变量声明</li>\n<li><code>CONSTRUCTOR</code>: 构造函数的声明</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"注解处理器\"><a href=\"#注解处理器\" class=\"headerlink\" title=\"注解处理器\"></a>注解处理器</h3><p>同样需要新建一个java-library, 对应gradle的配置如下<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'java-library'</span></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 协助我们生成类文件</span></span><br><span class=\"line\">    implementation <span class=\"string\">'com.squareup:javapoet:1.11.0'</span></span><br><span class=\"line\">    <span class=\"comment\">// 自定义注解的库</span></span><br><span class=\"line\">    implementation project(<span class=\"string\">':anno'</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 协助自动注册META-INF</span></span><br><span class=\"line\">    implementation <span class=\"string\">'com.google.auto.service:auto-service:1.0-rc4'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后开始编写处理器, 关于如何使用<a href=\"https://github.com/square/javapoet\" target=\"_blank\" rel=\"noopener\">JavaPoet</a>, 建议看下官方文档, 在这里不再细说.最后通过<code>Filer</code>来进行文件的写入.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AutoService注解协助自动生成META-INF服务, 提供项目识别自定义的注解处理器</span></span><br><span class=\"line\"><span class=\"meta\">@AutoService</span>(Processor.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractProcessor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Filer mFiler;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Messager messager;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * init()方法可以初始化拿到一些使用的工具，比如文件相关的辅助类 Filer;元素相关的辅助类Elements;日志相关的辅助类Messager;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> processingEnv</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.init(processingEnv);</span><br><span class=\"line\">        mFiler = processingEnv.getFiler();</span><br><span class=\"line\">        messager = processingEnv.getMessager();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 返回Java版本</span></span><br><span class=\"line\"><span class=\"comment\">     * 也可以通过<span class=\"doctag\">@SupportedSourceVersion</span>来指定, 如果没有设置默认返回的是JDK1.6版本</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SourceVersion <span class=\"title\">getSupportedSourceVersion</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SourceVersion.latest();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 支持的注解类型</span></span><br><span class=\"line\"><span class=\"comment\">     * 即是这个处理器是需要注册在哪几个注解上的, 也可以通过<span class=\"doctag\">@SupportedAnnotationTypes</span>来指定</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title\">getSupportedAnnotationTypes</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        LinkedHashSet&lt;String&gt; types = <span class=\"keyword\">new</span> LinkedHashSet&lt;&gt;();</span><br><span class=\"line\">        types.add(TestAnnotation.class.getCanonicalName());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> types;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 一个Processor的main函数</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> annotations 请求被处理的注解</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> roundEnv 可以用来查询特定注解的被注解元素</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 被当前处理器处理; false 可能被其他同样声明支持对应注解的处理器用来处理</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">process</span><span class=\"params\">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class=\"line\">        HashMap&lt;String, String&gt; nameMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        Set&lt;? extends Element&gt; annotationElements = roundEnv.getElementsAnnotatedWith(TestAnnotation.class);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Element element: annotationElements</span><br><span class=\"line\">             ) &#123;</span><br><span class=\"line\">            TestAnnotation annotation = element.getAnnotation(TestAnnotation.class);</span><br><span class=\"line\">            String name = annotation.value();</span><br><span class=\"line\">            nameMap.put(name, element.getSimpleName().toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        generateJavaFile(nameMap);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">generateJavaFile</span><span class=\"params\">(Map&lt;String, String&gt; nameMap)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通过javaPoet生成java文件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"错误信息\"><a href=\"#错误信息\" class=\"headerlink\" title=\"错误信息\"></a>错误信息</h2><p>由于注解处理器是JVM在编译期进行运行, 所以普通的Log无法用来提示我们来打印一些日志或者用来提示错误信息.在<code>Processor</code>中, 当执行初始化的时候, 会传进来一个<code>ProcessingEnvironment</code>参数, 在上方代码注释内我也写了, 他会提供一些我们需要的参数, 比如<code>Messager</code>一个用来报告错误, 警报或者其他通知的工具, 它可以用来提醒第三方使用注解的开发者们来处理相关的错误.它有多个重载函数, 用于设置提醒到哪个地步, 具体可以自己尝试下.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Messager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printMessage</span><span class=\"params\">(Diagnostic.Kind kind, CharSequence msg)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printMessage</span><span class=\"params\">(Diagnostic.Kind kind, CharSequence msg, Element e)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printMessage</span><span class=\"params\">(Diagnostic.Kind kind, CharSequence msg, Element e, AnnotationMirror a)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> kind 通知类型</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> msg  内容</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> e    注解元素</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> a    包含注解的值得注解</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> v    提示到注解的值使用位置</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printMessage</span><span class=\"params\">(Diagnostic.Kind kind,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      CharSequence msg,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      Element e,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      AnnotationMirror a,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      AnnotationValue v)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用自定义注解\"><a href=\"#使用自定义注解\" class=\"headerlink\" title=\"使用自定义注解\"></a>使用自定义注解</h2><p>当我们需要使用的时候, 那么就跟常见的几个第三方库的使用(比如<code>Dagger</code>之类)是一样的.<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 依赖管理自定义注解的库</span></span><br><span class=\"line\">implementation project(<span class=\"string\">':anno'</span>)</span><br><span class=\"line\"><span class=\"comment\">// apt配置注解处理库</span></span><br><span class=\"line\">annotationProcessor project(<span class=\"string\">':aptlib'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>值得注意的是如果你使用的是kotlin开发使用到对应的注解, 那么首先需要依赖kapt插件, 然后以<code>kapt</code>替换<code>annotationProcessor</code>添加注解处理库, 当项目里有Java文件使用到注解的时候, <code>kapt</code>也会兼顾到.<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin-kapt'</span></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>], <span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    implementation project(<span class=\"string\">':anno'</span>)</span><br><span class=\"line\">    kapt project(<span class=\"string\">':aptlib'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h2><p>我们在开始的时候, 谈到注解的声明和处理器需要分别放在不同的module里, 原因是因为, 如果放在一个module里, 那么应用项目在依赖的时候, 就会变成<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation project(<span class=\"string\">':aptlib'</span>)</span><br><span class=\"line\">annotationProcessor project(<span class=\"string\">':aptlib'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>而不论是我们使用的<code>AbstractProcessor</code>还是<code>JavaPoet</code>库, 都是依赖于JDK进行编译的, 当应用项目依赖于(<code>implementation</code>)这个库的时候, AS就会默认用SDK来进行编译, 导致编译器提示部分类无法加载, 所以我们才需要分成两个module, 保证到进行逻辑处理的处理器可以不会通过<code>implementation</code>被依赖进项目中.相关可以看看相关的<a href=\"https://issuetracker.google.com/issues/37358824\" target=\"_blank\" rel=\"noopener\">issue</a>的说明</p>"},{"title":"利用gradle多aar发布私有maven","date":"2017-12-18T16:00:00.000Z","intro":"多aar发布","_content":"## 前言\n为了精简目前底层的基础组件库, 拆分出必要依赖项目(有一定精简)和完全的依赖项目,\n第一想法是在library上构建变种(Variant)版本, 一次发布所有的变种,在研究了一些相关的资料后,\n最后完美解决\n<!-- more -->\n## 基础部署到maven仓库\n我们可以通过gradle部署到远程或者本地的maven仓库,\n首先添加maven插件, 然后我们通过updaloadArchives任务自动生成POM文件, 并打包部署到指定的仓库中\n\n```\n  apply plugin: 'maven'  // 添加maven插件\n  uploadArchives {\n    repositories {\n        mavenDeployer {\n            repository(url: \"maven仓库地址\")\n            }\n        }\n    }\n```\n当然我们也可以通过authentication来添加服务器的认证信息, 也可以定义快照(snapshot)仓库\n```\napply plugin: 'maven'  // 添加maven插件\nuploadArchives {\n  repositories {\n      mavenDeployer {\n          repository(url: \"maven仓库地址\"){\n              authentication(userName: \"yourUserName\", password: \"yourPsw\")\n              }\n          snapshotRepository(url: \"maven snapshot仓库地址\"){\n              authentication(userName: \"yourUserName\", password: \"yourPsw\")\n          }\n      }\n  }\n```\n## POM文件的自定义\n我们可以针对POM做自定义处理, 最常见的就是设置版本号等等\n```\napply plugin: 'maven'  // 添加maven插件\nuploadArchives {\n  repositories {\n      mavenDeployer {\n          repository(url: \"maven仓库地址\")\n          }\n          pom.groupId = \"com.maven.test\"\n          pom.artifactId = \"myLibrary\"\n          pom.version = \"1.0.0\"\n          pom.packaging = \"aar\"\n      }\n  }\n```\n针对上面的设置, 我们依赖引用的就应该是\n```\nimplementation \"com.maven.test:myLibrary:1.0.0\"\n```\nMaven默认每个项目只会处理一个artifact, 当我们library没有设置productFlavor和buildType时, 默认上传的是release的variant.\n当我们两个variant代码不同, 依赖不同时, 需要生产不同的POM进行上传,这种情况下我们需要显示声明每个artifact, 并针对每个POM进行自定义上传.\n在这方面我们可以分别参考[MavenDeployer][0]和[MavenPom][1]开放的API\n```\n// 上略\nmavenDeployer {\n            repository(url: \"仓库地址\")\n            android.libraryVariants.all {variant->\n                def isFlavor = !variant.flavorName.isEmpty()\n                def _name = \"${variant.name}\"\n                // 生成多个pom\n                addFilter(_name){artifact, file->\n                    true\n                }\n                // 对应pom属性设置\n                pom(_name).artifactId = project.archivesBaseName + \"-\" + _name\n                pom(_name).version = \"1.0.0\"\n                pom(_name).groupId = \"com.maven.test\"\n                pom(_name).packaging = 'aar'\n                // 自定义pom的依赖集\n                pom(_name).withXml{\n                    def root = asNode()\n                    def depsNode = root[\"dependencies\"][0] ?: root.appendNode(\"dependencies\")\n                    def addDep = {\n                        if (it.group == null) return // Avoid empty dependency nodes\n                        def dependencyNode = depsNode.appendNode('dependency')\n                        dependencyNode.appendNode('groupId', it.group)\n                        dependencyNode.appendNode('artifactId', it.name)\n                        dependencyNode.appendNode('version', it.version)\n                        if (it.hasProperty('optional') && it.optional) {\n                            dependencyNode.appendNode('optional', 'true')\n                        }\n                    }\n                    // 添加基本依赖\n                    configurations.api.allDependencies.each addDep\n                    configurations.implementation.allDependencies.each addDep\n                    // 添加特殊依赖\n                    if (isFlavor) {\n                        configurations[\"${_name}Implementation\"].allDependencies.each addDep\n                        def flavorName = variant.flavorName\n                        configurations[\"${flavorName}Implementation\"].allDependencies.each addDep\n                        configurations[\"${_name}Api\"].allDependencies.each addDep\n                        configurations[\"${flavorName}Api\"].allDependencies.each addDep\n                    }\n                }\n\n            }\n        }\n```\n相关demo可以看[这里][2]\n\n## 依赖对应的组件库\n在成功发布后, 我们仓库内容应该如下图\n\n![pic](./demopic.png)\n\n假设我们的flavor分别为full和simple,当我们去依赖的时候, 就可以通过\n```\nreleaseImplementation \"com.maven.test:libraryNameFullRelease:1.0.0\"\ndebugImplementation \"com.maven.test:libraryNameFullDebug:1.0.0\"\n```\n[0]:https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/maven/MavenDeployer.html\n[1]:https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/maven/MavenPom.html\n[2]:https://github.com/YuTianTina/ForMultiUploadMaven\n[3]:https://github.com/YuTianTina/ForMultiUploadMaven/blob/master/demopic.png\n","source":"_posts/基于as3.0 多aar打包发布.md","raw":"title: 利用gradle多aar发布私有maven\ndate: 2017-12-19 00:00:00\nintro: 多aar发布\ncategories :\n- android学习记录\ntags:\n- android\n- gradle\n---\n## 前言\n为了精简目前底层的基础组件库, 拆分出必要依赖项目(有一定精简)和完全的依赖项目,\n第一想法是在library上构建变种(Variant)版本, 一次发布所有的变种,在研究了一些相关的资料后,\n最后完美解决\n<!-- more -->\n## 基础部署到maven仓库\n我们可以通过gradle部署到远程或者本地的maven仓库,\n首先添加maven插件, 然后我们通过updaloadArchives任务自动生成POM文件, 并打包部署到指定的仓库中\n\n```\n  apply plugin: 'maven'  // 添加maven插件\n  uploadArchives {\n    repositories {\n        mavenDeployer {\n            repository(url: \"maven仓库地址\")\n            }\n        }\n    }\n```\n当然我们也可以通过authentication来添加服务器的认证信息, 也可以定义快照(snapshot)仓库\n```\napply plugin: 'maven'  // 添加maven插件\nuploadArchives {\n  repositories {\n      mavenDeployer {\n          repository(url: \"maven仓库地址\"){\n              authentication(userName: \"yourUserName\", password: \"yourPsw\")\n              }\n          snapshotRepository(url: \"maven snapshot仓库地址\"){\n              authentication(userName: \"yourUserName\", password: \"yourPsw\")\n          }\n      }\n  }\n```\n## POM文件的自定义\n我们可以针对POM做自定义处理, 最常见的就是设置版本号等等\n```\napply plugin: 'maven'  // 添加maven插件\nuploadArchives {\n  repositories {\n      mavenDeployer {\n          repository(url: \"maven仓库地址\")\n          }\n          pom.groupId = \"com.maven.test\"\n          pom.artifactId = \"myLibrary\"\n          pom.version = \"1.0.0\"\n          pom.packaging = \"aar\"\n      }\n  }\n```\n针对上面的设置, 我们依赖引用的就应该是\n```\nimplementation \"com.maven.test:myLibrary:1.0.0\"\n```\nMaven默认每个项目只会处理一个artifact, 当我们library没有设置productFlavor和buildType时, 默认上传的是release的variant.\n当我们两个variant代码不同, 依赖不同时, 需要生产不同的POM进行上传,这种情况下我们需要显示声明每个artifact, 并针对每个POM进行自定义上传.\n在这方面我们可以分别参考[MavenDeployer][0]和[MavenPom][1]开放的API\n```\n// 上略\nmavenDeployer {\n            repository(url: \"仓库地址\")\n            android.libraryVariants.all {variant->\n                def isFlavor = !variant.flavorName.isEmpty()\n                def _name = \"${variant.name}\"\n                // 生成多个pom\n                addFilter(_name){artifact, file->\n                    true\n                }\n                // 对应pom属性设置\n                pom(_name).artifactId = project.archivesBaseName + \"-\" + _name\n                pom(_name).version = \"1.0.0\"\n                pom(_name).groupId = \"com.maven.test\"\n                pom(_name).packaging = 'aar'\n                // 自定义pom的依赖集\n                pom(_name).withXml{\n                    def root = asNode()\n                    def depsNode = root[\"dependencies\"][0] ?: root.appendNode(\"dependencies\")\n                    def addDep = {\n                        if (it.group == null) return // Avoid empty dependency nodes\n                        def dependencyNode = depsNode.appendNode('dependency')\n                        dependencyNode.appendNode('groupId', it.group)\n                        dependencyNode.appendNode('artifactId', it.name)\n                        dependencyNode.appendNode('version', it.version)\n                        if (it.hasProperty('optional') && it.optional) {\n                            dependencyNode.appendNode('optional', 'true')\n                        }\n                    }\n                    // 添加基本依赖\n                    configurations.api.allDependencies.each addDep\n                    configurations.implementation.allDependencies.each addDep\n                    // 添加特殊依赖\n                    if (isFlavor) {\n                        configurations[\"${_name}Implementation\"].allDependencies.each addDep\n                        def flavorName = variant.flavorName\n                        configurations[\"${flavorName}Implementation\"].allDependencies.each addDep\n                        configurations[\"${_name}Api\"].allDependencies.each addDep\n                        configurations[\"${flavorName}Api\"].allDependencies.each addDep\n                    }\n                }\n\n            }\n        }\n```\n相关demo可以看[这里][2]\n\n## 依赖对应的组件库\n在成功发布后, 我们仓库内容应该如下图\n\n![pic](./demopic.png)\n\n假设我们的flavor分别为full和simple,当我们去依赖的时候, 就可以通过\n```\nreleaseImplementation \"com.maven.test:libraryNameFullRelease:1.0.0\"\ndebugImplementation \"com.maven.test:libraryNameFullDebug:1.0.0\"\n```\n[0]:https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/maven/MavenDeployer.html\n[1]:https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/maven/MavenPom.html\n[2]:https://github.com/YuTianTina/ForMultiUploadMaven\n[3]:https://github.com/YuTianTina/ForMultiUploadMaven/blob/master/demopic.png\n","slug":"基于as3.0 多aar打包发布","published":1,"updated":"2018-05-15T09:05:18.715Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjld5agvi000acqs67zhlpq4j","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>为了精简目前底层的基础组件库, 拆分出必要依赖项目(有一定精简)和完全的依赖项目,<br>第一想法是在library上构建变种(Variant)版本, 一次发布所有的变种,在研究了一些相关的资料后,<br>最后完美解决<br><a id=\"more\"></a></p>\n<h2 id=\"基础部署到maven仓库\"><a href=\"#基础部署到maven仓库\" class=\"headerlink\" title=\"基础部署到maven仓库\"></a>基础部署到maven仓库</h2><p>我们可以通过gradle部署到远程或者本地的maven仓库,<br>首先添加maven插件, 然后我们通过updaloadArchives任务自动生成POM文件, 并打包部署到指定的仓库中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &apos;maven&apos;  // 添加maven插件</span><br><span class=\"line\">uploadArchives &#123;</span><br><span class=\"line\">  repositories &#123;</span><br><span class=\"line\">      mavenDeployer &#123;</span><br><span class=\"line\">          repository(url: &quot;maven仓库地址&quot;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>当然我们也可以通过authentication来添加服务器的认证信息, 也可以定义快照(snapshot)仓库<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &apos;maven&apos;  // 添加maven插件</span><br><span class=\"line\">uploadArchives &#123;</span><br><span class=\"line\">  repositories &#123;</span><br><span class=\"line\">      mavenDeployer &#123;</span><br><span class=\"line\">          repository(url: &quot;maven仓库地址&quot;)&#123;</span><br><span class=\"line\">              authentication(userName: &quot;yourUserName&quot;, password: &quot;yourPsw&quot;)</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          snapshotRepository(url: &quot;maven snapshot仓库地址&quot;)&#123;</span><br><span class=\"line\">              authentication(userName: &quot;yourUserName&quot;, password: &quot;yourPsw&quot;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"POM文件的自定义\"><a href=\"#POM文件的自定义\" class=\"headerlink\" title=\"POM文件的自定义\"></a>POM文件的自定义</h2><p>我们可以针对POM做自定义处理, 最常见的就是设置版本号等等<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &apos;maven&apos;  // 添加maven插件</span><br><span class=\"line\">uploadArchives &#123;</span><br><span class=\"line\">  repositories &#123;</span><br><span class=\"line\">      mavenDeployer &#123;</span><br><span class=\"line\">          repository(url: &quot;maven仓库地址&quot;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          pom.groupId = &quot;com.maven.test&quot;</span><br><span class=\"line\">          pom.artifactId = &quot;myLibrary&quot;</span><br><span class=\"line\">          pom.version = &quot;1.0.0&quot;</span><br><span class=\"line\">          pom.packaging = &quot;aar&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>针对上面的设置, 我们依赖引用的就应该是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation &quot;com.maven.test:myLibrary:1.0.0&quot;</span><br></pre></td></tr></table></figure></p>\n<p>Maven默认每个项目只会处理一个artifact, 当我们library没有设置productFlavor和buildType时, 默认上传的是release的variant.<br>当我们两个variant代码不同, 依赖不同时, 需要生产不同的POM进行上传,这种情况下我们需要显示声明每个artifact, 并针对每个POM进行自定义上传.<br>在这方面我们可以分别参考<a href=\"https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/maven/MavenDeployer.html\" target=\"_blank\" rel=\"noopener\">MavenDeployer</a>和<a href=\"https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/maven/MavenPom.html\" target=\"_blank\" rel=\"noopener\">MavenPom</a>开放的API<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 上略</span><br><span class=\"line\">mavenDeployer &#123;</span><br><span class=\"line\">            repository(url: &quot;仓库地址&quot;)</span><br><span class=\"line\">            android.libraryVariants.all &#123;variant-&gt;</span><br><span class=\"line\">                def isFlavor = !variant.flavorName.isEmpty()</span><br><span class=\"line\">                def _name = &quot;$&#123;variant.name&#125;&quot;</span><br><span class=\"line\">                // 生成多个pom</span><br><span class=\"line\">                addFilter(_name)&#123;artifact, file-&gt;</span><br><span class=\"line\">                    true</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                // 对应pom属性设置</span><br><span class=\"line\">                pom(_name).artifactId = project.archivesBaseName + &quot;-&quot; + _name</span><br><span class=\"line\">                pom(_name).version = &quot;1.0.0&quot;</span><br><span class=\"line\">                pom(_name).groupId = &quot;com.maven.test&quot;</span><br><span class=\"line\">                pom(_name).packaging = &apos;aar&apos;</span><br><span class=\"line\">                // 自定义pom的依赖集</span><br><span class=\"line\">                pom(_name).withXml&#123;</span><br><span class=\"line\">                    def root = asNode()</span><br><span class=\"line\">                    def depsNode = root[&quot;dependencies&quot;][0] ?: root.appendNode(&quot;dependencies&quot;)</span><br><span class=\"line\">                    def addDep = &#123;</span><br><span class=\"line\">                        if (it.group == null) return // Avoid empty dependency nodes</span><br><span class=\"line\">                        def dependencyNode = depsNode.appendNode(&apos;dependency&apos;)</span><br><span class=\"line\">                        dependencyNode.appendNode(&apos;groupId&apos;, it.group)</span><br><span class=\"line\">                        dependencyNode.appendNode(&apos;artifactId&apos;, it.name)</span><br><span class=\"line\">                        dependencyNode.appendNode(&apos;version&apos;, it.version)</span><br><span class=\"line\">                        if (it.hasProperty(&apos;optional&apos;) &amp;&amp; it.optional) &#123;</span><br><span class=\"line\">                            dependencyNode.appendNode(&apos;optional&apos;, &apos;true&apos;)</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    // 添加基本依赖</span><br><span class=\"line\">                    configurations.api.allDependencies.each addDep</span><br><span class=\"line\">                    configurations.implementation.allDependencies.each addDep</span><br><span class=\"line\">                    // 添加特殊依赖</span><br><span class=\"line\">                    if (isFlavor) &#123;</span><br><span class=\"line\">                        configurations[&quot;$&#123;_name&#125;Implementation&quot;].allDependencies.each addDep</span><br><span class=\"line\">                        def flavorName = variant.flavorName</span><br><span class=\"line\">                        configurations[&quot;$&#123;flavorName&#125;Implementation&quot;].allDependencies.each addDep</span><br><span class=\"line\">                        configurations[&quot;$&#123;_name&#125;Api&quot;].allDependencies.each addDep</span><br><span class=\"line\">                        configurations[&quot;$&#123;flavorName&#125;Api&quot;].allDependencies.each addDep</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>相关demo可以看<a href=\"https://github.com/YuTianTina/ForMultiUploadMaven\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h2 id=\"依赖对应的组件库\"><a href=\"#依赖对应的组件库\" class=\"headerlink\" title=\"依赖对应的组件库\"></a>依赖对应的组件库</h2><p>在成功发布后, 我们仓库内容应该如下图</p>\n<p><img src=\"./demopic.png\" alt=\"pic\"></p>\n<p>假设我们的flavor分别为full和simple,当我们去依赖的时候, 就可以通过<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">releaseImplementation &quot;com.maven.test:libraryNameFullRelease:1.0.0&quot;</span><br><span class=\"line\">debugImplementation &quot;com.maven.test:libraryNameFullDebug:1.0.0&quot;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>为了精简目前底层的基础组件库, 拆分出必要依赖项目(有一定精简)和完全的依赖项目,<br>第一想法是在library上构建变种(Variant)版本, 一次发布所有的变种,在研究了一些相关的资料后,<br>最后完美解决<br>","more":"</p>\n<h2 id=\"基础部署到maven仓库\"><a href=\"#基础部署到maven仓库\" class=\"headerlink\" title=\"基础部署到maven仓库\"></a>基础部署到maven仓库</h2><p>我们可以通过gradle部署到远程或者本地的maven仓库,<br>首先添加maven插件, 然后我们通过updaloadArchives任务自动生成POM文件, 并打包部署到指定的仓库中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &apos;maven&apos;  // 添加maven插件</span><br><span class=\"line\">uploadArchives &#123;</span><br><span class=\"line\">  repositories &#123;</span><br><span class=\"line\">      mavenDeployer &#123;</span><br><span class=\"line\">          repository(url: &quot;maven仓库地址&quot;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>当然我们也可以通过authentication来添加服务器的认证信息, 也可以定义快照(snapshot)仓库<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &apos;maven&apos;  // 添加maven插件</span><br><span class=\"line\">uploadArchives &#123;</span><br><span class=\"line\">  repositories &#123;</span><br><span class=\"line\">      mavenDeployer &#123;</span><br><span class=\"line\">          repository(url: &quot;maven仓库地址&quot;)&#123;</span><br><span class=\"line\">              authentication(userName: &quot;yourUserName&quot;, password: &quot;yourPsw&quot;)</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          snapshotRepository(url: &quot;maven snapshot仓库地址&quot;)&#123;</span><br><span class=\"line\">              authentication(userName: &quot;yourUserName&quot;, password: &quot;yourPsw&quot;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"POM文件的自定义\"><a href=\"#POM文件的自定义\" class=\"headerlink\" title=\"POM文件的自定义\"></a>POM文件的自定义</h2><p>我们可以针对POM做自定义处理, 最常见的就是设置版本号等等<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &apos;maven&apos;  // 添加maven插件</span><br><span class=\"line\">uploadArchives &#123;</span><br><span class=\"line\">  repositories &#123;</span><br><span class=\"line\">      mavenDeployer &#123;</span><br><span class=\"line\">          repository(url: &quot;maven仓库地址&quot;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          pom.groupId = &quot;com.maven.test&quot;</span><br><span class=\"line\">          pom.artifactId = &quot;myLibrary&quot;</span><br><span class=\"line\">          pom.version = &quot;1.0.0&quot;</span><br><span class=\"line\">          pom.packaging = &quot;aar&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>针对上面的设置, 我们依赖引用的就应该是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation &quot;com.maven.test:myLibrary:1.0.0&quot;</span><br></pre></td></tr></table></figure></p>\n<p>Maven默认每个项目只会处理一个artifact, 当我们library没有设置productFlavor和buildType时, 默认上传的是release的variant.<br>当我们两个variant代码不同, 依赖不同时, 需要生产不同的POM进行上传,这种情况下我们需要显示声明每个artifact, 并针对每个POM进行自定义上传.<br>在这方面我们可以分别参考<a href=\"https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/maven/MavenDeployer.html\" target=\"_blank\" rel=\"noopener\">MavenDeployer</a>和<a href=\"https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/maven/MavenPom.html\" target=\"_blank\" rel=\"noopener\">MavenPom</a>开放的API<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 上略</span><br><span class=\"line\">mavenDeployer &#123;</span><br><span class=\"line\">            repository(url: &quot;仓库地址&quot;)</span><br><span class=\"line\">            android.libraryVariants.all &#123;variant-&gt;</span><br><span class=\"line\">                def isFlavor = !variant.flavorName.isEmpty()</span><br><span class=\"line\">                def _name = &quot;$&#123;variant.name&#125;&quot;</span><br><span class=\"line\">                // 生成多个pom</span><br><span class=\"line\">                addFilter(_name)&#123;artifact, file-&gt;</span><br><span class=\"line\">                    true</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                // 对应pom属性设置</span><br><span class=\"line\">                pom(_name).artifactId = project.archivesBaseName + &quot;-&quot; + _name</span><br><span class=\"line\">                pom(_name).version = &quot;1.0.0&quot;</span><br><span class=\"line\">                pom(_name).groupId = &quot;com.maven.test&quot;</span><br><span class=\"line\">                pom(_name).packaging = &apos;aar&apos;</span><br><span class=\"line\">                // 自定义pom的依赖集</span><br><span class=\"line\">                pom(_name).withXml&#123;</span><br><span class=\"line\">                    def root = asNode()</span><br><span class=\"line\">                    def depsNode = root[&quot;dependencies&quot;][0] ?: root.appendNode(&quot;dependencies&quot;)</span><br><span class=\"line\">                    def addDep = &#123;</span><br><span class=\"line\">                        if (it.group == null) return // Avoid empty dependency nodes</span><br><span class=\"line\">                        def dependencyNode = depsNode.appendNode(&apos;dependency&apos;)</span><br><span class=\"line\">                        dependencyNode.appendNode(&apos;groupId&apos;, it.group)</span><br><span class=\"line\">                        dependencyNode.appendNode(&apos;artifactId&apos;, it.name)</span><br><span class=\"line\">                        dependencyNode.appendNode(&apos;version&apos;, it.version)</span><br><span class=\"line\">                        if (it.hasProperty(&apos;optional&apos;) &amp;&amp; it.optional) &#123;</span><br><span class=\"line\">                            dependencyNode.appendNode(&apos;optional&apos;, &apos;true&apos;)</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    // 添加基本依赖</span><br><span class=\"line\">                    configurations.api.allDependencies.each addDep</span><br><span class=\"line\">                    configurations.implementation.allDependencies.each addDep</span><br><span class=\"line\">                    // 添加特殊依赖</span><br><span class=\"line\">                    if (isFlavor) &#123;</span><br><span class=\"line\">                        configurations[&quot;$&#123;_name&#125;Implementation&quot;].allDependencies.each addDep</span><br><span class=\"line\">                        def flavorName = variant.flavorName</span><br><span class=\"line\">                        configurations[&quot;$&#123;flavorName&#125;Implementation&quot;].allDependencies.each addDep</span><br><span class=\"line\">                        configurations[&quot;$&#123;_name&#125;Api&quot;].allDependencies.each addDep</span><br><span class=\"line\">                        configurations[&quot;$&#123;flavorName&#125;Api&quot;].allDependencies.each addDep</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>相关demo可以看<a href=\"https://github.com/YuTianTina/ForMultiUploadMaven\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h2 id=\"依赖对应的组件库\"><a href=\"#依赖对应的组件库\" class=\"headerlink\" title=\"依赖对应的组件库\"></a>依赖对应的组件库</h2><p>在成功发布后, 我们仓库内容应该如下图</p>\n<p><img src=\"./demopic.png\" alt=\"pic\"></p>\n<p>假设我们的flavor分别为full和simple,当我们去依赖的时候, 就可以通过<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">releaseImplementation &quot;com.maven.test:libraryNameFullRelease:1.0.0&quot;</span><br><span class=\"line\">debugImplementation &quot;com.maven.test:libraryNameFullDebug:1.0.0&quot;</span><br></pre></td></tr></table></figure></p>"},{"title":"记录一次Gradle的踩坑","date":"2018-05-14T16:00:00.000Z","_content":"### 前提背景\n来了新公司后第一个任务是给项目升级支持gradle插件3.0, 这个当初还是3.0.1的时候就做过, 所以并没有什么难度, 但是顺带要将内部的热更新插件同样升级碰到了个百思不得其解的问题.\n<!-- more -->\n### 问题\n我们先看下出现问题的伪代码, 当我在AS上需要编译运行项目的时候, 会提示`dexTask`为空的错误信息, 而在同事的PC上却可以顺利的运行.(gradle插件环境都是3.0.1, gradle使用的是4.1版本)\n``` groovy\nafterEvaluate{\n  android.buildTypes.each{\n    type ->\n    def typeName = type.name\n    if(\"release\" == typeName){\n        def dexTask = project.tasks.findByName(\"transformClassesWithDexForRelease\")\n        // 针对于dexTask的逻辑处理...\n    }\n  }\n}\n```\n由于`Gradle`开发经验少的可怜, 所以此次我们一行行来看代码\n### Gradle的执行流程\n要解释`afterEvaluate`, 我们必须先了解Gradle的执行流程.它主要可分为三个步骤\n1. 初始化, 解析`settings.gradle`, 根据module生成对应`project`的实例\n2. 配置, 解析每个`project`, 获取对应的`task`\n3. 执行task\n\n当然这一块流程, 我们可以从AS的Build上分析得出.\n![执行流程](./Gradle执行时序.png)\n然后我们再回头说到`afterEvaluate`, 它是在配置阶段后, 已经获取对应`project`的`task`后, 回调执行的.具体可以看[官方文档的说明](https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html#afterEvaluate-groovy.lang.Closure-)(这里放的是最新版本的API文档, 要看对应版本的文档, 可以看本地的gradle文件夹内的javadoc文档)\n### 问题和解决\nok, 那么关于`afterEvaluate`我们已经了解了, 再往下看,`android.buildTypes.each`就是对`project`的配置的`buildType`进行遍历, 然后当`buildType`为`release`的时候, 获取对应`buildType`的`transformClassesWithDex`.\n而在调试的过程中, 我发现走debug的时候`transformClassesWithDexForDebug`是有的, 可以看出配置阶段只会获取当前`buildType`的task.\n那么现在我们要做的就是改为判断当前`buildType`为`release`的时候, 再获取对应的task.\n``` groovy\nandroid.applicationVariants.all{\n    variant ->\n      variant.outputs.each{\n        type ->\n        if(\"release\" == type.name){\n          def dexTask = project.tasks.findByName(\"transformClassesWithDexForRelease\")\n          // 针对于dexTask的逻辑处理...\n        }\n      }\n}\n```\n然后这里还有个问题, 我们已知task的获取是要在配置结束后才能获得的, 这里不通过`afterEvaluate`是否可以获取到对应的task? 这块我们可以看下源码注释\n``` java\n/**\n     * Returns a collection of <a\n     * href=\"https://developer.android.com/studio/build/build-variants.html\">build variants</a> that\n     * the app project includes.\n     *\n     * <p>To process elements in this collection, you should use the <a\n     * href=\"https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectCollection.html#all(org.gradle.api.Action)\">\n     * <code>all</code></a> iterator. That's because the plugin populates this collection only after\n     * the project is evaluated. Unlike the <code>each</code> iterator, using <code>all</code>\n     * processes future elements as the plugin creates them.\n     *\n     * <p>The following sample iterates through all <code>applicationVariants</code> elements to <a\n     * href=\"https://developer.android.com/studio/build/manifest-build-variables.html\">inject a\n     * build variable into the manifest</a>:\n     *\n     * <pre>\n     * android.applicationVariants.all { variant -&gt;\n     *     def mergedFlavor = variant.getMergedFlavor()\n     *     // Defines the value of a build variable you can use in the manifest.\n     *     mergedFlavor.manifestPlaceholders = [hostName:\"www.example.com/${variant.versionName}\"]\n     * }\n     * </pre>\n     */\n    public DomainObjectSet<ApplicationVariant> getApplicationVariants() {\n        return applicationVariantList;\n    }\n```\n`all`与`each`不同, 他只会在`configuration`阶段后进行获取填充.\n### 其他\n至于为什么同事的PC上可以运行, 我的不行, 后来排查下来, 应该是在AS`3.1.2`版本(同事的AS是3.0.1)在执行获取配置这块, 校验更为严格的原因. 但是具体的我并没有查询相关的文档.\n### 总结\n其实本次问题并不难解决, 可能是前期因为同事可以运行, 本地环境却不能运行的状况给搞懵逼了. 但是后来还是顺利解决了.关于Gradle, 这次的踩坑经验是教了我去看官方API...虽然说Gradle的文档是真的好难定位\n","source":"_posts/记录一次Gradle的踩坑.md","raw":"title: 记录一次Gradle的踩坑\ndate: 2018-05-15 00:00:00\ncategories :\n- 日常开发踩坑记录\ntags:\n- android\n- gradle\n---\n### 前提背景\n来了新公司后第一个任务是给项目升级支持gradle插件3.0, 这个当初还是3.0.1的时候就做过, 所以并没有什么难度, 但是顺带要将内部的热更新插件同样升级碰到了个百思不得其解的问题.\n<!-- more -->\n### 问题\n我们先看下出现问题的伪代码, 当我在AS上需要编译运行项目的时候, 会提示`dexTask`为空的错误信息, 而在同事的PC上却可以顺利的运行.(gradle插件环境都是3.0.1, gradle使用的是4.1版本)\n``` groovy\nafterEvaluate{\n  android.buildTypes.each{\n    type ->\n    def typeName = type.name\n    if(\"release\" == typeName){\n        def dexTask = project.tasks.findByName(\"transformClassesWithDexForRelease\")\n        // 针对于dexTask的逻辑处理...\n    }\n  }\n}\n```\n由于`Gradle`开发经验少的可怜, 所以此次我们一行行来看代码\n### Gradle的执行流程\n要解释`afterEvaluate`, 我们必须先了解Gradle的执行流程.它主要可分为三个步骤\n1. 初始化, 解析`settings.gradle`, 根据module生成对应`project`的实例\n2. 配置, 解析每个`project`, 获取对应的`task`\n3. 执行task\n\n当然这一块流程, 我们可以从AS的Build上分析得出.\n![执行流程](./Gradle执行时序.png)\n然后我们再回头说到`afterEvaluate`, 它是在配置阶段后, 已经获取对应`project`的`task`后, 回调执行的.具体可以看[官方文档的说明](https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html#afterEvaluate-groovy.lang.Closure-)(这里放的是最新版本的API文档, 要看对应版本的文档, 可以看本地的gradle文件夹内的javadoc文档)\n### 问题和解决\nok, 那么关于`afterEvaluate`我们已经了解了, 再往下看,`android.buildTypes.each`就是对`project`的配置的`buildType`进行遍历, 然后当`buildType`为`release`的时候, 获取对应`buildType`的`transformClassesWithDex`.\n而在调试的过程中, 我发现走debug的时候`transformClassesWithDexForDebug`是有的, 可以看出配置阶段只会获取当前`buildType`的task.\n那么现在我们要做的就是改为判断当前`buildType`为`release`的时候, 再获取对应的task.\n``` groovy\nandroid.applicationVariants.all{\n    variant ->\n      variant.outputs.each{\n        type ->\n        if(\"release\" == type.name){\n          def dexTask = project.tasks.findByName(\"transformClassesWithDexForRelease\")\n          // 针对于dexTask的逻辑处理...\n        }\n      }\n}\n```\n然后这里还有个问题, 我们已知task的获取是要在配置结束后才能获得的, 这里不通过`afterEvaluate`是否可以获取到对应的task? 这块我们可以看下源码注释\n``` java\n/**\n     * Returns a collection of <a\n     * href=\"https://developer.android.com/studio/build/build-variants.html\">build variants</a> that\n     * the app project includes.\n     *\n     * <p>To process elements in this collection, you should use the <a\n     * href=\"https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectCollection.html#all(org.gradle.api.Action)\">\n     * <code>all</code></a> iterator. That's because the plugin populates this collection only after\n     * the project is evaluated. Unlike the <code>each</code> iterator, using <code>all</code>\n     * processes future elements as the plugin creates them.\n     *\n     * <p>The following sample iterates through all <code>applicationVariants</code> elements to <a\n     * href=\"https://developer.android.com/studio/build/manifest-build-variables.html\">inject a\n     * build variable into the manifest</a>:\n     *\n     * <pre>\n     * android.applicationVariants.all { variant -&gt;\n     *     def mergedFlavor = variant.getMergedFlavor()\n     *     // Defines the value of a build variable you can use in the manifest.\n     *     mergedFlavor.manifestPlaceholders = [hostName:\"www.example.com/${variant.versionName}\"]\n     * }\n     * </pre>\n     */\n    public DomainObjectSet<ApplicationVariant> getApplicationVariants() {\n        return applicationVariantList;\n    }\n```\n`all`与`each`不同, 他只会在`configuration`阶段后进行获取填充.\n### 其他\n至于为什么同事的PC上可以运行, 我的不行, 后来排查下来, 应该是在AS`3.1.2`版本(同事的AS是3.0.1)在执行获取配置这块, 校验更为严格的原因. 但是具体的我并没有查询相关的文档.\n### 总结\n其实本次问题并不难解决, 可能是前期因为同事可以运行, 本地环境却不能运行的状况给搞懵逼了. 但是后来还是顺利解决了.关于Gradle, 这次的踩坑经验是教了我去看官方API...虽然说Gradle的文档是真的好难定位\n","slug":"记录一次Gradle的踩坑","published":1,"updated":"2018-05-15T09:07:53.023Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjld5agvm000ecqs6ih6kwgb8","content":"<h3 id=\"前提背景\"><a href=\"#前提背景\" class=\"headerlink\" title=\"前提背景\"></a>前提背景</h3><p>来了新公司后第一个任务是给项目升级支持gradle插件3.0, 这个当初还是3.0.1的时候就做过, 所以并没有什么难度, 但是顺带要将内部的热更新插件同样升级碰到了个百思不得其解的问题.<br><a id=\"more\"></a></p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>我们先看下出现问题的伪代码, 当我在AS上需要编译运行项目的时候, 会提示<code>dexTask</code>为空的错误信息, 而在同事的PC上却可以顺利的运行.(gradle插件环境都是3.0.1, gradle使用的是4.1版本)<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">afterEvaluate&#123;</span><br><span class=\"line\">  android.buildTypes.each&#123;</span><br><span class=\"line\">    type -&gt;</span><br><span class=\"line\">    <span class=\"keyword\">def</span> typeName = type.name</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"string\">\"release\"</span> == typeName)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">def</span> dexTask = project.tasks.findByName(<span class=\"string\">\"transformClassesWithDexForRelease\"</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 针对于dexTask的逻辑处理...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于<code>Gradle</code>开发经验少的可怜, 所以此次我们一行行来看代码</p>\n<h3 id=\"Gradle的执行流程\"><a href=\"#Gradle的执行流程\" class=\"headerlink\" title=\"Gradle的执行流程\"></a>Gradle的执行流程</h3><p>要解释<code>afterEvaluate</code>, 我们必须先了解Gradle的执行流程.它主要可分为三个步骤</p>\n<ol>\n<li>初始化, 解析<code>settings.gradle</code>, 根据module生成对应<code>project</code>的实例</li>\n<li>配置, 解析每个<code>project</code>, 获取对应的<code>task</code></li>\n<li>执行task</li>\n</ol>\n<p>当然这一块流程, 我们可以从AS的Build上分析得出.<br><img src=\"./Gradle执行时序.png\" alt=\"执行流程\"><br>然后我们再回头说到<code>afterEvaluate</code>, 它是在配置阶段后, 已经获取对应<code>project</code>的<code>task</code>后, 回调执行的.具体可以看<a href=\"https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html#afterEvaluate-groovy.lang.Closure-\" target=\"_blank\" rel=\"noopener\">官方文档的说明</a>(这里放的是最新版本的API文档, 要看对应版本的文档, 可以看本地的gradle文件夹内的javadoc文档)</p>\n<h3 id=\"问题和解决\"><a href=\"#问题和解决\" class=\"headerlink\" title=\"问题和解决\"></a>问题和解决</h3><p>ok, 那么关于<code>afterEvaluate</code>我们已经了解了, 再往下看,<code>android.buildTypes.each</code>就是对<code>project</code>的配置的<code>buildType</code>进行遍历, 然后当<code>buildType</code>为<code>release</code>的时候, 获取对应<code>buildType</code>的<code>transformClassesWithDex</code>.<br>而在调试的过程中, 我发现走debug的时候<code>transformClassesWithDexForDebug</code>是有的, 可以看出配置阶段只会获取当前<code>buildType</code>的task.<br>那么现在我们要做的就是改为判断当前<code>buildType</code>为<code>release</code>的时候, 再获取对应的task.<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android.applicationVariants.all&#123;</span><br><span class=\"line\">    variant -&gt;</span><br><span class=\"line\">      variant.outputs.each&#123;</span><br><span class=\"line\">        type -&gt;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">\"release\"</span> == type.name)&#123;</span><br><span class=\"line\">          <span class=\"keyword\">def</span> dexTask = project.tasks.findByName(<span class=\"string\">\"transformClassesWithDexForRelease\"</span>)</span><br><span class=\"line\">          <span class=\"comment\">// 针对于dexTask的逻辑处理...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后这里还有个问题, 我们已知task的获取是要在配置结束后才能获得的, 这里不通过<code>afterEvaluate</code>是否可以获取到对应的task? 这块我们可以看下源码注释<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns a collection of &lt;a</span></span><br><span class=\"line\"><span class=\"comment\">     * href=\"https://developer.android.com/studio/build/build-variants.html\"&gt;build variants&lt;/a&gt; that</span></span><br><span class=\"line\"><span class=\"comment\">     * the app project includes.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;To process elements in this collection, you should use the &lt;a</span></span><br><span class=\"line\"><span class=\"comment\">     * href=\"https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectCollection.html#all(org.gradle.api.Action)\"&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;code&gt;all&lt;/code&gt;&lt;/a&gt; iterator. That's because the plugin populates this collection only after</span></span><br><span class=\"line\"><span class=\"comment\">     * the project is evaluated. Unlike the &lt;code&gt;each&lt;/code&gt; iterator, using &lt;code&gt;all&lt;/code&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * processes future elements as the plugin creates them.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;The following sample iterates through all &lt;code&gt;applicationVariants&lt;/code&gt; elements to &lt;a</span></span><br><span class=\"line\"><span class=\"comment\">     * href=\"https://developer.android.com/studio/build/manifest-build-variables.html\"&gt;inject a</span></span><br><span class=\"line\"><span class=\"comment\">     * build variable into the manifest&lt;/a&gt;:</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * android.applicationVariants.all &#123; variant -&amp;gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *     def mergedFlavor = variant.getMergedFlavor()</span></span><br><span class=\"line\"><span class=\"comment\">     *     // Defines the value of a build variable you can use in the manifest.</span></span><br><span class=\"line\"><span class=\"comment\">     *     mergedFlavor.manifestPlaceholders = [hostName:\"www.example.com/$&#123;variant.versionName&#125;\"]</span></span><br><span class=\"line\"><span class=\"comment\">     * &#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;/pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DomainObjectSet&lt;ApplicationVariant&gt; <span class=\"title\">getApplicationVariants</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> applicationVariantList;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>all</code>与<code>each</code>不同, 他只会在<code>configuration</code>阶段后进行获取填充.</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>至于为什么同事的PC上可以运行, 我的不行, 后来排查下来, 应该是在AS<code>3.1.2</code>版本(同事的AS是3.0.1)在执行获取配置这块, 校验更为严格的原因. 但是具体的我并没有查询相关的文档.</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>其实本次问题并不难解决, 可能是前期因为同事可以运行, 本地环境却不能运行的状况给搞懵逼了. 但是后来还是顺利解决了.关于Gradle, 这次的踩坑经验是教了我去看官方API…虽然说Gradle的文档是真的好难定位</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前提背景\"><a href=\"#前提背景\" class=\"headerlink\" title=\"前提背景\"></a>前提背景</h3><p>来了新公司后第一个任务是给项目升级支持gradle插件3.0, 这个当初还是3.0.1的时候就做过, 所以并没有什么难度, 但是顺带要将内部的热更新插件同样升级碰到了个百思不得其解的问题.<br>","more":"</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>我们先看下出现问题的伪代码, 当我在AS上需要编译运行项目的时候, 会提示<code>dexTask</code>为空的错误信息, 而在同事的PC上却可以顺利的运行.(gradle插件环境都是3.0.1, gradle使用的是4.1版本)<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">afterEvaluate&#123;</span><br><span class=\"line\">  android.buildTypes.each&#123;</span><br><span class=\"line\">    type -&gt;</span><br><span class=\"line\">    <span class=\"keyword\">def</span> typeName = type.name</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"string\">\"release\"</span> == typeName)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">def</span> dexTask = project.tasks.findByName(<span class=\"string\">\"transformClassesWithDexForRelease\"</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 针对于dexTask的逻辑处理...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于<code>Gradle</code>开发经验少的可怜, 所以此次我们一行行来看代码</p>\n<h3 id=\"Gradle的执行流程\"><a href=\"#Gradle的执行流程\" class=\"headerlink\" title=\"Gradle的执行流程\"></a>Gradle的执行流程</h3><p>要解释<code>afterEvaluate</code>, 我们必须先了解Gradle的执行流程.它主要可分为三个步骤</p>\n<ol>\n<li>初始化, 解析<code>settings.gradle</code>, 根据module生成对应<code>project</code>的实例</li>\n<li>配置, 解析每个<code>project</code>, 获取对应的<code>task</code></li>\n<li>执行task</li>\n</ol>\n<p>当然这一块流程, 我们可以从AS的Build上分析得出.<br><img src=\"./Gradle执行时序.png\" alt=\"执行流程\"><br>然后我们再回头说到<code>afterEvaluate</code>, 它是在配置阶段后, 已经获取对应<code>project</code>的<code>task</code>后, 回调执行的.具体可以看<a href=\"https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html#afterEvaluate-groovy.lang.Closure-\" target=\"_blank\" rel=\"noopener\">官方文档的说明</a>(这里放的是最新版本的API文档, 要看对应版本的文档, 可以看本地的gradle文件夹内的javadoc文档)</p>\n<h3 id=\"问题和解决\"><a href=\"#问题和解决\" class=\"headerlink\" title=\"问题和解决\"></a>问题和解决</h3><p>ok, 那么关于<code>afterEvaluate</code>我们已经了解了, 再往下看,<code>android.buildTypes.each</code>就是对<code>project</code>的配置的<code>buildType</code>进行遍历, 然后当<code>buildType</code>为<code>release</code>的时候, 获取对应<code>buildType</code>的<code>transformClassesWithDex</code>.<br>而在调试的过程中, 我发现走debug的时候<code>transformClassesWithDexForDebug</code>是有的, 可以看出配置阶段只会获取当前<code>buildType</code>的task.<br>那么现在我们要做的就是改为判断当前<code>buildType</code>为<code>release</code>的时候, 再获取对应的task.<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android.applicationVariants.all&#123;</span><br><span class=\"line\">    variant -&gt;</span><br><span class=\"line\">      variant.outputs.each&#123;</span><br><span class=\"line\">        type -&gt;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">\"release\"</span> == type.name)&#123;</span><br><span class=\"line\">          <span class=\"keyword\">def</span> dexTask = project.tasks.findByName(<span class=\"string\">\"transformClassesWithDexForRelease\"</span>)</span><br><span class=\"line\">          <span class=\"comment\">// 针对于dexTask的逻辑处理...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后这里还有个问题, 我们已知task的获取是要在配置结束后才能获得的, 这里不通过<code>afterEvaluate</code>是否可以获取到对应的task? 这块我们可以看下源码注释<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns a collection of &lt;a</span></span><br><span class=\"line\"><span class=\"comment\">     * href=\"https://developer.android.com/studio/build/build-variants.html\"&gt;build variants&lt;/a&gt; that</span></span><br><span class=\"line\"><span class=\"comment\">     * the app project includes.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;To process elements in this collection, you should use the &lt;a</span></span><br><span class=\"line\"><span class=\"comment\">     * href=\"https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectCollection.html#all(org.gradle.api.Action)\"&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;code&gt;all&lt;/code&gt;&lt;/a&gt; iterator. That's because the plugin populates this collection only after</span></span><br><span class=\"line\"><span class=\"comment\">     * the project is evaluated. Unlike the &lt;code&gt;each&lt;/code&gt; iterator, using &lt;code&gt;all&lt;/code&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * processes future elements as the plugin creates them.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;The following sample iterates through all &lt;code&gt;applicationVariants&lt;/code&gt; elements to &lt;a</span></span><br><span class=\"line\"><span class=\"comment\">     * href=\"https://developer.android.com/studio/build/manifest-build-variables.html\"&gt;inject a</span></span><br><span class=\"line\"><span class=\"comment\">     * build variable into the manifest&lt;/a&gt;:</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * android.applicationVariants.all &#123; variant -&amp;gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *     def mergedFlavor = variant.getMergedFlavor()</span></span><br><span class=\"line\"><span class=\"comment\">     *     // Defines the value of a build variable you can use in the manifest.</span></span><br><span class=\"line\"><span class=\"comment\">     *     mergedFlavor.manifestPlaceholders = [hostName:\"www.example.com/$&#123;variant.versionName&#125;\"]</span></span><br><span class=\"line\"><span class=\"comment\">     * &#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;/pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DomainObjectSet&lt;ApplicationVariant&gt; <span class=\"title\">getApplicationVariants</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> applicationVariantList;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>all</code>与<code>each</code>不同, 他只会在<code>configuration</code>阶段后进行获取填充.</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>至于为什么同事的PC上可以运行, 我的不行, 后来排查下来, 应该是在AS<code>3.1.2</code>版本(同事的AS是3.0.1)在执行获取配置这块, 校验更为严格的原因. 但是具体的我并没有查询相关的文档.</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>其实本次问题并不难解决, 可能是前期因为同事可以运行, 本地环境却不能运行的状况给搞懵逼了. 但是后来还是顺利解决了.关于Gradle, 这次的踩坑经验是教了我去看官方API…虽然说Gradle的文档是真的好难定位</p>"},{"title":"谈谈GC和引用","date":"2018-01-11T16:00:00.000Z","_content":"## 前言\nA拿了一串代码和[一篇文章](http://www.cnblogs.com/absfree/p/5555687.html)来问我,\n\n      ...当productA变为null时（表明它所引用的Product已经无需存在于内存中），这时指向这个Product对象的就是由弱引用对象weakProductA了，那么显然这时候相应的Product对象时弱可达的，\n      所以指向它的弱引用会被清除，这个Product对象随即会被回收，指向它的弱引用对象会进入引用队列中。\n根据文章上述引用内容, 当他在执行下文代码的`putnull`方法时, 为什么`userWeakReference.get()`对象不为null, 难道`userWeakReference.get()` 和 `user` 不是一个对象吗?\n``` java\npublic class MainActivity extends AppCompatActivity {\n    private User user;\n    public static final int period = 2000;\n    private WeakReference<User> userWeakReference;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        user = new User();\n        userWeakReference = new WeakReference<>(user);\n\n        Observable.interval(period, TimeUnit.MILLISECONDS)\n                .subscribe(new Consumer<Long>() {\n                    @Override\n                    public void accept(Long aLong) throws Exception {\n                        Log.d(\"gc\", String.format(\"user is %s null\", (null == user) ? \"\" : \"not\") +\n                                String.format(\" ****\" +\n                                        \" userWeakReference.get() is %s null\", (null == userWeakReference.get()) ? \"\" : \"not\"));\n                    }\n                });\n\n    }\n\n    public void putnull(View view) {\n        Log.i(\"gc\", \"============ user = null ==============\");\n        user = null;\n    }\n\n    public void excutegc(View view) {\n        Log.i(\"gc\", \"========== gc done =============\");\n        System.runFinalization();\n        System.gc();\n\n    }\n}\n```\n<!-- more -->\n我们不妨先看下打印日志![打印日志](./gc.png)\n当`user`为空的时候, `userWeakReference.get()`不为空, 直到GC以后, 才为空.\n## 对象的初始化\n这个问题的道理其实很简单.首先我们来看下下面代码的含义\n``` java\nUser user = new User();\n```\n当虚拟机遇到一条`new`指令的时候, 在类加载检查通过以后, 会为新生对象分配内存, 然后将分配到的内存空间都初始化为零值, 然后通过对象头(Object Header)对对象进行一些必要的设置(譬如对象GC分代年龄等等), 最后, 把对象按照程序员的意愿进行初始化(执行`<init>`方法), 这个时候, 从Java程序角度上来讲, 一个新的对象就产生了.而`user`这个引用变量通过`=`指向的就是这个新生成的对象的内存地址.\n\n需要注意的是, 真正的对象是`new User()`, 而`user`表示的是引用.\n\n这时候当我们执行下面的代码\n``` java\nuser = null;\n```\n`null`既不是对象, 也不是类型, 它是一种特殊的值, 这里可以表示为`user`引用没有指向任何对象.但是从内存分配上来说, `new User()`这个对象仍然存在, 只是没有引用指向它.\n``` java\n/**\n     * Returns this reference object's referent.  If this reference object has\n     * been cleared, either by the program or by the garbage collector, then\n     * this method returns <code>null</code>.\n     *\n     * @return   The object to which this reference refers, or\n     *           <code>null</code> if this reference object has been cleared\n     */\n    public T get() {\n        return getReferent();\n    }\n```\n然后我们看下`Reference.get()`返回的是什么, 这个源码的注释给了我们答案, 它指向目标引用地址.那么我们就可以解释, 为什么`user`为空的时候, `userWeakReference.get()`仍然不为空.\n## GC\n我们先复习下GC的一些基础知识\n### 如何判断对象可回收\n在当前常用的虚拟机, 都是使用`可达性分析算法`, 通过可达判断(`GC Root`作为起始点, 引用链向下搜索, 如果对象和GC Root之前没有引用链, 则认为不可达, 即GC可回收)GC是否可以回收.`GC Roots`的对象可包括以下几种:\n- 虚拟机栈中引用的对象\n- 方法区中类静态属性引用的对象\n- 方法区中常量引用的对象\n- 本地方法栈中JNI(Native方法)引用的对象\n\n### 引用级别\n同样, 我们在看下`WeakReference`是什么. 在判断对象的引用链是否可达的时候, 我们都需要用到引用.引用级别可分为四层, 引用强度分别自强到弱\n- 强引用: 代码中最常见的, 譬如上面的`user`就是强引用, 强引用只要存在, GC就永远不会回收它\n- 软引用`SoftReference`: 软引用只有在内存不足时, GC才会回收. 当要发生OOM的时候, GC会把这些对象列进回收范围进行第二次回收, 如果这次回收后还是没有足够的内存, 则会报OOM\n- 弱引用`WeakReference`: 无论内存是否足够, GC肯定会回收. 所以弱引用关联的对象无法存活到下一次GC.`LeakCanary`就是通过使用`WeakReference`和引用队列通过二次回收判定来判断是否存在内存泄漏.\n- 虚引用`PhantomReference`:最弱的一种引用关系, 一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响, 也无法通过虚引用来取得一个对象实例。他存在的唯一目的即是能在这个对象被收集器回收时受到一个系统通知.\n\n## 结论\n  由此可以理解, 当发生GC时, `WeakReference`引用相关的对象就不会再存活, 这也是为什么,上面的代码里, 要等到GC发生后`userWeakReference.get()`才为空.\n\n  从这个问题我们引申出来的还是比较基础的东西, 不过不妨碍我们再去做一次巩固.\n","source":"_posts/谈谈GC和引用.md","raw":"title: 谈谈GC和引用\ndate: 2018-01-12 00:00:00\ncategories :\n- Java\ntags:\n- java\n- JVM\n---\n## 前言\nA拿了一串代码和[一篇文章](http://www.cnblogs.com/absfree/p/5555687.html)来问我,\n\n      ...当productA变为null时（表明它所引用的Product已经无需存在于内存中），这时指向这个Product对象的就是由弱引用对象weakProductA了，那么显然这时候相应的Product对象时弱可达的，\n      所以指向它的弱引用会被清除，这个Product对象随即会被回收，指向它的弱引用对象会进入引用队列中。\n根据文章上述引用内容, 当他在执行下文代码的`putnull`方法时, 为什么`userWeakReference.get()`对象不为null, 难道`userWeakReference.get()` 和 `user` 不是一个对象吗?\n``` java\npublic class MainActivity extends AppCompatActivity {\n    private User user;\n    public static final int period = 2000;\n    private WeakReference<User> userWeakReference;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        user = new User();\n        userWeakReference = new WeakReference<>(user);\n\n        Observable.interval(period, TimeUnit.MILLISECONDS)\n                .subscribe(new Consumer<Long>() {\n                    @Override\n                    public void accept(Long aLong) throws Exception {\n                        Log.d(\"gc\", String.format(\"user is %s null\", (null == user) ? \"\" : \"not\") +\n                                String.format(\" ****\" +\n                                        \" userWeakReference.get() is %s null\", (null == userWeakReference.get()) ? \"\" : \"not\"));\n                    }\n                });\n\n    }\n\n    public void putnull(View view) {\n        Log.i(\"gc\", \"============ user = null ==============\");\n        user = null;\n    }\n\n    public void excutegc(View view) {\n        Log.i(\"gc\", \"========== gc done =============\");\n        System.runFinalization();\n        System.gc();\n\n    }\n}\n```\n<!-- more -->\n我们不妨先看下打印日志![打印日志](./gc.png)\n当`user`为空的时候, `userWeakReference.get()`不为空, 直到GC以后, 才为空.\n## 对象的初始化\n这个问题的道理其实很简单.首先我们来看下下面代码的含义\n``` java\nUser user = new User();\n```\n当虚拟机遇到一条`new`指令的时候, 在类加载检查通过以后, 会为新生对象分配内存, 然后将分配到的内存空间都初始化为零值, 然后通过对象头(Object Header)对对象进行一些必要的设置(譬如对象GC分代年龄等等), 最后, 把对象按照程序员的意愿进行初始化(执行`<init>`方法), 这个时候, 从Java程序角度上来讲, 一个新的对象就产生了.而`user`这个引用变量通过`=`指向的就是这个新生成的对象的内存地址.\n\n需要注意的是, 真正的对象是`new User()`, 而`user`表示的是引用.\n\n这时候当我们执行下面的代码\n``` java\nuser = null;\n```\n`null`既不是对象, 也不是类型, 它是一种特殊的值, 这里可以表示为`user`引用没有指向任何对象.但是从内存分配上来说, `new User()`这个对象仍然存在, 只是没有引用指向它.\n``` java\n/**\n     * Returns this reference object's referent.  If this reference object has\n     * been cleared, either by the program or by the garbage collector, then\n     * this method returns <code>null</code>.\n     *\n     * @return   The object to which this reference refers, or\n     *           <code>null</code> if this reference object has been cleared\n     */\n    public T get() {\n        return getReferent();\n    }\n```\n然后我们看下`Reference.get()`返回的是什么, 这个源码的注释给了我们答案, 它指向目标引用地址.那么我们就可以解释, 为什么`user`为空的时候, `userWeakReference.get()`仍然不为空.\n## GC\n我们先复习下GC的一些基础知识\n### 如何判断对象可回收\n在当前常用的虚拟机, 都是使用`可达性分析算法`, 通过可达判断(`GC Root`作为起始点, 引用链向下搜索, 如果对象和GC Root之前没有引用链, 则认为不可达, 即GC可回收)GC是否可以回收.`GC Roots`的对象可包括以下几种:\n- 虚拟机栈中引用的对象\n- 方法区中类静态属性引用的对象\n- 方法区中常量引用的对象\n- 本地方法栈中JNI(Native方法)引用的对象\n\n### 引用级别\n同样, 我们在看下`WeakReference`是什么. 在判断对象的引用链是否可达的时候, 我们都需要用到引用.引用级别可分为四层, 引用强度分别自强到弱\n- 强引用: 代码中最常见的, 譬如上面的`user`就是强引用, 强引用只要存在, GC就永远不会回收它\n- 软引用`SoftReference`: 软引用只有在内存不足时, GC才会回收. 当要发生OOM的时候, GC会把这些对象列进回收范围进行第二次回收, 如果这次回收后还是没有足够的内存, 则会报OOM\n- 弱引用`WeakReference`: 无论内存是否足够, GC肯定会回收. 所以弱引用关联的对象无法存活到下一次GC.`LeakCanary`就是通过使用`WeakReference`和引用队列通过二次回收判定来判断是否存在内存泄漏.\n- 虚引用`PhantomReference`:最弱的一种引用关系, 一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响, 也无法通过虚引用来取得一个对象实例。他存在的唯一目的即是能在这个对象被收集器回收时受到一个系统通知.\n\n## 结论\n  由此可以理解, 当发生GC时, `WeakReference`引用相关的对象就不会再存活, 这也是为什么,上面的代码里, 要等到GC发生后`userWeakReference.get()`才为空.\n\n  从这个问题我们引申出来的还是比较基础的东西, 不过不妨碍我们再去做一次巩固.\n","slug":"谈谈GC和引用","published":1,"updated":"2018-05-15T09:05:32.477Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjld5agvr000fcqs6hxsdbyb3","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>A拿了一串代码和<a href=\"http://www.cnblogs.com/absfree/p/5555687.html\" target=\"_blank\" rel=\"noopener\">一篇文章</a>来问我,</p>\n<pre><code>...当productA变为null时（表明它所引用的Product已经无需存在于内存中），这时指向这个Product对象的就是由弱引用对象weakProductA了，那么显然这时候相应的Product对象时弱可达的，\n所以指向它的弱引用会被清除，这个Product对象随即会被回收，指向它的弱引用对象会进入引用队列中。\n</code></pre><p>根据文章上述引用内容, 当他在执行下文代码的<code>putnull</code>方法时, 为什么<code>userWeakReference.get()</code>对象不为null, 难道<code>userWeakReference.get()</code> 和 <code>user</code> 不是一个对象吗?<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> User user;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> period = <span class=\"number\">2000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> WeakReference&lt;User&gt; userWeakReference;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\"></span><br><span class=\"line\">        user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">        userWeakReference = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(user);</span><br><span class=\"line\"></span><br><span class=\"line\">        Observable.interval(period, TimeUnit.MILLISECONDS)</span><br><span class=\"line\">                .subscribe(<span class=\"keyword\">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Long aLong)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                        Log.d(<span class=\"string\">\"gc\"</span>, String.format(<span class=\"string\">\"user is %s null\"</span>, (<span class=\"keyword\">null</span> == user) ? <span class=\"string\">\"\"</span> : <span class=\"string\">\"not\"</span>) +</span><br><span class=\"line\">                                String.format(<span class=\"string\">\" ****\"</span> +</span><br><span class=\"line\">                                        <span class=\"string\">\" userWeakReference.get() is %s null\"</span>, (<span class=\"keyword\">null</span> == userWeakReference.get()) ? <span class=\"string\">\"\"</span> : <span class=\"string\">\"not\"</span>));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putnull</span><span class=\"params\">(View view)</span> </span>&#123;</span><br><span class=\"line\">        Log.i(<span class=\"string\">\"gc\"</span>, <span class=\"string\">\"============ user = null ==============\"</span>);</span><br><span class=\"line\">        user = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">excutegc</span><span class=\"params\">(View view)</span> </span>&#123;</span><br><span class=\"line\">        Log.i(<span class=\"string\">\"gc\"</span>, <span class=\"string\">\"========== gc done =============\"</span>);</span><br><span class=\"line\">        System.runFinalization();</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>我们不妨先看下打印日志<img src=\"./gc.png\" alt=\"打印日志\"><br>当<code>user</code>为空的时候, <code>userWeakReference.get()</code>不为空, 直到GC以后, 才为空.</p>\n<h2 id=\"对象的初始化\"><a href=\"#对象的初始化\" class=\"headerlink\" title=\"对象的初始化\"></a>对象的初始化</h2><p>这个问题的道理其实很简单.首先我们来看下下面代码的含义<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">User user = <span class=\"keyword\">new</span> User();</span><br></pre></td></tr></table></figure></p>\n<p>当虚拟机遇到一条<code>new</code>指令的时候, 在类加载检查通过以后, 会为新生对象分配内存, 然后将分配到的内存空间都初始化为零值, 然后通过对象头(Object Header)对对象进行一些必要的设置(譬如对象GC分代年龄等等), 最后, 把对象按照程序员的意愿进行初始化(执行<code>&lt;init&gt;</code>方法), 这个时候, 从Java程序角度上来讲, 一个新的对象就产生了.而<code>user</code>这个引用变量通过<code>=</code>指向的就是这个新生成的对象的内存地址.</p>\n<p>需要注意的是, 真正的对象是<code>new User()</code>, 而<code>user</code>表示的是引用.</p>\n<p>这时候当我们执行下面的代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure></p>\n<p><code>null</code>既不是对象, 也不是类型, 它是一种特殊的值, 这里可以表示为<code>user</code>引用没有指向任何对象.但是从内存分配上来说, <code>new User()</code>这个对象仍然存在, 只是没有引用指向它.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns this reference object's referent.  If this reference object has</span></span><br><span class=\"line\"><span class=\"comment\">     * been cleared, either by the program or by the garbage collector, then</span></span><br><span class=\"line\"><span class=\"comment\">     * this method returns &lt;code&gt;null&lt;/code&gt;.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span>   The object to which this reference refers, or</span></span><br><span class=\"line\"><span class=\"comment\">     *           &lt;code&gt;null&lt;/code&gt; if this reference object has been cleared</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getReferent();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后我们看下<code>Reference.get()</code>返回的是什么, 这个源码的注释给了我们答案, 它指向目标引用地址.那么我们就可以解释, 为什么<code>user</code>为空的时候, <code>userWeakReference.get()</code>仍然不为空.</p>\n<h2 id=\"GC\"><a href=\"#GC\" class=\"headerlink\" title=\"GC\"></a>GC</h2><p>我们先复习下GC的一些基础知识</p>\n<h3 id=\"如何判断对象可回收\"><a href=\"#如何判断对象可回收\" class=\"headerlink\" title=\"如何判断对象可回收\"></a>如何判断对象可回收</h3><p>在当前常用的虚拟机, 都是使用<code>可达性分析算法</code>, 通过可达判断(<code>GC Root</code>作为起始点, 引用链向下搜索, 如果对象和GC Root之前没有引用链, 则认为不可达, 即GC可回收)GC是否可以回收.<code>GC Roots</code>的对象可包括以下几种:</p>\n<ul>\n<li>虚拟机栈中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中JNI(Native方法)引用的对象</li>\n</ul>\n<h3 id=\"引用级别\"><a href=\"#引用级别\" class=\"headerlink\" title=\"引用级别\"></a>引用级别</h3><p>同样, 我们在看下<code>WeakReference</code>是什么. 在判断对象的引用链是否可达的时候, 我们都需要用到引用.引用级别可分为四层, 引用强度分别自强到弱</p>\n<ul>\n<li>强引用: 代码中最常见的, 譬如上面的<code>user</code>就是强引用, 强引用只要存在, GC就永远不会回收它</li>\n<li>软引用<code>SoftReference</code>: 软引用只有在内存不足时, GC才会回收. 当要发生OOM的时候, GC会把这些对象列进回收范围进行第二次回收, 如果这次回收后还是没有足够的内存, 则会报OOM</li>\n<li>弱引用<code>WeakReference</code>: 无论内存是否足够, GC肯定会回收. 所以弱引用关联的对象无法存活到下一次GC.<code>LeakCanary</code>就是通过使用<code>WeakReference</code>和引用队列通过二次回收判定来判断是否存在内存泄漏.</li>\n<li>虚引用<code>PhantomReference</code>:最弱的一种引用关系, 一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响, 也无法通过虚引用来取得一个对象实例。他存在的唯一目的即是能在这个对象被收集器回收时受到一个系统通知.</li>\n</ul>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>  由此可以理解, 当发生GC时, <code>WeakReference</code>引用相关的对象就不会再存活, 这也是为什么,上面的代码里, 要等到GC发生后<code>userWeakReference.get()</code>才为空.</p>\n<p>  从这个问题我们引申出来的还是比较基础的东西, 不过不妨碍我们再去做一次巩固.</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>A拿了一串代码和<a href=\"http://www.cnblogs.com/absfree/p/5555687.html\" target=\"_blank\" rel=\"noopener\">一篇文章</a>来问我,</p>\n<pre><code>...当productA变为null时（表明它所引用的Product已经无需存在于内存中），这时指向这个Product对象的就是由弱引用对象weakProductA了，那么显然这时候相应的Product对象时弱可达的，\n所以指向它的弱引用会被清除，这个Product对象随即会被回收，指向它的弱引用对象会进入引用队列中。\n</code></pre><p>根据文章上述引用内容, 当他在执行下文代码的<code>putnull</code>方法时, 为什么<code>userWeakReference.get()</code>对象不为null, 难道<code>userWeakReference.get()</code> 和 <code>user</code> 不是一个对象吗?<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> User user;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> period = <span class=\"number\">2000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> WeakReference&lt;User&gt; userWeakReference;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\"></span><br><span class=\"line\">        user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">        userWeakReference = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(user);</span><br><span class=\"line\"></span><br><span class=\"line\">        Observable.interval(period, TimeUnit.MILLISECONDS)</span><br><span class=\"line\">                .subscribe(<span class=\"keyword\">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Long aLong)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                        Log.d(<span class=\"string\">\"gc\"</span>, String.format(<span class=\"string\">\"user is %s null\"</span>, (<span class=\"keyword\">null</span> == user) ? <span class=\"string\">\"\"</span> : <span class=\"string\">\"not\"</span>) +</span><br><span class=\"line\">                                String.format(<span class=\"string\">\" ****\"</span> +</span><br><span class=\"line\">                                        <span class=\"string\">\" userWeakReference.get() is %s null\"</span>, (<span class=\"keyword\">null</span> == userWeakReference.get()) ? <span class=\"string\">\"\"</span> : <span class=\"string\">\"not\"</span>));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putnull</span><span class=\"params\">(View view)</span> </span>&#123;</span><br><span class=\"line\">        Log.i(<span class=\"string\">\"gc\"</span>, <span class=\"string\">\"============ user = null ==============\"</span>);</span><br><span class=\"line\">        user = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">excutegc</span><span class=\"params\">(View view)</span> </span>&#123;</span><br><span class=\"line\">        Log.i(<span class=\"string\">\"gc\"</span>, <span class=\"string\">\"========== gc done =============\"</span>);</span><br><span class=\"line\">        System.runFinalization();</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>","more":"<p>我们不妨先看下打印日志<img src=\"./gc.png\" alt=\"打印日志\"><br>当<code>user</code>为空的时候, <code>userWeakReference.get()</code>不为空, 直到GC以后, 才为空.</p>\n<h2 id=\"对象的初始化\"><a href=\"#对象的初始化\" class=\"headerlink\" title=\"对象的初始化\"></a>对象的初始化</h2><p>这个问题的道理其实很简单.首先我们来看下下面代码的含义<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">User user = <span class=\"keyword\">new</span> User();</span><br></pre></td></tr></table></figure></p>\n<p>当虚拟机遇到一条<code>new</code>指令的时候, 在类加载检查通过以后, 会为新生对象分配内存, 然后将分配到的内存空间都初始化为零值, 然后通过对象头(Object Header)对对象进行一些必要的设置(譬如对象GC分代年龄等等), 最后, 把对象按照程序员的意愿进行初始化(执行<code>&lt;init&gt;</code>方法), 这个时候, 从Java程序角度上来讲, 一个新的对象就产生了.而<code>user</code>这个引用变量通过<code>=</code>指向的就是这个新生成的对象的内存地址.</p>\n<p>需要注意的是, 真正的对象是<code>new User()</code>, 而<code>user</code>表示的是引用.</p>\n<p>这时候当我们执行下面的代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure></p>\n<p><code>null</code>既不是对象, 也不是类型, 它是一种特殊的值, 这里可以表示为<code>user</code>引用没有指向任何对象.但是从内存分配上来说, <code>new User()</code>这个对象仍然存在, 只是没有引用指向它.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns this reference object's referent.  If this reference object has</span></span><br><span class=\"line\"><span class=\"comment\">     * been cleared, either by the program or by the garbage collector, then</span></span><br><span class=\"line\"><span class=\"comment\">     * this method returns &lt;code&gt;null&lt;/code&gt;.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span>   The object to which this reference refers, or</span></span><br><span class=\"line\"><span class=\"comment\">     *           &lt;code&gt;null&lt;/code&gt; if this reference object has been cleared</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getReferent();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后我们看下<code>Reference.get()</code>返回的是什么, 这个源码的注释给了我们答案, 它指向目标引用地址.那么我们就可以解释, 为什么<code>user</code>为空的时候, <code>userWeakReference.get()</code>仍然不为空.</p>\n<h2 id=\"GC\"><a href=\"#GC\" class=\"headerlink\" title=\"GC\"></a>GC</h2><p>我们先复习下GC的一些基础知识</p>\n<h3 id=\"如何判断对象可回收\"><a href=\"#如何判断对象可回收\" class=\"headerlink\" title=\"如何判断对象可回收\"></a>如何判断对象可回收</h3><p>在当前常用的虚拟机, 都是使用<code>可达性分析算法</code>, 通过可达判断(<code>GC Root</code>作为起始点, 引用链向下搜索, 如果对象和GC Root之前没有引用链, 则认为不可达, 即GC可回收)GC是否可以回收.<code>GC Roots</code>的对象可包括以下几种:</p>\n<ul>\n<li>虚拟机栈中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中JNI(Native方法)引用的对象</li>\n</ul>\n<h3 id=\"引用级别\"><a href=\"#引用级别\" class=\"headerlink\" title=\"引用级别\"></a>引用级别</h3><p>同样, 我们在看下<code>WeakReference</code>是什么. 在判断对象的引用链是否可达的时候, 我们都需要用到引用.引用级别可分为四层, 引用强度分别自强到弱</p>\n<ul>\n<li>强引用: 代码中最常见的, 譬如上面的<code>user</code>就是强引用, 强引用只要存在, GC就永远不会回收它</li>\n<li>软引用<code>SoftReference</code>: 软引用只有在内存不足时, GC才会回收. 当要发生OOM的时候, GC会把这些对象列进回收范围进行第二次回收, 如果这次回收后还是没有足够的内存, 则会报OOM</li>\n<li>弱引用<code>WeakReference</code>: 无论内存是否足够, GC肯定会回收. 所以弱引用关联的对象无法存活到下一次GC.<code>LeakCanary</code>就是通过使用<code>WeakReference</code>和引用队列通过二次回收判定来判断是否存在内存泄漏.</li>\n<li>虚引用<code>PhantomReference</code>:最弱的一种引用关系, 一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响, 也无法通过虚引用来取得一个对象实例。他存在的唯一目的即是能在这个对象被收集器回收时受到一个系统通知.</li>\n</ul>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>  由此可以理解, 当发生GC时, <code>WeakReference</code>引用相关的对象就不会再存活, 这也是为什么,上面的代码里, 要等到GC发生后<code>userWeakReference.get()</code>才为空.</p>\n<p>  从这个问题我们引申出来的还是比较基础的东西, 不过不妨碍我们再去做一次巩固.</p>"},{"title":"ArrayList源码解析","date":"2018-04-25T16:00:00.000Z","_content":"## 前言\n每个`ArrayList`都有一个容量(capacity)的含义, 他接近于本身队列长度大小, 基本每个元素在新增的时候,都可以做到自动扩容.本篇主要是了解他的扩容机制.本篇源码以openjdk8为准\n<!-- more -->\n## 构造\n`ArrayList`实现了`Serializable`接口, 说明它是支持序列化的, 在它的内部有个`elementData`数组对象元素用来实现内存中的元素缓存, 它的长度相当于就是ArrayList的长度.这里有个关于`transient`关键字的知识点, 它保证了`elementData`不会被序列化, 使得它的生命周期保在调用者的内存中而不会被保存在磁盘中.\n``` java\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable{\n          transient Object[] elementData;\n        }\n```\n首先我们看下, 日常开发中我们最常用到的无参构造函数, 它主要做的就是将`elementData`引用指向默认静态的一个空数组.\n``` java\npublic ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n```\n还有其他的两个构造函数, 一个是可以初始定义队列的容量, 当传入的`initialCapacity`为负数的时候, 会抛出异常.要注意的是, 当定义的初始容量为0的时候, `elementData`指向的是另外一个空数组`EMPTY_ELEMENTDATA`, 具体为什么要区分两个静态空数组实例, 留在后面的扩容机制上说明.\n``` java\npublic ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n```\n最后一个构造函数式可以直接传集合进去, `elementData`引用指向传入的集合数组, 当集合长度为`0`的时候, 仍然会使它指向 `EMPTY_ELEMENTDATA`空数组.而当传入的集合有元素的情况下, 从注释上看是为了处理6260652的bug, 所以需要判断不是`Object[]`的情况下的时候, 使用`Arrays`内部实现的拷贝的方法`copyOf`进行元素的拷贝.\n``` java\n    public ArrayList(Collection<? extends E> c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n```\n具体我们可以稍微看下`Arrays.copyOf`的源码, 后面会发现他是内部核心调用方法, 可以看出每次调用的时候, 实际是实例化了一个新的数组, 将原来的数组元素填充进去实现了copy的目的.\n``` java\npublic static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {\n        @SuppressWarnings(\"unchecked\")\n        T[] copy = ((Object)newType == (Object)Object[].class)\n            ? (T[]) new Object[newLength]\n            : (T[]) Array.newInstance(newType.getComponentType(), newLength);\n        System.arraycopy(original, 0, copy, 0,\n                         Math.min(original.length, newLength));\n        return copy;\n    }\n```\n## add\n我们首先看下几个add的方法, 其实内部实现的原理都不会错过扩容的操作, 所以我们具体看下扩容的原理.\n``` java\npublic boolean add(E e) {\n        // size为arrayList的长度大小\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        elementData[size++] = e;\n        return true;\n    }\n\npublic void add(int index, E element) {\n    if (index > size || index < 0)\n        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n\n    // 容量确保\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    // 空出index位, 进行拷贝\n    System.arraycopy(elementData, index, elementData, index + 1,\n                     size - index);\n    // 根据索引获取数组index位进行赋值\n    elementData[index] = element;\n    // 长度 + 1\n    size++;\n}\n```\n首先, 每次都需要调用到`ensureCapacityInternal`, 进行容量的确定\n``` java\n/**\n     * 确保内部容量大小\n     * @param minCapacity\n     */\n    private void ensureCapacityInternal(int minCapacity) {\n        // 当调用ArrayList()构造函数, 内部维护的数组是DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n        // 则minCapacity = 10\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n        // minCapacity为10 或者为 size + 1\n        ensureExplicitCapacity(minCapacity);\n    }\n```\n这里可以看到, 当内部管理数组`elementData`指向内存地址与`DEFAULTCAPACITY_EMPTY_ELEMENTDATA`默认空数组实例相等的时候, 最小的容量会以传入的最小容量和默认容量(10)的最大值为准, 同时, 这里可以了解到, 区分两个空数组的实例, 就是为了扩容的时候确定容量的时候, 可以区分到调用无参构造函数的arrayList, 在第一次添加元素的时候, 可以保证他的容量首先是10(`DEFAULT_CAPACITY`)).然后再是调用到`ensureExplicitCapacity`方法.\n``` java\nprivate void ensureExplicitCapacity(int minCapacity) {\n        // 操作数记录\n        modCount++;\n\n        // overflow-conscious code\n        // 如果 当前数组的长度比添加元素后的长度要小则进行扩容\n        if (minCapacity - elementData.length > 0)\n            grow(minCapacity);\n    }\n```\n当内部当前管理的数组`elementData`的长度小于添加元素后的长度, 则需要进行真正的扩容方法`grow`\n\n可以看到, 每次容量是根据原来容量的1.5倍来扩充的, 当扩充后的容量仍然没有加入新元素后的长度大的时候, 那么直接扩容到加入后的长度.\n\n而实现扩容的真正机制, 其实还是调用了`Arrays.copyOf`方法, 声明了目标容量的数组, 进行元素拷贝. 这样的话, 其实每次`ArrayList`的内部元素变化的时候, 都会存在相对的内存开销.\n``` java\n/**\n     * 将原来的数组, 拷贝到一个扩容后新长度的数组内\n     * Increases the capacity to ensure that it can hold at least the\n     * number of elements specified by the minimum capacity argument.\n     *\n     * @param minCapacity the desired minimum capacity\n     */\n    private void grow(int minCapacity) {\n        // overflow-conscious code\n        int oldCapacity = elementData.length;\n        // oldCapacity >> 1 相当于 oldCapacity / 2\n        // 新容量为老容量的1.5倍\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        // 如果扩容后容量比添加元素后的长度小\n        if (newCapacity - minCapacity < 0)\n            // 直接扩容到添加元素后的长度大小\n            newCapacity = minCapacity;\n        // 新容量大小比 MAX_ARRAY_SIZE 大\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        // 构建newCapacity长度的新数组, elementData指向它\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\nprivate static int hugeCapacity(int minCapacity) {\n    if (minCapacity < 0) // overflow\n        throw new OutOfMemoryError();\n    // 如果是添加元素后的长度大于 MAX_ARRAY_SIZE, 则容量设为Integer的最大. 否则 -8\n    return (minCapacity > MAX_ARRAY_SIZE) ?\n        Integer.MAX_VALUE :\n        MAX_ARRAY_SIZE;\n}\n```\n## remove\n搞懂扩容机制后, 我们可以对应看下其他我们常用的API, 首先看下`remove`相关, 可以看出在移除元素的时候, 其实实际上我们还是做了个拷贝的动作, 将除去移除目标元素的数组其他元素, 拷贝到新的数组中, 同时, 这个时候容量其实是没有变的.\n``` java\npublic E remove(int index) {\n        if (index >= size)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n\n        modCount++;\n        E oldValue = (E) elementData[index];\n\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n\n        return oldValue;\n    }\n\npublic boolean remove(Object o) {\n        if (o == null) {\n            for (int index = 0; index < size; index++)\n                if (elementData[index] == null) {\n                    fastRemove(index);\n                    return true;\n                }\n        } else {\n            for (int index = 0; index < size; index++)\n                if (o.equals(elementData[index])) {\n                    fastRemove(index);\n                    return true;\n                }\n        }\n        return false;\n    }\nprivate void fastRemove(int index) {\n    // 操作数的新增\n    modCount++;\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        System.arraycopy(elementData, index+1, elementData, index,\n                         numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n}\n```\n## 其他\n我们在看下`get`和`contains`是怎么实现的\n``` java\npublic E get(int index) {\n        if (index >= size)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n\n        return (E) elementData[index];\n    }\n```\n可以看到`get`的方法, 实际就是对于内部数组的索引查找\n``` java\npublic boolean contains(Object o) {\n        return indexOf(o) >= 0;\n    }\n\npublic int indexOf(Object o) {\n    if (o == null) {\n        for (int i = 0; i < size; i++)\n            if (elementData[i]==null)\n                return i;\n    } else {\n        for (int i = 0; i < size; i++)\n            if (o.equals(elementData[i]))\n                return i;\n    }\n    return -1;\n}\n```\n而`contains(Object o)`方法其实做的就是对内部数组进行遍历查找.\n## 总结\n考量到使用无参构造函数的时候, 当添加元素的时候, 初始容量为10, 以10为基准进行1.5倍的扩容, 通过源码的解读, 我们可以就可以进行一定的内存优化, 譬如在使用ArrayList的时候, 就应该避免使用无参构造函数, 尽量多的给它定义明确的初始容量, 一个是可以导致不会有过多的内存空间被浪费, 另外一个是可以减少调用到`System.arraycopy`native方法, 保证了一定的内存开销的节省.\n","source":"_posts/ArrayList源码解析.md","raw":"title: ArrayList源码解析\ndate: 2018-04-26 00:00:00\ncategories:  \n- 源码解析\ntags:\n- Java\n- 源码解析\n---\n## 前言\n每个`ArrayList`都有一个容量(capacity)的含义, 他接近于本身队列长度大小, 基本每个元素在新增的时候,都可以做到自动扩容.本篇主要是了解他的扩容机制.本篇源码以openjdk8为准\n<!-- more -->\n## 构造\n`ArrayList`实现了`Serializable`接口, 说明它是支持序列化的, 在它的内部有个`elementData`数组对象元素用来实现内存中的元素缓存, 它的长度相当于就是ArrayList的长度.这里有个关于`transient`关键字的知识点, 它保证了`elementData`不会被序列化, 使得它的生命周期保在调用者的内存中而不会被保存在磁盘中.\n``` java\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable{\n          transient Object[] elementData;\n        }\n```\n首先我们看下, 日常开发中我们最常用到的无参构造函数, 它主要做的就是将`elementData`引用指向默认静态的一个空数组.\n``` java\npublic ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n```\n还有其他的两个构造函数, 一个是可以初始定义队列的容量, 当传入的`initialCapacity`为负数的时候, 会抛出异常.要注意的是, 当定义的初始容量为0的时候, `elementData`指向的是另外一个空数组`EMPTY_ELEMENTDATA`, 具体为什么要区分两个静态空数组实例, 留在后面的扩容机制上说明.\n``` java\npublic ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n```\n最后一个构造函数式可以直接传集合进去, `elementData`引用指向传入的集合数组, 当集合长度为`0`的时候, 仍然会使它指向 `EMPTY_ELEMENTDATA`空数组.而当传入的集合有元素的情况下, 从注释上看是为了处理6260652的bug, 所以需要判断不是`Object[]`的情况下的时候, 使用`Arrays`内部实现的拷贝的方法`copyOf`进行元素的拷贝.\n``` java\n    public ArrayList(Collection<? extends E> c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n```\n具体我们可以稍微看下`Arrays.copyOf`的源码, 后面会发现他是内部核心调用方法, 可以看出每次调用的时候, 实际是实例化了一个新的数组, 将原来的数组元素填充进去实现了copy的目的.\n``` java\npublic static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {\n        @SuppressWarnings(\"unchecked\")\n        T[] copy = ((Object)newType == (Object)Object[].class)\n            ? (T[]) new Object[newLength]\n            : (T[]) Array.newInstance(newType.getComponentType(), newLength);\n        System.arraycopy(original, 0, copy, 0,\n                         Math.min(original.length, newLength));\n        return copy;\n    }\n```\n## add\n我们首先看下几个add的方法, 其实内部实现的原理都不会错过扩容的操作, 所以我们具体看下扩容的原理.\n``` java\npublic boolean add(E e) {\n        // size为arrayList的长度大小\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        elementData[size++] = e;\n        return true;\n    }\n\npublic void add(int index, E element) {\n    if (index > size || index < 0)\n        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n\n    // 容量确保\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    // 空出index位, 进行拷贝\n    System.arraycopy(elementData, index, elementData, index + 1,\n                     size - index);\n    // 根据索引获取数组index位进行赋值\n    elementData[index] = element;\n    // 长度 + 1\n    size++;\n}\n```\n首先, 每次都需要调用到`ensureCapacityInternal`, 进行容量的确定\n``` java\n/**\n     * 确保内部容量大小\n     * @param minCapacity\n     */\n    private void ensureCapacityInternal(int minCapacity) {\n        // 当调用ArrayList()构造函数, 内部维护的数组是DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n        // 则minCapacity = 10\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n        // minCapacity为10 或者为 size + 1\n        ensureExplicitCapacity(minCapacity);\n    }\n```\n这里可以看到, 当内部管理数组`elementData`指向内存地址与`DEFAULTCAPACITY_EMPTY_ELEMENTDATA`默认空数组实例相等的时候, 最小的容量会以传入的最小容量和默认容量(10)的最大值为准, 同时, 这里可以了解到, 区分两个空数组的实例, 就是为了扩容的时候确定容量的时候, 可以区分到调用无参构造函数的arrayList, 在第一次添加元素的时候, 可以保证他的容量首先是10(`DEFAULT_CAPACITY`)).然后再是调用到`ensureExplicitCapacity`方法.\n``` java\nprivate void ensureExplicitCapacity(int minCapacity) {\n        // 操作数记录\n        modCount++;\n\n        // overflow-conscious code\n        // 如果 当前数组的长度比添加元素后的长度要小则进行扩容\n        if (minCapacity - elementData.length > 0)\n            grow(minCapacity);\n    }\n```\n当内部当前管理的数组`elementData`的长度小于添加元素后的长度, 则需要进行真正的扩容方法`grow`\n\n可以看到, 每次容量是根据原来容量的1.5倍来扩充的, 当扩充后的容量仍然没有加入新元素后的长度大的时候, 那么直接扩容到加入后的长度.\n\n而实现扩容的真正机制, 其实还是调用了`Arrays.copyOf`方法, 声明了目标容量的数组, 进行元素拷贝. 这样的话, 其实每次`ArrayList`的内部元素变化的时候, 都会存在相对的内存开销.\n``` java\n/**\n     * 将原来的数组, 拷贝到一个扩容后新长度的数组内\n     * Increases the capacity to ensure that it can hold at least the\n     * number of elements specified by the minimum capacity argument.\n     *\n     * @param minCapacity the desired minimum capacity\n     */\n    private void grow(int minCapacity) {\n        // overflow-conscious code\n        int oldCapacity = elementData.length;\n        // oldCapacity >> 1 相当于 oldCapacity / 2\n        // 新容量为老容量的1.5倍\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        // 如果扩容后容量比添加元素后的长度小\n        if (newCapacity - minCapacity < 0)\n            // 直接扩容到添加元素后的长度大小\n            newCapacity = minCapacity;\n        // 新容量大小比 MAX_ARRAY_SIZE 大\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        // 构建newCapacity长度的新数组, elementData指向它\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\nprivate static int hugeCapacity(int minCapacity) {\n    if (minCapacity < 0) // overflow\n        throw new OutOfMemoryError();\n    // 如果是添加元素后的长度大于 MAX_ARRAY_SIZE, 则容量设为Integer的最大. 否则 -8\n    return (minCapacity > MAX_ARRAY_SIZE) ?\n        Integer.MAX_VALUE :\n        MAX_ARRAY_SIZE;\n}\n```\n## remove\n搞懂扩容机制后, 我们可以对应看下其他我们常用的API, 首先看下`remove`相关, 可以看出在移除元素的时候, 其实实际上我们还是做了个拷贝的动作, 将除去移除目标元素的数组其他元素, 拷贝到新的数组中, 同时, 这个时候容量其实是没有变的.\n``` java\npublic E remove(int index) {\n        if (index >= size)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n\n        modCount++;\n        E oldValue = (E) elementData[index];\n\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n\n        return oldValue;\n    }\n\npublic boolean remove(Object o) {\n        if (o == null) {\n            for (int index = 0; index < size; index++)\n                if (elementData[index] == null) {\n                    fastRemove(index);\n                    return true;\n                }\n        } else {\n            for (int index = 0; index < size; index++)\n                if (o.equals(elementData[index])) {\n                    fastRemove(index);\n                    return true;\n                }\n        }\n        return false;\n    }\nprivate void fastRemove(int index) {\n    // 操作数的新增\n    modCount++;\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        System.arraycopy(elementData, index+1, elementData, index,\n                         numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n}\n```\n## 其他\n我们在看下`get`和`contains`是怎么实现的\n``` java\npublic E get(int index) {\n        if (index >= size)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n\n        return (E) elementData[index];\n    }\n```\n可以看到`get`的方法, 实际就是对于内部数组的索引查找\n``` java\npublic boolean contains(Object o) {\n        return indexOf(o) >= 0;\n    }\n\npublic int indexOf(Object o) {\n    if (o == null) {\n        for (int i = 0; i < size; i++)\n            if (elementData[i]==null)\n                return i;\n    } else {\n        for (int i = 0; i < size; i++)\n            if (o.equals(elementData[i]))\n                return i;\n    }\n    return -1;\n}\n```\n而`contains(Object o)`方法其实做的就是对内部数组进行遍历查找.\n## 总结\n考量到使用无参构造函数的时候, 当添加元素的时候, 初始容量为10, 以10为基准进行1.5倍的扩容, 通过源码的解读, 我们可以就可以进行一定的内存优化, 譬如在使用ArrayList的时候, 就应该避免使用无参构造函数, 尽量多的给它定义明确的初始容量, 一个是可以导致不会有过多的内存空间被浪费, 另外一个是可以减少调用到`System.arraycopy`native方法, 保证了一定的内存开销的节省.\n","slug":"ArrayList源码解析","published":1,"updated":"2018-05-07T02:04:20.166Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjld5ah2h001acqs6sxqrxsaz","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>每个<code>ArrayList</code>都有一个容量(capacity)的含义, 他接近于本身队列长度大小, 基本每个元素在新增的时候,都可以做到自动扩容.本篇主要是了解他的扩容机制.本篇源码以openjdk8为准<br><a id=\"more\"></a></p>\n<h2 id=\"构造\"><a href=\"#构造\" class=\"headerlink\" title=\"构造\"></a>构造</h2><p><code>ArrayList</code>实现了<code>Serializable</code>接口, 说明它是支持序列化的, 在它的内部有个<code>elementData</code>数组对象元素用来实现内存中的元素缓存, 它的长度相当于就是ArrayList的长度.这里有个关于<code>transient</code>关键字的知识点, 它保证了<code>elementData</code>不会被序列化, 使得它的生命周期保在调用者的内存中而不会被保存在磁盘中.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">RandomAccess</span>, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">transient</span> Object[] elementData;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先我们看下, 日常开发中我们最常用到的无参构造函数, 它主要做的就是将<code>elementData</code>引用指向默认静态的一个空数组.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>还有其他的两个构造函数, 一个是可以初始定义队列的容量, 当传入的<code>initialCapacity</code>为负数的时候, 会抛出异常.要注意的是, 当定义的初始容量为0的时候, <code>elementData</code>指向的是另外一个空数组<code>EMPTY_ELEMENTDATA</code>, 具体为什么要区分两个静态空数组实例, 留在后面的扩容机制上说明.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+</span><br><span class=\"line\">                                               initialCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后一个构造函数式可以直接传集合进去, <code>elementData</code>引用指向传入的集合数组, 当集合长度为<code>0</code>的时候, 仍然会使它指向 <code>EMPTY_ELEMENTDATA</code>空数组.而当传入的集合有元素的情况下, 从注释上看是为了处理6260652的bug, 所以需要判断不是<code>Object[]</code>的情况下的时候, 使用<code>Arrays</code>内部实现的拷贝的方法<code>copyOf</code>进行元素的拷贝.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    elementData = c.toArray();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// replace with empty array.</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>具体我们可以稍微看下<code>Arrays.copyOf</code>的源码, 后面会发现他是内部核心调用方法, 可以看出每次调用的时候, 实际是实例化了一个新的数组, 将原来的数组元素填充进去实现了copy的目的.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class=\"keyword\">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">        T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class=\"line\">            ? (T[]) <span class=\"keyword\">new</span> Object[newLength]</span><br><span class=\"line\">            : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class=\"line\">        System.arraycopy(original, <span class=\"number\">0</span>, copy, <span class=\"number\">0</span>,</span><br><span class=\"line\">                         Math.min(original.length, newLength));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> copy;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add\"></a>add</h2><p>我们首先看下几个add的方法, 其实内部实现的原理都不会错过扩容的操作, 所以我们具体看下扩容的原理.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// size为arrayList的长度大小</span></span><br><span class=\"line\">        ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">        elementData[size++] = e;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt; size || index &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 容量确保</span></span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    <span class=\"comment\">// 空出index位, 进行拷贝</span></span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>,</span><br><span class=\"line\">                     size - index);</span><br><span class=\"line\">    <span class=\"comment\">// 根据索引获取数组index位进行赋值</span></span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    <span class=\"comment\">// 长度 + 1</span></span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先, 每次都需要调用到<code>ensureCapacityInternal</code>, 进行容量的确定<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 确保内部容量大小</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> minCapacity</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当调用ArrayList()构造函数, 内部维护的数组是DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class=\"line\">        <span class=\"comment\">// 则minCapacity = 10</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// minCapacity为10 或者为 size + 1</span></span><br><span class=\"line\">        ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里可以看到, 当内部管理数组<code>elementData</code>指向内存地址与<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>默认空数组实例相等的时候, 最小的容量会以传入的最小容量和默认容量(10)的最大值为准, 同时, 这里可以了解到, 区分两个空数组的实例, 就是为了扩容的时候确定容量的时候, 可以区分到调用无参构造函数的arrayList, 在第一次添加元素的时候, 可以保证他的容量首先是10(<code>DEFAULT_CAPACITY</code>)).然后再是调用到<code>ensureExplicitCapacity</code>方法.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 操作数记录</span></span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果 当前数组的长度比添加元素后的长度要小则进行扩容</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            grow(minCapacity);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>当内部当前管理的数组<code>elementData</code>的长度小于添加元素后的长度, 则需要进行真正的扩容方法<code>grow</code></p>\n<p>可以看到, 每次容量是根据原来容量的1.5倍来扩充的, 当扩充后的容量仍然没有加入新元素后的长度大的时候, 那么直接扩容到加入后的长度.</p>\n<p>而实现扩容的真正机制, 其实还是调用了<code>Arrays.copyOf</code>方法, 声明了目标容量的数组, 进行元素拷贝. 这样的话, 其实每次<code>ArrayList</code>的内部元素变化的时候, 都会存在相对的内存开销.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将原来的数组, 拷贝到一个扩容后新长度的数组内</span></span><br><span class=\"line\"><span class=\"comment\">     * Increases the capacity to ensure that it can hold at least the</span></span><br><span class=\"line\"><span class=\"comment\">     * number of elements specified by the minimum capacity argument.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> minCapacity the desired minimum capacity</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">        <span class=\"comment\">// oldCapacity &gt;&gt; 1 相当于 oldCapacity / 2</span></span><br><span class=\"line\">        <span class=\"comment\">// 新容量为老容量的1.5倍</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 如果扩容后容量比添加元素后的长度小</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\">// 直接扩容到添加元素后的长度大小</span></span><br><span class=\"line\">            newCapacity = minCapacity;</span><br><span class=\"line\">        <span class=\"comment\">// 新容量大小比 MAX_ARRAY_SIZE 大</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">        <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">        <span class=\"comment\">// 构建newCapacity长度的新数组, elementData指向它</span></span><br><span class=\"line\">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();</span><br><span class=\"line\">    <span class=\"comment\">// 如果是添加元素后的长度大于 MAX_ARRAY_SIZE, 则容量设为Integer的最大. 否则 -8</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">        Integer.MAX_VALUE :</span><br><span class=\"line\">        MAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove\"></a>remove</h2><p>搞懂扩容机制后, 我们可以对应看下其他我们常用的API, 首先看下<code>remove</code>相关, 可以看出在移除元素的时候, 其实实际上我们还是做了个拷贝的动作, 将除去移除目标元素的数组其他元素, 拷贝到新的数组中, 同时, 这个时候容量其实是没有变的.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt;= size)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\"></span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        E oldValue = (E) elementData[index];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                             numMoved);</span><br><span class=\"line\">        elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (elementData[index] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    fastRemove(index);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(elementData[index])) &#123;</span><br><span class=\"line\">                    fastRemove(index);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fastRemove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 操作数的新增</span></span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                         numMoved);</span><br><span class=\"line\">    elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>我们在看下<code>get</code>和<code>contains</code>是怎么实现的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt;= size)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (E) elementData[index];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到<code>get</code>的方法, 实际就是对于内部数组的索引查找<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> indexOf(o) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elementData[i]==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(elementData[i]))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>而<code>contains(Object o)</code>方法其实做的就是对内部数组进行遍历查找.</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>考量到使用无参构造函数的时候, 当添加元素的时候, 初始容量为10, 以10为基准进行1.5倍的扩容, 通过源码的解读, 我们可以就可以进行一定的内存优化, 譬如在使用ArrayList的时候, 就应该避免使用无参构造函数, 尽量多的给它定义明确的初始容量, 一个是可以导致不会有过多的内存空间被浪费, 另外一个是可以减少调用到<code>System.arraycopy</code>native方法, 保证了一定的内存开销的节省.</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>每个<code>ArrayList</code>都有一个容量(capacity)的含义, 他接近于本身队列长度大小, 基本每个元素在新增的时候,都可以做到自动扩容.本篇主要是了解他的扩容机制.本篇源码以openjdk8为准<br>","more":"</p>\n<h2 id=\"构造\"><a href=\"#构造\" class=\"headerlink\" title=\"构造\"></a>构造</h2><p><code>ArrayList</code>实现了<code>Serializable</code>接口, 说明它是支持序列化的, 在它的内部有个<code>elementData</code>数组对象元素用来实现内存中的元素缓存, 它的长度相当于就是ArrayList的长度.这里有个关于<code>transient</code>关键字的知识点, 它保证了<code>elementData</code>不会被序列化, 使得它的生命周期保在调用者的内存中而不会被保存在磁盘中.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">RandomAccess</span>, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">transient</span> Object[] elementData;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先我们看下, 日常开发中我们最常用到的无参构造函数, 它主要做的就是将<code>elementData</code>引用指向默认静态的一个空数组.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>还有其他的两个构造函数, 一个是可以初始定义队列的容量, 当传入的<code>initialCapacity</code>为负数的时候, 会抛出异常.要注意的是, 当定义的初始容量为0的时候, <code>elementData</code>指向的是另外一个空数组<code>EMPTY_ELEMENTDATA</code>, 具体为什么要区分两个静态空数组实例, 留在后面的扩容机制上说明.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+</span><br><span class=\"line\">                                               initialCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后一个构造函数式可以直接传集合进去, <code>elementData</code>引用指向传入的集合数组, 当集合长度为<code>0</code>的时候, 仍然会使它指向 <code>EMPTY_ELEMENTDATA</code>空数组.而当传入的集合有元素的情况下, 从注释上看是为了处理6260652的bug, 所以需要判断不是<code>Object[]</code>的情况下的时候, 使用<code>Arrays</code>内部实现的拷贝的方法<code>copyOf</code>进行元素的拷贝.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    elementData = c.toArray();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// replace with empty array.</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>具体我们可以稍微看下<code>Arrays.copyOf</code>的源码, 后面会发现他是内部核心调用方法, 可以看出每次调用的时候, 实际是实例化了一个新的数组, 将原来的数组元素填充进去实现了copy的目的.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class=\"keyword\">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">        T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class=\"line\">            ? (T[]) <span class=\"keyword\">new</span> Object[newLength]</span><br><span class=\"line\">            : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class=\"line\">        System.arraycopy(original, <span class=\"number\">0</span>, copy, <span class=\"number\">0</span>,</span><br><span class=\"line\">                         Math.min(original.length, newLength));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> copy;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add\"></a>add</h2><p>我们首先看下几个add的方法, 其实内部实现的原理都不会错过扩容的操作, 所以我们具体看下扩容的原理.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// size为arrayList的长度大小</span></span><br><span class=\"line\">        ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">        elementData[size++] = e;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt; size || index &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 容量确保</span></span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    <span class=\"comment\">// 空出index位, 进行拷贝</span></span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>,</span><br><span class=\"line\">                     size - index);</span><br><span class=\"line\">    <span class=\"comment\">// 根据索引获取数组index位进行赋值</span></span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    <span class=\"comment\">// 长度 + 1</span></span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先, 每次都需要调用到<code>ensureCapacityInternal</code>, 进行容量的确定<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 确保内部容量大小</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> minCapacity</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当调用ArrayList()构造函数, 内部维护的数组是DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class=\"line\">        <span class=\"comment\">// 则minCapacity = 10</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// minCapacity为10 或者为 size + 1</span></span><br><span class=\"line\">        ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里可以看到, 当内部管理数组<code>elementData</code>指向内存地址与<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>默认空数组实例相等的时候, 最小的容量会以传入的最小容量和默认容量(10)的最大值为准, 同时, 这里可以了解到, 区分两个空数组的实例, 就是为了扩容的时候确定容量的时候, 可以区分到调用无参构造函数的arrayList, 在第一次添加元素的时候, 可以保证他的容量首先是10(<code>DEFAULT_CAPACITY</code>)).然后再是调用到<code>ensureExplicitCapacity</code>方法.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 操作数记录</span></span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果 当前数组的长度比添加元素后的长度要小则进行扩容</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            grow(minCapacity);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>当内部当前管理的数组<code>elementData</code>的长度小于添加元素后的长度, 则需要进行真正的扩容方法<code>grow</code></p>\n<p>可以看到, 每次容量是根据原来容量的1.5倍来扩充的, 当扩充后的容量仍然没有加入新元素后的长度大的时候, 那么直接扩容到加入后的长度.</p>\n<p>而实现扩容的真正机制, 其实还是调用了<code>Arrays.copyOf</code>方法, 声明了目标容量的数组, 进行元素拷贝. 这样的话, 其实每次<code>ArrayList</code>的内部元素变化的时候, 都会存在相对的内存开销.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将原来的数组, 拷贝到一个扩容后新长度的数组内</span></span><br><span class=\"line\"><span class=\"comment\">     * Increases the capacity to ensure that it can hold at least the</span></span><br><span class=\"line\"><span class=\"comment\">     * number of elements specified by the minimum capacity argument.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> minCapacity the desired minimum capacity</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">        <span class=\"comment\">// oldCapacity &gt;&gt; 1 相当于 oldCapacity / 2</span></span><br><span class=\"line\">        <span class=\"comment\">// 新容量为老容量的1.5倍</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 如果扩容后容量比添加元素后的长度小</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\">// 直接扩容到添加元素后的长度大小</span></span><br><span class=\"line\">            newCapacity = minCapacity;</span><br><span class=\"line\">        <span class=\"comment\">// 新容量大小比 MAX_ARRAY_SIZE 大</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">        <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">        <span class=\"comment\">// 构建newCapacity长度的新数组, elementData指向它</span></span><br><span class=\"line\">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();</span><br><span class=\"line\">    <span class=\"comment\">// 如果是添加元素后的长度大于 MAX_ARRAY_SIZE, 则容量设为Integer的最大. 否则 -8</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">        Integer.MAX_VALUE :</span><br><span class=\"line\">        MAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove\"></a>remove</h2><p>搞懂扩容机制后, 我们可以对应看下其他我们常用的API, 首先看下<code>remove</code>相关, 可以看出在移除元素的时候, 其实实际上我们还是做了个拷贝的动作, 将除去移除目标元素的数组其他元素, 拷贝到新的数组中, 同时, 这个时候容量其实是没有变的.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt;= size)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\"></span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        E oldValue = (E) elementData[index];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                             numMoved);</span><br><span class=\"line\">        elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (elementData[index] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    fastRemove(index);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(elementData[index])) &#123;</span><br><span class=\"line\">                    fastRemove(index);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fastRemove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 操作数的新增</span></span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                         numMoved);</span><br><span class=\"line\">    elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>我们在看下<code>get</code>和<code>contains</code>是怎么实现的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt;= size)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (E) elementData[index];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到<code>get</code>的方法, 实际就是对于内部数组的索引查找<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> indexOf(o) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elementData[i]==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(elementData[i]))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>而<code>contains(Object o)</code>方法其实做的就是对内部数组进行遍历查找.</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>考量到使用无参构造函数的时候, 当添加元素的时候, 初始容量为10, 以10为基准进行1.5倍的扩容, 通过源码的解读, 我们可以就可以进行一定的内存优化, 譬如在使用ArrayList的时候, 就应该避免使用无参构造函数, 尽量多的给它定义明确的初始容量, 一个是可以导致不会有过多的内存空间被浪费, 另外一个是可以减少调用到<code>System.arraycopy</code>native方法, 保证了一定的内存开销的节省.</p>"},{"title":"Glide源码解析","date":"2017-12-21T16:00:00.000Z","_content":"基于v4最新版本的Glide解析, 从最开始的简单加载开始看源码, 仅作个人记录.\n<!-- more -->\n一个Glide加载图片的核心用法如下:\n``` java\nGlideApp.with(this)\n                .load(uri)\n                .into(imageViewLookup);\n```\n我们通过一步步链式调用进去查看\n## Glide.with : 同步生命周期\n``` java\nprivate RequestManager supportFragmentGet(@NonNull Context context, @NonNull FragmentManager fm,\n      @Nullable Fragment parentHint) {\n    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);\n    RequestManager requestManager = current.getRequestManager();\n    if (requestManager == null) {\n      Glide glide = Glide.get(context);\n      requestManager =\n          factory.build(\n              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);\n      current.setRequestManager(requestManager);\n    }\n    return requestManager;\n  }\n```\n通过`getSupportRequestManagerFragment(final FragmentManager fm, Fragment parentHint)`方法调用, 在`Glide.with(context)`中传入的组件中,\n新增一个子Fragment, 这个Fragment类根据传入的是`support.fragment`或者是`fragment`来决定是`RequestManagerFragment`还是`SupportRequestManagerFragment`,然后通过`current.SupportRequestManagerFragment()` 将Glide的生命周期与这个子fragment的声明周期绑定, 实现了组件与Glide加载同步的功能\n## 图片的加载\n我们通过暴露的into的API跳进去, 最终到了`RequestBuilder.into(@NonNull Y target, @Nullable RequestListener<TranscodeType> targetListener, @NonNull RequestOptions options)`, 详细代码如下:\n``` java\nprivate <Y extends Target<TranscodeType>> Y into(\n      @NonNull Y target,\n      @Nullable RequestListener<TranscodeType> targetListener,\n      @NonNull RequestOptions options) {\n    // 判断是否在主线程\n    Util.assertMainThread();\n    // target是否为空判断\n    Preconditions.checkNotNull(target);\n    // load()方法是否已经被调用, 如果没被调用, 则将抛出异常\n    if (!isModelSet) {\n      throw new IllegalArgumentException(\"You must call #load() before calling #into()\");\n    }\n    options = options.autoClone();\n    // 创建请求\n    Request request = buildRequest(target, targetListener, options);\n    // 获取target当前的请求\n    Request previous = target.getRequest();\n    // 如果请求相同, 而且当前请求设置可以使用内存缓存\n    // 则请求回收\n    if (request.isEquivalentTo(previous)\n        && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {\n      request.recycle();\n      // If the request is completed, beginning again will ensure the result is re-delivered,\n      // triggering RequestListeners and Targets. If the request is failed, beginning again will\n      // restart the request, giving it another chance to complete. If the request is already\n      // running, we can let it continue running without interruption.\n      // 如果当前请求不在执行, 则会重新开始请求\n      if (!Preconditions.checkNotNull(previous).isRunning()) {\n        // Use the previous request rather than the new one to allow for optimizations like skipping\n        // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions\n        // that are done in the individual Request.\n        previous.begin();\n      }\n      return target;\n    }\n    requestManager.clear(target);\n    target.setRequest(request);\n    // 请求追踪\n    requestManager.track(target, request);\n\n    return target;\n  }\n```\n然后通过`requestManager.track()`发起Request执行, 如果当前状态(`status`)既不是`RUNNING`也不是`COMPLETE`, 则会执行`onSizeReady`, 到这里直到`Engine.load()`才开始资源的加载, 相关的代码及注释如下:\n``` java\npublic <R> LoadStatus load(\n      GlideContext glideContext,\n      Object model,\n      Key signature,\n      int width,\n      int height,\n      Class<?> resourceClass,\n      Class<R> transcodeClass,\n      Priority priority,\n      DiskCacheStrategy diskCacheStrategy,\n      Map<Class<?>, Transformation<?>> transformations,\n      boolean isTransformationRequired,\n      boolean isScaleOnlyOrNoTransform,\n      Options options,\n      boolean isMemoryCacheable,\n      boolean useUnlimitedSourceExecutorPool,\n      boolean useAnimationPool,\n      boolean onlyRetrieveFromCache,\n      ResourceCallback cb) {\n    Util.assertMainThread();\n    long startTime = LogTime.getLogTime();\n    // 创建缓存key\n    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,\n        resourceClass, transcodeClass, options);\n\n    // 从存活资源内读取数据, 内部缓存由value为弱引用对象的map做管理, 做手动的计数管理\n    // 当资源计数为0时, 则回收\n    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);\n    if (active != null) {\n      // 如果命中, 则回调加载\n      cb.onResourceReady(active, DataSource.MEMORY_CACHE);\n      if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logWithTimeAndKey(\"Loaded resource from active resources\", startTime, key);\n      }\n      return null;\n    }\n\n    // 获取内存缓存数据\n    // 当内存缓存中有命中, 则删除Cache, 并将目标资源加到activeResources中\n    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);\n    if (cached != null) {\n      // 如果命中, 则回调加载\n      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);\n      if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logWithTimeAndKey(\"Loaded resource from cache\", startTime, key);\n      }\n      return null;\n    }\n    //  EngineJob : 调度DecodeJob，添加，移除资源回调，并notify回调\n    EngineJob<?> current = jobs.get(key, onlyRetrieveFromCache);\n    // 当前存活的资源和内存缓存都没有的情况下\n    // 1. 先判断是否有资源(resouce什么时候回调true 不明), 如果有, 则回调加载\n    // 2. 如果加载失败, 则加载抛出异常\n    // 3. 否则, 在资源回调中添加\n    if (current != null) {\n      current.addCallback(cb);\n      if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logWithTimeAndKey(\"Added to existing load\", startTime, key);\n      }\n      // 返回当前的LoadStatus\n      return new LoadStatus(cb, current);\n    }\n    // 当资源回调中都没有的情况\n    EngineJob<R> engineJob =\n        engineJobFactory.build(\n            key,\n            isMemoryCacheable,\n            useUnlimitedSourceExecutorPool,\n            useAnimationPool,\n            onlyRetrieveFromCache);\n\n    // 实现了Runnable接口，调度任务的核心类，整个请求的繁重工作都在这里完成：处理来自缓存或者原始的资源，应用转换动画以及transcode。\n    // 负责根据缓存类型获取不同的Generator加载数据，数据加载成功后回调DecodeJob的onDataFetcherReady方法对资源进行处理\n    DecodeJob<R> decodeJob =\n        decodeJobFactory.build(\n            glideContext,\n            model,\n            key,\n            signature,\n            width,\n            height,\n            resourceClass,\n            transcodeClass,\n            priority,\n            diskCacheStrategy,\n            transformations,\n            isTransformationRequired,\n            isScaleOnlyOrNoTransform,\n            onlyRetrieveFromCache,\n            options,\n            engineJob);\n\n    jobs.put(key, engineJob);\n\n    engineJob.addCallback(cb);\n    engineJob.start(decodeJob);\n\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n      logWithTimeAndKey(\"Started new load\", startTime, key);\n    }\n    return new LoadStatus(cb, engineJob);\n  }\n```\n这里的流程图可以看下图:\n![Engine.load()流程图](./glide_load时序图.png)\n## 资源图片的缓存\n当无法再当前存活的资源以及缓存内找到对应key的资源时, 会通过`engineJob`开始执行`decodeJob`, 所以我们可以直接看`decodeJob`的`run()`.\n``` java\n/**\n   * 根据不同的runReason执行不同任务\n   */\n  private void runWrapped() {\n     switch (runReason) {\n       // 首次请求时\n      case INITIALIZE:\n        stage = getNextStage(Stage.INITIALIZE);\n        currentGenerator = getNextGenerator();\n        // load数据\n        runGenerators();\n        break;\n      case SWITCH_TO_SOURCE_SERVICE:\n        // load数据\n        runGenerators();\n        break;\n      case DECODE_DATA:\n        // 数据处理\n        decodeFromRetrievedData();\n        break;\n      default:\n        throw new IllegalStateException(\"Unrecognized run reason: \" + runReason);\n    }\n  }\n```\n核心的执行流程如下代码:\n``` java\n/**\n   * 执行Generators\n   */\n  private void runGenerators() {\n    // 获取当前线程\n    currentThread = Thread.currentThread();\n    startFetchTime = LogTime.getLogTime();\n    boolean isStarted = false;\n    // currentGenerator.startNext() : 从当前策略对应的Generator获取数据，数据获取成功则回调DecodeJob的onDataFetcherReady对资源进行处理。否则尝试从下一个策略的Generator获取数据\n    while (!isCancelled && currentGenerator != null\n        && !(isStarted = currentGenerator.startNext())) {\n      stage = getNextStage(stage);\n      // 根据Stage获取到相应的Generator后会执行currentGenerator.startNext()，如果中途startNext返回true，则直接回调，否则最终会得到SOURCE的stage，重新调度任务\n      currentGenerator = getNextGenerator();\n\n      if (stage == Stage.SOURCE) {\n        // 重新调度当前任务\n        reschedule();\n        return;\n      }\n    }\n    // We've run out of stages and generators, give up.\n    if ((stage == Stage.FINISHED || isCancelled) && !isStarted) {\n      notifyFailed();\n    }\n\n    // Otherwise a generator started a new load and we expect to be called back in\n    // onDataFetcherReady.\n  }\n```\n我们看下DecodeJob的执行流程\n![decodeJob执行流程](./decodeJob流程图.png)\n## 总结\n到这里, 整体的流程大致是搞清楚了, 至于说是缓存的原理机制, 在之前`Engine.load()`的方法内, 删除缓存的方法进去可以看到一个`LruCache`的类文件, 从名字可以推断是Glide自己实现的`Lru算法`作为缓存的处理, 关于Lru的算法原理, 在本篇内就不再做赘述了, 而`ActiveCache`用到了`引用计数`算法.\nGlide用到了大量的抽象工厂类, 另外方法内经常是包括了十来个参数, 在阅读的经过上还是有点困难(对我而言).\n相应的代码注释可看[Github上我补充的注释](https://github.com/YuTianTina/glide)\n","source":"_posts/Glide源码解析1.md","raw":"title: Glide源码解析\ndate: 2017-12-22 00:00:00\ncategories:\n- android学习记录\n- 源码解析\ntags:\n- android\n- Glide\n- 源码解析\n---\n基于v4最新版本的Glide解析, 从最开始的简单加载开始看源码, 仅作个人记录.\n<!-- more -->\n一个Glide加载图片的核心用法如下:\n``` java\nGlideApp.with(this)\n                .load(uri)\n                .into(imageViewLookup);\n```\n我们通过一步步链式调用进去查看\n## Glide.with : 同步生命周期\n``` java\nprivate RequestManager supportFragmentGet(@NonNull Context context, @NonNull FragmentManager fm,\n      @Nullable Fragment parentHint) {\n    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);\n    RequestManager requestManager = current.getRequestManager();\n    if (requestManager == null) {\n      Glide glide = Glide.get(context);\n      requestManager =\n          factory.build(\n              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);\n      current.setRequestManager(requestManager);\n    }\n    return requestManager;\n  }\n```\n通过`getSupportRequestManagerFragment(final FragmentManager fm, Fragment parentHint)`方法调用, 在`Glide.with(context)`中传入的组件中,\n新增一个子Fragment, 这个Fragment类根据传入的是`support.fragment`或者是`fragment`来决定是`RequestManagerFragment`还是`SupportRequestManagerFragment`,然后通过`current.SupportRequestManagerFragment()` 将Glide的生命周期与这个子fragment的声明周期绑定, 实现了组件与Glide加载同步的功能\n## 图片的加载\n我们通过暴露的into的API跳进去, 最终到了`RequestBuilder.into(@NonNull Y target, @Nullable RequestListener<TranscodeType> targetListener, @NonNull RequestOptions options)`, 详细代码如下:\n``` java\nprivate <Y extends Target<TranscodeType>> Y into(\n      @NonNull Y target,\n      @Nullable RequestListener<TranscodeType> targetListener,\n      @NonNull RequestOptions options) {\n    // 判断是否在主线程\n    Util.assertMainThread();\n    // target是否为空判断\n    Preconditions.checkNotNull(target);\n    // load()方法是否已经被调用, 如果没被调用, 则将抛出异常\n    if (!isModelSet) {\n      throw new IllegalArgumentException(\"You must call #load() before calling #into()\");\n    }\n    options = options.autoClone();\n    // 创建请求\n    Request request = buildRequest(target, targetListener, options);\n    // 获取target当前的请求\n    Request previous = target.getRequest();\n    // 如果请求相同, 而且当前请求设置可以使用内存缓存\n    // 则请求回收\n    if (request.isEquivalentTo(previous)\n        && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {\n      request.recycle();\n      // If the request is completed, beginning again will ensure the result is re-delivered,\n      // triggering RequestListeners and Targets. If the request is failed, beginning again will\n      // restart the request, giving it another chance to complete. If the request is already\n      // running, we can let it continue running without interruption.\n      // 如果当前请求不在执行, 则会重新开始请求\n      if (!Preconditions.checkNotNull(previous).isRunning()) {\n        // Use the previous request rather than the new one to allow for optimizations like skipping\n        // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions\n        // that are done in the individual Request.\n        previous.begin();\n      }\n      return target;\n    }\n    requestManager.clear(target);\n    target.setRequest(request);\n    // 请求追踪\n    requestManager.track(target, request);\n\n    return target;\n  }\n```\n然后通过`requestManager.track()`发起Request执行, 如果当前状态(`status`)既不是`RUNNING`也不是`COMPLETE`, 则会执行`onSizeReady`, 到这里直到`Engine.load()`才开始资源的加载, 相关的代码及注释如下:\n``` java\npublic <R> LoadStatus load(\n      GlideContext glideContext,\n      Object model,\n      Key signature,\n      int width,\n      int height,\n      Class<?> resourceClass,\n      Class<R> transcodeClass,\n      Priority priority,\n      DiskCacheStrategy diskCacheStrategy,\n      Map<Class<?>, Transformation<?>> transformations,\n      boolean isTransformationRequired,\n      boolean isScaleOnlyOrNoTransform,\n      Options options,\n      boolean isMemoryCacheable,\n      boolean useUnlimitedSourceExecutorPool,\n      boolean useAnimationPool,\n      boolean onlyRetrieveFromCache,\n      ResourceCallback cb) {\n    Util.assertMainThread();\n    long startTime = LogTime.getLogTime();\n    // 创建缓存key\n    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,\n        resourceClass, transcodeClass, options);\n\n    // 从存活资源内读取数据, 内部缓存由value为弱引用对象的map做管理, 做手动的计数管理\n    // 当资源计数为0时, 则回收\n    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);\n    if (active != null) {\n      // 如果命中, 则回调加载\n      cb.onResourceReady(active, DataSource.MEMORY_CACHE);\n      if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logWithTimeAndKey(\"Loaded resource from active resources\", startTime, key);\n      }\n      return null;\n    }\n\n    // 获取内存缓存数据\n    // 当内存缓存中有命中, 则删除Cache, 并将目标资源加到activeResources中\n    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);\n    if (cached != null) {\n      // 如果命中, 则回调加载\n      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);\n      if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logWithTimeAndKey(\"Loaded resource from cache\", startTime, key);\n      }\n      return null;\n    }\n    //  EngineJob : 调度DecodeJob，添加，移除资源回调，并notify回调\n    EngineJob<?> current = jobs.get(key, onlyRetrieveFromCache);\n    // 当前存活的资源和内存缓存都没有的情况下\n    // 1. 先判断是否有资源(resouce什么时候回调true 不明), 如果有, 则回调加载\n    // 2. 如果加载失败, 则加载抛出异常\n    // 3. 否则, 在资源回调中添加\n    if (current != null) {\n      current.addCallback(cb);\n      if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logWithTimeAndKey(\"Added to existing load\", startTime, key);\n      }\n      // 返回当前的LoadStatus\n      return new LoadStatus(cb, current);\n    }\n    // 当资源回调中都没有的情况\n    EngineJob<R> engineJob =\n        engineJobFactory.build(\n            key,\n            isMemoryCacheable,\n            useUnlimitedSourceExecutorPool,\n            useAnimationPool,\n            onlyRetrieveFromCache);\n\n    // 实现了Runnable接口，调度任务的核心类，整个请求的繁重工作都在这里完成：处理来自缓存或者原始的资源，应用转换动画以及transcode。\n    // 负责根据缓存类型获取不同的Generator加载数据，数据加载成功后回调DecodeJob的onDataFetcherReady方法对资源进行处理\n    DecodeJob<R> decodeJob =\n        decodeJobFactory.build(\n            glideContext,\n            model,\n            key,\n            signature,\n            width,\n            height,\n            resourceClass,\n            transcodeClass,\n            priority,\n            diskCacheStrategy,\n            transformations,\n            isTransformationRequired,\n            isScaleOnlyOrNoTransform,\n            onlyRetrieveFromCache,\n            options,\n            engineJob);\n\n    jobs.put(key, engineJob);\n\n    engineJob.addCallback(cb);\n    engineJob.start(decodeJob);\n\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n      logWithTimeAndKey(\"Started new load\", startTime, key);\n    }\n    return new LoadStatus(cb, engineJob);\n  }\n```\n这里的流程图可以看下图:\n![Engine.load()流程图](./glide_load时序图.png)\n## 资源图片的缓存\n当无法再当前存活的资源以及缓存内找到对应key的资源时, 会通过`engineJob`开始执行`decodeJob`, 所以我们可以直接看`decodeJob`的`run()`.\n``` java\n/**\n   * 根据不同的runReason执行不同任务\n   */\n  private void runWrapped() {\n     switch (runReason) {\n       // 首次请求时\n      case INITIALIZE:\n        stage = getNextStage(Stage.INITIALIZE);\n        currentGenerator = getNextGenerator();\n        // load数据\n        runGenerators();\n        break;\n      case SWITCH_TO_SOURCE_SERVICE:\n        // load数据\n        runGenerators();\n        break;\n      case DECODE_DATA:\n        // 数据处理\n        decodeFromRetrievedData();\n        break;\n      default:\n        throw new IllegalStateException(\"Unrecognized run reason: \" + runReason);\n    }\n  }\n```\n核心的执行流程如下代码:\n``` java\n/**\n   * 执行Generators\n   */\n  private void runGenerators() {\n    // 获取当前线程\n    currentThread = Thread.currentThread();\n    startFetchTime = LogTime.getLogTime();\n    boolean isStarted = false;\n    // currentGenerator.startNext() : 从当前策略对应的Generator获取数据，数据获取成功则回调DecodeJob的onDataFetcherReady对资源进行处理。否则尝试从下一个策略的Generator获取数据\n    while (!isCancelled && currentGenerator != null\n        && !(isStarted = currentGenerator.startNext())) {\n      stage = getNextStage(stage);\n      // 根据Stage获取到相应的Generator后会执行currentGenerator.startNext()，如果中途startNext返回true，则直接回调，否则最终会得到SOURCE的stage，重新调度任务\n      currentGenerator = getNextGenerator();\n\n      if (stage == Stage.SOURCE) {\n        // 重新调度当前任务\n        reschedule();\n        return;\n      }\n    }\n    // We've run out of stages and generators, give up.\n    if ((stage == Stage.FINISHED || isCancelled) && !isStarted) {\n      notifyFailed();\n    }\n\n    // Otherwise a generator started a new load and we expect to be called back in\n    // onDataFetcherReady.\n  }\n```\n我们看下DecodeJob的执行流程\n![decodeJob执行流程](./decodeJob流程图.png)\n## 总结\n到这里, 整体的流程大致是搞清楚了, 至于说是缓存的原理机制, 在之前`Engine.load()`的方法内, 删除缓存的方法进去可以看到一个`LruCache`的类文件, 从名字可以推断是Glide自己实现的`Lru算法`作为缓存的处理, 关于Lru的算法原理, 在本篇内就不再做赘述了, 而`ActiveCache`用到了`引用计数`算法.\nGlide用到了大量的抽象工厂类, 另外方法内经常是包括了十来个参数, 在阅读的经过上还是有点困难(对我而言).\n相应的代码注释可看[Github上我补充的注释](https://github.com/YuTianTina/glide)\n","slug":"Glide源码解析1","published":1,"updated":"2018-05-15T09:04:53.843Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjld5ah2n001bcqs61fceydo7","content":"<p>基于v4最新版本的Glide解析, 从最开始的简单加载开始看源码, 仅作个人记录.<br><a id=\"more\"></a><br>一个Glide加载图片的核心用法如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlideApp.with(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">                .load(uri)</span><br><span class=\"line\">                .into(imageViewLookup);</span><br></pre></td></tr></table></figure></p>\n<p>我们通过一步步链式调用进去查看</p>\n<h2 id=\"Glide-with-同步生命周期\"><a href=\"#Glide-with-同步生命周期\" class=\"headerlink\" title=\"Glide.with : 同步生命周期\"></a>Glide.with : 同步生命周期</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> RequestManager <span class=\"title\">supportFragmentGet</span><span class=\"params\">(@NonNull Context context, @NonNull FragmentManager fm,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      @Nullable Fragment parentHint)</span> </span>&#123;</span><br><span class=\"line\">    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);</span><br><span class=\"line\">    RequestManager requestManager = current.getRequestManager();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (requestManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      Glide glide = Glide.get(context);</span><br><span class=\"line\">      requestManager =</span><br><span class=\"line\">          factory.build(</span><br><span class=\"line\">              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class=\"line\">      current.setRequestManager(requestManager);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> requestManager;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>通过<code>getSupportRequestManagerFragment(final FragmentManager fm, Fragment parentHint)</code>方法调用, 在<code>Glide.with(context)</code>中传入的组件中,<br>新增一个子Fragment, 这个Fragment类根据传入的是<code>support.fragment</code>或者是<code>fragment</code>来决定是<code>RequestManagerFragment</code>还是<code>SupportRequestManagerFragment</code>,然后通过<code>current.SupportRequestManagerFragment()</code> 将Glide的生命周期与这个子fragment的声明周期绑定, 实现了组件与Glide加载同步的功能</p>\n<h2 id=\"图片的加载\"><a href=\"#图片的加载\" class=\"headerlink\" title=\"图片的加载\"></a>图片的加载</h2><p>我们通过暴露的into的API跳进去, 最终到了<code>RequestBuilder.into(@NonNull Y target, @Nullable RequestListener&lt;TranscodeType&gt; targetListener, @NonNull RequestOptions options)</code>, 详细代码如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class=\"function\">Y <span class=\"title\">into</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      @NonNull Y target,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      @NonNull RequestOptions options)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否在主线程</span></span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    <span class=\"comment\">// target是否为空判断</span></span><br><span class=\"line\">    Preconditions.checkNotNull(target);</span><br><span class=\"line\">    <span class=\"comment\">// load()方法是否已经被调用, 如果没被调用, 则将抛出异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isModelSet) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"You must call #load() before calling #into()\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    options = options.autoClone();</span><br><span class=\"line\">    <span class=\"comment\">// 创建请求</span></span><br><span class=\"line\">    Request request = buildRequest(target, targetListener, options);</span><br><span class=\"line\">    <span class=\"comment\">// 获取target当前的请求</span></span><br><span class=\"line\">    Request previous = target.getRequest();</span><br><span class=\"line\">    <span class=\"comment\">// 如果请求相同, 而且当前请求设置可以使用内存缓存</span></span><br><span class=\"line\">    <span class=\"comment\">// 则请求回收</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (request.isEquivalentTo(previous)</span><br><span class=\"line\">        &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class=\"line\">      request.recycle();</span><br><span class=\"line\">      <span class=\"comment\">// If the request is completed, beginning again will ensure the result is re-delivered,</span></span><br><span class=\"line\">      <span class=\"comment\">// triggering RequestListeners and Targets. If the request is failed, beginning again will</span></span><br><span class=\"line\">      <span class=\"comment\">// restart the request, giving it another chance to complete. If the request is already</span></span><br><span class=\"line\">      <span class=\"comment\">// running, we can let it continue running without interruption.</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果当前请求不在执行, 则会重新开始请求</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Use the previous request rather than the new one to allow for optimizations like skipping</span></span><br><span class=\"line\">        <span class=\"comment\">// setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions</span></span><br><span class=\"line\">        <span class=\"comment\">// that are done in the individual Request.</span></span><br><span class=\"line\">        previous.begin();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    requestManager.clear(target);</span><br><span class=\"line\">    target.setRequest(request);</span><br><span class=\"line\">    <span class=\"comment\">// 请求追踪</span></span><br><span class=\"line\">    requestManager.track(target, request);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后通过<code>requestManager.track()</code>发起Request执行, 如果当前状态(<code>status</code>)既不是<code>RUNNING</code>也不是<code>COMPLETE</code>, 则会执行<code>onSizeReady</code>, 到这里直到<code>Engine.load()</code>才开始资源的加载, 相关的代码及注释如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;R&gt; <span class=\"function\">LoadStatus <span class=\"title\">load</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      GlideContext glideContext,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Object model,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Key signature,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">int</span> width,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">int</span> height,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Class&lt;?&gt; resourceClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Class&lt;R&gt; transcodeClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Priority priority,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      DiskCacheStrategy diskCacheStrategy,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> isTransformationRequired,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> isScaleOnlyOrNoTransform,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Options options,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> isMemoryCacheable,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> useUnlimitedSourceExecutorPool,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> useAnimationPool,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> onlyRetrieveFromCache,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      ResourceCallback cb)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"comment\">// 创建缓存key</span></span><br><span class=\"line\">    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</span><br><span class=\"line\">        resourceClass, transcodeClass, options);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从存活资源内读取数据, 内部缓存由value为弱引用对象的map做管理, 做手动的计数管理</span></span><br><span class=\"line\">    <span class=\"comment\">// 当资源计数为0时, 则回收</span></span><br><span class=\"line\">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (active != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果命中, 则回调加载</span></span><br><span class=\"line\">      cb.onResourceReady(active, DataSource.MEMORY_CACHE);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logWithTimeAndKey(<span class=\"string\">\"Loaded resource from active resources\"</span>, startTime, key);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取内存缓存数据</span></span><br><span class=\"line\">    <span class=\"comment\">// 当内存缓存中有命中, 则删除Cache, 并将目标资源加到activeResources中</span></span><br><span class=\"line\">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cached != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果命中, 则回调加载</span></span><br><span class=\"line\">      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logWithTimeAndKey(<span class=\"string\">\"Loaded resource from cache\"</span>, startTime, key);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//  EngineJob : 调度DecodeJob，添加，移除资源回调，并notify回调</span></span><br><span class=\"line\">    EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class=\"line\">    <span class=\"comment\">// 当前存活的资源和内存缓存都没有的情况下</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. 先判断是否有资源(resouce什么时候回调true 不明), 如果有, 则回调加载</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 如果加载失败, 则加载抛出异常</span></span><br><span class=\"line\">    <span class=\"comment\">// 3. 否则, 在资源回调中添加</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      current.addCallback(cb);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logWithTimeAndKey(<span class=\"string\">\"Added to existing load\"</span>, startTime, key);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 返回当前的LoadStatus</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, current);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当资源回调中都没有的情况</span></span><br><span class=\"line\">    EngineJob&lt;R&gt; engineJob =</span><br><span class=\"line\">        engineJobFactory.build(</span><br><span class=\"line\">            key,</span><br><span class=\"line\">            isMemoryCacheable,</span><br><span class=\"line\">            useUnlimitedSourceExecutorPool,</span><br><span class=\"line\">            useAnimationPool,</span><br><span class=\"line\">            onlyRetrieveFromCache);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现了Runnable接口，调度任务的核心类，整个请求的繁重工作都在这里完成：处理来自缓存或者原始的资源，应用转换动画以及transcode。</span></span><br><span class=\"line\">    <span class=\"comment\">// 负责根据缓存类型获取不同的Generator加载数据，数据加载成功后回调DecodeJob的onDataFetcherReady方法对资源进行处理</span></span><br><span class=\"line\">    DecodeJob&lt;R&gt; decodeJob =</span><br><span class=\"line\">        decodeJobFactory.build(</span><br><span class=\"line\">            glideContext,</span><br><span class=\"line\">            model,</span><br><span class=\"line\">            key,</span><br><span class=\"line\">            signature,</span><br><span class=\"line\">            width,</span><br><span class=\"line\">            height,</span><br><span class=\"line\">            resourceClass,</span><br><span class=\"line\">            transcodeClass,</span><br><span class=\"line\">            priority,</span><br><span class=\"line\">            diskCacheStrategy,</span><br><span class=\"line\">            transformations,</span><br><span class=\"line\">            isTransformationRequired,</span><br><span class=\"line\">            isScaleOnlyOrNoTransform,</span><br><span class=\"line\">            onlyRetrieveFromCache,</span><br><span class=\"line\">            options,</span><br><span class=\"line\">            engineJob);</span><br><span class=\"line\"></span><br><span class=\"line\">    jobs.put(key, engineJob);</span><br><span class=\"line\"></span><br><span class=\"line\">    engineJob.addCallback(cb);</span><br><span class=\"line\">    engineJob.start(decodeJob);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">      logWithTimeAndKey(<span class=\"string\">\"Started new load\"</span>, startTime, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, engineJob);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的流程图可以看下图:<br><img src=\"./glide_load时序图.png\" alt=\"Engine.load()流程图\"></p>\n<h2 id=\"资源图片的缓存\"><a href=\"#资源图片的缓存\" class=\"headerlink\" title=\"资源图片的缓存\"></a>资源图片的缓存</h2><p>当无法再当前存活的资源以及缓存内找到对应key的资源时, 会通过<code>engineJob</code>开始执行<code>decodeJob</code>, 所以我们可以直接看<code>decodeJob</code>的<code>run()</code>.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 根据不同的runReason执行不同任务</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">runWrapped</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">switch</span> (runReason) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 首次请求时</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> INITIALIZE:</span><br><span class=\"line\">        stage = getNextStage(Stage.INITIALIZE);</span><br><span class=\"line\">        currentGenerator = getNextGenerator();</span><br><span class=\"line\">        <span class=\"comment\">// load数据</span></span><br><span class=\"line\">        runGenerators();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> SWITCH_TO_SOURCE_SERVICE:</span><br><span class=\"line\">        <span class=\"comment\">// load数据</span></span><br><span class=\"line\">        runGenerators();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> DECODE_DATA:</span><br><span class=\"line\">        <span class=\"comment\">// 数据处理</span></span><br><span class=\"line\">        decodeFromRetrievedData();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Unrecognized run reason: \"</span> + runReason);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>核心的执行流程如下代码:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 执行Generators</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">runGenerators</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前线程</span></span><br><span class=\"line\">    currentThread = Thread.currentThread();</span><br><span class=\"line\">    startFetchTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// currentGenerator.startNext() : 从当前策略对应的Generator获取数据，数据获取成功则回调DecodeJob的onDataFetcherReady对资源进行处理。否则尝试从下一个策略的Generator获取数据</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isCancelled &amp;&amp; currentGenerator != <span class=\"keyword\">null</span></span><br><span class=\"line\">        &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;</span><br><span class=\"line\">      stage = getNextStage(stage);</span><br><span class=\"line\">      <span class=\"comment\">// 根据Stage获取到相应的Generator后会执行currentGenerator.startNext()，如果中途startNext返回true，则直接回调，否则最终会得到SOURCE的stage，重新调度任务</span></span><br><span class=\"line\">      currentGenerator = getNextGenerator();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (stage == Stage.SOURCE) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 重新调度当前任务</span></span><br><span class=\"line\">        reschedule();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// We've run out of stages and generators, give up.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) &#123;</span><br><span class=\"line\">      notifyFailed();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Otherwise a generator started a new load and we expect to be called back in</span></span><br><span class=\"line\">    <span class=\"comment\">// onDataFetcherReady.</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们看下DecodeJob的执行流程<br><img src=\"./decodeJob流程图.png\" alt=\"decodeJob执行流程\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>到这里, 整体的流程大致是搞清楚了, 至于说是缓存的原理机制, 在之前<code>Engine.load()</code>的方法内, 删除缓存的方法进去可以看到一个<code>LruCache</code>的类文件, 从名字可以推断是Glide自己实现的<code>Lru算法</code>作为缓存的处理, 关于Lru的算法原理, 在本篇内就不再做赘述了, 而<code>ActiveCache</code>用到了<code>引用计数</code>算法.<br>Glide用到了大量的抽象工厂类, 另外方法内经常是包括了十来个参数, 在阅读的经过上还是有点困难(对我而言).<br>相应的代码注释可看<a href=\"https://github.com/YuTianTina/glide\" target=\"_blank\" rel=\"noopener\">Github上我补充的注释</a></p>\n","site":{"data":{}},"excerpt":"<p>基于v4最新版本的Glide解析, 从最开始的简单加载开始看源码, 仅作个人记录.<br>","more":"<br>一个Glide加载图片的核心用法如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlideApp.with(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">                .load(uri)</span><br><span class=\"line\">                .into(imageViewLookup);</span><br></pre></td></tr></table></figure></p>\n<p>我们通过一步步链式调用进去查看</p>\n<h2 id=\"Glide-with-同步生命周期\"><a href=\"#Glide-with-同步生命周期\" class=\"headerlink\" title=\"Glide.with : 同步生命周期\"></a>Glide.with : 同步生命周期</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> RequestManager <span class=\"title\">supportFragmentGet</span><span class=\"params\">(@NonNull Context context, @NonNull FragmentManager fm,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      @Nullable Fragment parentHint)</span> </span>&#123;</span><br><span class=\"line\">    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);</span><br><span class=\"line\">    RequestManager requestManager = current.getRequestManager();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (requestManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      Glide glide = Glide.get(context);</span><br><span class=\"line\">      requestManager =</span><br><span class=\"line\">          factory.build(</span><br><span class=\"line\">              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class=\"line\">      current.setRequestManager(requestManager);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> requestManager;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>通过<code>getSupportRequestManagerFragment(final FragmentManager fm, Fragment parentHint)</code>方法调用, 在<code>Glide.with(context)</code>中传入的组件中,<br>新增一个子Fragment, 这个Fragment类根据传入的是<code>support.fragment</code>或者是<code>fragment</code>来决定是<code>RequestManagerFragment</code>还是<code>SupportRequestManagerFragment</code>,然后通过<code>current.SupportRequestManagerFragment()</code> 将Glide的生命周期与这个子fragment的声明周期绑定, 实现了组件与Glide加载同步的功能</p>\n<h2 id=\"图片的加载\"><a href=\"#图片的加载\" class=\"headerlink\" title=\"图片的加载\"></a>图片的加载</h2><p>我们通过暴露的into的API跳进去, 最终到了<code>RequestBuilder.into(@NonNull Y target, @Nullable RequestListener&lt;TranscodeType&gt; targetListener, @NonNull RequestOptions options)</code>, 详细代码如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class=\"function\">Y <span class=\"title\">into</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      @NonNull Y target,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      @NonNull RequestOptions options)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否在主线程</span></span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    <span class=\"comment\">// target是否为空判断</span></span><br><span class=\"line\">    Preconditions.checkNotNull(target);</span><br><span class=\"line\">    <span class=\"comment\">// load()方法是否已经被调用, 如果没被调用, 则将抛出异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isModelSet) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"You must call #load() before calling #into()\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    options = options.autoClone();</span><br><span class=\"line\">    <span class=\"comment\">// 创建请求</span></span><br><span class=\"line\">    Request request = buildRequest(target, targetListener, options);</span><br><span class=\"line\">    <span class=\"comment\">// 获取target当前的请求</span></span><br><span class=\"line\">    Request previous = target.getRequest();</span><br><span class=\"line\">    <span class=\"comment\">// 如果请求相同, 而且当前请求设置可以使用内存缓存</span></span><br><span class=\"line\">    <span class=\"comment\">// 则请求回收</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (request.isEquivalentTo(previous)</span><br><span class=\"line\">        &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class=\"line\">      request.recycle();</span><br><span class=\"line\">      <span class=\"comment\">// If the request is completed, beginning again will ensure the result is re-delivered,</span></span><br><span class=\"line\">      <span class=\"comment\">// triggering RequestListeners and Targets. If the request is failed, beginning again will</span></span><br><span class=\"line\">      <span class=\"comment\">// restart the request, giving it another chance to complete. If the request is already</span></span><br><span class=\"line\">      <span class=\"comment\">// running, we can let it continue running without interruption.</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果当前请求不在执行, 则会重新开始请求</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Use the previous request rather than the new one to allow for optimizations like skipping</span></span><br><span class=\"line\">        <span class=\"comment\">// setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions</span></span><br><span class=\"line\">        <span class=\"comment\">// that are done in the individual Request.</span></span><br><span class=\"line\">        previous.begin();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    requestManager.clear(target);</span><br><span class=\"line\">    target.setRequest(request);</span><br><span class=\"line\">    <span class=\"comment\">// 请求追踪</span></span><br><span class=\"line\">    requestManager.track(target, request);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后通过<code>requestManager.track()</code>发起Request执行, 如果当前状态(<code>status</code>)既不是<code>RUNNING</code>也不是<code>COMPLETE</code>, 则会执行<code>onSizeReady</code>, 到这里直到<code>Engine.load()</code>才开始资源的加载, 相关的代码及注释如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;R&gt; <span class=\"function\">LoadStatus <span class=\"title\">load</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      GlideContext glideContext,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Object model,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Key signature,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">int</span> width,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">int</span> height,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Class&lt;?&gt; resourceClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Class&lt;R&gt; transcodeClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Priority priority,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      DiskCacheStrategy diskCacheStrategy,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> isTransformationRequired,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> isScaleOnlyOrNoTransform,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Options options,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> isMemoryCacheable,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> useUnlimitedSourceExecutorPool,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> useAnimationPool,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> onlyRetrieveFromCache,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      ResourceCallback cb)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"comment\">// 创建缓存key</span></span><br><span class=\"line\">    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</span><br><span class=\"line\">        resourceClass, transcodeClass, options);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从存活资源内读取数据, 内部缓存由value为弱引用对象的map做管理, 做手动的计数管理</span></span><br><span class=\"line\">    <span class=\"comment\">// 当资源计数为0时, 则回收</span></span><br><span class=\"line\">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (active != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果命中, 则回调加载</span></span><br><span class=\"line\">      cb.onResourceReady(active, DataSource.MEMORY_CACHE);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logWithTimeAndKey(<span class=\"string\">\"Loaded resource from active resources\"</span>, startTime, key);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取内存缓存数据</span></span><br><span class=\"line\">    <span class=\"comment\">// 当内存缓存中有命中, 则删除Cache, 并将目标资源加到activeResources中</span></span><br><span class=\"line\">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cached != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果命中, 则回调加载</span></span><br><span class=\"line\">      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logWithTimeAndKey(<span class=\"string\">\"Loaded resource from cache\"</span>, startTime, key);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//  EngineJob : 调度DecodeJob，添加，移除资源回调，并notify回调</span></span><br><span class=\"line\">    EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class=\"line\">    <span class=\"comment\">// 当前存活的资源和内存缓存都没有的情况下</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. 先判断是否有资源(resouce什么时候回调true 不明), 如果有, 则回调加载</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 如果加载失败, 则加载抛出异常</span></span><br><span class=\"line\">    <span class=\"comment\">// 3. 否则, 在资源回调中添加</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      current.addCallback(cb);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logWithTimeAndKey(<span class=\"string\">\"Added to existing load\"</span>, startTime, key);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 返回当前的LoadStatus</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, current);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当资源回调中都没有的情况</span></span><br><span class=\"line\">    EngineJob&lt;R&gt; engineJob =</span><br><span class=\"line\">        engineJobFactory.build(</span><br><span class=\"line\">            key,</span><br><span class=\"line\">            isMemoryCacheable,</span><br><span class=\"line\">            useUnlimitedSourceExecutorPool,</span><br><span class=\"line\">            useAnimationPool,</span><br><span class=\"line\">            onlyRetrieveFromCache);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现了Runnable接口，调度任务的核心类，整个请求的繁重工作都在这里完成：处理来自缓存或者原始的资源，应用转换动画以及transcode。</span></span><br><span class=\"line\">    <span class=\"comment\">// 负责根据缓存类型获取不同的Generator加载数据，数据加载成功后回调DecodeJob的onDataFetcherReady方法对资源进行处理</span></span><br><span class=\"line\">    DecodeJob&lt;R&gt; decodeJob =</span><br><span class=\"line\">        decodeJobFactory.build(</span><br><span class=\"line\">            glideContext,</span><br><span class=\"line\">            model,</span><br><span class=\"line\">            key,</span><br><span class=\"line\">            signature,</span><br><span class=\"line\">            width,</span><br><span class=\"line\">            height,</span><br><span class=\"line\">            resourceClass,</span><br><span class=\"line\">            transcodeClass,</span><br><span class=\"line\">            priority,</span><br><span class=\"line\">            diskCacheStrategy,</span><br><span class=\"line\">            transformations,</span><br><span class=\"line\">            isTransformationRequired,</span><br><span class=\"line\">            isScaleOnlyOrNoTransform,</span><br><span class=\"line\">            onlyRetrieveFromCache,</span><br><span class=\"line\">            options,</span><br><span class=\"line\">            engineJob);</span><br><span class=\"line\"></span><br><span class=\"line\">    jobs.put(key, engineJob);</span><br><span class=\"line\"></span><br><span class=\"line\">    engineJob.addCallback(cb);</span><br><span class=\"line\">    engineJob.start(decodeJob);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">      logWithTimeAndKey(<span class=\"string\">\"Started new load\"</span>, startTime, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, engineJob);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的流程图可以看下图:<br><img src=\"./glide_load时序图.png\" alt=\"Engine.load()流程图\"></p>\n<h2 id=\"资源图片的缓存\"><a href=\"#资源图片的缓存\" class=\"headerlink\" title=\"资源图片的缓存\"></a>资源图片的缓存</h2><p>当无法再当前存活的资源以及缓存内找到对应key的资源时, 会通过<code>engineJob</code>开始执行<code>decodeJob</code>, 所以我们可以直接看<code>decodeJob</code>的<code>run()</code>.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 根据不同的runReason执行不同任务</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">runWrapped</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">switch</span> (runReason) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 首次请求时</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> INITIALIZE:</span><br><span class=\"line\">        stage = getNextStage(Stage.INITIALIZE);</span><br><span class=\"line\">        currentGenerator = getNextGenerator();</span><br><span class=\"line\">        <span class=\"comment\">// load数据</span></span><br><span class=\"line\">        runGenerators();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> SWITCH_TO_SOURCE_SERVICE:</span><br><span class=\"line\">        <span class=\"comment\">// load数据</span></span><br><span class=\"line\">        runGenerators();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> DECODE_DATA:</span><br><span class=\"line\">        <span class=\"comment\">// 数据处理</span></span><br><span class=\"line\">        decodeFromRetrievedData();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Unrecognized run reason: \"</span> + runReason);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>核心的执行流程如下代码:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 执行Generators</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">runGenerators</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前线程</span></span><br><span class=\"line\">    currentThread = Thread.currentThread();</span><br><span class=\"line\">    startFetchTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// currentGenerator.startNext() : 从当前策略对应的Generator获取数据，数据获取成功则回调DecodeJob的onDataFetcherReady对资源进行处理。否则尝试从下一个策略的Generator获取数据</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isCancelled &amp;&amp; currentGenerator != <span class=\"keyword\">null</span></span><br><span class=\"line\">        &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;</span><br><span class=\"line\">      stage = getNextStage(stage);</span><br><span class=\"line\">      <span class=\"comment\">// 根据Stage获取到相应的Generator后会执行currentGenerator.startNext()，如果中途startNext返回true，则直接回调，否则最终会得到SOURCE的stage，重新调度任务</span></span><br><span class=\"line\">      currentGenerator = getNextGenerator();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (stage == Stage.SOURCE) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 重新调度当前任务</span></span><br><span class=\"line\">        reschedule();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// We've run out of stages and generators, give up.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) &#123;</span><br><span class=\"line\">      notifyFailed();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Otherwise a generator started a new load and we expect to be called back in</span></span><br><span class=\"line\">    <span class=\"comment\">// onDataFetcherReady.</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们看下DecodeJob的执行流程<br><img src=\"./decodeJob流程图.png\" alt=\"decodeJob执行流程\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>到这里, 整体的流程大致是搞清楚了, 至于说是缓存的原理机制, 在之前<code>Engine.load()</code>的方法内, 删除缓存的方法进去可以看到一个<code>LruCache</code>的类文件, 从名字可以推断是Glide自己实现的<code>Lru算法</code>作为缓存的处理, 关于Lru的算法原理, 在本篇内就不再做赘述了, 而<code>ActiveCache</code>用到了<code>引用计数</code>算法.<br>Glide用到了大量的抽象工厂类, 另外方法内经常是包括了十来个参数, 在阅读的经过上还是有点困难(对我而言).<br>相应的代码注释可看<a href=\"https://github.com/YuTianTina/glide\" target=\"_blank\" rel=\"noopener\">Github上我补充的注释</a></p>"},{"title":"HashMap源码解析(一)","date":"2018-02-01T16:00:00.000Z","_content":"\n## 前言\n本篇主要了解下`HashMap`的源码, 以便了解其常用方法的实现原理.本篇以android SDK API26内的Java源码为准\n## HashMap是什么\n`HashMap`是基于实现`Map`接口的哈希表, 但是他和`HashTable`有一定的区别, 主要区分在`HashMap`可以传`null`的键值对, 而且他`不是线程安全`的, 如果需要支持同步, 则需要调用`Collections.synchronizedMap(Map<K,V> m) `方法. 同时, `HashMap`不能保证时间推移下map内顺序不变.\n<!-- more -->\n## 构造函数\n国际惯例, 我们先看下他的构造函数, 他需要两个参数, 分别是初始容量`initialCapacity`(默认为 16)和负载因子`loadFactor`(默认为0.75f),\n奇怪的是, threshold的注释说明它应该是等于初始容量 * 负载因子, 而在`tableSizeFor()`方法的计算中, 我们获取到的是初始容量的两倍数据, 这点我们先压下疑问往后看\n``` java\npublic HashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity < 0)\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n        this.loadFactor = loadFactor;\n        // threshold 表示下次需要扩容时的容纳最大值(初始容量 * 负载因子), 如果超出这个值, 则会进行扩容\n        this.threshold = tableSizeFor(initialCapacity);\n    }\n```\n这里threshold的计算方法, 我们姑且看下, `MAXIMUM_CAPACITY`为`1<<30`, 位移运算后值为$2^{29}$\n``` java\n    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n```\n这段代码的意思就是会获取等于或大于`cap`最小的2的幂次,我们以默认值默认值$2^4$为例尝试计算一下, 得到的结果是$2^5$.\n## get(Object key)\n我们首先看下如果对`HashMap`进行查找.\n``` java\npublic V get(Object key) {\n        Node<K,V> e;\n        return (e = getNode(hash(key), key)) == null ? null : e.value;\n    }\n```\n这里`getNode`才是真正用来实现`Map.get`的方法.要注意的是, 这里的定位哈希桶数组的位置的算法, 由于`tab.length`永远是2的幂次, 这里的`(n - 1) & hash`就相当于`hash % n`的操作, 而&比%具有更高的效率, 所以这里的位运算相当于是一个小的优化\n``` java\n    /**\n     * 实现map的get方法\n     * Implements Map.get and related methods\n     *\n     * @param hash hash for key key的hash值\n     * @param key the key key\n     * @return the node, or null if none 返回目标节点, 如果没有则返回\n     */\n    final Node<K,V> getNode(int hash, Object key) {\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n        // tab为空, 并且获取到的目标节点不为空\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) {\n            // 如果hash和key相同\n            if (first.hash == hash && // always check first node\n                ((k = first.key) == key || (key != null && key.equals(k))))\n                // 返回目标节点\n                return first;\n            if ((e = first.next) != null) {\n                // 红黑树情况\n                if (first instanceof TreeNode)\n                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n                // 链表情况\n                do {\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;\n    }\n```\n## put\n同样, put的实际实现是以下方法\n``` java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        // 如果tab为空, 则调用resize分配内存\n        if ((tab = table) == null || (n = tab.length) == 0){\n            n = (tab = resize()).length;\n        }\n        // 通过(n - 1) & hash]获取存入位置, 得到插入位置中的节点p\n        if ((p = tab[i = (n - 1) & hash]) == null)\n            // 节点p为空, 则直接插入\n            tab[i] = newNode(hash, key, value, null);\n        else { // 节点p不为空, 插入位置冲突\n            Node<K,V> e; K k;\n            // 与当前节点第一个节点相同(hash和key都相同)\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k)))){\n                // 节点赋值tab[i]\n                e = p;\n            }\n            // 与第一个节点不相同\n            // 红黑树情况\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            // 链表情况\n            else {\n                // p从表头向后移动\n                for (int binCount = 0; ; ++binCount) {\n                    // 如果移动到链表尾部\n                    if ((e = p.next) == null) {\n                        // 插入到尾部\n                        p.next = newNode(hash, key, value, null);\n                        // 如果达到链->树阈值\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            // 替换红黑树\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    // 找到目标相同节点(hash&&key)\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    // p后移 p = p.next\n                    p = e;\n                }\n            }\n            // 处理hash和key相同的情况\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        // 如果size > threshold时, 进行扩容\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n`put`具体的流程图可以看下图\n\n![put流程图](./put.jpg)\n## 扩容resize\n该方法主要作用就是针对map进行容量初始化或者扩容双倍容量, 另外, 扩容之后, 需要重新计算键值对的位置, 并移动到目标位置上.\n``` java\nfinal Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        if (oldCap > 0) {\n            // 超过最大容量, 无法扩容, 只能改变阈值\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n            // 容量加倍\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                // 阈值加倍\n                newThr = oldThr << 1; // double threshold\n        }\n        // 用阈值初始值新的容量\n        else if (oldThr > 0) // initial capacity was placed in threshold\n            newCap = oldThr;\n        // 当阈值==0的时候\n        else {               // zero initial threshold signifies using defaults\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n        if (newThr == 0) {\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr;\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        // 将旧tab中的Node转移到新tab中, 分链表和红黑树两种情况\n        table = newTab;\n        if (oldTab != null) {\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { // preserve order\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n```\n`resize`做了两步工作, 一步是计算新的阈值和容量, 一步是键值对重新映射.\n之前我们有个疑问, 就是`threshold`的注释明明标注它说是等于初始容量*负载因子, 而在我们的`tableSizeFor`内并没有看到相关的逻辑代码, 这个问题就可以在这里得到解决.\n方法的前段逻辑如下:\n1. 判断当前哈希桶数组(`oldCap`)是否有值, 即哈希桶数组已经被初始化\n  1.  有且长度超过最大值, 则不做扩容\n  2. 有且没有超过最大值, 如果扩容后仍然小于最大值, 则做扩容处理\n2. 但是, 当哈希桶数组没有数据\n  1. 初始阈值(`oldThr`)有值且大于0 , 哈希桶数组容量长度直接沿用老的阈值大小\n  2. 初始阈值没有设置时, 阈值就会设为 加载因子 * 容量\n3. 如果新设置的阈值等于0, 则会赋值为加载因子 * 新的容量大小\n\n## removeNode\n删除的动作与上面的比较来说, 就容易理解了.\n主要可以分为三个动作:\n1. 寻找定位哈希桶数组索引位置\n2. 遍历链表找到键值相等的节点\n3. 删除目标节点\n\n``` java\nfinal Node<K,V> removeNode(int hash, Object key, Object value,\n                               boolean matchValue, boolean movable) {\n        Node<K,V>[] tab; Node<K,V> p; int n, index;\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (p = tab[index = (n - 1) & hash]) != null) {\n            Node<K,V> node = null, e; K k; V v;\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                node = p;\n            else if ((e = p.next) != null) {\n                if (p instanceof TreeNode)\n                    node = ((TreeNode<K,V>)p).getTreeNode(hash, key);\n                else {\n                    do {\n                        if (e.hash == hash &&\n                            ((k = e.key) == key ||\n                             (key != null && key.equals(k)))) {\n                            node = e;\n                            break;\n                        }\n                        p = e;\n                    } while ((e = e.next) != null);\n                }\n            }\n            if (node != null && (!matchValue || (v = node.value) == value ||\n                                 (value != null && value.equals(v)))) {\n                if (node instanceof TreeNode)\n                    ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);\n                else if (node == p)\n                    tab[index] = node.next;\n                else\n                    p.next = node.next;\n                ++modCount;\n                --size;\n                afterNodeRemoval(node);\n                return node;\n            }\n        }\n        return null;\n    }\n```\n## 总结\n本篇主要解释了几个常用方法的实现原理, 在此做下记录. 不过关于红黑树的相关知识, 就不在这里多加说明了.\n","source":"_posts/HashMap源码解析1.md","raw":"title: HashMap源码解析(一)\ndate: 2018-02-02 00:00:00\ncategories:\n- 源码解析\ntags:\n- 源码解析\n---\n\n## 前言\n本篇主要了解下`HashMap`的源码, 以便了解其常用方法的实现原理.本篇以android SDK API26内的Java源码为准\n## HashMap是什么\n`HashMap`是基于实现`Map`接口的哈希表, 但是他和`HashTable`有一定的区别, 主要区分在`HashMap`可以传`null`的键值对, 而且他`不是线程安全`的, 如果需要支持同步, 则需要调用`Collections.synchronizedMap(Map<K,V> m) `方法. 同时, `HashMap`不能保证时间推移下map内顺序不变.\n<!-- more -->\n## 构造函数\n国际惯例, 我们先看下他的构造函数, 他需要两个参数, 分别是初始容量`initialCapacity`(默认为 16)和负载因子`loadFactor`(默认为0.75f),\n奇怪的是, threshold的注释说明它应该是等于初始容量 * 负载因子, 而在`tableSizeFor()`方法的计算中, 我们获取到的是初始容量的两倍数据, 这点我们先压下疑问往后看\n``` java\npublic HashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity < 0)\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n        this.loadFactor = loadFactor;\n        // threshold 表示下次需要扩容时的容纳最大值(初始容量 * 负载因子), 如果超出这个值, 则会进行扩容\n        this.threshold = tableSizeFor(initialCapacity);\n    }\n```\n这里threshold的计算方法, 我们姑且看下, `MAXIMUM_CAPACITY`为`1<<30`, 位移运算后值为$2^{29}$\n``` java\n    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n```\n这段代码的意思就是会获取等于或大于`cap`最小的2的幂次,我们以默认值默认值$2^4$为例尝试计算一下, 得到的结果是$2^5$.\n## get(Object key)\n我们首先看下如果对`HashMap`进行查找.\n``` java\npublic V get(Object key) {\n        Node<K,V> e;\n        return (e = getNode(hash(key), key)) == null ? null : e.value;\n    }\n```\n这里`getNode`才是真正用来实现`Map.get`的方法.要注意的是, 这里的定位哈希桶数组的位置的算法, 由于`tab.length`永远是2的幂次, 这里的`(n - 1) & hash`就相当于`hash % n`的操作, 而&比%具有更高的效率, 所以这里的位运算相当于是一个小的优化\n``` java\n    /**\n     * 实现map的get方法\n     * Implements Map.get and related methods\n     *\n     * @param hash hash for key key的hash值\n     * @param key the key key\n     * @return the node, or null if none 返回目标节点, 如果没有则返回\n     */\n    final Node<K,V> getNode(int hash, Object key) {\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n        // tab为空, 并且获取到的目标节点不为空\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) {\n            // 如果hash和key相同\n            if (first.hash == hash && // always check first node\n                ((k = first.key) == key || (key != null && key.equals(k))))\n                // 返回目标节点\n                return first;\n            if ((e = first.next) != null) {\n                // 红黑树情况\n                if (first instanceof TreeNode)\n                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n                // 链表情况\n                do {\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;\n    }\n```\n## put\n同样, put的实际实现是以下方法\n``` java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        // 如果tab为空, 则调用resize分配内存\n        if ((tab = table) == null || (n = tab.length) == 0){\n            n = (tab = resize()).length;\n        }\n        // 通过(n - 1) & hash]获取存入位置, 得到插入位置中的节点p\n        if ((p = tab[i = (n - 1) & hash]) == null)\n            // 节点p为空, 则直接插入\n            tab[i] = newNode(hash, key, value, null);\n        else { // 节点p不为空, 插入位置冲突\n            Node<K,V> e; K k;\n            // 与当前节点第一个节点相同(hash和key都相同)\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k)))){\n                // 节点赋值tab[i]\n                e = p;\n            }\n            // 与第一个节点不相同\n            // 红黑树情况\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            // 链表情况\n            else {\n                // p从表头向后移动\n                for (int binCount = 0; ; ++binCount) {\n                    // 如果移动到链表尾部\n                    if ((e = p.next) == null) {\n                        // 插入到尾部\n                        p.next = newNode(hash, key, value, null);\n                        // 如果达到链->树阈值\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            // 替换红黑树\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    // 找到目标相同节点(hash&&key)\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    // p后移 p = p.next\n                    p = e;\n                }\n            }\n            // 处理hash和key相同的情况\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        // 如果size > threshold时, 进行扩容\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n`put`具体的流程图可以看下图\n\n![put流程图](./put.jpg)\n## 扩容resize\n该方法主要作用就是针对map进行容量初始化或者扩容双倍容量, 另外, 扩容之后, 需要重新计算键值对的位置, 并移动到目标位置上.\n``` java\nfinal Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        if (oldCap > 0) {\n            // 超过最大容量, 无法扩容, 只能改变阈值\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n            // 容量加倍\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                // 阈值加倍\n                newThr = oldThr << 1; // double threshold\n        }\n        // 用阈值初始值新的容量\n        else if (oldThr > 0) // initial capacity was placed in threshold\n            newCap = oldThr;\n        // 当阈值==0的时候\n        else {               // zero initial threshold signifies using defaults\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n        if (newThr == 0) {\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr;\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        // 将旧tab中的Node转移到新tab中, 分链表和红黑树两种情况\n        table = newTab;\n        if (oldTab != null) {\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { // preserve order\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n```\n`resize`做了两步工作, 一步是计算新的阈值和容量, 一步是键值对重新映射.\n之前我们有个疑问, 就是`threshold`的注释明明标注它说是等于初始容量*负载因子, 而在我们的`tableSizeFor`内并没有看到相关的逻辑代码, 这个问题就可以在这里得到解决.\n方法的前段逻辑如下:\n1. 判断当前哈希桶数组(`oldCap`)是否有值, 即哈希桶数组已经被初始化\n  1.  有且长度超过最大值, 则不做扩容\n  2. 有且没有超过最大值, 如果扩容后仍然小于最大值, 则做扩容处理\n2. 但是, 当哈希桶数组没有数据\n  1. 初始阈值(`oldThr`)有值且大于0 , 哈希桶数组容量长度直接沿用老的阈值大小\n  2. 初始阈值没有设置时, 阈值就会设为 加载因子 * 容量\n3. 如果新设置的阈值等于0, 则会赋值为加载因子 * 新的容量大小\n\n## removeNode\n删除的动作与上面的比较来说, 就容易理解了.\n主要可以分为三个动作:\n1. 寻找定位哈希桶数组索引位置\n2. 遍历链表找到键值相等的节点\n3. 删除目标节点\n\n``` java\nfinal Node<K,V> removeNode(int hash, Object key, Object value,\n                               boolean matchValue, boolean movable) {\n        Node<K,V>[] tab; Node<K,V> p; int n, index;\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (p = tab[index = (n - 1) & hash]) != null) {\n            Node<K,V> node = null, e; K k; V v;\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                node = p;\n            else if ((e = p.next) != null) {\n                if (p instanceof TreeNode)\n                    node = ((TreeNode<K,V>)p).getTreeNode(hash, key);\n                else {\n                    do {\n                        if (e.hash == hash &&\n                            ((k = e.key) == key ||\n                             (key != null && key.equals(k)))) {\n                            node = e;\n                            break;\n                        }\n                        p = e;\n                    } while ((e = e.next) != null);\n                }\n            }\n            if (node != null && (!matchValue || (v = node.value) == value ||\n                                 (value != null && value.equals(v)))) {\n                if (node instanceof TreeNode)\n                    ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);\n                else if (node == p)\n                    tab[index] = node.next;\n                else\n                    p.next = node.next;\n                ++modCount;\n                --size;\n                afterNodeRemoval(node);\n                return node;\n            }\n        }\n        return null;\n    }\n```\n## 总结\n本篇主要解释了几个常用方法的实现原理, 在此做下记录. 不过关于红黑树的相关知识, 就不在这里多加说明了.\n","slug":"HashMap源码解析1","published":1,"updated":"2018-05-15T09:05:49.049Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjld5ah2r001dcqs62z151ef2","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本篇主要了解下<code>HashMap</code>的源码, 以便了解其常用方法的实现原理.本篇以android SDK API26内的Java源码为准</p>\n<h2 id=\"HashMap是什么\"><a href=\"#HashMap是什么\" class=\"headerlink\" title=\"HashMap是什么\"></a>HashMap是什么</h2><p><code>HashMap</code>是基于实现<code>Map</code>接口的哈希表, 但是他和<code>HashTable</code>有一定的区别, 主要区分在<code>HashMap</code>可以传<code>null</code>的键值对, 而且他<code>不是线程安全</code>的, 如果需要支持同步, 则需要调用<code>Collections.synchronizedMap(Map&lt;K,V&gt; m)</code>方法. 同时, <code>HashMap</code>不能保证时间推移下map内顺序不变.<br><a id=\"more\"></a></p>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>国际惯例, 我们先看下他的构造函数, 他需要两个参数, 分别是初始容量<code>initialCapacity</code>(默认为 16)和负载因子<code>loadFactor</code>(默认为0.75f),<br>奇怪的是, threshold的注释说明它应该是等于初始容量 * 负载因子, 而在<code>tableSizeFor()</code>方法的计算中, 我们获取到的是初始容量的两倍数据, 这点我们先压下疑问往后看<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span> +</span><br><span class=\"line\">                                               initialCapacity);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span> +</span><br><span class=\"line\">                                               loadFactor);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">        <span class=\"comment\">// threshold 表示下次需要扩容时的容纳最大值(初始容量 * 负载因子), 如果超出这个值, 则会进行扩容</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里threshold的计算方法, 我们姑且看下, <code>MAXIMUM_CAPACITY</code>为<code>1&lt;&lt;30</code>, 位移运算后值为$2^{29}$<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码的意思就是会获取等于或大于<code>cap</code>最小的2的幂次,我们以默认值默认值$2^4$为例尝试计算一下, 得到的结果是$2^5$.</p>\n<h2 id=\"get-Object-key\"><a href=\"#get-Object-key\" class=\"headerlink\" title=\"get(Object key)\"></a>get(Object key)</h2><p>我们首先看下如果对<code>HashMap</code>进行查找.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里<code>getNode</code>才是真正用来实现<code>Map.get</code>的方法.要注意的是, 这里的定位哈希桶数组的位置的算法, 由于<code>tab.length</code>永远是2的幂次, 这里的<code>(n - 1) &amp; hash</code>就相当于<code>hash % n</code>的操作, 而&amp;比%具有更高的效率, 所以这里的位运算相当于是一个小的优化<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现map的get方法</span></span><br><span class=\"line\"><span class=\"comment\"> * Implements Map.get and related methods</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> hash hash for key key的hash值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key the key key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the node, or null if none 返回目标节点, 如果没有则返回</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</span><br><span class=\"line\">    <span class=\"comment\">// tab为空, 并且获取到的目标节点不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果hash和key相同</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">            ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            <span class=\"comment\">// 返回目标节点</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 红黑树情况</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">            <span class=\"comment\">// 链表情况</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put\"></a>put</h2><p>同样, put的实际实现是以下方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">        <span class=\"comment\">// 如果tab为空, 则调用resize分配内存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            n = (tab = resize()).length;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 通过(n - 1) &amp; hash]获取存入位置, 得到插入位置中的节点p</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"comment\">// 节点p为空, 则直接插入</span></span><br><span class=\"line\">            tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 节点p不为空, 插入位置冲突</span></span><br><span class=\"line\">            Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">            <span class=\"comment\">// 与当前节点第一个节点相同(hash和key都相同)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">                ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 节点赋值tab[i]</span></span><br><span class=\"line\">                e = p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 与第一个节点不相同</span></span><br><span class=\"line\">            <span class=\"comment\">// 红黑树情况</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">            <span class=\"comment\">// 链表情况</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// p从表头向后移动</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果移动到链表尾部</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 插入到尾部</span></span><br><span class=\"line\">                        p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                        <span class=\"comment\">// 如果达到链-&gt;树阈值</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                            <span class=\"comment\">// 替换红黑树</span></span><br><span class=\"line\">                            treeifyBin(tab, hash);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// 找到目标相同节点(hash&amp;&amp;key)</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                        ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// p后移 p = p.next</span></span><br><span class=\"line\">                    p = e;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 处理hash和key相同的情况</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">                V oldValue = e.value;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    e.value = value;</span><br><span class=\"line\">                afterNodeAccess(e);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ++modCount;</span><br><span class=\"line\">        <span class=\"comment\">// 如果size &gt; threshold时, 进行扩容</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        afterNodeInsertion(evict);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>put</code>具体的流程图可以看下图</p>\n<p><img src=\"./put.jpg\" alt=\"put流程图\"></p>\n<h2 id=\"扩容resize\"><a href=\"#扩容resize\" class=\"headerlink\" title=\"扩容resize\"></a>扩容resize</h2><p>该方法主要作用就是针对map进行容量初始化或者扩容双倍容量, 另外, 扩容之后, 需要重新计算键值对的位置, 并移动到目标位置上.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 超过最大容量, 无法扩容, 只能改变阈值</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">                threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 容量加倍</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">                <span class=\"comment\">// 阈值加倍</span></span><br><span class=\"line\">                newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 用阈值初始值新的容量</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">            newCap = oldThr;</span><br><span class=\"line\">        <span class=\"comment\">// 当阈值==0的时候</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">            newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                      (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        threshold = newThr;</span><br><span class=\"line\">        <span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"rawtypes\"</span>,<span class=\"string\">\"unchecked\"</span>&#125;)</span><br><span class=\"line\">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">        <span class=\"comment\">// 将旧tab中的Node转移到新tab中, 分链表和红黑树两种情况</span></span><br><span class=\"line\">        table = newTab;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">                Node&lt;K,V&gt; e;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                        ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">                        Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        Node&lt;K,V&gt; next;</span><br><span class=\"line\">                        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                            next = e.next;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                    loHead = e;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span></span><br><span class=\"line\">                                    loTail.next = e;</span><br><span class=\"line\">                                loTail = e;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                    hiHead = e;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span></span><br><span class=\"line\">                                    hiTail.next = e;</span><br><span class=\"line\">                                hiTail = e;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                            newTab[j] = loHead;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                            newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>resize</code>做了两步工作, 一步是计算新的阈值和容量, 一步是键值对重新映射.<br>之前我们有个疑问, 就是<code>threshold</code>的注释明明标注它说是等于初始容量*负载因子, 而在我们的<code>tableSizeFor</code>内并没有看到相关的逻辑代码, 这个问题就可以在这里得到解决.<br>方法的前段逻辑如下:</p>\n<ol>\n<li>判断当前哈希桶数组(<code>oldCap</code>)是否有值, 即哈希桶数组已经被初始化<ol>\n<li>有且长度超过最大值, 则不做扩容</li>\n<li>有且没有超过最大值, 如果扩容后仍然小于最大值, 则做扩容处理</li>\n</ol>\n</li>\n<li>但是, 当哈希桶数组没有数据<ol>\n<li>初始阈值(<code>oldThr</code>)有值且大于0 , 哈希桶数组容量长度直接沿用老的阈值大小</li>\n<li>初始阈值没有设置时, 阈值就会设为 加载因子 * 容量</li>\n</ol>\n</li>\n<li>如果新设置的阈值等于0, 则会赋值为加载因子 * 新的容量大小</li>\n</ol>\n<h2 id=\"removeNode\"><a href=\"#removeNode\" class=\"headerlink\" title=\"removeNode\"></a>removeNode</h2><p>删除的动作与上面的比较来说, 就容易理解了.<br>主要可以分为三个动作:</p>\n<ol>\n<li>寻找定位哈希桶数组索引位置</li>\n<li>遍历链表找到键值相等的节点</li>\n<li>删除目标节点</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">removeNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key, Object value,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                               <span class=\"keyword\">boolean</span> matchValue, <span class=\"keyword\">boolean</span> movable)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, index;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">            (p = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; node = <span class=\"keyword\">null</span>, e; K k; V v;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">                ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                node = p;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = p.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                            ((k = e.key) == key ||</span><br><span class=\"line\">                             (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class=\"line\">                            node = e;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        p = e;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node != <span class=\"keyword\">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class=\"line\">                                 (value != <span class=\"keyword\">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class=\"keyword\">this</span>, tab, movable);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node == p)</span><br><span class=\"line\">                    tab[index] = node.next;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    p.next = node.next;</span><br><span class=\"line\">                ++modCount;</span><br><span class=\"line\">                --size;</span><br><span class=\"line\">                afterNodeRemoval(node);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本篇主要解释了几个常用方法的实现原理, 在此做下记录. 不过关于红黑树的相关知识, 就不在这里多加说明了.</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本篇主要了解下<code>HashMap</code>的源码, 以便了解其常用方法的实现原理.本篇以android SDK API26内的Java源码为准</p>\n<h2 id=\"HashMap是什么\"><a href=\"#HashMap是什么\" class=\"headerlink\" title=\"HashMap是什么\"></a>HashMap是什么</h2><p><code>HashMap</code>是基于实现<code>Map</code>接口的哈希表, 但是他和<code>HashTable</code>有一定的区别, 主要区分在<code>HashMap</code>可以传<code>null</code>的键值对, 而且他<code>不是线程安全</code>的, 如果需要支持同步, 则需要调用<code>Collections.synchronizedMap(Map&lt;K,V&gt; m)</code>方法. 同时, <code>HashMap</code>不能保证时间推移下map内顺序不变.<br>","more":"</p>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>国际惯例, 我们先看下他的构造函数, 他需要两个参数, 分别是初始容量<code>initialCapacity</code>(默认为 16)和负载因子<code>loadFactor</code>(默认为0.75f),<br>奇怪的是, threshold的注释说明它应该是等于初始容量 * 负载因子, 而在<code>tableSizeFor()</code>方法的计算中, 我们获取到的是初始容量的两倍数据, 这点我们先压下疑问往后看<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span> +</span><br><span class=\"line\">                                               initialCapacity);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span> +</span><br><span class=\"line\">                                               loadFactor);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">        <span class=\"comment\">// threshold 表示下次需要扩容时的容纳最大值(初始容量 * 负载因子), 如果超出这个值, 则会进行扩容</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里threshold的计算方法, 我们姑且看下, <code>MAXIMUM_CAPACITY</code>为<code>1&lt;&lt;30</code>, 位移运算后值为$2^{29}$<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码的意思就是会获取等于或大于<code>cap</code>最小的2的幂次,我们以默认值默认值$2^4$为例尝试计算一下, 得到的结果是$2^5$.</p>\n<h2 id=\"get-Object-key\"><a href=\"#get-Object-key\" class=\"headerlink\" title=\"get(Object key)\"></a>get(Object key)</h2><p>我们首先看下如果对<code>HashMap</code>进行查找.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里<code>getNode</code>才是真正用来实现<code>Map.get</code>的方法.要注意的是, 这里的定位哈希桶数组的位置的算法, 由于<code>tab.length</code>永远是2的幂次, 这里的<code>(n - 1) &amp; hash</code>就相当于<code>hash % n</code>的操作, 而&amp;比%具有更高的效率, 所以这里的位运算相当于是一个小的优化<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现map的get方法</span></span><br><span class=\"line\"><span class=\"comment\"> * Implements Map.get and related methods</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> hash hash for key key的hash值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key the key key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the node, or null if none 返回目标节点, 如果没有则返回</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</span><br><span class=\"line\">    <span class=\"comment\">// tab为空, 并且获取到的目标节点不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果hash和key相同</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">            ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            <span class=\"comment\">// 返回目标节点</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 红黑树情况</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">            <span class=\"comment\">// 链表情况</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put\"></a>put</h2><p>同样, put的实际实现是以下方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">        <span class=\"comment\">// 如果tab为空, 则调用resize分配内存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            n = (tab = resize()).length;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 通过(n - 1) &amp; hash]获取存入位置, 得到插入位置中的节点p</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"comment\">// 节点p为空, 则直接插入</span></span><br><span class=\"line\">            tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 节点p不为空, 插入位置冲突</span></span><br><span class=\"line\">            Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">            <span class=\"comment\">// 与当前节点第一个节点相同(hash和key都相同)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">                ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 节点赋值tab[i]</span></span><br><span class=\"line\">                e = p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 与第一个节点不相同</span></span><br><span class=\"line\">            <span class=\"comment\">// 红黑树情况</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">            <span class=\"comment\">// 链表情况</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// p从表头向后移动</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果移动到链表尾部</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 插入到尾部</span></span><br><span class=\"line\">                        p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                        <span class=\"comment\">// 如果达到链-&gt;树阈值</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                            <span class=\"comment\">// 替换红黑树</span></span><br><span class=\"line\">                            treeifyBin(tab, hash);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// 找到目标相同节点(hash&amp;&amp;key)</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                        ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// p后移 p = p.next</span></span><br><span class=\"line\">                    p = e;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 处理hash和key相同的情况</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">                V oldValue = e.value;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    e.value = value;</span><br><span class=\"line\">                afterNodeAccess(e);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ++modCount;</span><br><span class=\"line\">        <span class=\"comment\">// 如果size &gt; threshold时, 进行扩容</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        afterNodeInsertion(evict);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>put</code>具体的流程图可以看下图</p>\n<p><img src=\"./put.jpg\" alt=\"put流程图\"></p>\n<h2 id=\"扩容resize\"><a href=\"#扩容resize\" class=\"headerlink\" title=\"扩容resize\"></a>扩容resize</h2><p>该方法主要作用就是针对map进行容量初始化或者扩容双倍容量, 另外, 扩容之后, 需要重新计算键值对的位置, 并移动到目标位置上.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 超过最大容量, 无法扩容, 只能改变阈值</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">                threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 容量加倍</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">                <span class=\"comment\">// 阈值加倍</span></span><br><span class=\"line\">                newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 用阈值初始值新的容量</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">            newCap = oldThr;</span><br><span class=\"line\">        <span class=\"comment\">// 当阈值==0的时候</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">            newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                      (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        threshold = newThr;</span><br><span class=\"line\">        <span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"rawtypes\"</span>,<span class=\"string\">\"unchecked\"</span>&#125;)</span><br><span class=\"line\">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">        <span class=\"comment\">// 将旧tab中的Node转移到新tab中, 分链表和红黑树两种情况</span></span><br><span class=\"line\">        table = newTab;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">                Node&lt;K,V&gt; e;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                        ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">                        Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        Node&lt;K,V&gt; next;</span><br><span class=\"line\">                        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                            next = e.next;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                    loHead = e;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span></span><br><span class=\"line\">                                    loTail.next = e;</span><br><span class=\"line\">                                loTail = e;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                    hiHead = e;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span></span><br><span class=\"line\">                                    hiTail.next = e;</span><br><span class=\"line\">                                hiTail = e;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                            newTab[j] = loHead;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                            newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>resize</code>做了两步工作, 一步是计算新的阈值和容量, 一步是键值对重新映射.<br>之前我们有个疑问, 就是<code>threshold</code>的注释明明标注它说是等于初始容量*负载因子, 而在我们的<code>tableSizeFor</code>内并没有看到相关的逻辑代码, 这个问题就可以在这里得到解决.<br>方法的前段逻辑如下:</p>\n<ol>\n<li>判断当前哈希桶数组(<code>oldCap</code>)是否有值, 即哈希桶数组已经被初始化<ol>\n<li>有且长度超过最大值, 则不做扩容</li>\n<li>有且没有超过最大值, 如果扩容后仍然小于最大值, 则做扩容处理</li>\n</ol>\n</li>\n<li>但是, 当哈希桶数组没有数据<ol>\n<li>初始阈值(<code>oldThr</code>)有值且大于0 , 哈希桶数组容量长度直接沿用老的阈值大小</li>\n<li>初始阈值没有设置时, 阈值就会设为 加载因子 * 容量</li>\n</ol>\n</li>\n<li>如果新设置的阈值等于0, 则会赋值为加载因子 * 新的容量大小</li>\n</ol>\n<h2 id=\"removeNode\"><a href=\"#removeNode\" class=\"headerlink\" title=\"removeNode\"></a>removeNode</h2><p>删除的动作与上面的比较来说, 就容易理解了.<br>主要可以分为三个动作:</p>\n<ol>\n<li>寻找定位哈希桶数组索引位置</li>\n<li>遍历链表找到键值相等的节点</li>\n<li>删除目标节点</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">removeNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key, Object value,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                               <span class=\"keyword\">boolean</span> matchValue, <span class=\"keyword\">boolean</span> movable)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, index;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">            (p = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; node = <span class=\"keyword\">null</span>, e; K k; V v;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">                ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                node = p;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = p.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                            ((k = e.key) == key ||</span><br><span class=\"line\">                             (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class=\"line\">                            node = e;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        p = e;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node != <span class=\"keyword\">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class=\"line\">                                 (value != <span class=\"keyword\">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class=\"keyword\">this</span>, tab, movable);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node == p)</span><br><span class=\"line\">                    tab[index] = node.next;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    p.next = node.next;</span><br><span class=\"line\">                ++modCount;</span><br><span class=\"line\">                --size;</span><br><span class=\"line\">                afterNodeRemoval(node);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本篇主要解释了几个常用方法的实现原理, 在此做下记录. 不过关于红黑树的相关知识, 就不在这里多加说明了.</p>"},{"title":"Kotlin零散二三点","date":"2018-05-24T16:00:00.000Z","_content":"本篇主要谈些`Kotlin`开发过程比较常用到的技巧\n<!--more-->\n## 空安全处理\n在Kotlin中, 最出名的特性莫过于就是它的`空安全`了, 毕竟`NPE`应该是大家最不想看到的错误信息.\n我们先回顾下Kotlin如何处理`空安全`\n> 我们有四种方法来避免NPE\n> 1. 在条件中检查null\n> 2. 安全调用使用?.\n> 3. 使用Elvis 操作符 ?:\n> 4. 使用!!操作符\n\n当然关于第四点使用`!!`操作符, 他的本质就回归到了当遇到null的时候仍然会抛出NPE. 所以在非必须的情况下, 我们应该尽量避免使用`!!`\n\n为了避免NPE, 在kotlin的类型系统中, 它做到的就是强制开发者明确定义目标类型是否是可空类型(通过`?`区别), 如果一个变量是可空的, 我们需要这样写\n``` java\nvar nullpossible: String? = null\n```\n而像下面这种, 是永远不会编译通过的\n``` java\nvar nullpossible: String = null\n```\n当我们在定义一个变量的时候, 当能够确保他是非空类型的时候就必须要在构造器中初始化, 然而这在实际开发中是非常不方便的.\n``` kotlin\nvar a: String = ...\n```\n我们可以利用几种方式来解决\n1. 使用`lateinit`延迟初始化\n2. 使用[委托](https://www.kotlincn.net/docs/reference/delegation.html)`Delegates.notNull()`\n\n``` java\nvar test: String by Delegates.notNull()\nlateinit var testinit: String\n```\n不管我们使用哪种方式, 都可以让我们避免在初次定义类型的时候就必须初始化工作, 当然不论哪种方式, 在初始化前调用属性都是会抛出异常的.\n\n而关于`Delegates.notNull()`, 通过源码我们可以看到他实际返回的是`NotNullVar`的委托.而通过`NotNullVar`中的`getValue()`返回直接定义为非空属性.\n``` java\npublic object Delegates {\n    public fun <T: Any> notNull(): ReadWriteProperty<Any?, T> = NotNullVar()\n}\nprivate class NotNullVar<T: Any>() : ReadWriteProperty<Any?, T> {\n    private var value: T? = null\n\n    public override fun getValue(thisRef: Any?, property: KProperty<*>): T {\n        return value ?: throw IllegalStateException(\"Property ${property.name} should be initialized before get.\")\n    }\n\n    public override fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {\n        this.value = value\n    }\n}\n```\n还有一种方式是通过委托属性`by lazy`, 但是他只可以修饰`val`, 会在第一次调用对应属性的时候进行初始化, 默认是线程安全\n``` java\nval testlazy: String by lazy { \"fff\"}\n```\n另外他可以通过传入参数来选择不同的多线程处理\n``` java\n@kotlin.jvm.JvmVersion\npublic fun <T> lazy(mode: LazyThreadSafetyMode, initializer: () -> T): Lazy<T> =\n        when (mode) {\n            /*\n            * 使用同步锁确保只有一条线程可以进行实例化\n            */\n            LazyThreadSafetyMode.SYNCHRONIZED -> SynchronizedLazyImpl(initializer)\n            /*\n            * 同一时期多个线程可以初始化实例，但是只有最先返回的值会作为延迟初始化的实例，使用 AtomicReferenceFieldUpdater.compareAndSet() 方法实现。\n            **/\n            LazyThreadSafetyMode.PUBLICATION -> SafePublicationLazyImpl(initializer)\n            /**\n            * 没有任何线程安全保证与开销\n            */\n            LazyThreadSafetyMode.NONE -> UnsafeLazyImpl(initializer)\n        }\n```\n## 单例模式的实现\nKotlin提供了`object`来很方便的支持了单例模式的实现\n``` java\nobject Singleton {\n    fun test(){\n        // ...\n    }\n}\n\n// kotlin中调用\nSingleton.test()\n// java中调用\nSingleton.INSTANCE.test();\n```\n我们看下他转为Java代码后是如何实现的.\n``` java\npublic final class Singleton {\n   public static final Singleton INSTANCE;\n\n   public final void test() {\n   }\n\n   static {\n      Singleton var0 = new Singleton();\n      INSTANCE = var0;\n   }\n}\n```\n很好, 一个典型的饿汉式. 饿汉式的缺点我们简明讲下, 由于是类加载的第一时间就会新建实例, 所以当我们整个工程没有用到的时候, 就会导致内存空间的浪费.另外, 它无法自定义构造函数.\n![object](./Kotlin.png)\n如果我们不适用`object`呢, 应该如何实现单例模式?\n\n我们来尝试用kotlin写一个`DSL`单例模式, 先看java的实现方法\n``` java\npublic class SingletonDSL {\n    private static volatile SingletonDSL instance;\n\n    private SingletonDSL(){\n\n    }\n\n    public static SingletonDSL getInstance() {\n        if(null == instance){\n            synchronized (SingletonDSL.class){\n                if(null == instance){\n                    instance = new SingletonDSL();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\nok, 下面是翻译工作\n``` java\nclass SingleDSLKotlin private constructor (){\n    companion object {\n        @Volatile private var sInstance: SingleDSLKotlin? = null\n\n        fun getInstance() = sInstance ?: synchronized(SingleDSLKotlin::class.java){\n            sInstance ?: SingleDSLKotlin().also { sInstance = it }\n        }\n    }\n}\n```\n根据上面`lazy`的延迟初始化的特性(通过查看源码我们可以发现他内部也是用双重锁机制来实现的), 我们还可以更加的简单实现\n``` java\nclass SingleDSLKotlin private constructor (){\n    companion object {\n        val INSTANCE by lazy { SingleDSLKotlin() }\n    }\n}\n```\n当然我们也可以通过静态内部类来实现单例模式\n``` java\nclass SingletonStaticClass private constructor(){\n\n    fun getInstance() = INSTANCE.sInstance\n\n\n    companion object INSTANCE{\n        private val sInstance = SingletonStaticClass()\n    }\n}\n```\n这里关于构造函数的相关基础知识可参见[官网](https://www.kotlincn.net/docs/reference/classes.html)\n\n## 域函数的区别\n我们在前面写DSL单例的demo的时候, 用到了一个`also`.我们开发过程中会经常用到这几个作用域函数`run`, `with`, `apply`, `with`, `also`, `let`\n\n要理解源码, 我们首先要搞明白`inline`[内联函数](https://www.kotlincn.net/docs/reference/inline-functions.html)是做什么用的.\n\n> 在kotlin中, 函数也是作为一个对象存储在内存中.当我们调用一个函数的时候, VM首先去找你函数存储的位置, 然后执行函数, 最后再回到你调用函数的地方. 这会分别引入了内存空间的开销和虚拟调用运行的时间开销\n\n而内联函数做的就是在编译期就将函数的`调用`替换成函数的`定义`.\n\n然后我们再回头看这几个函数的作用\n### let\n我们最开始接触的作用域函数应该就是`let`了, 当我们处理一个可空对象的时候, 要获取它的内部某个属性的时候, 我们一般都是通过使用`?.let{}`来忽略掉空对象逻辑处理情况\n``` java\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n```\n可以看到他是将自身T作为参数传入调用函数中, 然后返回最后执行的结果.\n``` Java\nprivate fun descriLet(){\n        val des = \"showValue\"\n        val letResult = des.let {\n            Log.e(\"lettt\", it)\n            true\n        }\n        Log.e(\"let result\", letResult.toString())\n    }\n```\n我们可以通过输出结果里验证\n![let](./let.png)\n### run\n``` Java\n/**\n * Calls the specified function [block] and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n```\n可以看出当我们使用`T.run`的时候, 是作为T.()扩展函数的调用块, 最后返回闭包执行的结果\n``` Java\nprivate fun describeRun(){\n        val runResult = run{\n            true\n        }\n        Log.e(\"run result\", runResult.toString())\n\n        val runResult1 = \"T.run\".run {\n            Log.e(\"run\", this)\n            Log.e(\"length\", length.toString()) // print \"length: 5\"\n            2\n        }\n        Log.e(\"run result2\", runResult1.toString())  // print \"run result2: 2\"\n    }\n```\n### also\n``` java\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n```\n`also`和`let`有点像, 但是他返回的对象与闭包执行结果没有关系, 返回的是调用对象本身\n``` Java\nprivate fun describeAlso(){\n        val alsoResult = \"also result\".also {\n            it.reversed()\n        }\n        Log.e(\"also result\", alsoResult) // print \"also result: also result\"\n    }\n```\n### apply\n``` java\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n```\n作为T.()扩展函数调用块执行, 返回被调用对象本身\n``` Java\nprivate fun describeApply(){\n        val applyResult = \"apply\".apply {\n            reversed()\n            length\n        }\n        Log.e(\"apply Result\", applyResult) // print \"apply Result: apply\"\n    }\n```\n### with\n``` Java\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n```\n`with`需要我们传入一个参数`receiver`, 然后作为它的扩展函数执行闭包, 返回执行结果.\n``` Java\nprivate fun describeWith(){\n        val withResult = with(\"with\"){\n            reversed()\n        }\n        Log.e(\"with result\", withResult) // print \"with result: htiw\"\n    }\n```\n关于他们在用处上的一些区别, 可以看[这里](https://medium.com/@elye.project/mastering-kotlin-standard-functions-run-with-let-also-and-apply-9cd334b0ef84)\n","source":"_posts/Kotlin零散二三点.md","raw":"title: Kotlin零散二三点\ndate: 2018-05-25 00:00:00\ncategories:\n- kotlin\ntags:\n- android\n- kotlin\n---\n本篇主要谈些`Kotlin`开发过程比较常用到的技巧\n<!--more-->\n## 空安全处理\n在Kotlin中, 最出名的特性莫过于就是它的`空安全`了, 毕竟`NPE`应该是大家最不想看到的错误信息.\n我们先回顾下Kotlin如何处理`空安全`\n> 我们有四种方法来避免NPE\n> 1. 在条件中检查null\n> 2. 安全调用使用?.\n> 3. 使用Elvis 操作符 ?:\n> 4. 使用!!操作符\n\n当然关于第四点使用`!!`操作符, 他的本质就回归到了当遇到null的时候仍然会抛出NPE. 所以在非必须的情况下, 我们应该尽量避免使用`!!`\n\n为了避免NPE, 在kotlin的类型系统中, 它做到的就是强制开发者明确定义目标类型是否是可空类型(通过`?`区别), 如果一个变量是可空的, 我们需要这样写\n``` java\nvar nullpossible: String? = null\n```\n而像下面这种, 是永远不会编译通过的\n``` java\nvar nullpossible: String = null\n```\n当我们在定义一个变量的时候, 当能够确保他是非空类型的时候就必须要在构造器中初始化, 然而这在实际开发中是非常不方便的.\n``` kotlin\nvar a: String = ...\n```\n我们可以利用几种方式来解决\n1. 使用`lateinit`延迟初始化\n2. 使用[委托](https://www.kotlincn.net/docs/reference/delegation.html)`Delegates.notNull()`\n\n``` java\nvar test: String by Delegates.notNull()\nlateinit var testinit: String\n```\n不管我们使用哪种方式, 都可以让我们避免在初次定义类型的时候就必须初始化工作, 当然不论哪种方式, 在初始化前调用属性都是会抛出异常的.\n\n而关于`Delegates.notNull()`, 通过源码我们可以看到他实际返回的是`NotNullVar`的委托.而通过`NotNullVar`中的`getValue()`返回直接定义为非空属性.\n``` java\npublic object Delegates {\n    public fun <T: Any> notNull(): ReadWriteProperty<Any?, T> = NotNullVar()\n}\nprivate class NotNullVar<T: Any>() : ReadWriteProperty<Any?, T> {\n    private var value: T? = null\n\n    public override fun getValue(thisRef: Any?, property: KProperty<*>): T {\n        return value ?: throw IllegalStateException(\"Property ${property.name} should be initialized before get.\")\n    }\n\n    public override fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {\n        this.value = value\n    }\n}\n```\n还有一种方式是通过委托属性`by lazy`, 但是他只可以修饰`val`, 会在第一次调用对应属性的时候进行初始化, 默认是线程安全\n``` java\nval testlazy: String by lazy { \"fff\"}\n```\n另外他可以通过传入参数来选择不同的多线程处理\n``` java\n@kotlin.jvm.JvmVersion\npublic fun <T> lazy(mode: LazyThreadSafetyMode, initializer: () -> T): Lazy<T> =\n        when (mode) {\n            /*\n            * 使用同步锁确保只有一条线程可以进行实例化\n            */\n            LazyThreadSafetyMode.SYNCHRONIZED -> SynchronizedLazyImpl(initializer)\n            /*\n            * 同一时期多个线程可以初始化实例，但是只有最先返回的值会作为延迟初始化的实例，使用 AtomicReferenceFieldUpdater.compareAndSet() 方法实现。\n            **/\n            LazyThreadSafetyMode.PUBLICATION -> SafePublicationLazyImpl(initializer)\n            /**\n            * 没有任何线程安全保证与开销\n            */\n            LazyThreadSafetyMode.NONE -> UnsafeLazyImpl(initializer)\n        }\n```\n## 单例模式的实现\nKotlin提供了`object`来很方便的支持了单例模式的实现\n``` java\nobject Singleton {\n    fun test(){\n        // ...\n    }\n}\n\n// kotlin中调用\nSingleton.test()\n// java中调用\nSingleton.INSTANCE.test();\n```\n我们看下他转为Java代码后是如何实现的.\n``` java\npublic final class Singleton {\n   public static final Singleton INSTANCE;\n\n   public final void test() {\n   }\n\n   static {\n      Singleton var0 = new Singleton();\n      INSTANCE = var0;\n   }\n}\n```\n很好, 一个典型的饿汉式. 饿汉式的缺点我们简明讲下, 由于是类加载的第一时间就会新建实例, 所以当我们整个工程没有用到的时候, 就会导致内存空间的浪费.另外, 它无法自定义构造函数.\n![object](./Kotlin.png)\n如果我们不适用`object`呢, 应该如何实现单例模式?\n\n我们来尝试用kotlin写一个`DSL`单例模式, 先看java的实现方法\n``` java\npublic class SingletonDSL {\n    private static volatile SingletonDSL instance;\n\n    private SingletonDSL(){\n\n    }\n\n    public static SingletonDSL getInstance() {\n        if(null == instance){\n            synchronized (SingletonDSL.class){\n                if(null == instance){\n                    instance = new SingletonDSL();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\nok, 下面是翻译工作\n``` java\nclass SingleDSLKotlin private constructor (){\n    companion object {\n        @Volatile private var sInstance: SingleDSLKotlin? = null\n\n        fun getInstance() = sInstance ?: synchronized(SingleDSLKotlin::class.java){\n            sInstance ?: SingleDSLKotlin().also { sInstance = it }\n        }\n    }\n}\n```\n根据上面`lazy`的延迟初始化的特性(通过查看源码我们可以发现他内部也是用双重锁机制来实现的), 我们还可以更加的简单实现\n``` java\nclass SingleDSLKotlin private constructor (){\n    companion object {\n        val INSTANCE by lazy { SingleDSLKotlin() }\n    }\n}\n```\n当然我们也可以通过静态内部类来实现单例模式\n``` java\nclass SingletonStaticClass private constructor(){\n\n    fun getInstance() = INSTANCE.sInstance\n\n\n    companion object INSTANCE{\n        private val sInstance = SingletonStaticClass()\n    }\n}\n```\n这里关于构造函数的相关基础知识可参见[官网](https://www.kotlincn.net/docs/reference/classes.html)\n\n## 域函数的区别\n我们在前面写DSL单例的demo的时候, 用到了一个`also`.我们开发过程中会经常用到这几个作用域函数`run`, `with`, `apply`, `with`, `also`, `let`\n\n要理解源码, 我们首先要搞明白`inline`[内联函数](https://www.kotlincn.net/docs/reference/inline-functions.html)是做什么用的.\n\n> 在kotlin中, 函数也是作为一个对象存储在内存中.当我们调用一个函数的时候, VM首先去找你函数存储的位置, 然后执行函数, 最后再回到你调用函数的地方. 这会分别引入了内存空间的开销和虚拟调用运行的时间开销\n\n而内联函数做的就是在编译期就将函数的`调用`替换成函数的`定义`.\n\n然后我们再回头看这几个函数的作用\n### let\n我们最开始接触的作用域函数应该就是`let`了, 当我们处理一个可空对象的时候, 要获取它的内部某个属性的时候, 我们一般都是通过使用`?.let{}`来忽略掉空对象逻辑处理情况\n``` java\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n```\n可以看到他是将自身T作为参数传入调用函数中, 然后返回最后执行的结果.\n``` Java\nprivate fun descriLet(){\n        val des = \"showValue\"\n        val letResult = des.let {\n            Log.e(\"lettt\", it)\n            true\n        }\n        Log.e(\"let result\", letResult.toString())\n    }\n```\n我们可以通过输出结果里验证\n![let](./let.png)\n### run\n``` Java\n/**\n * Calls the specified function [block] and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n```\n可以看出当我们使用`T.run`的时候, 是作为T.()扩展函数的调用块, 最后返回闭包执行的结果\n``` Java\nprivate fun describeRun(){\n        val runResult = run{\n            true\n        }\n        Log.e(\"run result\", runResult.toString())\n\n        val runResult1 = \"T.run\".run {\n            Log.e(\"run\", this)\n            Log.e(\"length\", length.toString()) // print \"length: 5\"\n            2\n        }\n        Log.e(\"run result2\", runResult1.toString())  // print \"run result2: 2\"\n    }\n```\n### also\n``` java\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n```\n`also`和`let`有点像, 但是他返回的对象与闭包执行结果没有关系, 返回的是调用对象本身\n``` Java\nprivate fun describeAlso(){\n        val alsoResult = \"also result\".also {\n            it.reversed()\n        }\n        Log.e(\"also result\", alsoResult) // print \"also result: also result\"\n    }\n```\n### apply\n``` java\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n```\n作为T.()扩展函数调用块执行, 返回被调用对象本身\n``` Java\nprivate fun describeApply(){\n        val applyResult = \"apply\".apply {\n            reversed()\n            length\n        }\n        Log.e(\"apply Result\", applyResult) // print \"apply Result: apply\"\n    }\n```\n### with\n``` Java\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n```\n`with`需要我们传入一个参数`receiver`, 然后作为它的扩展函数执行闭包, 返回执行结果.\n``` Java\nprivate fun describeWith(){\n        val withResult = with(\"with\"){\n            reversed()\n        }\n        Log.e(\"with result\", withResult) // print \"with result: htiw\"\n    }\n```\n关于他们在用处上的一些区别, 可以看[这里](https://medium.com/@elye.project/mastering-kotlin-standard-functions-run-with-let-also-and-apply-9cd334b0ef84)\n","slug":"Kotlin零散二三点","published":1,"updated":"2018-05-28T01:42:27.896Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjld5ah2u001ecqs64emaoazo","content":"<p>本篇主要谈些<code>Kotlin</code>开发过程比较常用到的技巧<br><a id=\"more\"></a></p>\n<h2 id=\"空安全处理\"><a href=\"#空安全处理\" class=\"headerlink\" title=\"空安全处理\"></a>空安全处理</h2><p>在Kotlin中, 最出名的特性莫过于就是它的<code>空安全</code>了, 毕竟<code>NPE</code>应该是大家最不想看到的错误信息.<br>我们先回顾下Kotlin如何处理<code>空安全</code></p>\n<blockquote>\n<p>我们有四种方法来避免NPE</p>\n<ol>\n<li>在条件中检查null</li>\n<li>安全调用使用?.</li>\n<li>使用Elvis 操作符 ?:</li>\n<li>使用!!操作符</li>\n</ol>\n</blockquote>\n<p>当然关于第四点使用<code>!!</code>操作符, 他的本质就回归到了当遇到null的时候仍然会抛出NPE. 所以在非必须的情况下, 我们应该尽量避免使用<code>!!</code></p>\n<p>为了避免NPE, 在kotlin的类型系统中, 它做到的就是强制开发者明确定义目标类型是否是可空类型(通过<code>?</code>区别), 如果一个变量是可空的, 我们需要这样写<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var nullpossible: String? = <span class=\"keyword\">null</span></span><br></pre></td></tr></table></figure></p>\n<p>而像下面这种, 是永远不会编译通过的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var nullpossible: String = <span class=\"keyword\">null</span></span><br></pre></td></tr></table></figure></p>\n<p>当我们在定义一个变量的时候, 当能够确保他是非空类型的时候就必须要在构造器中初始化, 然而这在实际开发中是非常不方便的.<br><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a: String = ...</span><br></pre></td></tr></table></figure></p>\n<p>我们可以利用几种方式来解决</p>\n<ol>\n<li>使用<code>lateinit</code>延迟初始化</li>\n<li>使用<a href=\"https://www.kotlincn.net/docs/reference/delegation.html\" target=\"_blank\" rel=\"noopener\">委托</a><code>Delegates.notNull()</code></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var test: String by Delegates.notNull()</span><br><span class=\"line\">lateinit var testinit: String</span><br></pre></td></tr></table></figure>\n<p>不管我们使用哪种方式, 都可以让我们避免在初次定义类型的时候就必须初始化工作, 当然不论哪种方式, 在初始化前调用属性都是会抛出异常的.</p>\n<p>而关于<code>Delegates.notNull()</code>, 通过源码我们可以看到他实际返回的是<code>NotNullVar</code>的委托.而通过<code>NotNullVar</code>中的<code>getValue()</code>返回直接定义为非空属性.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> object Delegates &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> fun &lt;T: Any&gt; notNull(): ReadWriteProperty&lt;Any?, T&gt; = NotNullVar()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">private class NotNullVar&lt;T: Any&gt;() : ReadWriteProperty&lt;Any?, T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> var value: T? = <span class=\"keyword\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> override fun <span class=\"title\">getValue</span><span class=\"params\">(thisRef: Any?, property: KProperty&lt;*&gt;)</span>: T </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value ?: <span class=\"keyword\">throw</span> IllegalStateException(<span class=\"string\">\"Property $&#123;property.name&#125; should be initialized before get.\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> override fun <span class=\"title\">setValue</span><span class=\"params\">(thisRef: Any?, property: KProperty&lt;*&gt;, value: T)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>还有一种方式是通过委托属性<code>by lazy</code>, 但是他只可以修饰<code>val</code>, 会在第一次调用对应属性的时候进行初始化, 默认是线程安全<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val testlazy: String by lazy &#123; <span class=\"string\">\"fff\"</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<p>另外他可以通过传入参数来选择不同的多线程处理<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@kotlin</span>.jvm.JvmVersion</span><br><span class=\"line\"><span class=\"keyword\">public</span> fun &lt;T&gt; lazy(mode: LazyThreadSafetyMode, initializer: () -&gt; T): Lazy&lt;T&gt; =</span><br><span class=\"line\">        when (mode) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            * 使用同步锁确保只有一条线程可以进行实例化</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">            LazyThreadSafetyMode.SYNCHRONIZED -&gt; SynchronizedLazyImpl(initializer)</span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            * 同一时期多个线程可以初始化实例，但是只有最先返回的值会作为延迟初始化的实例，使用 AtomicReferenceFieldUpdater.compareAndSet() 方法实现。</span></span><br><span class=\"line\"><span class=\"comment\">            **/</span></span><br><span class=\"line\">            LazyThreadSafetyMode.PUBLICATION -&gt; SafePublicationLazyImpl(initializer)</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">            * 没有任何线程安全保证与开销</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">            LazyThreadSafetyMode.NONE -&gt; UnsafeLazyImpl(initializer)</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"单例模式的实现\"><a href=\"#单例模式的实现\" class=\"headerlink\" title=\"单例模式的实现\"></a>单例模式的实现</h2><p>Kotlin提供了<code>object</code>来很方便的支持了单例模式的实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object Singleton &#123;</span><br><span class=\"line\">    <span class=\"function\">fun <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// kotlin中调用</span></span><br><span class=\"line\">Singleton.test()</span><br><span class=\"line\"><span class=\"comment\">// java中调用</span></span><br><span class=\"line\">Singleton.INSTANCE.test();</span><br></pre></td></tr></table></figure></p>\n<p>我们看下他转为Java代码后是如何实现的.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">      Singleton var0 = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">      INSTANCE = var0;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>很好, 一个典型的饿汉式. 饿汉式的缺点我们简明讲下, 由于是类加载的第一时间就会新建实例, 所以当我们整个工程没有用到的时候, 就会导致内存空间的浪费.另外, 它无法自定义构造函数.<br><img src=\"./Kotlin.png\" alt=\"object\"><br>如果我们不适用<code>object</code>呢, 应该如何实现单例模式?</p>\n<p>我们来尝试用kotlin写一个<code>DSL</code>单例模式, 先看java的实现方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonDSL</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> SingletonDSL instance;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SingletonDSL</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingletonDSL <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">null</span> == instance)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (SingletonDSL.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"keyword\">null</span> == instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> SingletonDSL();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ok, 下面是翻译工作<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingleDSLKotlin</span> <span class=\"title\">private</span> <span class=\"title\">constructor</span> ()</span>&#123;</span><br><span class=\"line\">    companion object &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Volatile</span> <span class=\"keyword\">private</span> var sInstance: SingleDSLKotlin? = <span class=\"keyword\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\">fun <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>= sInstance ?: <span class=\"keyword\">synchronized</span>(SingleDSLKotlin::<span class=\"class\"><span class=\"keyword\">class</span>.<span class=\"title\">java</span>)</span>&#123;</span><br><span class=\"line\">            sInstance ?: SingleDSLKotlin().also &#123; sInstance = it &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>根据上面<code>lazy</code>的延迟初始化的特性(通过查看源码我们可以发现他内部也是用双重锁机制来实现的), 我们还可以更加的简单实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingleDSLKotlin</span> <span class=\"title\">private</span> <span class=\"title\">constructor</span> ()</span>&#123;</span><br><span class=\"line\">    companion object &#123;</span><br><span class=\"line\">        val INSTANCE by lazy &#123; SingleDSLKotlin() &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当然我们也可以通过静态内部类来实现单例模式<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonStaticClass</span> <span class=\"title\">private</span> <span class=\"title\">constructor</span>()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">fun <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>= INSTANCE.sInstance</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    companion object INSTANCE&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> val sInstance = SingletonStaticClass()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里关于构造函数的相关基础知识可参见<a href=\"https://www.kotlincn.net/docs/reference/classes.html\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<h2 id=\"域函数的区别\"><a href=\"#域函数的区别\" class=\"headerlink\" title=\"域函数的区别\"></a>域函数的区别</h2><p>我们在前面写DSL单例的demo的时候, 用到了一个<code>also</code>.我们开发过程中会经常用到这几个作用域函数<code>run</code>, <code>with</code>, <code>apply</code>, <code>with</code>, <code>also</code>, <code>let</code></p>\n<p>要理解源码, 我们首先要搞明白<code>inline</code><a href=\"https://www.kotlincn.net/docs/reference/inline-functions.html\" target=\"_blank\" rel=\"noopener\">内联函数</a>是做什么用的.</p>\n<blockquote>\n<p>在kotlin中, 函数也是作为一个对象存储在内存中.当我们调用一个函数的时候, VM首先去找你函数存储的位置, 然后执行函数, 最后再回到你调用函数的地方. 这会分别引入了内存空间的开销和虚拟调用运行的时间开销</p>\n</blockquote>\n<p>而内联函数做的就是在编译期就将函数的<code>调用</code>替换成函数的<code>定义</code>.</p>\n<p>然后我们再回头看这几个函数的作用</p>\n<h3 id=\"let\"><a href=\"#let\" class=\"headerlink\" title=\"let\"></a>let</h3><p>我们最开始接触的作用域函数应该就是<code>let</code>了, 当我们处理一个可空对象的时候, 要获取它的内部某个属性的时候, 我们一般都是通过使用<code>?.let{}</code>来忽略掉空对象逻辑处理情况<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@kotlin</span>.internal.InlineOnly</span><br><span class=\"line\"><span class=\"keyword\">public</span> inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R &#123;</span><br><span class=\"line\">    contract &#123;</span><br><span class=\"line\">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> block(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到他是将自身T作为参数传入调用函数中, 然后返回最后执行的结果.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> fun <span class=\"title\">descriLet</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        val des = <span class=\"string\">\"showValue\"</span></span><br><span class=\"line\">        val letResult = des.let &#123;</span><br><span class=\"line\">            Log.e(<span class=\"string\">\"lettt\"</span>, it)</span><br><span class=\"line\">            <span class=\"keyword\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Log.e(<span class=\"string\">\"let result\"</span>, letResult.toString())</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以通过输出结果里验证<br><img src=\"./let.png\" alt=\"let\"></p>\n<h3 id=\"run\"><a href=\"#run\" class=\"headerlink\" title=\"run\"></a>run</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Calls the specified function [block] and returns its result.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@kotlin</span>.internal.InlineOnly</span><br><span class=\"line\"><span class=\"keyword\">public</span> inline fun &lt;R&gt; run(block: () -&gt; R): R &#123;</span><br><span class=\"line\">    contract &#123;</span><br><span class=\"line\">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> block()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Calls the specified function [block] with `this` value as its receiver and returns its result.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@kotlin</span>.internal.InlineOnly</span><br><span class=\"line\"><span class=\"keyword\">public</span> inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R &#123;</span><br><span class=\"line\">    contract &#123;</span><br><span class=\"line\">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> block()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出当我们使用<code>T.run</code>的时候, 是作为T.()扩展函数的调用块, 最后返回闭包执行的结果<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> fun <span class=\"title\">describeRun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        val runResult = run&#123;</span><br><span class=\"line\">            <span class=\"keyword\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Log.e(<span class=\"string\">\"run result\"</span>, runResult.toString())</span><br><span class=\"line\"></span><br><span class=\"line\">        val runResult1 = <span class=\"string\">\"T.run\"</span>.run &#123;</span><br><span class=\"line\">            Log.e(<span class=\"string\">\"run\"</span>, <span class=\"keyword\">this</span>)</span><br><span class=\"line\">            Log.e(<span class=\"string\">\"length\"</span>, length.toString()) <span class=\"comment\">// print \"length: 5\"</span></span><br><span class=\"line\">            <span class=\"number\">2</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Log.e(<span class=\"string\">\"run result2\"</span>, runResult1.toString())  <span class=\"comment\">// print \"run result2: 2\"</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"also\"><a href=\"#also\" class=\"headerlink\" title=\"also\"></a>also</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Calls the specified function [block] with `this` value as its argument and returns `this` value.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@kotlin</span>.internal.InlineOnly</span><br><span class=\"line\"><span class=\"meta\">@SinceKotlin</span>(<span class=\"string\">\"1.1\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T &#123;</span><br><span class=\"line\">    contract &#123;</span><br><span class=\"line\">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    block(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>also</code>和<code>let</code>有点像, 但是他返回的对象与闭包执行结果没有关系, 返回的是调用对象本身<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> fun <span class=\"title\">describeAlso</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        val alsoResult = <span class=\"string\">\"also result\"</span>.also &#123;</span><br><span class=\"line\">            it.reversed()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Log.e(<span class=\"string\">\"also result\"</span>, alsoResult) <span class=\"comment\">// print \"also result: also result\"</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Calls the specified function [block] with `this` value as its receiver and returns `this` value.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@kotlin</span>.internal.InlineOnly</span><br><span class=\"line\"><span class=\"keyword\">public</span> inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123;</span><br><span class=\"line\">    contract &#123;</span><br><span class=\"line\">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    block()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>作为T.()扩展函数调用块执行, 返回被调用对象本身<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> fun <span class=\"title\">describeApply</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        val applyResult = <span class=\"string\">\"apply\"</span>.apply &#123;</span><br><span class=\"line\">            reversed()</span><br><span class=\"line\">            length</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Log.e(<span class=\"string\">\"apply Result\"</span>, applyResult) <span class=\"comment\">// print \"apply Result: apply\"</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"with\"><a href=\"#with\" class=\"headerlink\" title=\"with\"></a>with</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@kotlin</span>.internal.InlineOnly</span><br><span class=\"line\"><span class=\"keyword\">public</span> inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R &#123;</span><br><span class=\"line\">    contract &#123;</span><br><span class=\"line\">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> receiver.block()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>with</code>需要我们传入一个参数<code>receiver</code>, 然后作为它的扩展函数执行闭包, 返回执行结果.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> fun <span class=\"title\">describeWith</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        val withResult = with(<span class=\"string\">\"with\"</span>)&#123;</span><br><span class=\"line\">            reversed()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Log.e(<span class=\"string\">\"with result\"</span>, withResult) <span class=\"comment\">// print \"with result: htiw\"</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>关于他们在用处上的一些区别, 可以看<a href=\"https://medium.com/@elye.project/mastering-kotlin-standard-functions-run-with-let-also-and-apply-9cd334b0ef84\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n","site":{"data":{}},"excerpt":"<p>本篇主要谈些<code>Kotlin</code>开发过程比较常用到的技巧<br>","more":"</p>\n<h2 id=\"空安全处理\"><a href=\"#空安全处理\" class=\"headerlink\" title=\"空安全处理\"></a>空安全处理</h2><p>在Kotlin中, 最出名的特性莫过于就是它的<code>空安全</code>了, 毕竟<code>NPE</code>应该是大家最不想看到的错误信息.<br>我们先回顾下Kotlin如何处理<code>空安全</code></p>\n<blockquote>\n<p>我们有四种方法来避免NPE</p>\n<ol>\n<li>在条件中检查null</li>\n<li>安全调用使用?.</li>\n<li>使用Elvis 操作符 ?:</li>\n<li>使用!!操作符</li>\n</ol>\n</blockquote>\n<p>当然关于第四点使用<code>!!</code>操作符, 他的本质就回归到了当遇到null的时候仍然会抛出NPE. 所以在非必须的情况下, 我们应该尽量避免使用<code>!!</code></p>\n<p>为了避免NPE, 在kotlin的类型系统中, 它做到的就是强制开发者明确定义目标类型是否是可空类型(通过<code>?</code>区别), 如果一个变量是可空的, 我们需要这样写<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var nullpossible: String? = <span class=\"keyword\">null</span></span><br></pre></td></tr></table></figure></p>\n<p>而像下面这种, 是永远不会编译通过的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var nullpossible: String = <span class=\"keyword\">null</span></span><br></pre></td></tr></table></figure></p>\n<p>当我们在定义一个变量的时候, 当能够确保他是非空类型的时候就必须要在构造器中初始化, 然而这在实际开发中是非常不方便的.<br><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a: String = ...</span><br></pre></td></tr></table></figure></p>\n<p>我们可以利用几种方式来解决</p>\n<ol>\n<li>使用<code>lateinit</code>延迟初始化</li>\n<li>使用<a href=\"https://www.kotlincn.net/docs/reference/delegation.html\" target=\"_blank\" rel=\"noopener\">委托</a><code>Delegates.notNull()</code></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var test: String by Delegates.notNull()</span><br><span class=\"line\">lateinit var testinit: String</span><br></pre></td></tr></table></figure>\n<p>不管我们使用哪种方式, 都可以让我们避免在初次定义类型的时候就必须初始化工作, 当然不论哪种方式, 在初始化前调用属性都是会抛出异常的.</p>\n<p>而关于<code>Delegates.notNull()</code>, 通过源码我们可以看到他实际返回的是<code>NotNullVar</code>的委托.而通过<code>NotNullVar</code>中的<code>getValue()</code>返回直接定义为非空属性.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> object Delegates &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> fun &lt;T: Any&gt; notNull(): ReadWriteProperty&lt;Any?, T&gt; = NotNullVar()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">private class NotNullVar&lt;T: Any&gt;() : ReadWriteProperty&lt;Any?, T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> var value: T? = <span class=\"keyword\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> override fun <span class=\"title\">getValue</span><span class=\"params\">(thisRef: Any?, property: KProperty&lt;*&gt;)</span>: T </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value ?: <span class=\"keyword\">throw</span> IllegalStateException(<span class=\"string\">\"Property $&#123;property.name&#125; should be initialized before get.\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> override fun <span class=\"title\">setValue</span><span class=\"params\">(thisRef: Any?, property: KProperty&lt;*&gt;, value: T)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>还有一种方式是通过委托属性<code>by lazy</code>, 但是他只可以修饰<code>val</code>, 会在第一次调用对应属性的时候进行初始化, 默认是线程安全<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val testlazy: String by lazy &#123; <span class=\"string\">\"fff\"</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<p>另外他可以通过传入参数来选择不同的多线程处理<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@kotlin</span>.jvm.JvmVersion</span><br><span class=\"line\"><span class=\"keyword\">public</span> fun &lt;T&gt; lazy(mode: LazyThreadSafetyMode, initializer: () -&gt; T): Lazy&lt;T&gt; =</span><br><span class=\"line\">        when (mode) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            * 使用同步锁确保只有一条线程可以进行实例化</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">            LazyThreadSafetyMode.SYNCHRONIZED -&gt; SynchronizedLazyImpl(initializer)</span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            * 同一时期多个线程可以初始化实例，但是只有最先返回的值会作为延迟初始化的实例，使用 AtomicReferenceFieldUpdater.compareAndSet() 方法实现。</span></span><br><span class=\"line\"><span class=\"comment\">            **/</span></span><br><span class=\"line\">            LazyThreadSafetyMode.PUBLICATION -&gt; SafePublicationLazyImpl(initializer)</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">            * 没有任何线程安全保证与开销</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">            LazyThreadSafetyMode.NONE -&gt; UnsafeLazyImpl(initializer)</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"单例模式的实现\"><a href=\"#单例模式的实现\" class=\"headerlink\" title=\"单例模式的实现\"></a>单例模式的实现</h2><p>Kotlin提供了<code>object</code>来很方便的支持了单例模式的实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object Singleton &#123;</span><br><span class=\"line\">    <span class=\"function\">fun <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// kotlin中调用</span></span><br><span class=\"line\">Singleton.test()</span><br><span class=\"line\"><span class=\"comment\">// java中调用</span></span><br><span class=\"line\">Singleton.INSTANCE.test();</span><br></pre></td></tr></table></figure></p>\n<p>我们看下他转为Java代码后是如何实现的.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">      Singleton var0 = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">      INSTANCE = var0;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>很好, 一个典型的饿汉式. 饿汉式的缺点我们简明讲下, 由于是类加载的第一时间就会新建实例, 所以当我们整个工程没有用到的时候, 就会导致内存空间的浪费.另外, 它无法自定义构造函数.<br><img src=\"./Kotlin.png\" alt=\"object\"><br>如果我们不适用<code>object</code>呢, 应该如何实现单例模式?</p>\n<p>我们来尝试用kotlin写一个<code>DSL</code>单例模式, 先看java的实现方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonDSL</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> SingletonDSL instance;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SingletonDSL</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingletonDSL <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">null</span> == instance)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (SingletonDSL.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"keyword\">null</span> == instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> SingletonDSL();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ok, 下面是翻译工作<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingleDSLKotlin</span> <span class=\"title\">private</span> <span class=\"title\">constructor</span> ()</span>&#123;</span><br><span class=\"line\">    companion object &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Volatile</span> <span class=\"keyword\">private</span> var sInstance: SingleDSLKotlin? = <span class=\"keyword\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\">fun <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>= sInstance ?: <span class=\"keyword\">synchronized</span>(SingleDSLKotlin::<span class=\"class\"><span class=\"keyword\">class</span>.<span class=\"title\">java</span>)</span>&#123;</span><br><span class=\"line\">            sInstance ?: SingleDSLKotlin().also &#123; sInstance = it &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>根据上面<code>lazy</code>的延迟初始化的特性(通过查看源码我们可以发现他内部也是用双重锁机制来实现的), 我们还可以更加的简单实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingleDSLKotlin</span> <span class=\"title\">private</span> <span class=\"title\">constructor</span> ()</span>&#123;</span><br><span class=\"line\">    companion object &#123;</span><br><span class=\"line\">        val INSTANCE by lazy &#123; SingleDSLKotlin() &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当然我们也可以通过静态内部类来实现单例模式<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonStaticClass</span> <span class=\"title\">private</span> <span class=\"title\">constructor</span>()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">fun <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>= INSTANCE.sInstance</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    companion object INSTANCE&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> val sInstance = SingletonStaticClass()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里关于构造函数的相关基础知识可参见<a href=\"https://www.kotlincn.net/docs/reference/classes.html\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<h2 id=\"域函数的区别\"><a href=\"#域函数的区别\" class=\"headerlink\" title=\"域函数的区别\"></a>域函数的区别</h2><p>我们在前面写DSL单例的demo的时候, 用到了一个<code>also</code>.我们开发过程中会经常用到这几个作用域函数<code>run</code>, <code>with</code>, <code>apply</code>, <code>with</code>, <code>also</code>, <code>let</code></p>\n<p>要理解源码, 我们首先要搞明白<code>inline</code><a href=\"https://www.kotlincn.net/docs/reference/inline-functions.html\" target=\"_blank\" rel=\"noopener\">内联函数</a>是做什么用的.</p>\n<blockquote>\n<p>在kotlin中, 函数也是作为一个对象存储在内存中.当我们调用一个函数的时候, VM首先去找你函数存储的位置, 然后执行函数, 最后再回到你调用函数的地方. 这会分别引入了内存空间的开销和虚拟调用运行的时间开销</p>\n</blockquote>\n<p>而内联函数做的就是在编译期就将函数的<code>调用</code>替换成函数的<code>定义</code>.</p>\n<p>然后我们再回头看这几个函数的作用</p>\n<h3 id=\"let\"><a href=\"#let\" class=\"headerlink\" title=\"let\"></a>let</h3><p>我们最开始接触的作用域函数应该就是<code>let</code>了, 当我们处理一个可空对象的时候, 要获取它的内部某个属性的时候, 我们一般都是通过使用<code>?.let{}</code>来忽略掉空对象逻辑处理情况<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@kotlin</span>.internal.InlineOnly</span><br><span class=\"line\"><span class=\"keyword\">public</span> inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R &#123;</span><br><span class=\"line\">    contract &#123;</span><br><span class=\"line\">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> block(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到他是将自身T作为参数传入调用函数中, 然后返回最后执行的结果.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> fun <span class=\"title\">descriLet</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        val des = <span class=\"string\">\"showValue\"</span></span><br><span class=\"line\">        val letResult = des.let &#123;</span><br><span class=\"line\">            Log.e(<span class=\"string\">\"lettt\"</span>, it)</span><br><span class=\"line\">            <span class=\"keyword\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Log.e(<span class=\"string\">\"let result\"</span>, letResult.toString())</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以通过输出结果里验证<br><img src=\"./let.png\" alt=\"let\"></p>\n<h3 id=\"run\"><a href=\"#run\" class=\"headerlink\" title=\"run\"></a>run</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Calls the specified function [block] and returns its result.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@kotlin</span>.internal.InlineOnly</span><br><span class=\"line\"><span class=\"keyword\">public</span> inline fun &lt;R&gt; run(block: () -&gt; R): R &#123;</span><br><span class=\"line\">    contract &#123;</span><br><span class=\"line\">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> block()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Calls the specified function [block] with `this` value as its receiver and returns its result.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@kotlin</span>.internal.InlineOnly</span><br><span class=\"line\"><span class=\"keyword\">public</span> inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R &#123;</span><br><span class=\"line\">    contract &#123;</span><br><span class=\"line\">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> block()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出当我们使用<code>T.run</code>的时候, 是作为T.()扩展函数的调用块, 最后返回闭包执行的结果<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> fun <span class=\"title\">describeRun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        val runResult = run&#123;</span><br><span class=\"line\">            <span class=\"keyword\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Log.e(<span class=\"string\">\"run result\"</span>, runResult.toString())</span><br><span class=\"line\"></span><br><span class=\"line\">        val runResult1 = <span class=\"string\">\"T.run\"</span>.run &#123;</span><br><span class=\"line\">            Log.e(<span class=\"string\">\"run\"</span>, <span class=\"keyword\">this</span>)</span><br><span class=\"line\">            Log.e(<span class=\"string\">\"length\"</span>, length.toString()) <span class=\"comment\">// print \"length: 5\"</span></span><br><span class=\"line\">            <span class=\"number\">2</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Log.e(<span class=\"string\">\"run result2\"</span>, runResult1.toString())  <span class=\"comment\">// print \"run result2: 2\"</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"also\"><a href=\"#also\" class=\"headerlink\" title=\"also\"></a>also</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Calls the specified function [block] with `this` value as its argument and returns `this` value.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@kotlin</span>.internal.InlineOnly</span><br><span class=\"line\"><span class=\"meta\">@SinceKotlin</span>(<span class=\"string\">\"1.1\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T &#123;</span><br><span class=\"line\">    contract &#123;</span><br><span class=\"line\">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    block(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>also</code>和<code>let</code>有点像, 但是他返回的对象与闭包执行结果没有关系, 返回的是调用对象本身<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> fun <span class=\"title\">describeAlso</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        val alsoResult = <span class=\"string\">\"also result\"</span>.also &#123;</span><br><span class=\"line\">            it.reversed()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Log.e(<span class=\"string\">\"also result\"</span>, alsoResult) <span class=\"comment\">// print \"also result: also result\"</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Calls the specified function [block] with `this` value as its receiver and returns `this` value.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@kotlin</span>.internal.InlineOnly</span><br><span class=\"line\"><span class=\"keyword\">public</span> inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123;</span><br><span class=\"line\">    contract &#123;</span><br><span class=\"line\">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    block()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>作为T.()扩展函数调用块执行, 返回被调用对象本身<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> fun <span class=\"title\">describeApply</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        val applyResult = <span class=\"string\">\"apply\"</span>.apply &#123;</span><br><span class=\"line\">            reversed()</span><br><span class=\"line\">            length</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Log.e(<span class=\"string\">\"apply Result\"</span>, applyResult) <span class=\"comment\">// print \"apply Result: apply\"</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"with\"><a href=\"#with\" class=\"headerlink\" title=\"with\"></a>with</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@kotlin</span>.internal.InlineOnly</span><br><span class=\"line\"><span class=\"keyword\">public</span> inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R &#123;</span><br><span class=\"line\">    contract &#123;</span><br><span class=\"line\">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> receiver.block()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>with</code>需要我们传入一个参数<code>receiver</code>, 然后作为它的扩展函数执行闭包, 返回执行结果.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> fun <span class=\"title\">describeWith</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        val withResult = with(<span class=\"string\">\"with\"</span>)&#123;</span><br><span class=\"line\">            reversed()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Log.e(<span class=\"string\">\"with result\"</span>, withResult) <span class=\"comment\">// print \"with result: htiw\"</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>关于他们在用处上的一些区别, 可以看<a href=\"https://medium.com/@elye.project/mastering-kotlin-standard-functions-run-with-let-also-and-apply-9cd334b0ef84\" target=\"_blank\" rel=\"noopener\">这里</a></p>"},{"title":"RxJava2源码解析(一)","date":"2018-02-06T16:00:00.000Z","_content":"## 前言\n最近组内大佬打算分享RxJava2的源码, 赶紧先预习一波, 防止技术分享会上有听没懂.大概个人准备了几天的时间, 打算先整理以下自己的源码阅读记录.RxJava2的源码解析系列打算分别从以下三面来阐述:\n1. 数据源的订阅和响应原理\n2. 线程切换的原理\n3. 背压的实现(Flowable)\n\n本篇主要尝试阐明**数据源的订阅和响应原理**\n<!-- more -->\n## 基础使用的Demo\n抛开线程切换和背压, 我们来写一个单纯的发送数据, 订阅响应的Demo,为了便于理解, 我们抛开链式调用来写\n``` java\n// 被观察者\nObservable<Integer> observable = Observable.create(new ObservableOnSubscribe<Integer>() {\n    @Override\n    public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {\n        Log.e(TAG, \"subscribe\");\n        emitter.onNext(123);\n        emitter.onComplete();\n    }\n});\n// 观察者\nObserver<Integer> observer = new Observer<Integer>() {\n    @Override\n    public void onSubscribe(Disposable d) {\n        Log.e(TAG, \"onSubscribe\");\n    }\n\n    @Override\n    public void onNext(Integer integer) {\n        Log.e(TAG, \"onNext\" + integer);\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        Log.e(TAG, \"onError\");\n    }\n\n    @Override\n    public void onComplete() {\n        Log.e(TAG, \"onComplete\");\n    }\n};\n// 订阅\nobservable.subscribe(observer);\n```\n## ObservableSource\n我们首先来看当我们创建一个`Observable`(被观察者)的时候, 实际上他做了什么\n``` java\npublic static <T> Observable<T> create(ObservableOnSubscribe<T> source) {\n        // npe校验\n        ObjectHelper.requireNonNull(source, \"source is null\");\n        return RxJavaPlugins.onAssembly(new ObservableCreate<T>(source));\n    }\n\npublic static <T> Observable<T> onAssembly(@NonNull Observable<T> source) {\n    Function<? super Observable, ? extends Observable> f = onObservableAssembly;\n    if (f != null) {\n        return apply(f, source);\n    }\n    return source;\n}\n```\n`RxJavaPlugins.onAssembly()`这个方法主要是为了hook使用, 本篇暂且不表. 所以这里`Observable.create()`返回的是一个`ObervableCreate`对象.它继承于`Observable`, 是`ObservableSource`的实现类\n## observable.subscribe(observer)\n我们主要看订阅的时候做了什么, 先上源码\n``` java\npublic final void subscribe(Observer<? super T> observer) {\n        // npe校验\n        ObjectHelper.requireNonNull(observer, \"observer is null\");\n        try {\n            // hook, 主要返回的就是我们的observer\n            observer = RxJavaPlugins.onSubscribe(this, observer);\n            // npe校验\n            ObjectHelper.requireNonNull(observer, \"Plugin returned null Observer\");\n\n            subscribeActual(observer);\n        } catch (NullPointerException e) { // NOPMD\n            throw e;\n        } catch (Throwable e) {\n            Exceptions.throwIfFatal(e);\n            // can't call onError because no way to know if a Disposable has been set or not\n            // can't call onSubscribe because the call might have set a Subscription already\n            RxJavaPlugins.onError(e);\n\n            NullPointerException npe = new NullPointerException(\"Actually not, but can't throw other exceptions due to RS\");\n            npe.initCause(e);\n            throw npe;\n        }\n    }\n```\n可以看到这里实际执行的是`subscribeActual(observer)`这个方法, 这里调用是个抽象接口, 我们在`ObervableCreate`找具体的实现\n``` java\n@Override\nprotected void subscribeActual(Observer<? super T> observer) {\n        // 包装数据发射器\n        CreateEmitter<T> parent = new CreateEmitter<T>(observer);\n        // 订阅监听\n        observer.onSubscribe(parent);\n\n        try {\n            // 上游的执行\n            source.subscribe(parent);\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            parent.onError(ex);\n        }\n    }\n```\n``` java\nemitter.onNext(123);\nemitter.onComplete();\n```\n从`source.subscribe(parent);`我们就会走到以下我们自己写的数据发送事件.这里的`emitter`通过源码我们可以看到是将`observer`包装后的`CreateEmitter`类对象, 我们在往里面看.\n``` java\nstatic final class CreateEmitter<T> extends AtomicReference<Disposable> implements ObservableEmitter<T>, Disposable {\n\n\n        private static final long serialVersionUID = -3434801548987643227L;\n\n        final Observer<? super T> observer;\n\n        CreateEmitter(Observer<? super T> observer) {\n            this.observer = observer;\n        }\n\n        @Override\n        public void onNext(T t) {\n            if (t == null) {\n                onError(new NullPointerException(\"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\"));\n                return;\n            }\n            if (!isDisposed()) {\n                observer.onNext(t);\n            }\n        }\n\n        @Override\n        public void onError(Throwable t) {\n            if (!tryOnError(t)) {\n                RxJavaPlugins.onError(t);\n            }\n        }\n\n        @Override\n        public boolean tryOnError(Throwable t) {\n            if (t == null) {\n                t = new NullPointerException(\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\");\n            }\n            if (!isDisposed()) {\n                try {\n                    observer.onError(t);\n                } finally {\n                    dispose();\n                }\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public void onComplete() {\n            if (!isDisposed()) {\n                try {\n                    observer.onComplete();\n                } finally {\n                    dispose();\n                }\n            }\n        }\n\n        @Override\n        public void setDisposable(Disposable d) {\n            DisposableHelper.set(this, d);\n        }\n\n        @Override\n        public void setCancellable(Cancellable c) {\n            setDisposable(new CancellableDisposable(c));\n        }\n\n        @Override\n        public ObservableEmitter<T> serialize() {\n            return new SerializedEmitter<T>(this);\n        }\n\n        @Override\n        public void dispose() {\n            DisposableHelper.dispose(this);\n        }\n\n        @Override\n        public boolean isDisposed() {\n            return DisposableHelper.isDisposed(get());\n        }\n    }\n```\n通过之前将`observer`传入`CreateEmitter`, 调用`emitter.onNext`最终调用走到了`observer.onNext`.\n整体的流程非常的清晰. 下面我们看下, 如果中间有多重数据转换, 是什么样的流程\n## 数据转换实现流程\n以第一个基础demo为例, 我们改造下`Observable`(被观察者), 将他进行一次数据转换, 并且做一次筛除.这个demo的意思就是发送123, 中间做+1处理, 然后筛选出大于122的数据发送给观察者.这个很容易理解.\n``` java\nObservable<Integer> observable =\n                Observable\n                        .create(new ObservableOnSubscribe<Integer>() {\n                            @Override\n                            public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {\n                                Log.e(TAG, \"subscribe\");\n                                emitter.onNext(123);\n                                emitter.onComplete();\n                            }\n                        })\n                        .map(new Function<Integer, Integer>() {\n                            @Override\n                            public Integer apply(Integer integer) throws Exception {\n                                Log.e(TAG, \"map\");\n                                return integer + 1;\n                            }\n                        })\n                        .filter(new Predicate<Integer>() {\n                            @Override\n                            public boolean test(Integer integer) throws Exception {\n                                Log.e(TAG, \"filter\");\n                                return integer > 122;\n                            }\n                        });\n```\n我们依旧来看下`map`操作符的源码\n``` java\npublic final <R> Observable<R> map(Function<? super T, ? extends R> mapper) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        return RxJavaPlugins.onAssembly(new ObservableMap<T, R>(this, mapper));\n    }\n```\n是不是很眼熟? 忽略掉hook, 这里返回的是`ObservableMap`对象.同样, `filter`操作符返回的是一个`ObservableFilter`\n``` java\npublic final Observable<T> filter(Predicate<? super T> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n        return RxJavaPlugins.onAssembly(new ObservableFilter<T>(this, predicate));\n    }\n```\n不论是`ObservableMap`还是`ObservableFilter`他们都继承于`AbstractObservableWithUpstream`抽象类, 它继承于`Observable`, 带有上游的`Observable`\n``` java\nabstract class AbstractObservableWithUpstream<T, U> extends Observable<U> implements HasUpstreamObservableSource<T> {\n\n    /** The source consumable Observable. */\n    // 上游Obervable\n    protected final ObservableSource<T> source;\n\n    /**\n     * Constructs the ObservableSource with the given consumable.\n     * @param source the consumable Observable\n     */\n    AbstractObservableWithUpstream(ObservableSource<T> source) {\n        this.source = source;\n    }\n\n    @Override\n    public final ObservableSource<T> source() {\n        return source;\n    }\n\n}\n```\n这时候, 我们重新看下订阅的处理, 当我们执行`observable.subscribe(observer)`的时候, `observable`最终返回的是`ObservableFilter`对象, 所以我们需要看这个类对象的`subscribeActual(observer)`方法.他的代码很简洁, 实际就是将我们的`observer`和`filter`操作符的具体操作方法包装成一个`FilterObserver`对象, 然后由上游`ObservableMap`对象来subscribe(订阅)它.\n``` java\n@Override\n    public void subscribeActual(Observer<? super T> s) {\n        source.subscribe(new FilterObserver<T>(s, predicate));\n    }\n```\n我们已经知道`Observable.subscribe(observer)`方法实际调用的是对应实现类的`subscribeActual(observer)`方法, 所以我们直接去看`ObservableMap.subscribeActual(observer)`方法就可以了, 他的方法与`FilterObserver`内的类似, 这时候是将前面传进来的`FilterObserver`对象和我们`map`操作符做的操作包装成一个`MapObserver`对象, 交给上游.\n``` java\n@Override\n    public void subscribeActual(Observer<? super U> t) {\n        source.subscribe(new MapObserver<T, U>(t, function));\n    }\n```\n这时候我们的上游是`ObservableCreate`对象,它的`subscribeActual(observer)`方法上文有提到, 他将`MapObserver`对象包装进`CreateEmitter`对象, 这个时候, 才开始执行订阅动作, 然后我们走到`CreateEmitter`的`onNext()`方法,实际会执行到下游观察者的`onNext`方法, 在这层, 我们的观察者是`MapObserver`.它继承于`BasicFuseableObserver`, 表示一个流程执行中间的观察者对象. 现在我们看`MapObserver`的`onNext`的执行, 这里我们主要关注主流程的执行逻辑, 忽略掉其他代码, 可以看到它最终调用的是`actual.onNext(v)`, 首先将我们`map`操作符的逻辑处理返回的数据赋值给`v`, 这里的`actual`指的是我们下游的`observer`(观察者), 那么这个时候是我们的`FilterObserver`对象, 将`v`对象通过`onNext`传递下去.\n``` java\nstatic final class MapObserver<T, U> extends BasicFuseableObserver<T, U> {\n        final Function<? super T, ? extends U> mapper;\n\n        MapObserver(Observer<? super U> actual, Function<? super T, ? extends U> mapper) {\n            super(actual);\n            this.mapper = mapper;\n        }\n\n        @Override\n        public void onNext(T t) {\n            if (done) {\n                return;\n            }\n\n            if (sourceMode != NONE) {\n                actual.onNext(null);\n                return;\n            }\n\n            U v;\n\n            try {\n                v = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper function returned a null value.\");\n            } catch (Throwable ex) {\n                fail(ex);\n                return;\n            }\n            actual.onNext(v);\n        }\n\n        @Override\n        public int requestFusion(int mode) {\n            return transitiveBoundaryFusion(mode);\n        }\n\n        @Nullable\n        @Override\n        public U poll() throws Exception {\n            T t = qs.poll();\n            return t != null ? ObjectHelper.<U>requireNonNull(mapper.apply(t), \"The mapper function returned a null value.\") : null;\n        }\n    }\n```\n然后我们看`FilterObserver`的源码, 他的`onNext`逻辑就是会执行我们传进去的`Predicate`对象的`test`方法, 如果符合筛选逻辑, 就会通过调用下游的`onNext`将数据传下去, 这个时候的下游是我们new的`Observer`, 这时候的执行,我们应该就清楚了.\n``` java\nstatic final class FilterObserver<T> extends BasicFuseableObserver<T, T> {\n        final Predicate<? super T> filter;\n\n        FilterObserver(Observer<? super T> actual, Predicate<? super T> filter) {\n            super(actual);\n            this.filter = filter;\n        }\n\n        @Override\n        public void onNext(T t) {\n            if (sourceMode == NONE) {\n                boolean b;\n                try {\n                    b = filter.test(t);\n                } catch (Throwable e) {\n                    fail(e);\n                    return;\n                }\n                if (b) {\n                    actual.onNext(t);\n                }\n            } else {\n                actual.onNext(null);\n            }\n        }\n\n        @Override\n        public int requestFusion(int mode) {\n            return transitiveBoundaryFusion(mode);\n        }\n\n        @Nullable\n        @Override\n        public T poll() throws Exception {\n            for (;;) {\n                T v = qs.poll();\n                if (v == null || filter.test(v)) {\n                    return v;\n                }\n            }\n        }\n    }\n```\n## 总结\n订阅和数据的传输的原理就是如此. 我们用流程图来总结下上面的整个流程.\n![流程图](./rxjava实现原理.jpg)\n总的来说, 订阅的动作是层层递归上传到最开始的`Observable`, 然后从最开始的`Observable`将数据一层层往下传.\n当然, 从`装饰模式`来讲, 他这里的实际动作就是将`Observable`做了层层装饰来传递订阅, 对设计模式有兴趣的同学可以看看相关的书籍, 对于理解这段代码有点睛之用\n","source":"_posts/RxJava2源码解析1.md","raw":"title: RxJava2源码解析(一)\ndate: 2018-02-07 00:00:00\ncategories:\n- 源码解析\ntags:\n- 源码解析\n- RxJava2\n---\n## 前言\n最近组内大佬打算分享RxJava2的源码, 赶紧先预习一波, 防止技术分享会上有听没懂.大概个人准备了几天的时间, 打算先整理以下自己的源码阅读记录.RxJava2的源码解析系列打算分别从以下三面来阐述:\n1. 数据源的订阅和响应原理\n2. 线程切换的原理\n3. 背压的实现(Flowable)\n\n本篇主要尝试阐明**数据源的订阅和响应原理**\n<!-- more -->\n## 基础使用的Demo\n抛开线程切换和背压, 我们来写一个单纯的发送数据, 订阅响应的Demo,为了便于理解, 我们抛开链式调用来写\n``` java\n// 被观察者\nObservable<Integer> observable = Observable.create(new ObservableOnSubscribe<Integer>() {\n    @Override\n    public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {\n        Log.e(TAG, \"subscribe\");\n        emitter.onNext(123);\n        emitter.onComplete();\n    }\n});\n// 观察者\nObserver<Integer> observer = new Observer<Integer>() {\n    @Override\n    public void onSubscribe(Disposable d) {\n        Log.e(TAG, \"onSubscribe\");\n    }\n\n    @Override\n    public void onNext(Integer integer) {\n        Log.e(TAG, \"onNext\" + integer);\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        Log.e(TAG, \"onError\");\n    }\n\n    @Override\n    public void onComplete() {\n        Log.e(TAG, \"onComplete\");\n    }\n};\n// 订阅\nobservable.subscribe(observer);\n```\n## ObservableSource\n我们首先来看当我们创建一个`Observable`(被观察者)的时候, 实际上他做了什么\n``` java\npublic static <T> Observable<T> create(ObservableOnSubscribe<T> source) {\n        // npe校验\n        ObjectHelper.requireNonNull(source, \"source is null\");\n        return RxJavaPlugins.onAssembly(new ObservableCreate<T>(source));\n    }\n\npublic static <T> Observable<T> onAssembly(@NonNull Observable<T> source) {\n    Function<? super Observable, ? extends Observable> f = onObservableAssembly;\n    if (f != null) {\n        return apply(f, source);\n    }\n    return source;\n}\n```\n`RxJavaPlugins.onAssembly()`这个方法主要是为了hook使用, 本篇暂且不表. 所以这里`Observable.create()`返回的是一个`ObervableCreate`对象.它继承于`Observable`, 是`ObservableSource`的实现类\n## observable.subscribe(observer)\n我们主要看订阅的时候做了什么, 先上源码\n``` java\npublic final void subscribe(Observer<? super T> observer) {\n        // npe校验\n        ObjectHelper.requireNonNull(observer, \"observer is null\");\n        try {\n            // hook, 主要返回的就是我们的observer\n            observer = RxJavaPlugins.onSubscribe(this, observer);\n            // npe校验\n            ObjectHelper.requireNonNull(observer, \"Plugin returned null Observer\");\n\n            subscribeActual(observer);\n        } catch (NullPointerException e) { // NOPMD\n            throw e;\n        } catch (Throwable e) {\n            Exceptions.throwIfFatal(e);\n            // can't call onError because no way to know if a Disposable has been set or not\n            // can't call onSubscribe because the call might have set a Subscription already\n            RxJavaPlugins.onError(e);\n\n            NullPointerException npe = new NullPointerException(\"Actually not, but can't throw other exceptions due to RS\");\n            npe.initCause(e);\n            throw npe;\n        }\n    }\n```\n可以看到这里实际执行的是`subscribeActual(observer)`这个方法, 这里调用是个抽象接口, 我们在`ObervableCreate`找具体的实现\n``` java\n@Override\nprotected void subscribeActual(Observer<? super T> observer) {\n        // 包装数据发射器\n        CreateEmitter<T> parent = new CreateEmitter<T>(observer);\n        // 订阅监听\n        observer.onSubscribe(parent);\n\n        try {\n            // 上游的执行\n            source.subscribe(parent);\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            parent.onError(ex);\n        }\n    }\n```\n``` java\nemitter.onNext(123);\nemitter.onComplete();\n```\n从`source.subscribe(parent);`我们就会走到以下我们自己写的数据发送事件.这里的`emitter`通过源码我们可以看到是将`observer`包装后的`CreateEmitter`类对象, 我们在往里面看.\n``` java\nstatic final class CreateEmitter<T> extends AtomicReference<Disposable> implements ObservableEmitter<T>, Disposable {\n\n\n        private static final long serialVersionUID = -3434801548987643227L;\n\n        final Observer<? super T> observer;\n\n        CreateEmitter(Observer<? super T> observer) {\n            this.observer = observer;\n        }\n\n        @Override\n        public void onNext(T t) {\n            if (t == null) {\n                onError(new NullPointerException(\"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\"));\n                return;\n            }\n            if (!isDisposed()) {\n                observer.onNext(t);\n            }\n        }\n\n        @Override\n        public void onError(Throwable t) {\n            if (!tryOnError(t)) {\n                RxJavaPlugins.onError(t);\n            }\n        }\n\n        @Override\n        public boolean tryOnError(Throwable t) {\n            if (t == null) {\n                t = new NullPointerException(\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\");\n            }\n            if (!isDisposed()) {\n                try {\n                    observer.onError(t);\n                } finally {\n                    dispose();\n                }\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public void onComplete() {\n            if (!isDisposed()) {\n                try {\n                    observer.onComplete();\n                } finally {\n                    dispose();\n                }\n            }\n        }\n\n        @Override\n        public void setDisposable(Disposable d) {\n            DisposableHelper.set(this, d);\n        }\n\n        @Override\n        public void setCancellable(Cancellable c) {\n            setDisposable(new CancellableDisposable(c));\n        }\n\n        @Override\n        public ObservableEmitter<T> serialize() {\n            return new SerializedEmitter<T>(this);\n        }\n\n        @Override\n        public void dispose() {\n            DisposableHelper.dispose(this);\n        }\n\n        @Override\n        public boolean isDisposed() {\n            return DisposableHelper.isDisposed(get());\n        }\n    }\n```\n通过之前将`observer`传入`CreateEmitter`, 调用`emitter.onNext`最终调用走到了`observer.onNext`.\n整体的流程非常的清晰. 下面我们看下, 如果中间有多重数据转换, 是什么样的流程\n## 数据转换实现流程\n以第一个基础demo为例, 我们改造下`Observable`(被观察者), 将他进行一次数据转换, 并且做一次筛除.这个demo的意思就是发送123, 中间做+1处理, 然后筛选出大于122的数据发送给观察者.这个很容易理解.\n``` java\nObservable<Integer> observable =\n                Observable\n                        .create(new ObservableOnSubscribe<Integer>() {\n                            @Override\n                            public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {\n                                Log.e(TAG, \"subscribe\");\n                                emitter.onNext(123);\n                                emitter.onComplete();\n                            }\n                        })\n                        .map(new Function<Integer, Integer>() {\n                            @Override\n                            public Integer apply(Integer integer) throws Exception {\n                                Log.e(TAG, \"map\");\n                                return integer + 1;\n                            }\n                        })\n                        .filter(new Predicate<Integer>() {\n                            @Override\n                            public boolean test(Integer integer) throws Exception {\n                                Log.e(TAG, \"filter\");\n                                return integer > 122;\n                            }\n                        });\n```\n我们依旧来看下`map`操作符的源码\n``` java\npublic final <R> Observable<R> map(Function<? super T, ? extends R> mapper) {\n        ObjectHelper.requireNonNull(mapper, \"mapper is null\");\n        return RxJavaPlugins.onAssembly(new ObservableMap<T, R>(this, mapper));\n    }\n```\n是不是很眼熟? 忽略掉hook, 这里返回的是`ObservableMap`对象.同样, `filter`操作符返回的是一个`ObservableFilter`\n``` java\npublic final Observable<T> filter(Predicate<? super T> predicate) {\n        ObjectHelper.requireNonNull(predicate, \"predicate is null\");\n        return RxJavaPlugins.onAssembly(new ObservableFilter<T>(this, predicate));\n    }\n```\n不论是`ObservableMap`还是`ObservableFilter`他们都继承于`AbstractObservableWithUpstream`抽象类, 它继承于`Observable`, 带有上游的`Observable`\n``` java\nabstract class AbstractObservableWithUpstream<T, U> extends Observable<U> implements HasUpstreamObservableSource<T> {\n\n    /** The source consumable Observable. */\n    // 上游Obervable\n    protected final ObservableSource<T> source;\n\n    /**\n     * Constructs the ObservableSource with the given consumable.\n     * @param source the consumable Observable\n     */\n    AbstractObservableWithUpstream(ObservableSource<T> source) {\n        this.source = source;\n    }\n\n    @Override\n    public final ObservableSource<T> source() {\n        return source;\n    }\n\n}\n```\n这时候, 我们重新看下订阅的处理, 当我们执行`observable.subscribe(observer)`的时候, `observable`最终返回的是`ObservableFilter`对象, 所以我们需要看这个类对象的`subscribeActual(observer)`方法.他的代码很简洁, 实际就是将我们的`observer`和`filter`操作符的具体操作方法包装成一个`FilterObserver`对象, 然后由上游`ObservableMap`对象来subscribe(订阅)它.\n``` java\n@Override\n    public void subscribeActual(Observer<? super T> s) {\n        source.subscribe(new FilterObserver<T>(s, predicate));\n    }\n```\n我们已经知道`Observable.subscribe(observer)`方法实际调用的是对应实现类的`subscribeActual(observer)`方法, 所以我们直接去看`ObservableMap.subscribeActual(observer)`方法就可以了, 他的方法与`FilterObserver`内的类似, 这时候是将前面传进来的`FilterObserver`对象和我们`map`操作符做的操作包装成一个`MapObserver`对象, 交给上游.\n``` java\n@Override\n    public void subscribeActual(Observer<? super U> t) {\n        source.subscribe(new MapObserver<T, U>(t, function));\n    }\n```\n这时候我们的上游是`ObservableCreate`对象,它的`subscribeActual(observer)`方法上文有提到, 他将`MapObserver`对象包装进`CreateEmitter`对象, 这个时候, 才开始执行订阅动作, 然后我们走到`CreateEmitter`的`onNext()`方法,实际会执行到下游观察者的`onNext`方法, 在这层, 我们的观察者是`MapObserver`.它继承于`BasicFuseableObserver`, 表示一个流程执行中间的观察者对象. 现在我们看`MapObserver`的`onNext`的执行, 这里我们主要关注主流程的执行逻辑, 忽略掉其他代码, 可以看到它最终调用的是`actual.onNext(v)`, 首先将我们`map`操作符的逻辑处理返回的数据赋值给`v`, 这里的`actual`指的是我们下游的`observer`(观察者), 那么这个时候是我们的`FilterObserver`对象, 将`v`对象通过`onNext`传递下去.\n``` java\nstatic final class MapObserver<T, U> extends BasicFuseableObserver<T, U> {\n        final Function<? super T, ? extends U> mapper;\n\n        MapObserver(Observer<? super U> actual, Function<? super T, ? extends U> mapper) {\n            super(actual);\n            this.mapper = mapper;\n        }\n\n        @Override\n        public void onNext(T t) {\n            if (done) {\n                return;\n            }\n\n            if (sourceMode != NONE) {\n                actual.onNext(null);\n                return;\n            }\n\n            U v;\n\n            try {\n                v = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper function returned a null value.\");\n            } catch (Throwable ex) {\n                fail(ex);\n                return;\n            }\n            actual.onNext(v);\n        }\n\n        @Override\n        public int requestFusion(int mode) {\n            return transitiveBoundaryFusion(mode);\n        }\n\n        @Nullable\n        @Override\n        public U poll() throws Exception {\n            T t = qs.poll();\n            return t != null ? ObjectHelper.<U>requireNonNull(mapper.apply(t), \"The mapper function returned a null value.\") : null;\n        }\n    }\n```\n然后我们看`FilterObserver`的源码, 他的`onNext`逻辑就是会执行我们传进去的`Predicate`对象的`test`方法, 如果符合筛选逻辑, 就会通过调用下游的`onNext`将数据传下去, 这个时候的下游是我们new的`Observer`, 这时候的执行,我们应该就清楚了.\n``` java\nstatic final class FilterObserver<T> extends BasicFuseableObserver<T, T> {\n        final Predicate<? super T> filter;\n\n        FilterObserver(Observer<? super T> actual, Predicate<? super T> filter) {\n            super(actual);\n            this.filter = filter;\n        }\n\n        @Override\n        public void onNext(T t) {\n            if (sourceMode == NONE) {\n                boolean b;\n                try {\n                    b = filter.test(t);\n                } catch (Throwable e) {\n                    fail(e);\n                    return;\n                }\n                if (b) {\n                    actual.onNext(t);\n                }\n            } else {\n                actual.onNext(null);\n            }\n        }\n\n        @Override\n        public int requestFusion(int mode) {\n            return transitiveBoundaryFusion(mode);\n        }\n\n        @Nullable\n        @Override\n        public T poll() throws Exception {\n            for (;;) {\n                T v = qs.poll();\n                if (v == null || filter.test(v)) {\n                    return v;\n                }\n            }\n        }\n    }\n```\n## 总结\n订阅和数据的传输的原理就是如此. 我们用流程图来总结下上面的整个流程.\n![流程图](./rxjava实现原理.jpg)\n总的来说, 订阅的动作是层层递归上传到最开始的`Observable`, 然后从最开始的`Observable`将数据一层层往下传.\n当然, 从`装饰模式`来讲, 他这里的实际动作就是将`Observable`做了层层装饰来传递订阅, 对设计模式有兴趣的同学可以看看相关的书籍, 对于理解这段代码有点睛之用\n","slug":"RxJava2源码解析1","published":1,"updated":"2018-05-15T09:06:17.061Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjld5ah2x001icqs6ehyxk4sm","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近组内大佬打算分享RxJava2的源码, 赶紧先预习一波, 防止技术分享会上有听没懂.大概个人准备了几天的时间, 打算先整理以下自己的源码阅读记录.RxJava2的源码解析系列打算分别从以下三面来阐述:</p>\n<ol>\n<li>数据源的订阅和响应原理</li>\n<li>线程切换的原理</li>\n<li>背压的实现(Flowable)</li>\n</ol>\n<p>本篇主要尝试阐明<strong>数据源的订阅和响应原理</strong><br><a id=\"more\"></a></p>\n<h2 id=\"基础使用的Demo\"><a href=\"#基础使用的Demo\" class=\"headerlink\" title=\"基础使用的Demo\"></a>基础使用的Demo</h2><p>抛开线程切换和背压, 我们来写一个单纯的发送数据, 订阅响应的Demo,为了便于理解, 我们抛开链式调用来写<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 被观察者</span></span><br><span class=\"line\">Observable&lt;Integer&gt; observable = Observable.create(<span class=\"keyword\">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">\"subscribe\"</span>);</span><br><span class=\"line\">        emitter.onNext(<span class=\"number\">123</span>);</span><br><span class=\"line\">        emitter.onComplete();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 观察者</span></span><br><span class=\"line\">Observer&lt;Integer&gt; observer = <span class=\"keyword\">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSubscribe</span><span class=\"params\">(Disposable d)</span> </span>&#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">\"onSubscribe\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(Integer integer)</span> </span>&#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">\"onNext\"</span> + integer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">\"onError\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">\"onComplete\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 订阅</span></span><br><span class=\"line\">observable.subscribe(observer);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"ObservableSource\"><a href=\"#ObservableSource\" class=\"headerlink\" title=\"ObservableSource\"></a>ObservableSource</h2><p>我们首先来看当我们创建一个<code>Observable</code>(被观察者)的时候, 实际上他做了什么<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Observable&lt;T&gt; <span class=\"title\">create</span><span class=\"params\">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// npe校验</span></span><br><span class=\"line\">        ObjectHelper.requireNonNull(source, <span class=\"string\">\"source is null\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RxJavaPlugins.onAssembly(<span class=\"keyword\">new</span> ObservableCreate&lt;T&gt;(source));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Observable&lt;T&gt; <span class=\"title\">onAssembly</span><span class=\"params\">(@NonNull Observable&lt;T&gt; source)</span> </span>&#123;</span><br><span class=\"line\">    Function&lt;? <span class=\"keyword\">super</span> Observable, ? extends Observable&gt; f = onObservableAssembly;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> apply(f, source);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> source;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>RxJavaPlugins.onAssembly()</code>这个方法主要是为了hook使用, 本篇暂且不表. 所以这里<code>Observable.create()</code>返回的是一个<code>ObervableCreate</code>对象.它继承于<code>Observable</code>, 是<code>ObservableSource</code>的实现类</p>\n<h2 id=\"observable-subscribe-observer\"><a href=\"#observable-subscribe-observer\" class=\"headerlink\" title=\"observable.subscribe(observer)\"></a>observable.subscribe(observer)</h2><p>我们主要看订阅的时候做了什么, 先上源码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// npe校验</span></span><br><span class=\"line\">        ObjectHelper.requireNonNull(observer, <span class=\"string\">\"observer is null\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// hook, 主要返回的就是我们的observer</span></span><br><span class=\"line\">            observer = RxJavaPlugins.onSubscribe(<span class=\"keyword\">this</span>, observer);</span><br><span class=\"line\">            <span class=\"comment\">// npe校验</span></span><br><span class=\"line\">            ObjectHelper.requireNonNull(observer, <span class=\"string\">\"Plugin returned null Observer\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            subscribeActual(observer);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NullPointerException e) &#123; <span class=\"comment\">// NOPMD</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            Exceptions.throwIfFatal(e);</span><br><span class=\"line\">            <span class=\"comment\">// can't call onError because no way to know if a Disposable has been set or not</span></span><br><span class=\"line\">            <span class=\"comment\">// can't call onSubscribe because the call might have set a Subscription already</span></span><br><span class=\"line\">            RxJavaPlugins.onError(e);</span><br><span class=\"line\"></span><br><span class=\"line\">            NullPointerException npe = <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"Actually not, but can't throw other exceptions due to RS\"</span>);</span><br><span class=\"line\">            npe.initCause(e);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> npe;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到这里实际执行的是<code>subscribeActual(observer)</code>这个方法, 这里调用是个抽象接口, 我们在<code>ObervableCreate</code>找具体的实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribeActual</span><span class=\"params\">(Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 包装数据发射器</span></span><br><span class=\"line\">        CreateEmitter&lt;T&gt; parent = <span class=\"keyword\">new</span> CreateEmitter&lt;T&gt;(observer);</span><br><span class=\"line\">        <span class=\"comment\">// 订阅监听</span></span><br><span class=\"line\">        observer.onSubscribe(parent);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 上游的执行</span></span><br><span class=\"line\">            source.subscribe(parent);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">            Exceptions.throwIfFatal(ex);</span><br><span class=\"line\">            parent.onError(ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">emitter.onNext(<span class=\"number\">123</span>);</span><br><span class=\"line\">emitter.onComplete();</span><br></pre></td></tr></table></figure>\n<p>从<code>source.subscribe(parent);</code>我们就会走到以下我们自己写的数据发送事件.这里的<code>emitter</code>通过源码我们可以看到是将<code>observer</code>包装后的<code>CreateEmitter</code>类对象, 我们在往里面看.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CreateEmitter</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AtomicReference</span>&lt;<span class=\"title\">Disposable</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">ObservableEmitter</span>&lt;<span class=\"title\">T</span>&gt;, <span class=\"title\">Disposable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">3434801548987643227L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer;</span><br><span class=\"line\"></span><br><span class=\"line\">        CreateEmitter(Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.observer = observer;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                onError(<span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\"</span>));</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!isDisposed()) &#123;</span><br><span class=\"line\">                observer.onNext(t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable t)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!tryOnError(t)) &#123;</span><br><span class=\"line\">                RxJavaPlugins.onError(t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryOnError</span><span class=\"params\">(Throwable t)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                t = <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!isDisposed()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    observer.onError(t);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    dispose();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!isDisposed()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    observer.onComplete();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    dispose();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDisposable</span><span class=\"params\">(Disposable d)</span> </span>&#123;</span><br><span class=\"line\">            DisposableHelper.set(<span class=\"keyword\">this</span>, d);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCancellable</span><span class=\"params\">(Cancellable c)</span> </span>&#123;</span><br><span class=\"line\">            setDisposable(<span class=\"keyword\">new</span> CancellableDisposable(c));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> ObservableEmitter&lt;T&gt; <span class=\"title\">serialize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SerializedEmitter&lt;T&gt;(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispose</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            DisposableHelper.dispose(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isDisposed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> DisposableHelper.isDisposed(get());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过之前将<code>observer</code>传入<code>CreateEmitter</code>, 调用<code>emitter.onNext</code>最终调用走到了<code>observer.onNext</code>.<br>整体的流程非常的清晰. 下面我们看下, 如果中间有多重数据转换, 是什么样的流程</p>\n<h2 id=\"数据转换实现流程\"><a href=\"#数据转换实现流程\" class=\"headerlink\" title=\"数据转换实现流程\"></a>数据转换实现流程</h2><p>以第一个基础demo为例, 我们改造下<code>Observable</code>(被观察者), 将他进行一次数据转换, 并且做一次筛除.这个demo的意思就是发送123, 中间做+1处理, 然后筛选出大于122的数据发送给观察者.这个很容易理解.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable&lt;Integer&gt; observable =</span><br><span class=\"line\">                Observable</span><br><span class=\"line\">                        .create(<span class=\"keyword\">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class=\"line\">                            <span class=\"meta\">@Override</span></span><br><span class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                                Log.e(TAG, <span class=\"string\">\"subscribe\"</span>);</span><br><span class=\"line\">                                emitter.onNext(<span class=\"number\">123</span>);</span><br><span class=\"line\">                                emitter.onComplete();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;)</span><br><span class=\"line\">                        .map(<span class=\"keyword\">new</span> Function&lt;Integer, Integer&gt;() &#123;</span><br><span class=\"line\">                            <span class=\"meta\">@Override</span></span><br><span class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">apply</span><span class=\"params\">(Integer integer)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                                Log.e(TAG, <span class=\"string\">\"map\"</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">return</span> integer + <span class=\"number\">1</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;)</span><br><span class=\"line\">                        .filter(<span class=\"keyword\">new</span> Predicate&lt;Integer&gt;() &#123;</span><br><span class=\"line\">                            <span class=\"meta\">@Override</span></span><br><span class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">test</span><span class=\"params\">(Integer integer)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                                Log.e(TAG, <span class=\"string\">\"filter\"</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">return</span> integer &gt; <span class=\"number\">122</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>我们依旧来看下<code>map</code>操作符的源码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> &lt;R&gt; <span class=\"function\">Observable&lt;R&gt; <span class=\"title\">map</span><span class=\"params\">(Function&lt;? <span class=\"keyword\">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class=\"line\">        ObjectHelper.requireNonNull(mapper, <span class=\"string\">\"mapper is null\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RxJavaPlugins.onAssembly(<span class=\"keyword\">new</span> ObservableMap&lt;T, R&gt;(<span class=\"keyword\">this</span>, mapper));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>是不是很眼熟? 忽略掉hook, 这里返回的是<code>ObservableMap</code>对象.同样, <code>filter</code>操作符返回的是一个<code>ObservableFilter</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Observable&lt;T&gt; <span class=\"title\">filter</span><span class=\"params\">(Predicate&lt;? <span class=\"keyword\">super</span> T&gt; predicate)</span> </span>&#123;</span><br><span class=\"line\">        ObjectHelper.requireNonNull(predicate, <span class=\"string\">\"predicate is null\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RxJavaPlugins.onAssembly(<span class=\"keyword\">new</span> ObservableFilter&lt;T&gt;(<span class=\"keyword\">this</span>, predicate));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>不论是<code>ObservableMap</code>还是<code>ObservableFilter</code>他们都继承于<code>AbstractObservableWithUpstream</code>抽象类, 它继承于<code>Observable</code>, 带有上游的<code>Observable</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractObservableWithUpstream</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">U</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Observable</span>&lt;<span class=\"title\">U</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">HasUpstreamObservableSource</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** The source consumable Observable. */</span></span><br><span class=\"line\">    <span class=\"comment\">// 上游Obervable</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> ObservableSource&lt;T&gt; source;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructs the ObservableSource with the given consumable.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> source the consumable Observable</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    AbstractObservableWithUpstream(ObservableSource&lt;T&gt; source) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.source = source;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ObservableSource&lt;T&gt; <span class=\"title\">source</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> source;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这时候, 我们重新看下订阅的处理, 当我们执行<code>observable.subscribe(observer)</code>的时候, <code>observable</code>最终返回的是<code>ObservableFilter</code>对象, 所以我们需要看这个类对象的<code>subscribeActual(observer)</code>方法.他的代码很简洁, 实际就是将我们的<code>observer</code>和<code>filter</code>操作符的具体操作方法包装成一个<code>FilterObserver</code>对象, 然后由上游<code>ObservableMap</code>对象来subscribe(订阅)它.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribeActual</span><span class=\"params\">(Observer&lt;? <span class=\"keyword\">super</span> T&gt; s)</span> </span>&#123;</span><br><span class=\"line\">        source.subscribe(<span class=\"keyword\">new</span> FilterObserver&lt;T&gt;(s, predicate));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们已经知道<code>Observable.subscribe(observer)</code>方法实际调用的是对应实现类的<code>subscribeActual(observer)</code>方法, 所以我们直接去看<code>ObservableMap.subscribeActual(observer)</code>方法就可以了, 他的方法与<code>FilterObserver</code>内的类似, 这时候是将前面传进来的<code>FilterObserver</code>对象和我们<code>map</code>操作符做的操作包装成一个<code>MapObserver</code>对象, 交给上游.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribeActual</span><span class=\"params\">(Observer&lt;? <span class=\"keyword\">super</span> U&gt; t)</span> </span>&#123;</span><br><span class=\"line\">        source.subscribe(<span class=\"keyword\">new</span> MapObserver&lt;T, U&gt;(t, function));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这时候我们的上游是<code>ObservableCreate</code>对象,它的<code>subscribeActual(observer)</code>方法上文有提到, 他将<code>MapObserver</code>对象包装进<code>CreateEmitter</code>对象, 这个时候, 才开始执行订阅动作, 然后我们走到<code>CreateEmitter</code>的<code>onNext()</code>方法,实际会执行到下游观察者的<code>onNext</code>方法, 在这层, 我们的观察者是<code>MapObserver</code>.它继承于<code>BasicFuseableObserver</code>, 表示一个流程执行中间的观察者对象. 现在我们看<code>MapObserver</code>的<code>onNext</code>的执行, 这里我们主要关注主流程的执行逻辑, 忽略掉其他代码, 可以看到它最终调用的是<code>actual.onNext(v)</code>, 首先将我们<code>map</code>操作符的逻辑处理返回的数据赋值给<code>v</code>, 这里的<code>actual</code>指的是我们下游的<code>observer</code>(观察者), 那么这个时候是我们的<code>FilterObserver</code>对象, 将<code>v</code>对象通过<code>onNext</code>传递下去.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapObserver</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">U</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">BasicFuseableObserver</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">U</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Function&lt;? <span class=\"keyword\">super</span> T, ? extends U&gt; mapper;</span><br><span class=\"line\"></span><br><span class=\"line\">        MapObserver(Observer&lt;? <span class=\"keyword\">super</span> U&gt; actual, Function&lt;? <span class=\"keyword\">super</span> T, ? extends U&gt; mapper) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(actual);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.mapper = mapper;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (done) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sourceMode != NONE) &#123;</span><br><span class=\"line\">                actual.onNext(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            U v;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                v = ObjectHelper.requireNonNull(mapper.apply(t), <span class=\"string\">\"The mapper function returned a null value.\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                fail(ex);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            actual.onNext(v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">requestFusion</span><span class=\"params\">(<span class=\"keyword\">int</span> mode)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> transitiveBoundaryFusion(mode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> U <span class=\"title\">poll</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            T t = qs.poll();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t != <span class=\"keyword\">null</span> ? ObjectHelper.&lt;U&gt;requireNonNull(mapper.apply(t), <span class=\"string\">\"The mapper function returned a null value.\"</span>) : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后我们看<code>FilterObserver</code>的源码, 他的<code>onNext</code>逻辑就是会执行我们传进去的<code>Predicate</code>对象的<code>test</code>方法, 如果符合筛选逻辑, 就会通过调用下游的<code>onNext</code>将数据传下去, 这个时候的下游是我们new的<code>Observer</code>, 这时候的执行,我们应该就清楚了.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FilterObserver</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">BasicFuseableObserver</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Predicate&lt;? <span class=\"keyword\">super</span> T&gt; filter;</span><br><span class=\"line\"></span><br><span class=\"line\">        FilterObserver(Observer&lt;? <span class=\"keyword\">super</span> T&gt; actual, Predicate&lt;? <span class=\"keyword\">super</span> T&gt; filter) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(actual);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.filter = filter;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sourceMode == NONE) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> b;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    b = filter.test(t);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">                    fail(e);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (b) &#123;</span><br><span class=\"line\">                    actual.onNext(t);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                actual.onNext(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">requestFusion</span><span class=\"params\">(<span class=\"keyword\">int</span> mode)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> transitiveBoundaryFusion(mode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">poll</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                T v = qs.poll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (v == <span class=\"keyword\">null</span> || filter.test(v)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>订阅和数据的传输的原理就是如此. 我们用流程图来总结下上面的整个流程.<br><img src=\"./rxjava实现原理.jpg\" alt=\"流程图\"><br>总的来说, 订阅的动作是层层递归上传到最开始的<code>Observable</code>, 然后从最开始的<code>Observable</code>将数据一层层往下传.<br>当然, 从<code>装饰模式</code>来讲, 他这里的实际动作就是将<code>Observable</code>做了层层装饰来传递订阅, 对设计模式有兴趣的同学可以看看相关的书籍, 对于理解这段代码有点睛之用</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近组内大佬打算分享RxJava2的源码, 赶紧先预习一波, 防止技术分享会上有听没懂.大概个人准备了几天的时间, 打算先整理以下自己的源码阅读记录.RxJava2的源码解析系列打算分别从以下三面来阐述:</p>\n<ol>\n<li>数据源的订阅和响应原理</li>\n<li>线程切换的原理</li>\n<li>背压的实现(Flowable)</li>\n</ol>\n<p>本篇主要尝试阐明<strong>数据源的订阅和响应原理</strong><br>","more":"</p>\n<h2 id=\"基础使用的Demo\"><a href=\"#基础使用的Demo\" class=\"headerlink\" title=\"基础使用的Demo\"></a>基础使用的Demo</h2><p>抛开线程切换和背压, 我们来写一个单纯的发送数据, 订阅响应的Demo,为了便于理解, 我们抛开链式调用来写<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 被观察者</span></span><br><span class=\"line\">Observable&lt;Integer&gt; observable = Observable.create(<span class=\"keyword\">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">\"subscribe\"</span>);</span><br><span class=\"line\">        emitter.onNext(<span class=\"number\">123</span>);</span><br><span class=\"line\">        emitter.onComplete();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 观察者</span></span><br><span class=\"line\">Observer&lt;Integer&gt; observer = <span class=\"keyword\">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSubscribe</span><span class=\"params\">(Disposable d)</span> </span>&#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">\"onSubscribe\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(Integer integer)</span> </span>&#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">\"onNext\"</span> + integer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">\"onError\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">\"onComplete\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 订阅</span></span><br><span class=\"line\">observable.subscribe(observer);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"ObservableSource\"><a href=\"#ObservableSource\" class=\"headerlink\" title=\"ObservableSource\"></a>ObservableSource</h2><p>我们首先来看当我们创建一个<code>Observable</code>(被观察者)的时候, 实际上他做了什么<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Observable&lt;T&gt; <span class=\"title\">create</span><span class=\"params\">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// npe校验</span></span><br><span class=\"line\">        ObjectHelper.requireNonNull(source, <span class=\"string\">\"source is null\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RxJavaPlugins.onAssembly(<span class=\"keyword\">new</span> ObservableCreate&lt;T&gt;(source));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Observable&lt;T&gt; <span class=\"title\">onAssembly</span><span class=\"params\">(@NonNull Observable&lt;T&gt; source)</span> </span>&#123;</span><br><span class=\"line\">    Function&lt;? <span class=\"keyword\">super</span> Observable, ? extends Observable&gt; f = onObservableAssembly;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> apply(f, source);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> source;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>RxJavaPlugins.onAssembly()</code>这个方法主要是为了hook使用, 本篇暂且不表. 所以这里<code>Observable.create()</code>返回的是一个<code>ObervableCreate</code>对象.它继承于<code>Observable</code>, 是<code>ObservableSource</code>的实现类</p>\n<h2 id=\"observable-subscribe-observer\"><a href=\"#observable-subscribe-observer\" class=\"headerlink\" title=\"observable.subscribe(observer)\"></a>observable.subscribe(observer)</h2><p>我们主要看订阅的时候做了什么, 先上源码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// npe校验</span></span><br><span class=\"line\">        ObjectHelper.requireNonNull(observer, <span class=\"string\">\"observer is null\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// hook, 主要返回的就是我们的observer</span></span><br><span class=\"line\">            observer = RxJavaPlugins.onSubscribe(<span class=\"keyword\">this</span>, observer);</span><br><span class=\"line\">            <span class=\"comment\">// npe校验</span></span><br><span class=\"line\">            ObjectHelper.requireNonNull(observer, <span class=\"string\">\"Plugin returned null Observer\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            subscribeActual(observer);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NullPointerException e) &#123; <span class=\"comment\">// NOPMD</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            Exceptions.throwIfFatal(e);</span><br><span class=\"line\">            <span class=\"comment\">// can't call onError because no way to know if a Disposable has been set or not</span></span><br><span class=\"line\">            <span class=\"comment\">// can't call onSubscribe because the call might have set a Subscription already</span></span><br><span class=\"line\">            RxJavaPlugins.onError(e);</span><br><span class=\"line\"></span><br><span class=\"line\">            NullPointerException npe = <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"Actually not, but can't throw other exceptions due to RS\"</span>);</span><br><span class=\"line\">            npe.initCause(e);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> npe;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到这里实际执行的是<code>subscribeActual(observer)</code>这个方法, 这里调用是个抽象接口, 我们在<code>ObervableCreate</code>找具体的实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribeActual</span><span class=\"params\">(Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 包装数据发射器</span></span><br><span class=\"line\">        CreateEmitter&lt;T&gt; parent = <span class=\"keyword\">new</span> CreateEmitter&lt;T&gt;(observer);</span><br><span class=\"line\">        <span class=\"comment\">// 订阅监听</span></span><br><span class=\"line\">        observer.onSubscribe(parent);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 上游的执行</span></span><br><span class=\"line\">            source.subscribe(parent);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">            Exceptions.throwIfFatal(ex);</span><br><span class=\"line\">            parent.onError(ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">emitter.onNext(<span class=\"number\">123</span>);</span><br><span class=\"line\">emitter.onComplete();</span><br></pre></td></tr></table></figure>\n<p>从<code>source.subscribe(parent);</code>我们就会走到以下我们自己写的数据发送事件.这里的<code>emitter</code>通过源码我们可以看到是将<code>observer</code>包装后的<code>CreateEmitter</code>类对象, 我们在往里面看.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CreateEmitter</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AtomicReference</span>&lt;<span class=\"title\">Disposable</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">ObservableEmitter</span>&lt;<span class=\"title\">T</span>&gt;, <span class=\"title\">Disposable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">3434801548987643227L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer;</span><br><span class=\"line\"></span><br><span class=\"line\">        CreateEmitter(Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.observer = observer;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                onError(<span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\"</span>));</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!isDisposed()) &#123;</span><br><span class=\"line\">                observer.onNext(t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable t)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!tryOnError(t)) &#123;</span><br><span class=\"line\">                RxJavaPlugins.onError(t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryOnError</span><span class=\"params\">(Throwable t)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                t = <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!isDisposed()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    observer.onError(t);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    dispose();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!isDisposed()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    observer.onComplete();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    dispose();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDisposable</span><span class=\"params\">(Disposable d)</span> </span>&#123;</span><br><span class=\"line\">            DisposableHelper.set(<span class=\"keyword\">this</span>, d);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCancellable</span><span class=\"params\">(Cancellable c)</span> </span>&#123;</span><br><span class=\"line\">            setDisposable(<span class=\"keyword\">new</span> CancellableDisposable(c));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> ObservableEmitter&lt;T&gt; <span class=\"title\">serialize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SerializedEmitter&lt;T&gt;(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispose</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            DisposableHelper.dispose(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isDisposed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> DisposableHelper.isDisposed(get());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过之前将<code>observer</code>传入<code>CreateEmitter</code>, 调用<code>emitter.onNext</code>最终调用走到了<code>observer.onNext</code>.<br>整体的流程非常的清晰. 下面我们看下, 如果中间有多重数据转换, 是什么样的流程</p>\n<h2 id=\"数据转换实现流程\"><a href=\"#数据转换实现流程\" class=\"headerlink\" title=\"数据转换实现流程\"></a>数据转换实现流程</h2><p>以第一个基础demo为例, 我们改造下<code>Observable</code>(被观察者), 将他进行一次数据转换, 并且做一次筛除.这个demo的意思就是发送123, 中间做+1处理, 然后筛选出大于122的数据发送给观察者.这个很容易理解.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable&lt;Integer&gt; observable =</span><br><span class=\"line\">                Observable</span><br><span class=\"line\">                        .create(<span class=\"keyword\">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class=\"line\">                            <span class=\"meta\">@Override</span></span><br><span class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                                Log.e(TAG, <span class=\"string\">\"subscribe\"</span>);</span><br><span class=\"line\">                                emitter.onNext(<span class=\"number\">123</span>);</span><br><span class=\"line\">                                emitter.onComplete();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;)</span><br><span class=\"line\">                        .map(<span class=\"keyword\">new</span> Function&lt;Integer, Integer&gt;() &#123;</span><br><span class=\"line\">                            <span class=\"meta\">@Override</span></span><br><span class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">apply</span><span class=\"params\">(Integer integer)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                                Log.e(TAG, <span class=\"string\">\"map\"</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">return</span> integer + <span class=\"number\">1</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;)</span><br><span class=\"line\">                        .filter(<span class=\"keyword\">new</span> Predicate&lt;Integer&gt;() &#123;</span><br><span class=\"line\">                            <span class=\"meta\">@Override</span></span><br><span class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">test</span><span class=\"params\">(Integer integer)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                                Log.e(TAG, <span class=\"string\">\"filter\"</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">return</span> integer &gt; <span class=\"number\">122</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>我们依旧来看下<code>map</code>操作符的源码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> &lt;R&gt; <span class=\"function\">Observable&lt;R&gt; <span class=\"title\">map</span><span class=\"params\">(Function&lt;? <span class=\"keyword\">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class=\"line\">        ObjectHelper.requireNonNull(mapper, <span class=\"string\">\"mapper is null\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RxJavaPlugins.onAssembly(<span class=\"keyword\">new</span> ObservableMap&lt;T, R&gt;(<span class=\"keyword\">this</span>, mapper));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>是不是很眼熟? 忽略掉hook, 这里返回的是<code>ObservableMap</code>对象.同样, <code>filter</code>操作符返回的是一个<code>ObservableFilter</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Observable&lt;T&gt; <span class=\"title\">filter</span><span class=\"params\">(Predicate&lt;? <span class=\"keyword\">super</span> T&gt; predicate)</span> </span>&#123;</span><br><span class=\"line\">        ObjectHelper.requireNonNull(predicate, <span class=\"string\">\"predicate is null\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RxJavaPlugins.onAssembly(<span class=\"keyword\">new</span> ObservableFilter&lt;T&gt;(<span class=\"keyword\">this</span>, predicate));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>不论是<code>ObservableMap</code>还是<code>ObservableFilter</code>他们都继承于<code>AbstractObservableWithUpstream</code>抽象类, 它继承于<code>Observable</code>, 带有上游的<code>Observable</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractObservableWithUpstream</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">U</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Observable</span>&lt;<span class=\"title\">U</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">HasUpstreamObservableSource</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** The source consumable Observable. */</span></span><br><span class=\"line\">    <span class=\"comment\">// 上游Obervable</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> ObservableSource&lt;T&gt; source;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructs the ObservableSource with the given consumable.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> source the consumable Observable</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    AbstractObservableWithUpstream(ObservableSource&lt;T&gt; source) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.source = source;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ObservableSource&lt;T&gt; <span class=\"title\">source</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> source;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这时候, 我们重新看下订阅的处理, 当我们执行<code>observable.subscribe(observer)</code>的时候, <code>observable</code>最终返回的是<code>ObservableFilter</code>对象, 所以我们需要看这个类对象的<code>subscribeActual(observer)</code>方法.他的代码很简洁, 实际就是将我们的<code>observer</code>和<code>filter</code>操作符的具体操作方法包装成一个<code>FilterObserver</code>对象, 然后由上游<code>ObservableMap</code>对象来subscribe(订阅)它.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribeActual</span><span class=\"params\">(Observer&lt;? <span class=\"keyword\">super</span> T&gt; s)</span> </span>&#123;</span><br><span class=\"line\">        source.subscribe(<span class=\"keyword\">new</span> FilterObserver&lt;T&gt;(s, predicate));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们已经知道<code>Observable.subscribe(observer)</code>方法实际调用的是对应实现类的<code>subscribeActual(observer)</code>方法, 所以我们直接去看<code>ObservableMap.subscribeActual(observer)</code>方法就可以了, 他的方法与<code>FilterObserver</code>内的类似, 这时候是将前面传进来的<code>FilterObserver</code>对象和我们<code>map</code>操作符做的操作包装成一个<code>MapObserver</code>对象, 交给上游.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribeActual</span><span class=\"params\">(Observer&lt;? <span class=\"keyword\">super</span> U&gt; t)</span> </span>&#123;</span><br><span class=\"line\">        source.subscribe(<span class=\"keyword\">new</span> MapObserver&lt;T, U&gt;(t, function));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这时候我们的上游是<code>ObservableCreate</code>对象,它的<code>subscribeActual(observer)</code>方法上文有提到, 他将<code>MapObserver</code>对象包装进<code>CreateEmitter</code>对象, 这个时候, 才开始执行订阅动作, 然后我们走到<code>CreateEmitter</code>的<code>onNext()</code>方法,实际会执行到下游观察者的<code>onNext</code>方法, 在这层, 我们的观察者是<code>MapObserver</code>.它继承于<code>BasicFuseableObserver</code>, 表示一个流程执行中间的观察者对象. 现在我们看<code>MapObserver</code>的<code>onNext</code>的执行, 这里我们主要关注主流程的执行逻辑, 忽略掉其他代码, 可以看到它最终调用的是<code>actual.onNext(v)</code>, 首先将我们<code>map</code>操作符的逻辑处理返回的数据赋值给<code>v</code>, 这里的<code>actual</code>指的是我们下游的<code>observer</code>(观察者), 那么这个时候是我们的<code>FilterObserver</code>对象, 将<code>v</code>对象通过<code>onNext</code>传递下去.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapObserver</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">U</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">BasicFuseableObserver</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">U</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Function&lt;? <span class=\"keyword\">super</span> T, ? extends U&gt; mapper;</span><br><span class=\"line\"></span><br><span class=\"line\">        MapObserver(Observer&lt;? <span class=\"keyword\">super</span> U&gt; actual, Function&lt;? <span class=\"keyword\">super</span> T, ? extends U&gt; mapper) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(actual);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.mapper = mapper;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (done) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sourceMode != NONE) &#123;</span><br><span class=\"line\">                actual.onNext(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            U v;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                v = ObjectHelper.requireNonNull(mapper.apply(t), <span class=\"string\">\"The mapper function returned a null value.\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                fail(ex);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            actual.onNext(v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">requestFusion</span><span class=\"params\">(<span class=\"keyword\">int</span> mode)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> transitiveBoundaryFusion(mode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> U <span class=\"title\">poll</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            T t = qs.poll();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t != <span class=\"keyword\">null</span> ? ObjectHelper.&lt;U&gt;requireNonNull(mapper.apply(t), <span class=\"string\">\"The mapper function returned a null value.\"</span>) : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后我们看<code>FilterObserver</code>的源码, 他的<code>onNext</code>逻辑就是会执行我们传进去的<code>Predicate</code>对象的<code>test</code>方法, 如果符合筛选逻辑, 就会通过调用下游的<code>onNext</code>将数据传下去, 这个时候的下游是我们new的<code>Observer</code>, 这时候的执行,我们应该就清楚了.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FilterObserver</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">BasicFuseableObserver</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Predicate&lt;? <span class=\"keyword\">super</span> T&gt; filter;</span><br><span class=\"line\"></span><br><span class=\"line\">        FilterObserver(Observer&lt;? <span class=\"keyword\">super</span> T&gt; actual, Predicate&lt;? <span class=\"keyword\">super</span> T&gt; filter) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(actual);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.filter = filter;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sourceMode == NONE) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> b;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    b = filter.test(t);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">                    fail(e);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (b) &#123;</span><br><span class=\"line\">                    actual.onNext(t);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                actual.onNext(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">requestFusion</span><span class=\"params\">(<span class=\"keyword\">int</span> mode)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> transitiveBoundaryFusion(mode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">poll</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                T v = qs.poll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (v == <span class=\"keyword\">null</span> || filter.test(v)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>订阅和数据的传输的原理就是如此. 我们用流程图来总结下上面的整个流程.<br><img src=\"./rxjava实现原理.jpg\" alt=\"流程图\"><br>总的来说, 订阅的动作是层层递归上传到最开始的<code>Observable</code>, 然后从最开始的<code>Observable</code>将数据一层层往下传.<br>当然, 从<code>装饰模式</code>来讲, 他这里的实际动作就是将<code>Observable</code>做了层层装饰来传递订阅, 对设计模式有兴趣的同学可以看看相关的书籍, 对于理解这段代码有点睛之用</p>"},{"title":"RxJava2源码解析(二)","date":"2018-02-07T16:00:00.000Z","_content":"## 前言\n本篇主要解析RxJava的线程切换的原理实现\n<!-- more -->\n## subscribeOn\n首先, 我们先看下`subscribeOn()`方法, 老样子, 先上Demo\n``` java\nObservable<Integer> observable =\n                Observable\n                .create(new ObservableOnSubscribe<Integer>() {\n                    @Override\n                    public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {\n                        emitter.onNext(123);\n                        emitter.onComplete();\n                    }\n                });\n\nobservable\n        .subscribeOn(Schedulers.io())\n        .subscribe(getObserver());\n```\n`subscribeOn`操作符源码里其实是返回了一个`ObservableSubscribeOn`对象, 而从[上篇](https://yutiantina.github.io/2018/02/07/RxJava2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%901/)我们已经知道, 订阅的动作其实在每个`Observable`的`subscribeActual(observer)`中执行, 所以我们直接去看`ObservableSubscribeOn`中的对应重载方法就行了.\n``` java\n@Override\n    public void subscribeActual(final Observer<? super T> s) {\n        final SubscribeOnObserver<T> parent = new SubscribeOnObserver<T>(s);\n\n        s.onSubscribe(parent);\n\n        parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));\n    }\n```\n``` java\nfinal class SubscribeTask implements Runnable {\n        private final SubscribeOnObserver<T> parent;\n\n        SubscribeTask(SubscribeOnObserver<T> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void run() {\n            source.subscribe(parent);\n        }\n    }\n```\n`SubscribeTask`是一个Runnable的实现类, 执行内容就是修饰后的`Observer`订阅上游的动作, 我们先看`scheduler.scheduleDirect(runable)`方法\n``` java\n@NonNull\npublic Disposable scheduleDirect(@NonNull Runnable run) {\n    return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);\n}\n\n@NonNull\npublic Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) {\n    final Worker w = createWorker();\n\n    final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);\n\n    DisposeTask task = new DisposeTask(decoratedRun, w);\n\n    w.schedule(task, delay, unit);\n\n    return task;\n}\n```\n这里`createWorker`是个抽象方法, 我们需要找到对应的修饰类, 我们返回去看`Schedulers.io()`, `IO`是`IoScheduler`的实例, 它的重载方法代码如下\n``` java\nfinal AtomicReference<CachedWorkerPool> pool;\npublic Worker createWorker() {\n        return new EventLoopWorker(pool.get());\n    }\n```\n可以看到IO线程实际使用的是一个有线程缓存的线程调度器.它内部通过`ScheduledExecutorService`实例来尝试重用之前`worker`开始使用的实例, 由于本篇着重在流程实现原理, 所以略过细节处.\n在`EventLoopWorker`中, 我们看下对应的重载方法\n``` java\npublic Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) {\n            if (tasks.isDisposed()) {\n                // don't schedule, we are unsubscribed\n                return EmptyDisposable.INSTANCE;\n            }\n\n            return threadWorker.scheduleActual(action, delayTime, unit, tasks);\n        }\n```\n继续往下, 其实这个时候已经是在线程池目标线程执行相关的工作了. 再深入就是线程池的操作了, 所以这里我们不再赘述\n``` java\npublic ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) {\n        Runnable decoratedRun = RxJavaPlugins.onSchedule(run);\n\n        ScheduledRunnable sr = new ScheduledRunnable(decoratedRun, parent);\n\n        if (parent != null) {\n            if (!parent.add(sr)) {\n                return sr;\n            }\n        }\n\n        Future<?> f;\n        try {\n            if (delayTime <= 0) {\n                f = executor.submit((Callable<Object>)sr);\n            } else {\n                f = executor.schedule((Callable<Object>)sr, delayTime, unit);\n            }\n            sr.setFuture(f);\n        } catch (RejectedExecutionException ex) {\n            if (parent != null) {\n                parent.remove(sr);\n            }\n            RxJavaPlugins.onError(ex);\n        }\n\n        return sr;\n    }\n```\n由此我们可以看出来, 每次每个`subscribeOn`操作符执行的时候, 其实在`source.subscribe(parent);`订阅动作就做了线程切换, 所以在多次调`subscribeOn`的时候, 就会一直切换线程, 直到离`ObservableSource`最近的`subscribeOn`线程切换生效.\n## observeOn\n废话不说, 我们直接看`ObservableObserveOn.subscribeActual(observer)`\n``` java\nprotected void subscribeActual(Observer<? super T> observer) {\n        if (scheduler instanceof TrampolineScheduler) {\n            source.subscribe(observer);\n        } else {\n            Scheduler.Worker w = scheduler.createWorker();\n\n            source.subscribe(new ObserveOnObserver<T>(observer, w, delayError, bufferSize));\n        }\n    }\n```\n熟悉的配方, 当相同想成的时候, 直接订阅, 而当不同线程的时候, 可以看到我们获取目标切换线程对应的worker实例以及装饰对应的`Observer`成`ObserveOnOberver`,后面的流程我们心知肚明, 就是`Observer`层层订阅上去, 然后我们看当碰到最上流的`ObservableSource`往下执行的时候, 做什么操作.具体我们看`ObserveOnOberver`代码, 我们这里着重看下`onSubscribe`和`onNext`方法\n``` java\n@Override\npublic void onSubscribe(Disposable s) {\n    if (DisposableHelper.validate(this.s, s)) {\n        this.s = s;\n        // 发送的数据是集合队列形式的时候\n        if (s instanceof QueueDisposable) {\n            @SuppressWarnings(\"unchecked\")\n            QueueDisposable<T> qd = (QueueDisposable<T>) s;\n\n            int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);\n            //是同步模式的时候\n            if (m == QueueDisposable.SYNC) {\n                sourceMode = m;\n                queue = qd;\n                done = true;\n                actual.onSubscribe(this);\n                // 线程调度\n                schedule();\n                return;\n            }\n            // 异步模式\n            if (m == QueueDisposable.ASYNC) {\n                sourceMode = m;\n                queue = qd;\n                actual.onSubscribe(this);\n                return;\n            }\n        }\n\n        queue = new SpscLinkedArrayQueue<T>(bufferSize);\n\n        actual.onSubscribe(this);\n    }\n}\n\n@Override\npublic void onNext(T t) {\n    // 是否已经调用到onComplete 或者 onError, 如果是, 则不再执行后面的onNext\n    if (done) {\n        return;\n    }\n    // 如果是非异步操作, 将数据添加到队列中\n    if (sourceMode != QueueDisposable.ASYNC) {\n        queue.offer(t);\n    }\n    // 线程调度\n    schedule();\n}\n```\n大概的注释都加在代码上了, 我们再补充看下看`onSubscribe`方法, 首先判断发送的数据是否属于`QueueDisposable`, 如果不是, 直接执行下游的`onSubscribe`,这里我卡了一下, 看不到他的线程切换是在哪里做, 后来往回看, 发现在我们执行`ObservableSubscribeOn.subscribeActual(observer)`的时候, `onSubscribe()`方法本身的确不是在切换后的线程内执行的. 但是, 当我们发送的是集合数据, 那么我们需要判断是哪种线程模式进行线程调度.\n\n我们来看具体的`schedule()`方法代码\n``` java\nvoid schedule() {\n            // 判断当前自增值是否为0, 原子性保证worker.schedule(this);不会在调用结束前被重复调用\n            if (getAndIncrement() == 0) {\n                worker.schedule(this);\n            }\n        }\n```\n这个时候就是在指定线程内run了, `Disposable schedule(@NonNull Runnable run)`传入的是个`Runnable`的实现类, 我们来找重载的`run`方法\n``` java\n@Override\npublic void run() {\n    if (outputFused) {\n        drainFused();\n    } else {\n        drainNormal();\n    }\n}\n\nvoid drainNormal() {\n    int missed = 1;\n\n    final SimpleQueue<T> q = queue;\n    final Observer<? super T> a = actual;\n    // 无限循环\n    for (;;) {\n        // 判断是否被取消, 或者调用onError 或者调用onComplete则退出循环\n        if (checkTerminated(done, q.isEmpty(), a)) {\n            return;\n        }\n        // 无限循环\n        for (;;) {\n            boolean d = done;\n            T v;\n\n            try {\n                // 队列数据分发\n                v = q.poll();\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                s.dispose();\n                q.clear();\n                a.onError(ex);\n                worker.dispose();\n                return;\n            }\n            boolean empty = v == null;\n            // 判断是否应该被终止\n            if (checkTerminated(d, empty, a)) {\n                return;\n            }\n\n            if (empty) {\n                break;\n            }\n            a.onNext(v);\n        }\n        // 原子性保证worker.schedule(this)的调用\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n\n// 判断循环是否终止\nboolean checkTerminated(boolean d, boolean empty, Observer<? super T> a) {\n    // 如果订阅已经被取消, 则清除队列, 终止\n    if (cancelled) {\n        queue.clear();\n        return true;\n    }\n    // 如果调用过onError 或者 onComplete\n    if (d) {\n        Throwable e = error;\n        // 默认false\n        if (delayError) {\n            // 等到队列为空的时候再调用onError或者onComplete\n            if (empty) {\n                if (e != null) {\n                    a.onError(e);\n                } else {\n                    a.onComplete();\n                }\n                worker.dispose();\n                return true;\n            }\n        } else {\n            // 如果有抛出异常, 走下游的onError\n            // 线程任务停止\n            if (e != null) {\n                queue.clear();\n                a.onError(e);\n                worker.dispose();\n                return true;\n            }\n            // 没有, 走下游的onComplete\n            // 线程任务停止\n            else if (empty) {\n                a.onComplete();\n                worker.dispose();\n                return true;\n            }\n        }\n    }\n    // 否则不结束\n    return false;\n}\n```\n由此我们可以得出结论, `observeOn`的操作符可以保证我们下流操作线程切换生效\n## 总结\n到这里, 我们线程切换的原理大体流程就基本分析完毕了, 可以看出`subscribeOn`操作符只对上游生效, 而且因为他是在订阅的时候进行线程切换, 而我们每个操作符中间都有订阅动作, 所以越接近我们的`ObservableSource`的订阅的`subscribeOn`越是最后生效的. 而`observeOn`生效在我们的`onNext`,`onComplete`, `onError`方法内, 所以每次的`observeOn`针对它的下游都可以生效.\n","source":"_posts/RxJava2源码解析2.md","raw":"title: RxJava2源码解析(二)\ndate: 2018-02-08 00:00:00\ncategories:\n- 源码解析\ntags:\n- 源码解析\n- rxJava2\n---\n## 前言\n本篇主要解析RxJava的线程切换的原理实现\n<!-- more -->\n## subscribeOn\n首先, 我们先看下`subscribeOn()`方法, 老样子, 先上Demo\n``` java\nObservable<Integer> observable =\n                Observable\n                .create(new ObservableOnSubscribe<Integer>() {\n                    @Override\n                    public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {\n                        emitter.onNext(123);\n                        emitter.onComplete();\n                    }\n                });\n\nobservable\n        .subscribeOn(Schedulers.io())\n        .subscribe(getObserver());\n```\n`subscribeOn`操作符源码里其实是返回了一个`ObservableSubscribeOn`对象, 而从[上篇](https://yutiantina.github.io/2018/02/07/RxJava2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%901/)我们已经知道, 订阅的动作其实在每个`Observable`的`subscribeActual(observer)`中执行, 所以我们直接去看`ObservableSubscribeOn`中的对应重载方法就行了.\n``` java\n@Override\n    public void subscribeActual(final Observer<? super T> s) {\n        final SubscribeOnObserver<T> parent = new SubscribeOnObserver<T>(s);\n\n        s.onSubscribe(parent);\n\n        parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));\n    }\n```\n``` java\nfinal class SubscribeTask implements Runnable {\n        private final SubscribeOnObserver<T> parent;\n\n        SubscribeTask(SubscribeOnObserver<T> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void run() {\n            source.subscribe(parent);\n        }\n    }\n```\n`SubscribeTask`是一个Runnable的实现类, 执行内容就是修饰后的`Observer`订阅上游的动作, 我们先看`scheduler.scheduleDirect(runable)`方法\n``` java\n@NonNull\npublic Disposable scheduleDirect(@NonNull Runnable run) {\n    return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);\n}\n\n@NonNull\npublic Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) {\n    final Worker w = createWorker();\n\n    final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);\n\n    DisposeTask task = new DisposeTask(decoratedRun, w);\n\n    w.schedule(task, delay, unit);\n\n    return task;\n}\n```\n这里`createWorker`是个抽象方法, 我们需要找到对应的修饰类, 我们返回去看`Schedulers.io()`, `IO`是`IoScheduler`的实例, 它的重载方法代码如下\n``` java\nfinal AtomicReference<CachedWorkerPool> pool;\npublic Worker createWorker() {\n        return new EventLoopWorker(pool.get());\n    }\n```\n可以看到IO线程实际使用的是一个有线程缓存的线程调度器.它内部通过`ScheduledExecutorService`实例来尝试重用之前`worker`开始使用的实例, 由于本篇着重在流程实现原理, 所以略过细节处.\n在`EventLoopWorker`中, 我们看下对应的重载方法\n``` java\npublic Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) {\n            if (tasks.isDisposed()) {\n                // don't schedule, we are unsubscribed\n                return EmptyDisposable.INSTANCE;\n            }\n\n            return threadWorker.scheduleActual(action, delayTime, unit, tasks);\n        }\n```\n继续往下, 其实这个时候已经是在线程池目标线程执行相关的工作了. 再深入就是线程池的操作了, 所以这里我们不再赘述\n``` java\npublic ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) {\n        Runnable decoratedRun = RxJavaPlugins.onSchedule(run);\n\n        ScheduledRunnable sr = new ScheduledRunnable(decoratedRun, parent);\n\n        if (parent != null) {\n            if (!parent.add(sr)) {\n                return sr;\n            }\n        }\n\n        Future<?> f;\n        try {\n            if (delayTime <= 0) {\n                f = executor.submit((Callable<Object>)sr);\n            } else {\n                f = executor.schedule((Callable<Object>)sr, delayTime, unit);\n            }\n            sr.setFuture(f);\n        } catch (RejectedExecutionException ex) {\n            if (parent != null) {\n                parent.remove(sr);\n            }\n            RxJavaPlugins.onError(ex);\n        }\n\n        return sr;\n    }\n```\n由此我们可以看出来, 每次每个`subscribeOn`操作符执行的时候, 其实在`source.subscribe(parent);`订阅动作就做了线程切换, 所以在多次调`subscribeOn`的时候, 就会一直切换线程, 直到离`ObservableSource`最近的`subscribeOn`线程切换生效.\n## observeOn\n废话不说, 我们直接看`ObservableObserveOn.subscribeActual(observer)`\n``` java\nprotected void subscribeActual(Observer<? super T> observer) {\n        if (scheduler instanceof TrampolineScheduler) {\n            source.subscribe(observer);\n        } else {\n            Scheduler.Worker w = scheduler.createWorker();\n\n            source.subscribe(new ObserveOnObserver<T>(observer, w, delayError, bufferSize));\n        }\n    }\n```\n熟悉的配方, 当相同想成的时候, 直接订阅, 而当不同线程的时候, 可以看到我们获取目标切换线程对应的worker实例以及装饰对应的`Observer`成`ObserveOnOberver`,后面的流程我们心知肚明, 就是`Observer`层层订阅上去, 然后我们看当碰到最上流的`ObservableSource`往下执行的时候, 做什么操作.具体我们看`ObserveOnOberver`代码, 我们这里着重看下`onSubscribe`和`onNext`方法\n``` java\n@Override\npublic void onSubscribe(Disposable s) {\n    if (DisposableHelper.validate(this.s, s)) {\n        this.s = s;\n        // 发送的数据是集合队列形式的时候\n        if (s instanceof QueueDisposable) {\n            @SuppressWarnings(\"unchecked\")\n            QueueDisposable<T> qd = (QueueDisposable<T>) s;\n\n            int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);\n            //是同步模式的时候\n            if (m == QueueDisposable.SYNC) {\n                sourceMode = m;\n                queue = qd;\n                done = true;\n                actual.onSubscribe(this);\n                // 线程调度\n                schedule();\n                return;\n            }\n            // 异步模式\n            if (m == QueueDisposable.ASYNC) {\n                sourceMode = m;\n                queue = qd;\n                actual.onSubscribe(this);\n                return;\n            }\n        }\n\n        queue = new SpscLinkedArrayQueue<T>(bufferSize);\n\n        actual.onSubscribe(this);\n    }\n}\n\n@Override\npublic void onNext(T t) {\n    // 是否已经调用到onComplete 或者 onError, 如果是, 则不再执行后面的onNext\n    if (done) {\n        return;\n    }\n    // 如果是非异步操作, 将数据添加到队列中\n    if (sourceMode != QueueDisposable.ASYNC) {\n        queue.offer(t);\n    }\n    // 线程调度\n    schedule();\n}\n```\n大概的注释都加在代码上了, 我们再补充看下看`onSubscribe`方法, 首先判断发送的数据是否属于`QueueDisposable`, 如果不是, 直接执行下游的`onSubscribe`,这里我卡了一下, 看不到他的线程切换是在哪里做, 后来往回看, 发现在我们执行`ObservableSubscribeOn.subscribeActual(observer)`的时候, `onSubscribe()`方法本身的确不是在切换后的线程内执行的. 但是, 当我们发送的是集合数据, 那么我们需要判断是哪种线程模式进行线程调度.\n\n我们来看具体的`schedule()`方法代码\n``` java\nvoid schedule() {\n            // 判断当前自增值是否为0, 原子性保证worker.schedule(this);不会在调用结束前被重复调用\n            if (getAndIncrement() == 0) {\n                worker.schedule(this);\n            }\n        }\n```\n这个时候就是在指定线程内run了, `Disposable schedule(@NonNull Runnable run)`传入的是个`Runnable`的实现类, 我们来找重载的`run`方法\n``` java\n@Override\npublic void run() {\n    if (outputFused) {\n        drainFused();\n    } else {\n        drainNormal();\n    }\n}\n\nvoid drainNormal() {\n    int missed = 1;\n\n    final SimpleQueue<T> q = queue;\n    final Observer<? super T> a = actual;\n    // 无限循环\n    for (;;) {\n        // 判断是否被取消, 或者调用onError 或者调用onComplete则退出循环\n        if (checkTerminated(done, q.isEmpty(), a)) {\n            return;\n        }\n        // 无限循环\n        for (;;) {\n            boolean d = done;\n            T v;\n\n            try {\n                // 队列数据分发\n                v = q.poll();\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                s.dispose();\n                q.clear();\n                a.onError(ex);\n                worker.dispose();\n                return;\n            }\n            boolean empty = v == null;\n            // 判断是否应该被终止\n            if (checkTerminated(d, empty, a)) {\n                return;\n            }\n\n            if (empty) {\n                break;\n            }\n            a.onNext(v);\n        }\n        // 原子性保证worker.schedule(this)的调用\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n\n// 判断循环是否终止\nboolean checkTerminated(boolean d, boolean empty, Observer<? super T> a) {\n    // 如果订阅已经被取消, 则清除队列, 终止\n    if (cancelled) {\n        queue.clear();\n        return true;\n    }\n    // 如果调用过onError 或者 onComplete\n    if (d) {\n        Throwable e = error;\n        // 默认false\n        if (delayError) {\n            // 等到队列为空的时候再调用onError或者onComplete\n            if (empty) {\n                if (e != null) {\n                    a.onError(e);\n                } else {\n                    a.onComplete();\n                }\n                worker.dispose();\n                return true;\n            }\n        } else {\n            // 如果有抛出异常, 走下游的onError\n            // 线程任务停止\n            if (e != null) {\n                queue.clear();\n                a.onError(e);\n                worker.dispose();\n                return true;\n            }\n            // 没有, 走下游的onComplete\n            // 线程任务停止\n            else if (empty) {\n                a.onComplete();\n                worker.dispose();\n                return true;\n            }\n        }\n    }\n    // 否则不结束\n    return false;\n}\n```\n由此我们可以得出结论, `observeOn`的操作符可以保证我们下流操作线程切换生效\n## 总结\n到这里, 我们线程切换的原理大体流程就基本分析完毕了, 可以看出`subscribeOn`操作符只对上游生效, 而且因为他是在订阅的时候进行线程切换, 而我们每个操作符中间都有订阅动作, 所以越接近我们的`ObservableSource`的订阅的`subscribeOn`越是最后生效的. 而`observeOn`生效在我们的`onNext`,`onComplete`, `onError`方法内, 所以每次的`observeOn`针对它的下游都可以生效.\n","slug":"RxJava2源码解析2","published":1,"updated":"2018-05-07T02:03:35.090Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjld5ah30001lcqs6d4jj48ah","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本篇主要解析RxJava的线程切换的原理实现<br><a id=\"more\"></a></p>\n<h2 id=\"subscribeOn\"><a href=\"#subscribeOn\" class=\"headerlink\" title=\"subscribeOn\"></a>subscribeOn</h2><p>首先, 我们先看下<code>subscribeOn()</code>方法, 老样子, 先上Demo<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable&lt;Integer&gt; observable =</span><br><span class=\"line\">                Observable</span><br><span class=\"line\">                .create(<span class=\"keyword\">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                        emitter.onNext(<span class=\"number\">123</span>);</span><br><span class=\"line\">                        emitter.onComplete();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">observable</span><br><span class=\"line\">        .subscribeOn(Schedulers.io())</span><br><span class=\"line\">        .subscribe(getObserver());</span><br></pre></td></tr></table></figure></p>\n<p><code>subscribeOn</code>操作符源码里其实是返回了一个<code>ObservableSubscribeOn</code>对象, 而从<a href=\"https://yutiantina.github.io/2018/02/07/RxJava2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%901/\" target=\"_blank\" rel=\"noopener\">上篇</a>我们已经知道, 订阅的动作其实在每个<code>Observable</code>的<code>subscribeActual(observer)</code>中执行, 所以我们直接去看<code>ObservableSubscribeOn</code>中的对应重载方法就行了.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribeActual</span><span class=\"params\">(<span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class=\"keyword\">new</span> SubscribeOnObserver&lt;T&gt;(s);</span><br><span class=\"line\"></span><br><span class=\"line\">        s.onSubscribe(parent);</span><br><span class=\"line\"></span><br><span class=\"line\">        parent.setDisposable(scheduler.scheduleDirect(<span class=\"keyword\">new</span> SubscribeTask(parent)));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubscribeTask</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SubscribeOnObserver&lt;T&gt; parent;</span><br><span class=\"line\"></span><br><span class=\"line\">        SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.parent = parent;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            source.subscribe(parent);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><code>SubscribeTask</code>是一个Runnable的实现类, 执行内容就是修饰后的<code>Observer</code>订阅上游的动作, 我们先看<code>scheduler.scheduleDirect(runable)</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Disposable <span class=\"title\">scheduleDirect</span><span class=\"params\">(@NonNull Runnable run)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> scheduleDirect(run, <span class=\"number\">0L</span>, TimeUnit.NANOSECONDS);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Disposable <span class=\"title\">scheduleDirect</span><span class=\"params\">(@NonNull Runnable run, <span class=\"keyword\">long</span> delay, @NonNull TimeUnit unit)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Worker w = createWorker();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class=\"line\"></span><br><span class=\"line\">    DisposeTask task = <span class=\"keyword\">new</span> DisposeTask(decoratedRun, w);</span><br><span class=\"line\"></span><br><span class=\"line\">    w.schedule(task, delay, unit);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> task;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里<code>createWorker</code>是个抽象方法, 我们需要找到对应的修饰类, 我们返回去看<code>Schedulers.io()</code>, <code>IO</code>是<code>IoScheduler</code>的实例, 它的重载方法代码如下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> AtomicReference&lt;CachedWorkerPool&gt; pool;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Worker <span class=\"title\">createWorker</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EventLoopWorker(pool.get());</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到IO线程实际使用的是一个有线程缓存的线程调度器.它内部通过<code>ScheduledExecutorService</code>实例来尝试重用之前<code>worker</code>开始使用的实例, 由于本篇着重在流程实现原理, 所以略过细节处.<br>在<code>EventLoopWorker</code>中, 我们看下对应的重载方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Disposable <span class=\"title\">schedule</span><span class=\"params\">(@NonNull Runnable action, <span class=\"keyword\">long</span> delayTime, @NonNull TimeUnit unit)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tasks.isDisposed()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// don't schedule, we are unsubscribed</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> EmptyDisposable.INSTANCE;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> threadWorker.scheduleActual(action, delayTime, unit, tasks);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>继续往下, 其实这个时候已经是在线程池目标线程执行相关的工作了. 再深入就是线程池的操作了, 所以这里我们不再赘述<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ScheduledRunnable <span class=\"title\">scheduleActual</span><span class=\"params\">(<span class=\"keyword\">final</span> Runnable run, <span class=\"keyword\">long</span> delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent)</span> </span>&#123;</span><br><span class=\"line\">        Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class=\"line\"></span><br><span class=\"line\">        ScheduledRunnable sr = <span class=\"keyword\">new</span> ScheduledRunnable(decoratedRun, parent);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!parent.add(sr)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> sr;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Future&lt;?&gt; f;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (delayTime &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                f = executor.submit((Callable&lt;Object&gt;)sr);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sr.setFuture(f);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                parent.remove(sr);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            RxJavaPlugins.onError(ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sr;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>由此我们可以看出来, 每次每个<code>subscribeOn</code>操作符执行的时候, 其实在<code>source.subscribe(parent);</code>订阅动作就做了线程切换, 所以在多次调<code>subscribeOn</code>的时候, 就会一直切换线程, 直到离<code>ObservableSource</code>最近的<code>subscribeOn</code>线程切换生效.</p>\n<h2 id=\"observeOn\"><a href=\"#observeOn\" class=\"headerlink\" title=\"observeOn\"></a>observeOn</h2><p>废话不说, 我们直接看<code>ObservableObserveOn.subscribeActual(observer)</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribeActual</span><span class=\"params\">(Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (scheduler <span class=\"keyword\">instanceof</span> TrampolineScheduler) &#123;</span><br><span class=\"line\">            source.subscribe(observer);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Scheduler.Worker w = scheduler.createWorker();</span><br><span class=\"line\"></span><br><span class=\"line\">            source.subscribe(<span class=\"keyword\">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>熟悉的配方, 当相同想成的时候, 直接订阅, 而当不同线程的时候, 可以看到我们获取目标切换线程对应的worker实例以及装饰对应的<code>Observer</code>成<code>ObserveOnOberver</code>,后面的流程我们心知肚明, 就是<code>Observer</code>层层订阅上去, 然后我们看当碰到最上流的<code>ObservableSource</code>往下执行的时候, 做什么操作.具体我们看<code>ObserveOnOberver</code>代码, 我们这里着重看下<code>onSubscribe</code>和<code>onNext</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSubscribe</span><span class=\"params\">(Disposable s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DisposableHelper.validate(<span class=\"keyword\">this</span>.s, s)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.s = s;</span><br><span class=\"line\">        <span class=\"comment\">// 发送的数据是集合队列形式的时候</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s <span class=\"keyword\">instanceof</span> QueueDisposable) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            QueueDisposable&lt;T&gt; qd = (QueueDisposable&lt;T&gt;) s;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">int</span> m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);</span><br><span class=\"line\">            <span class=\"comment\">//是同步模式的时候</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m == QueueDisposable.SYNC) &#123;</span><br><span class=\"line\">                sourceMode = m;</span><br><span class=\"line\">                queue = qd;</span><br><span class=\"line\">                done = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                actual.onSubscribe(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 线程调度</span></span><br><span class=\"line\">                schedule();</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 异步模式</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m == QueueDisposable.ASYNC) &#123;</span><br><span class=\"line\">                sourceMode = m;</span><br><span class=\"line\">                queue = qd;</span><br><span class=\"line\">                actual.onSubscribe(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        queue = <span class=\"keyword\">new</span> SpscLinkedArrayQueue&lt;T&gt;(bufferSize);</span><br><span class=\"line\"></span><br><span class=\"line\">        actual.onSubscribe(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 是否已经调用到onComplete 或者 onError, 如果是, 则不再执行后面的onNext</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (done) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是非异步操作, 将数据添加到队列中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sourceMode != QueueDisposable.ASYNC) &#123;</span><br><span class=\"line\">        queue.offer(t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 线程调度</span></span><br><span class=\"line\">    schedule();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>大概的注释都加在代码上了, 我们再补充看下看<code>onSubscribe</code>方法, 首先判断发送的数据是否属于<code>QueueDisposable</code>, 如果不是, 直接执行下游的<code>onSubscribe</code>,这里我卡了一下, 看不到他的线程切换是在哪里做, 后来往回看, 发现在我们执行<code>ObservableSubscribeOn.subscribeActual(observer)</code>的时候, <code>onSubscribe()</code>方法本身的确不是在切换后的线程内执行的. 但是, 当我们发送的是集合数据, 那么我们需要判断是哪种线程模式进行线程调度.</p>\n<p>我们来看具体的<code>schedule()</code>方法代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">schedule</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断当前自增值是否为0, 原子性保证worker.schedule(this);不会在调用结束前被重复调用</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (getAndIncrement() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                worker.schedule(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个时候就是在指定线程内run了, <code>Disposable schedule(@NonNull Runnable run)</code>传入的是个<code>Runnable</code>的实现类, 我们来找重载的<code>run</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (outputFused) &#123;</span><br><span class=\"line\">        drainFused();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        drainNormal();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">drainNormal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> missed = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> SimpleQueue&lt;T&gt; q = queue;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; a = actual;</span><br><span class=\"line\">    <span class=\"comment\">// 无限循环</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断是否被取消, 或者调用onError 或者调用onComplete则退出循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (checkTerminated(done, q.isEmpty(), a)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 无限循环</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> d = done;</span><br><span class=\"line\">            T v;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 队列数据分发</span></span><br><span class=\"line\">                v = q.poll();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                Exceptions.throwIfFatal(ex);</span><br><span class=\"line\">                s.dispose();</span><br><span class=\"line\">                q.clear();</span><br><span class=\"line\">                a.onError(ex);</span><br><span class=\"line\">                worker.dispose();</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> empty = v == <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 判断是否应该被终止</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (checkTerminated(d, empty, a)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (empty) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            a.onNext(v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 原子性保证worker.schedule(this)的调用</span></span><br><span class=\"line\">        missed = addAndGet(-missed);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (missed == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断循环是否终止</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">checkTerminated</span><span class=\"params\">(<span class=\"keyword\">boolean</span> d, <span class=\"keyword\">boolean</span> empty, Observer&lt;? <span class=\"keyword\">super</span> T&gt; a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果订阅已经被取消, 则清除队列, 终止</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cancelled) &#123;</span><br><span class=\"line\">        queue.clear();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果调用过onError 或者 onComplete</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (d) &#123;</span><br><span class=\"line\">        Throwable e = error;</span><br><span class=\"line\">        <span class=\"comment\">// 默认false</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (delayError) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 等到队列为空的时候再调用onError或者onComplete</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (empty) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    a.onError(e);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    a.onComplete();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                worker.dispose();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果有抛出异常, 走下游的onError</span></span><br><span class=\"line\">            <span class=\"comment\">// 线程任务停止</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                queue.clear();</span><br><span class=\"line\">                a.onError(e);</span><br><span class=\"line\">                worker.dispose();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 没有, 走下游的onComplete</span></span><br><span class=\"line\">            <span class=\"comment\">// 线程任务停止</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (empty) &#123;</span><br><span class=\"line\">                a.onComplete();</span><br><span class=\"line\">                worker.dispose();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 否则不结束</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由此我们可以得出结论, <code>observeOn</code>的操作符可以保证我们下流操作线程切换生效</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>到这里, 我们线程切换的原理大体流程就基本分析完毕了, 可以看出<code>subscribeOn</code>操作符只对上游生效, 而且因为他是在订阅的时候进行线程切换, 而我们每个操作符中间都有订阅动作, 所以越接近我们的<code>ObservableSource</code>的订阅的<code>subscribeOn</code>越是最后生效的. 而<code>observeOn</code>生效在我们的<code>onNext</code>,<code>onComplete</code>, <code>onError</code>方法内, 所以每次的<code>observeOn</code>针对它的下游都可以生效.</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本篇主要解析RxJava的线程切换的原理实现<br>","more":"</p>\n<h2 id=\"subscribeOn\"><a href=\"#subscribeOn\" class=\"headerlink\" title=\"subscribeOn\"></a>subscribeOn</h2><p>首先, 我们先看下<code>subscribeOn()</code>方法, 老样子, 先上Demo<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable&lt;Integer&gt; observable =</span><br><span class=\"line\">                Observable</span><br><span class=\"line\">                .create(<span class=\"keyword\">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                        emitter.onNext(<span class=\"number\">123</span>);</span><br><span class=\"line\">                        emitter.onComplete();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">observable</span><br><span class=\"line\">        .subscribeOn(Schedulers.io())</span><br><span class=\"line\">        .subscribe(getObserver());</span><br></pre></td></tr></table></figure></p>\n<p><code>subscribeOn</code>操作符源码里其实是返回了一个<code>ObservableSubscribeOn</code>对象, 而从<a href=\"https://yutiantina.github.io/2018/02/07/RxJava2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%901/\" target=\"_blank\" rel=\"noopener\">上篇</a>我们已经知道, 订阅的动作其实在每个<code>Observable</code>的<code>subscribeActual(observer)</code>中执行, 所以我们直接去看<code>ObservableSubscribeOn</code>中的对应重载方法就行了.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribeActual</span><span class=\"params\">(<span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class=\"keyword\">new</span> SubscribeOnObserver&lt;T&gt;(s);</span><br><span class=\"line\"></span><br><span class=\"line\">        s.onSubscribe(parent);</span><br><span class=\"line\"></span><br><span class=\"line\">        parent.setDisposable(scheduler.scheduleDirect(<span class=\"keyword\">new</span> SubscribeTask(parent)));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubscribeTask</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SubscribeOnObserver&lt;T&gt; parent;</span><br><span class=\"line\"></span><br><span class=\"line\">        SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.parent = parent;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            source.subscribe(parent);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><code>SubscribeTask</code>是一个Runnable的实现类, 执行内容就是修饰后的<code>Observer</code>订阅上游的动作, 我们先看<code>scheduler.scheduleDirect(runable)</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Disposable <span class=\"title\">scheduleDirect</span><span class=\"params\">(@NonNull Runnable run)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> scheduleDirect(run, <span class=\"number\">0L</span>, TimeUnit.NANOSECONDS);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Disposable <span class=\"title\">scheduleDirect</span><span class=\"params\">(@NonNull Runnable run, <span class=\"keyword\">long</span> delay, @NonNull TimeUnit unit)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Worker w = createWorker();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class=\"line\"></span><br><span class=\"line\">    DisposeTask task = <span class=\"keyword\">new</span> DisposeTask(decoratedRun, w);</span><br><span class=\"line\"></span><br><span class=\"line\">    w.schedule(task, delay, unit);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> task;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里<code>createWorker</code>是个抽象方法, 我们需要找到对应的修饰类, 我们返回去看<code>Schedulers.io()</code>, <code>IO</code>是<code>IoScheduler</code>的实例, 它的重载方法代码如下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> AtomicReference&lt;CachedWorkerPool&gt; pool;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Worker <span class=\"title\">createWorker</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EventLoopWorker(pool.get());</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到IO线程实际使用的是一个有线程缓存的线程调度器.它内部通过<code>ScheduledExecutorService</code>实例来尝试重用之前<code>worker</code>开始使用的实例, 由于本篇着重在流程实现原理, 所以略过细节处.<br>在<code>EventLoopWorker</code>中, 我们看下对应的重载方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Disposable <span class=\"title\">schedule</span><span class=\"params\">(@NonNull Runnable action, <span class=\"keyword\">long</span> delayTime, @NonNull TimeUnit unit)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tasks.isDisposed()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// don't schedule, we are unsubscribed</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> EmptyDisposable.INSTANCE;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> threadWorker.scheduleActual(action, delayTime, unit, tasks);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>继续往下, 其实这个时候已经是在线程池目标线程执行相关的工作了. 再深入就是线程池的操作了, 所以这里我们不再赘述<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ScheduledRunnable <span class=\"title\">scheduleActual</span><span class=\"params\">(<span class=\"keyword\">final</span> Runnable run, <span class=\"keyword\">long</span> delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent)</span> </span>&#123;</span><br><span class=\"line\">        Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class=\"line\"></span><br><span class=\"line\">        ScheduledRunnable sr = <span class=\"keyword\">new</span> ScheduledRunnable(decoratedRun, parent);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!parent.add(sr)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> sr;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Future&lt;?&gt; f;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (delayTime &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                f = executor.submit((Callable&lt;Object&gt;)sr);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sr.setFuture(f);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                parent.remove(sr);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            RxJavaPlugins.onError(ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sr;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>由此我们可以看出来, 每次每个<code>subscribeOn</code>操作符执行的时候, 其实在<code>source.subscribe(parent);</code>订阅动作就做了线程切换, 所以在多次调<code>subscribeOn</code>的时候, 就会一直切换线程, 直到离<code>ObservableSource</code>最近的<code>subscribeOn</code>线程切换生效.</p>\n<h2 id=\"observeOn\"><a href=\"#observeOn\" class=\"headerlink\" title=\"observeOn\"></a>observeOn</h2><p>废话不说, 我们直接看<code>ObservableObserveOn.subscribeActual(observer)</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribeActual</span><span class=\"params\">(Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (scheduler <span class=\"keyword\">instanceof</span> TrampolineScheduler) &#123;</span><br><span class=\"line\">            source.subscribe(observer);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Scheduler.Worker w = scheduler.createWorker();</span><br><span class=\"line\"></span><br><span class=\"line\">            source.subscribe(<span class=\"keyword\">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>熟悉的配方, 当相同想成的时候, 直接订阅, 而当不同线程的时候, 可以看到我们获取目标切换线程对应的worker实例以及装饰对应的<code>Observer</code>成<code>ObserveOnOberver</code>,后面的流程我们心知肚明, 就是<code>Observer</code>层层订阅上去, 然后我们看当碰到最上流的<code>ObservableSource</code>往下执行的时候, 做什么操作.具体我们看<code>ObserveOnOberver</code>代码, 我们这里着重看下<code>onSubscribe</code>和<code>onNext</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSubscribe</span><span class=\"params\">(Disposable s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DisposableHelper.validate(<span class=\"keyword\">this</span>.s, s)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.s = s;</span><br><span class=\"line\">        <span class=\"comment\">// 发送的数据是集合队列形式的时候</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s <span class=\"keyword\">instanceof</span> QueueDisposable) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            QueueDisposable&lt;T&gt; qd = (QueueDisposable&lt;T&gt;) s;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">int</span> m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);</span><br><span class=\"line\">            <span class=\"comment\">//是同步模式的时候</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m == QueueDisposable.SYNC) &#123;</span><br><span class=\"line\">                sourceMode = m;</span><br><span class=\"line\">                queue = qd;</span><br><span class=\"line\">                done = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                actual.onSubscribe(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 线程调度</span></span><br><span class=\"line\">                schedule();</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 异步模式</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m == QueueDisposable.ASYNC) &#123;</span><br><span class=\"line\">                sourceMode = m;</span><br><span class=\"line\">                queue = qd;</span><br><span class=\"line\">                actual.onSubscribe(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        queue = <span class=\"keyword\">new</span> SpscLinkedArrayQueue&lt;T&gt;(bufferSize);</span><br><span class=\"line\"></span><br><span class=\"line\">        actual.onSubscribe(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 是否已经调用到onComplete 或者 onError, 如果是, 则不再执行后面的onNext</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (done) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是非异步操作, 将数据添加到队列中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sourceMode != QueueDisposable.ASYNC) &#123;</span><br><span class=\"line\">        queue.offer(t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 线程调度</span></span><br><span class=\"line\">    schedule();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>大概的注释都加在代码上了, 我们再补充看下看<code>onSubscribe</code>方法, 首先判断发送的数据是否属于<code>QueueDisposable</code>, 如果不是, 直接执行下游的<code>onSubscribe</code>,这里我卡了一下, 看不到他的线程切换是在哪里做, 后来往回看, 发现在我们执行<code>ObservableSubscribeOn.subscribeActual(observer)</code>的时候, <code>onSubscribe()</code>方法本身的确不是在切换后的线程内执行的. 但是, 当我们发送的是集合数据, 那么我们需要判断是哪种线程模式进行线程调度.</p>\n<p>我们来看具体的<code>schedule()</code>方法代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">schedule</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断当前自增值是否为0, 原子性保证worker.schedule(this);不会在调用结束前被重复调用</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (getAndIncrement() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                worker.schedule(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个时候就是在指定线程内run了, <code>Disposable schedule(@NonNull Runnable run)</code>传入的是个<code>Runnable</code>的实现类, 我们来找重载的<code>run</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (outputFused) &#123;</span><br><span class=\"line\">        drainFused();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        drainNormal();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">drainNormal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> missed = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> SimpleQueue&lt;T&gt; q = queue;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; a = actual;</span><br><span class=\"line\">    <span class=\"comment\">// 无限循环</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断是否被取消, 或者调用onError 或者调用onComplete则退出循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (checkTerminated(done, q.isEmpty(), a)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 无限循环</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> d = done;</span><br><span class=\"line\">            T v;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 队列数据分发</span></span><br><span class=\"line\">                v = q.poll();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                Exceptions.throwIfFatal(ex);</span><br><span class=\"line\">                s.dispose();</span><br><span class=\"line\">                q.clear();</span><br><span class=\"line\">                a.onError(ex);</span><br><span class=\"line\">                worker.dispose();</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> empty = v == <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 判断是否应该被终止</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (checkTerminated(d, empty, a)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (empty) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            a.onNext(v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 原子性保证worker.schedule(this)的调用</span></span><br><span class=\"line\">        missed = addAndGet(-missed);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (missed == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断循环是否终止</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">checkTerminated</span><span class=\"params\">(<span class=\"keyword\">boolean</span> d, <span class=\"keyword\">boolean</span> empty, Observer&lt;? <span class=\"keyword\">super</span> T&gt; a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果订阅已经被取消, 则清除队列, 终止</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cancelled) &#123;</span><br><span class=\"line\">        queue.clear();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果调用过onError 或者 onComplete</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (d) &#123;</span><br><span class=\"line\">        Throwable e = error;</span><br><span class=\"line\">        <span class=\"comment\">// 默认false</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (delayError) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 等到队列为空的时候再调用onError或者onComplete</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (empty) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    a.onError(e);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    a.onComplete();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                worker.dispose();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果有抛出异常, 走下游的onError</span></span><br><span class=\"line\">            <span class=\"comment\">// 线程任务停止</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                queue.clear();</span><br><span class=\"line\">                a.onError(e);</span><br><span class=\"line\">                worker.dispose();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 没有, 走下游的onComplete</span></span><br><span class=\"line\">            <span class=\"comment\">// 线程任务停止</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (empty) &#123;</span><br><span class=\"line\">                a.onComplete();</span><br><span class=\"line\">                worker.dispose();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 否则不结束</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由此我们可以得出结论, <code>observeOn</code>的操作符可以保证我们下流操作线程切换生效</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>到这里, 我们线程切换的原理大体流程就基本分析完毕了, 可以看出<code>subscribeOn</code>操作符只对上游生效, 而且因为他是在订阅的时候进行线程切换, 而我们每个操作符中间都有订阅动作, 所以越接近我们的<code>ObservableSource</code>的订阅的<code>subscribeOn</code>越是最后生效的. 而<code>observeOn</code>生效在我们的<code>onNext</code>,<code>onComplete</code>, <code>onError</code>方法内, 所以每次的<code>observeOn</code>针对它的下游都可以生效.</p>"},{"title":"okHttp3源码解析(一)","date":"2018-08-19T16:00:00.000Z","_content":"\n> 源码基于3.11.0版本\n\nokHttp的请求分为两种, 同步和异步的.\n本篇主要了解下两种请求的请求流程, 差异.\n<!-- more -->\n## 同步请求\n我们先看下同步请求api的使用\n``` kotlin\nval okHttpClient by lazy { OkHttpClient() }\nprivate fun synchronousRun(url: String): String?{\n        val request = Request.Builder()\n                .url(url)\n                .build()\n        val response = okHttpClient.newCall(request).execute()\n        return response?.body()?.string()\n    }\n```\n### Request\n`Request`的代码就不看了, 可以看出是使用建造者模式, 根据具体配置去build.要注意的是, 这里传入的url, 如果是websocket协议的url, 会替换成http, 最后url会包装成一个`HttpUrl`对象\n``` java\npublic Builder url(String url) {\n      if (url == null) throw new NullPointerException(\"url == null\");\n\n      // Silently replace web socket URLs with HTTP URLs.\n      if (url.regionMatches(true, 0, \"ws:\", 0, 3)) {\n        url = \"http:\" + url.substring(3);\n      } else if (url.regionMatches(true, 0, \"wss:\", 0, 4)) {\n        url = \"https:\" + url.substring(4);\n      }\n\n      return url(HttpUrl.get(url));\n    }\n```\n另外关于`GET`的请求, 在`Request`构造器初始的时候, 就会默认为`GET`请求, 所以如果是`POST`请求的时候, 需要调用`Request.Build().post(body)`方法\n``` java\npublic Builder() {\n      this.method = \"GET\";\n      this.headers = new Headers.Builder();\n    }\npublic Builder post(RequestBody body) {\n  return method(\"POST\", body);\n}\n```\n![img](./requestbuilder.png)\n\n我们可以看下Request可配置项, 分别包含一个Url, 一个请求的方法, header列表, 请求体和tags(关于tags我们后续再讲)\n### Call\n请求需要准备一个`Call`对象, 他表示在未来的时间点内可以随时执行准备好的请求. 我们可以看到实际执行的时候, 其实使用的是`RealCall`对象, 具体看下请求执行的过程\n``` java\n@Override public Call newCall(Request request) {\n    return RealCall.newRealCall(this, request, false /* for web socket */);\n  }\n```\n### execute\n``` java\n@Override public Response execute() throws IOException {\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already Executed\");\n      executed = true;\n    }\n    // 创建一个跟踪当前执行方法的堆栈, 赋值在失败重试的拦截器中\n    captureCallStackTrace();\n    // 监听\n    eventListener.callStart(this);\n    try {\n      // 通过dispatcher做管理, 将call加入同步请求队列中\n      client.dispatcher().executed(this);\n      // 获取返回的结果, 并执行一系列拦截器处理\n      Response result = getResponseWithInterceptorChain();\n      if (result == null) throw new IOException(\"Canceled\");\n      return result;\n    } catch (IOException e) {\n      eventListener.callFailed(this, e);\n      throw e;\n    } finally {\n      // 通过dispatcher通知结束\n      client.dispatcher().finished(this);\n    }\n  }\n```\n`executed`表示对应的`call`是否已经执行, 这里同步锁可以避免了竞态条件的出现, 可以看出一个`call`实例只能被执行一次, 是一个\"消耗品\"\n关于`Dispatcher`我们可以看下在同步请求下他具体的执行和结束的代码\n``` java\n// 执行方法\nsynchronized void executed(RealCall call) {\n    runningSyncCalls.add(call);\n  }\n// 通知结束\nvoid finished(RealCall call) {\n    finished(runningSyncCalls, call, false);\n  }\n\n  private <T> void finished(Deque<T> calls, T call, boolean promoteCalls) {\n    int runningCallsCount;\n    Runnable idleCallback;\n    synchronized (this) {\n      // 移除call\n      if (!calls.remove(call)) throw new AssertionError(\"Call wasn't in-flight!\");\n      if (promoteCalls) promoteCalls();\n      runningCallsCount = runningCallsCount();\n      idleCallback = this.idleCallback;\n    }\n    // 判断当前异步请求和同步请求数总和是否为0, 如果为0 则调用闲置时候的回调\n    if (runningCallsCount == 0 && idleCallback != null) {\n      idleCallback.run();\n    }\n  }\n```\n可以看到在同步请求的时候, `dispatcher`的执行和完成通知, 实际是针对于`runningSyncCalls`对象的管理.\n``` java\nResponse getResponseWithInterceptorChain() throws IOException {\n    // Build a full stack of interceptors.\n    List<Interceptor> interceptors = new ArrayList<>();\n    // 自定义拦截器\n    interceptors.addAll(client.interceptors());\n    // 失败重试或者重定向的拦截器\n    interceptors.add(retryAndFollowUpInterceptor);\n    // 请求和响应的转换处理拦截器\n    interceptors.add(new BridgeInterceptor(client.cookieJar()));\n    // 缓存拦截器, 从缓存中请求并将响应写入缓存\n    interceptors.add(new CacheInterceptor(client.internalCache()));\n    // 建立连接拦截器, 并继续下一个拦截器\n    interceptors.add(new ConnectInterceptor(client));\n    if (!forWebSocket) {\n      // 用户自定义的拦截器\n      interceptors.addAll(client.networkInterceptors());\n    }\n    // 最后一个拦截器, 处理网络调用服务器\n    interceptors.add(new CallServerInterceptor(forWebSocket));\n\n    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,\n        originalRequest, this, eventListener, client.connectTimeoutMillis(),\n        client.readTimeoutMillis(), client.writeTimeoutMillis());\n\n    return chain.proceed(originalRequest);\n  }\n```\n我们可以看到, 实际执行是`RealInterceptorChain.proceed`\n``` java\npublic Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,\n      RealConnection connection) throws IOException {\n    if (index >= interceptors.size()) throw new AssertionError();\n\n    calls++;\n\n    // If we already have a stream, confirm that the incoming request will use it.\n    if (this.httpCodec != null && !this.connection.supportsUrl(request.url())) {\n      throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1)\n          + \" must retain the same host and port\");\n    }\n\n    // If we already have a stream, confirm that this is the only call to chain.proceed().\n    if (this.httpCodec != null && calls > 1) {\n      throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1)\n          + \" must call proceed() exactly once\");\n    }\n\n    // 请求下一个责任链\n    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,\n        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,\n        writeTimeout);\n    // 获取当前的拦截器\n    Interceptor interceptor = interceptors.get(index);\n    // 执行, 返回响应\n    Response response = interceptor.intercept(next);\n\n    // 保证下一个拦截器会调用到chain.proceed().\n    if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {\n      throw new IllegalStateException(\"network interceptor \" + interceptor\n          + \" must call proceed() exactly once\");\n    }\n\n    // 保证拦截器返回的响应不为空\n    if (response == null) {\n      throw new NullPointerException(\"interceptor \" + interceptor + \" returned null\");\n    }\n    // 保证响应的body不为空\n    if (response.body() == null) {\n      throw new IllegalStateException(\n          \"interceptor \" + interceptor + \" returned a response with no body\");\n    }\n\n    return response;\n  }\n```\n这里可以把拦截器理解成工厂模式, 递归执行拦截器抽象的`intercept`方法, 然后将返回的`response`再传到下一个拦截器内做处理.再返回看前面的`getResponseWithInterceptorChain`方法, 可以看出真正请求执行的就在这一块, 根据责任链的设计思想, 将操作分开进行处理.\n## 异步请求\n现在我们再回头看下异步请求时, 与同步请求有什么区别.\n``` java\n@Override public void enqueue(Callback responseCallback) {\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already Executed\");\n      executed = true;\n    }\n    captureCallStackTrace();\n    eventListener.callStart(this);\n    client.dispatcher().enqueue(new AsyncCall(responseCallback));\n  }\n```\n在执行异步调用的时候, okHttp包装了一个`AsyncCall`对象通过`dispatcher`进行执行.`AsyncCall`继承`NamedRunnable`, 实现了`Runnable`接口.\n``` java\nsynchronized void enqueue(AsyncCall call) {\n  // 判断当前异步请求数是否小于最大请求数 以及 同主机的请求数是否小于每个主机的最大请求数\n    if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {\n      runningAsyncCalls.add(call);\n      executorService().execute(call);\n    } else {\n      readyAsyncCalls.add(call);\n    }\n  }\n```\n可以看到异步请求, 在`dispatcher`内部会维护两个集合以及一个线程池: `runningAsyncCalls`表示当前执行的异步请求队列, `readyAsyncCalls`表示等待执行的异步请求队列.执行内容我们可以看`AsyncCall.execute`, 他在判断请求是否取消后, 会调用`getResponseWithInterceptorChain`方法, 后面的请求走到的步骤就与同步相同了.然后通过`dispatcher`关闭管理.\n``` java\n@Override protected void execute() {\n      boolean signalledCallback = false;\n      try {\n        // 责任链执行\n        Response response = getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n          signalledCallback = true;\n          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback = true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n          eventListener.callFailed(RealCall.this, e);\n          responseCallback.onFailure(RealCall.this, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }\n  }\n```\n\n``` java\nprivate void promoteCalls() {\n    if (runningAsyncCalls.size() >= maxRequests) return; // Already running max capacity.\n    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.\n\n    for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {\n      AsyncCall call = i.next();\n\n      if (runningCallsForHost(call) < maxRequestsPerHost) {\n        i.remove();\n        runningAsyncCalls.add(call);\n        executorService().execute(call);\n      }\n\n      if (runningAsyncCalls.size() >= maxRequests) return; // Reached max capacity.\n    }\n  }\n```\n这里唯一的区别是, 异步请求调到`Dispatcher.finished`的时候, 会调到`promoteCalls`方法, 他用来判断调度当前异步请求数是否超过最大请求, 如果没有, 则会从异步请求等待队列中获取出来再进行请求执行.由此, `Dispatch`才做到了内部针对于异步请求的线程管理, 实现了对应策略下同时请求的最大化.\n## 总结\n本篇主要了解同步请求和异步请求的主干流程, 可以看出异步请求和同步请求的区别, 就在于, 异步请求真正执行是通过`Dispatcher`进行管理与执行, 虽然同步请求也用到了`Dispatcher`, 但它主要是用来做同步请求队列的管理.两类请求真正的请求网络的处理, 都是通过调用`getResponseWithInterceptorChain`方法进行处理.\n","source":"_posts/okHttp源码解析(一).md","raw":"title: okHttp3源码解析(一)\ndate: 2018-08-20 00:00:00\ncategories:\n- 源码解析\ntags:\n- 源码解析\n- okHttp3\n---\n\n> 源码基于3.11.0版本\n\nokHttp的请求分为两种, 同步和异步的.\n本篇主要了解下两种请求的请求流程, 差异.\n<!-- more -->\n## 同步请求\n我们先看下同步请求api的使用\n``` kotlin\nval okHttpClient by lazy { OkHttpClient() }\nprivate fun synchronousRun(url: String): String?{\n        val request = Request.Builder()\n                .url(url)\n                .build()\n        val response = okHttpClient.newCall(request).execute()\n        return response?.body()?.string()\n    }\n```\n### Request\n`Request`的代码就不看了, 可以看出是使用建造者模式, 根据具体配置去build.要注意的是, 这里传入的url, 如果是websocket协议的url, 会替换成http, 最后url会包装成一个`HttpUrl`对象\n``` java\npublic Builder url(String url) {\n      if (url == null) throw new NullPointerException(\"url == null\");\n\n      // Silently replace web socket URLs with HTTP URLs.\n      if (url.regionMatches(true, 0, \"ws:\", 0, 3)) {\n        url = \"http:\" + url.substring(3);\n      } else if (url.regionMatches(true, 0, \"wss:\", 0, 4)) {\n        url = \"https:\" + url.substring(4);\n      }\n\n      return url(HttpUrl.get(url));\n    }\n```\n另外关于`GET`的请求, 在`Request`构造器初始的时候, 就会默认为`GET`请求, 所以如果是`POST`请求的时候, 需要调用`Request.Build().post(body)`方法\n``` java\npublic Builder() {\n      this.method = \"GET\";\n      this.headers = new Headers.Builder();\n    }\npublic Builder post(RequestBody body) {\n  return method(\"POST\", body);\n}\n```\n![img](./requestbuilder.png)\n\n我们可以看下Request可配置项, 分别包含一个Url, 一个请求的方法, header列表, 请求体和tags(关于tags我们后续再讲)\n### Call\n请求需要准备一个`Call`对象, 他表示在未来的时间点内可以随时执行准备好的请求. 我们可以看到实际执行的时候, 其实使用的是`RealCall`对象, 具体看下请求执行的过程\n``` java\n@Override public Call newCall(Request request) {\n    return RealCall.newRealCall(this, request, false /* for web socket */);\n  }\n```\n### execute\n``` java\n@Override public Response execute() throws IOException {\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already Executed\");\n      executed = true;\n    }\n    // 创建一个跟踪当前执行方法的堆栈, 赋值在失败重试的拦截器中\n    captureCallStackTrace();\n    // 监听\n    eventListener.callStart(this);\n    try {\n      // 通过dispatcher做管理, 将call加入同步请求队列中\n      client.dispatcher().executed(this);\n      // 获取返回的结果, 并执行一系列拦截器处理\n      Response result = getResponseWithInterceptorChain();\n      if (result == null) throw new IOException(\"Canceled\");\n      return result;\n    } catch (IOException e) {\n      eventListener.callFailed(this, e);\n      throw e;\n    } finally {\n      // 通过dispatcher通知结束\n      client.dispatcher().finished(this);\n    }\n  }\n```\n`executed`表示对应的`call`是否已经执行, 这里同步锁可以避免了竞态条件的出现, 可以看出一个`call`实例只能被执行一次, 是一个\"消耗品\"\n关于`Dispatcher`我们可以看下在同步请求下他具体的执行和结束的代码\n``` java\n// 执行方法\nsynchronized void executed(RealCall call) {\n    runningSyncCalls.add(call);\n  }\n// 通知结束\nvoid finished(RealCall call) {\n    finished(runningSyncCalls, call, false);\n  }\n\n  private <T> void finished(Deque<T> calls, T call, boolean promoteCalls) {\n    int runningCallsCount;\n    Runnable idleCallback;\n    synchronized (this) {\n      // 移除call\n      if (!calls.remove(call)) throw new AssertionError(\"Call wasn't in-flight!\");\n      if (promoteCalls) promoteCalls();\n      runningCallsCount = runningCallsCount();\n      idleCallback = this.idleCallback;\n    }\n    // 判断当前异步请求和同步请求数总和是否为0, 如果为0 则调用闲置时候的回调\n    if (runningCallsCount == 0 && idleCallback != null) {\n      idleCallback.run();\n    }\n  }\n```\n可以看到在同步请求的时候, `dispatcher`的执行和完成通知, 实际是针对于`runningSyncCalls`对象的管理.\n``` java\nResponse getResponseWithInterceptorChain() throws IOException {\n    // Build a full stack of interceptors.\n    List<Interceptor> interceptors = new ArrayList<>();\n    // 自定义拦截器\n    interceptors.addAll(client.interceptors());\n    // 失败重试或者重定向的拦截器\n    interceptors.add(retryAndFollowUpInterceptor);\n    // 请求和响应的转换处理拦截器\n    interceptors.add(new BridgeInterceptor(client.cookieJar()));\n    // 缓存拦截器, 从缓存中请求并将响应写入缓存\n    interceptors.add(new CacheInterceptor(client.internalCache()));\n    // 建立连接拦截器, 并继续下一个拦截器\n    interceptors.add(new ConnectInterceptor(client));\n    if (!forWebSocket) {\n      // 用户自定义的拦截器\n      interceptors.addAll(client.networkInterceptors());\n    }\n    // 最后一个拦截器, 处理网络调用服务器\n    interceptors.add(new CallServerInterceptor(forWebSocket));\n\n    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,\n        originalRequest, this, eventListener, client.connectTimeoutMillis(),\n        client.readTimeoutMillis(), client.writeTimeoutMillis());\n\n    return chain.proceed(originalRequest);\n  }\n```\n我们可以看到, 实际执行是`RealInterceptorChain.proceed`\n``` java\npublic Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,\n      RealConnection connection) throws IOException {\n    if (index >= interceptors.size()) throw new AssertionError();\n\n    calls++;\n\n    // If we already have a stream, confirm that the incoming request will use it.\n    if (this.httpCodec != null && !this.connection.supportsUrl(request.url())) {\n      throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1)\n          + \" must retain the same host and port\");\n    }\n\n    // If we already have a stream, confirm that this is the only call to chain.proceed().\n    if (this.httpCodec != null && calls > 1) {\n      throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1)\n          + \" must call proceed() exactly once\");\n    }\n\n    // 请求下一个责任链\n    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,\n        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,\n        writeTimeout);\n    // 获取当前的拦截器\n    Interceptor interceptor = interceptors.get(index);\n    // 执行, 返回响应\n    Response response = interceptor.intercept(next);\n\n    // 保证下一个拦截器会调用到chain.proceed().\n    if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {\n      throw new IllegalStateException(\"network interceptor \" + interceptor\n          + \" must call proceed() exactly once\");\n    }\n\n    // 保证拦截器返回的响应不为空\n    if (response == null) {\n      throw new NullPointerException(\"interceptor \" + interceptor + \" returned null\");\n    }\n    // 保证响应的body不为空\n    if (response.body() == null) {\n      throw new IllegalStateException(\n          \"interceptor \" + interceptor + \" returned a response with no body\");\n    }\n\n    return response;\n  }\n```\n这里可以把拦截器理解成工厂模式, 递归执行拦截器抽象的`intercept`方法, 然后将返回的`response`再传到下一个拦截器内做处理.再返回看前面的`getResponseWithInterceptorChain`方法, 可以看出真正请求执行的就在这一块, 根据责任链的设计思想, 将操作分开进行处理.\n## 异步请求\n现在我们再回头看下异步请求时, 与同步请求有什么区别.\n``` java\n@Override public void enqueue(Callback responseCallback) {\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already Executed\");\n      executed = true;\n    }\n    captureCallStackTrace();\n    eventListener.callStart(this);\n    client.dispatcher().enqueue(new AsyncCall(responseCallback));\n  }\n```\n在执行异步调用的时候, okHttp包装了一个`AsyncCall`对象通过`dispatcher`进行执行.`AsyncCall`继承`NamedRunnable`, 实现了`Runnable`接口.\n``` java\nsynchronized void enqueue(AsyncCall call) {\n  // 判断当前异步请求数是否小于最大请求数 以及 同主机的请求数是否小于每个主机的最大请求数\n    if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {\n      runningAsyncCalls.add(call);\n      executorService().execute(call);\n    } else {\n      readyAsyncCalls.add(call);\n    }\n  }\n```\n可以看到异步请求, 在`dispatcher`内部会维护两个集合以及一个线程池: `runningAsyncCalls`表示当前执行的异步请求队列, `readyAsyncCalls`表示等待执行的异步请求队列.执行内容我们可以看`AsyncCall.execute`, 他在判断请求是否取消后, 会调用`getResponseWithInterceptorChain`方法, 后面的请求走到的步骤就与同步相同了.然后通过`dispatcher`关闭管理.\n``` java\n@Override protected void execute() {\n      boolean signalledCallback = false;\n      try {\n        // 责任链执行\n        Response response = getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n          signalledCallback = true;\n          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback = true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n          eventListener.callFailed(RealCall.this, e);\n          responseCallback.onFailure(RealCall.this, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }\n  }\n```\n\n``` java\nprivate void promoteCalls() {\n    if (runningAsyncCalls.size() >= maxRequests) return; // Already running max capacity.\n    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.\n\n    for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {\n      AsyncCall call = i.next();\n\n      if (runningCallsForHost(call) < maxRequestsPerHost) {\n        i.remove();\n        runningAsyncCalls.add(call);\n        executorService().execute(call);\n      }\n\n      if (runningAsyncCalls.size() >= maxRequests) return; // Reached max capacity.\n    }\n  }\n```\n这里唯一的区别是, 异步请求调到`Dispatcher.finished`的时候, 会调到`promoteCalls`方法, 他用来判断调度当前异步请求数是否超过最大请求, 如果没有, 则会从异步请求等待队列中获取出来再进行请求执行.由此, `Dispatch`才做到了内部针对于异步请求的线程管理, 实现了对应策略下同时请求的最大化.\n## 总结\n本篇主要了解同步请求和异步请求的主干流程, 可以看出异步请求和同步请求的区别, 就在于, 异步请求真正执行是通过`Dispatcher`进行管理与执行, 虽然同步请求也用到了`Dispatcher`, 但它主要是用来做同步请求队列的管理.两类请求真正的请求网络的处理, 都是通过调用`getResponseWithInterceptorChain`方法进行处理.\n","slug":"okHttp源码解析(一)","published":1,"updated":"2018-08-20T08:09:10.679Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjld5ah33001pcqs6giprir9u","content":"<blockquote>\n<p>源码基于3.11.0版本</p>\n</blockquote>\n<p>okHttp的请求分为两种, 同步和异步的.<br>本篇主要了解下两种请求的请求流程, 差异.<br><a id=\"more\"></a></p>\n<h2 id=\"同步请求\"><a href=\"#同步请求\" class=\"headerlink\" title=\"同步请求\"></a>同步请求</h2><p>我们先看下同步请求api的使用<br><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> okHttpClient <span class=\"keyword\">by</span> lazy &#123; OkHttpClient() &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">synchronousRun</span><span class=\"params\">(url: <span class=\"type\">String</span>)</span></span>: String?&#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> request = Request.Builder()</span><br><span class=\"line\">                .url(url)</span><br><span class=\"line\">                .build()</span><br><span class=\"line\">        <span class=\"keyword\">val</span> response = okHttpClient.newCall(request).execute()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> response?.body()?.string()</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Request\"><a href=\"#Request\" class=\"headerlink\" title=\"Request\"></a>Request</h3><p><code>Request</code>的代码就不看了, 可以看出是使用建造者模式, 根据具体配置去build.要注意的是, 这里传入的url, 如果是websocket协议的url, 会替换成http, 最后url会包装成一个<code>HttpUrl</code>对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">url</span><span class=\"params\">(String url)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (url == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"url == null\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Silently replace web socket URLs with HTTP URLs.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (url.regionMatches(<span class=\"keyword\">true</span>, <span class=\"number\">0</span>, <span class=\"string\">\"ws:\"</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>)) &#123;</span><br><span class=\"line\">        url = <span class=\"string\">\"http:\"</span> + url.substring(<span class=\"number\">3</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (url.regionMatches(<span class=\"keyword\">true</span>, <span class=\"number\">0</span>, <span class=\"string\">\"wss:\"</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>)) &#123;</span><br><span class=\"line\">        url = <span class=\"string\">\"https:\"</span> + url.substring(<span class=\"number\">4</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> url(HttpUrl.get(url));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>另外关于<code>GET</code>的请求, 在<code>Request</code>构造器初始的时候, 就会默认为<code>GET</code>请求, 所以如果是<code>POST</code>请求的时候, 需要调用<code>Request.Build().post(body)</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Builder</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.method = <span class=\"string\">\"GET\"</span>;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.headers = <span class=\"keyword\">new</span> Headers.Builder();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">post</span><span class=\"params\">(RequestBody body)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> method(<span class=\"string\">\"POST\"</span>, body);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./requestbuilder.png\" alt=\"img\"></p>\n<p>我们可以看下Request可配置项, 分别包含一个Url, 一个请求的方法, header列表, 请求体和tags(关于tags我们后续再讲)</p>\n<h3 id=\"Call\"><a href=\"#Call\" class=\"headerlink\" title=\"Call\"></a>Call</h3><p>请求需要准备一个<code>Call</code>对象, 他表示在未来的时间点内可以随时执行准备好的请求. 我们可以看到实际执行的时候, 其实使用的是<code>RealCall</code>对象, 具体看下请求执行的过程<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Call <span class=\"title\">newCall</span><span class=\"params\">(Request request)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> RealCall.newRealCall(<span class=\"keyword\">this</span>, request, <span class=\"keyword\">false</span> <span class=\"comment\">/* for web socket */</span>);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"execute\"><a href=\"#execute\" class=\"headerlink\" title=\"execute\"></a>execute</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">execute</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (executed) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Already Executed\"</span>);</span><br><span class=\"line\">      executed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个跟踪当前执行方法的堆栈, 赋值在失败重试的拦截器中</span></span><br><span class=\"line\">    captureCallStackTrace();</span><br><span class=\"line\">    <span class=\"comment\">// 监听</span></span><br><span class=\"line\">    eventListener.callStart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 通过dispatcher做管理, 将call加入同步请求队列中</span></span><br><span class=\"line\">      client.dispatcher().executed(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 获取返回的结果, 并执行一系列拦截器处理</span></span><br><span class=\"line\">      Response result = getResponseWithInterceptorChain();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">      eventListener.callFailed(<span class=\"keyword\">this</span>, e);</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 通过dispatcher通知结束</span></span><br><span class=\"line\">      client.dispatcher().finished(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p><code>executed</code>表示对应的<code>call</code>是否已经执行, 这里同步锁可以避免了竞态条件的出现, 可以看出一个<code>call</code>实例只能被执行一次, 是一个”消耗品”<br>关于<code>Dispatcher</code>我们可以看下在同步请求下他具体的执行和结束的代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 执行方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">executed</span><span class=\"params\">(RealCall call)</span> </span>&#123;</span><br><span class=\"line\">    runningSyncCalls.add(call);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"comment\">// 通知结束</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">finished</span><span class=\"params\">(RealCall call)</span> </span>&#123;</span><br><span class=\"line\">    finished(runningSyncCalls, call, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">finished</span><span class=\"params\">(Deque&lt;T&gt; calls, T call, <span class=\"keyword\">boolean</span> promoteCalls)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> runningCallsCount;</span><br><span class=\"line\">    Runnable idleCallback;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 移除call</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!calls.remove(call)) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(<span class=\"string\">\"Call wasn't in-flight!\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (promoteCalls) promoteCalls();</span><br><span class=\"line\">      runningCallsCount = runningCallsCount();</span><br><span class=\"line\">      idleCallback = <span class=\"keyword\">this</span>.idleCallback;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 判断当前异步请求和同步请求数总和是否为0, 如果为0 则调用闲置时候的回调</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (runningCallsCount == <span class=\"number\">0</span> &amp;&amp; idleCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      idleCallback.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到在同步请求的时候, <code>dispatcher</code>的执行和完成通知, 实际是针对于<code>runningSyncCalls</code>对象的管理.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Response <span class=\"title\">getResponseWithInterceptorChain</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Build a full stack of interceptors.</span></span><br><span class=\"line\">    List&lt;Interceptor&gt; interceptors = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 自定义拦截器</span></span><br><span class=\"line\">    interceptors.addAll(client.interceptors());</span><br><span class=\"line\">    <span class=\"comment\">// 失败重试或者重定向的拦截器</span></span><br><span class=\"line\">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class=\"line\">    <span class=\"comment\">// 请求和响应的转换处理拦截器</span></span><br><span class=\"line\">    interceptors.add(<span class=\"keyword\">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class=\"line\">    <span class=\"comment\">// 缓存拦截器, 从缓存中请求并将响应写入缓存</span></span><br><span class=\"line\">    interceptors.add(<span class=\"keyword\">new</span> CacheInterceptor(client.internalCache()));</span><br><span class=\"line\">    <span class=\"comment\">// 建立连接拦截器, 并继续下一个拦截器</span></span><br><span class=\"line\">    interceptors.add(<span class=\"keyword\">new</span> ConnectInterceptor(client));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!forWebSocket) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 用户自定义的拦截器</span></span><br><span class=\"line\">      interceptors.addAll(client.networkInterceptors());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 最后一个拦截器, 处理网络调用服务器</span></span><br><span class=\"line\">    interceptors.add(<span class=\"keyword\">new</span> CallServerInterceptor(forWebSocket));</span><br><span class=\"line\"></span><br><span class=\"line\">    Interceptor.Chain chain = <span class=\"keyword\">new</span> RealInterceptorChain(interceptors, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        originalRequest, <span class=\"keyword\">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class=\"line\">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> chain.proceed(originalRequest);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以看到, 实际执行是<code>RealInterceptorChain.proceed</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">proceed</span><span class=\"params\">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      RealConnection connection)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= interceptors.size()) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError();</span><br><span class=\"line\"></span><br><span class=\"line\">    calls++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we already have a stream, confirm that the incoming request will use it.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.httpCodec != <span class=\"keyword\">null</span> &amp;&amp; !<span class=\"keyword\">this</span>.connection.supportsUrl(request.url())) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"network interceptor \"</span> + interceptors.get(index - <span class=\"number\">1</span>)</span><br><span class=\"line\">          + <span class=\"string\">\" must retain the same host and port\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.httpCodec != <span class=\"keyword\">null</span> &amp;&amp; calls &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"network interceptor \"</span> + interceptors.get(index - <span class=\"number\">1</span>)</span><br><span class=\"line\">          + <span class=\"string\">\" must call proceed() exactly once\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 请求下一个责任链</span></span><br><span class=\"line\">    RealInterceptorChain next = <span class=\"keyword\">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class=\"line\">        connection, index + <span class=\"number\">1</span>, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class=\"line\">        writeTimeout);</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前的拦截器</span></span><br><span class=\"line\">    Interceptor interceptor = interceptors.get(index);</span><br><span class=\"line\">    <span class=\"comment\">// 执行, 返回响应</span></span><br><span class=\"line\">    Response response = interceptor.intercept(next);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 保证下一个拦截器会调用到chain.proceed().</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (httpCodec != <span class=\"keyword\">null</span> &amp;&amp; index + <span class=\"number\">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"network interceptor \"</span> + interceptor</span><br><span class=\"line\">          + <span class=\"string\">\" must call proceed() exactly once\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 保证拦截器返回的响应不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (response == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"interceptor \"</span> + interceptor + <span class=\"string\">\" returned null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 保证响应的body不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (response.body() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">          <span class=\"string\">\"interceptor \"</span> + interceptor + <span class=\"string\">\" returned a response with no body\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里可以把拦截器理解成工厂模式, 递归执行拦截器抽象的<code>intercept</code>方法, 然后将返回的<code>response</code>再传到下一个拦截器内做处理.再返回看前面的<code>getResponseWithInterceptorChain</code>方法, 可以看出真正请求执行的就在这一块, 根据责任链的设计思想, 将操作分开进行处理.</p>\n<h2 id=\"异步请求\"><a href=\"#异步请求\" class=\"headerlink\" title=\"异步请求\"></a>异步请求</h2><p>现在我们再回头看下异步请求时, 与同步请求有什么区别.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(Callback responseCallback)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (executed) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Already Executed\"</span>);</span><br><span class=\"line\">      executed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    captureCallStackTrace();</span><br><span class=\"line\">    eventListener.callStart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    client.dispatcher().enqueue(<span class=\"keyword\">new</span> AsyncCall(responseCallback));</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>在执行异步调用的时候, okHttp包装了一个<code>AsyncCall</code>对象通过<code>dispatcher</code>进行执行.<code>AsyncCall</code>继承<code>NamedRunnable</code>, 实现了<code>Runnable</code>接口.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(AsyncCall call)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 判断当前异步请求数是否小于最大请求数 以及 同主机的请求数是否小于每个主机的最大请求数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class=\"line\">      runningAsyncCalls.add(call);</span><br><span class=\"line\">      executorService().execute(call);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      readyAsyncCalls.add(call);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到异步请求, 在<code>dispatcher</code>内部会维护两个集合以及一个线程池: <code>runningAsyncCalls</code>表示当前执行的异步请求队列, <code>readyAsyncCalls</code>表示等待执行的异步请求队列.执行内容我们可以看<code>AsyncCall.execute</code>, 他在判断请求是否取消后, 会调用<code>getResponseWithInterceptorChain</code>方法, 后面的请求走到的步骤就与同步相同了.然后通过<code>dispatcher</code>关闭管理.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> signalledCallback = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 责任链执行</span></span><br><span class=\"line\">        Response response = getResponseWithInterceptorChain();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class=\"line\">          signalledCallback = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">          responseCallback.onFailure(RealCall.<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          signalledCallback = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">          responseCallback.onResponse(RealCall.<span class=\"keyword\">this</span>, response);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (signalledCallback) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// Do not signal the callback twice!</span></span><br><span class=\"line\">          Platform.get().log(INFO, <span class=\"string\">\"Callback failure for \"</span> + toLoggableString(), e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          eventListener.callFailed(RealCall.<span class=\"keyword\">this</span>, e);</span><br><span class=\"line\">          responseCallback.onFailure(RealCall.<span class=\"keyword\">this</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        client.dispatcher().finished(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">promoteCalls</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class=\"keyword\">return</span>; <span class=\"comment\">// Already running max capacity.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (readyAsyncCalls.isEmpty()) <span class=\"keyword\">return</span>; <span class=\"comment\">// No ready calls to promote.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class=\"line\">      AsyncCall call = i.next();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class=\"line\">        i.remove();</span><br><span class=\"line\">        runningAsyncCalls.add(call);</span><br><span class=\"line\">        executorService().execute(call);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class=\"keyword\">return</span>; <span class=\"comment\">// Reached max capacity.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>这里唯一的区别是, 异步请求调到<code>Dispatcher.finished</code>的时候, 会调到<code>promoteCalls</code>方法, 他用来判断调度当前异步请求数是否超过最大请求, 如果没有, 则会从异步请求等待队列中获取出来再进行请求执行.由此, <code>Dispatch</code>才做到了内部针对于异步请求的线程管理, 实现了对应策略下同时请求的最大化.</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本篇主要了解同步请求和异步请求的主干流程, 可以看出异步请求和同步请求的区别, 就在于, 异步请求真正执行是通过<code>Dispatcher</code>进行管理与执行, 虽然同步请求也用到了<code>Dispatcher</code>, 但它主要是用来做同步请求队列的管理.两类请求真正的请求网络的处理, 都是通过调用<code>getResponseWithInterceptorChain</code>方法进行处理.</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>源码基于3.11.0版本</p>\n</blockquote>\n<p>okHttp的请求分为两种, 同步和异步的.<br>本篇主要了解下两种请求的请求流程, 差异.<br>","more":"</p>\n<h2 id=\"同步请求\"><a href=\"#同步请求\" class=\"headerlink\" title=\"同步请求\"></a>同步请求</h2><p>我们先看下同步请求api的使用<br><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> okHttpClient <span class=\"keyword\">by</span> lazy &#123; OkHttpClient() &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">synchronousRun</span><span class=\"params\">(url: <span class=\"type\">String</span>)</span></span>: String?&#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> request = Request.Builder()</span><br><span class=\"line\">                .url(url)</span><br><span class=\"line\">                .build()</span><br><span class=\"line\">        <span class=\"keyword\">val</span> response = okHttpClient.newCall(request).execute()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> response?.body()?.string()</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Request\"><a href=\"#Request\" class=\"headerlink\" title=\"Request\"></a>Request</h3><p><code>Request</code>的代码就不看了, 可以看出是使用建造者模式, 根据具体配置去build.要注意的是, 这里传入的url, 如果是websocket协议的url, 会替换成http, 最后url会包装成一个<code>HttpUrl</code>对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">url</span><span class=\"params\">(String url)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (url == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"url == null\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Silently replace web socket URLs with HTTP URLs.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (url.regionMatches(<span class=\"keyword\">true</span>, <span class=\"number\">0</span>, <span class=\"string\">\"ws:\"</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>)) &#123;</span><br><span class=\"line\">        url = <span class=\"string\">\"http:\"</span> + url.substring(<span class=\"number\">3</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (url.regionMatches(<span class=\"keyword\">true</span>, <span class=\"number\">0</span>, <span class=\"string\">\"wss:\"</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>)) &#123;</span><br><span class=\"line\">        url = <span class=\"string\">\"https:\"</span> + url.substring(<span class=\"number\">4</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> url(HttpUrl.get(url));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>另外关于<code>GET</code>的请求, 在<code>Request</code>构造器初始的时候, 就会默认为<code>GET</code>请求, 所以如果是<code>POST</code>请求的时候, 需要调用<code>Request.Build().post(body)</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Builder</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.method = <span class=\"string\">\"GET\"</span>;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.headers = <span class=\"keyword\">new</span> Headers.Builder();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">post</span><span class=\"params\">(RequestBody body)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> method(<span class=\"string\">\"POST\"</span>, body);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./requestbuilder.png\" alt=\"img\"></p>\n<p>我们可以看下Request可配置项, 分别包含一个Url, 一个请求的方法, header列表, 请求体和tags(关于tags我们后续再讲)</p>\n<h3 id=\"Call\"><a href=\"#Call\" class=\"headerlink\" title=\"Call\"></a>Call</h3><p>请求需要准备一个<code>Call</code>对象, 他表示在未来的时间点内可以随时执行准备好的请求. 我们可以看到实际执行的时候, 其实使用的是<code>RealCall</code>对象, 具体看下请求执行的过程<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Call <span class=\"title\">newCall</span><span class=\"params\">(Request request)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> RealCall.newRealCall(<span class=\"keyword\">this</span>, request, <span class=\"keyword\">false</span> <span class=\"comment\">/* for web socket */</span>);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"execute\"><a href=\"#execute\" class=\"headerlink\" title=\"execute\"></a>execute</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">execute</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (executed) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Already Executed\"</span>);</span><br><span class=\"line\">      executed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个跟踪当前执行方法的堆栈, 赋值在失败重试的拦截器中</span></span><br><span class=\"line\">    captureCallStackTrace();</span><br><span class=\"line\">    <span class=\"comment\">// 监听</span></span><br><span class=\"line\">    eventListener.callStart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 通过dispatcher做管理, 将call加入同步请求队列中</span></span><br><span class=\"line\">      client.dispatcher().executed(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 获取返回的结果, 并执行一系列拦截器处理</span></span><br><span class=\"line\">      Response result = getResponseWithInterceptorChain();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">      eventListener.callFailed(<span class=\"keyword\">this</span>, e);</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 通过dispatcher通知结束</span></span><br><span class=\"line\">      client.dispatcher().finished(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p><code>executed</code>表示对应的<code>call</code>是否已经执行, 这里同步锁可以避免了竞态条件的出现, 可以看出一个<code>call</code>实例只能被执行一次, 是一个”消耗品”<br>关于<code>Dispatcher</code>我们可以看下在同步请求下他具体的执行和结束的代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 执行方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">executed</span><span class=\"params\">(RealCall call)</span> </span>&#123;</span><br><span class=\"line\">    runningSyncCalls.add(call);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"comment\">// 通知结束</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">finished</span><span class=\"params\">(RealCall call)</span> </span>&#123;</span><br><span class=\"line\">    finished(runningSyncCalls, call, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">finished</span><span class=\"params\">(Deque&lt;T&gt; calls, T call, <span class=\"keyword\">boolean</span> promoteCalls)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> runningCallsCount;</span><br><span class=\"line\">    Runnable idleCallback;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 移除call</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!calls.remove(call)) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(<span class=\"string\">\"Call wasn't in-flight!\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (promoteCalls) promoteCalls();</span><br><span class=\"line\">      runningCallsCount = runningCallsCount();</span><br><span class=\"line\">      idleCallback = <span class=\"keyword\">this</span>.idleCallback;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 判断当前异步请求和同步请求数总和是否为0, 如果为0 则调用闲置时候的回调</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (runningCallsCount == <span class=\"number\">0</span> &amp;&amp; idleCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      idleCallback.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到在同步请求的时候, <code>dispatcher</code>的执行和完成通知, 实际是针对于<code>runningSyncCalls</code>对象的管理.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Response <span class=\"title\">getResponseWithInterceptorChain</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Build a full stack of interceptors.</span></span><br><span class=\"line\">    List&lt;Interceptor&gt; interceptors = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 自定义拦截器</span></span><br><span class=\"line\">    interceptors.addAll(client.interceptors());</span><br><span class=\"line\">    <span class=\"comment\">// 失败重试或者重定向的拦截器</span></span><br><span class=\"line\">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class=\"line\">    <span class=\"comment\">// 请求和响应的转换处理拦截器</span></span><br><span class=\"line\">    interceptors.add(<span class=\"keyword\">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class=\"line\">    <span class=\"comment\">// 缓存拦截器, 从缓存中请求并将响应写入缓存</span></span><br><span class=\"line\">    interceptors.add(<span class=\"keyword\">new</span> CacheInterceptor(client.internalCache()));</span><br><span class=\"line\">    <span class=\"comment\">// 建立连接拦截器, 并继续下一个拦截器</span></span><br><span class=\"line\">    interceptors.add(<span class=\"keyword\">new</span> ConnectInterceptor(client));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!forWebSocket) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 用户自定义的拦截器</span></span><br><span class=\"line\">      interceptors.addAll(client.networkInterceptors());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 最后一个拦截器, 处理网络调用服务器</span></span><br><span class=\"line\">    interceptors.add(<span class=\"keyword\">new</span> CallServerInterceptor(forWebSocket));</span><br><span class=\"line\"></span><br><span class=\"line\">    Interceptor.Chain chain = <span class=\"keyword\">new</span> RealInterceptorChain(interceptors, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        originalRequest, <span class=\"keyword\">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class=\"line\">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> chain.proceed(originalRequest);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以看到, 实际执行是<code>RealInterceptorChain.proceed</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">proceed</span><span class=\"params\">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      RealConnection connection)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= interceptors.size()) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError();</span><br><span class=\"line\"></span><br><span class=\"line\">    calls++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we already have a stream, confirm that the incoming request will use it.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.httpCodec != <span class=\"keyword\">null</span> &amp;&amp; !<span class=\"keyword\">this</span>.connection.supportsUrl(request.url())) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"network interceptor \"</span> + interceptors.get(index - <span class=\"number\">1</span>)</span><br><span class=\"line\">          + <span class=\"string\">\" must retain the same host and port\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.httpCodec != <span class=\"keyword\">null</span> &amp;&amp; calls &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"network interceptor \"</span> + interceptors.get(index - <span class=\"number\">1</span>)</span><br><span class=\"line\">          + <span class=\"string\">\" must call proceed() exactly once\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 请求下一个责任链</span></span><br><span class=\"line\">    RealInterceptorChain next = <span class=\"keyword\">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class=\"line\">        connection, index + <span class=\"number\">1</span>, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class=\"line\">        writeTimeout);</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前的拦截器</span></span><br><span class=\"line\">    Interceptor interceptor = interceptors.get(index);</span><br><span class=\"line\">    <span class=\"comment\">// 执行, 返回响应</span></span><br><span class=\"line\">    Response response = interceptor.intercept(next);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 保证下一个拦截器会调用到chain.proceed().</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (httpCodec != <span class=\"keyword\">null</span> &amp;&amp; index + <span class=\"number\">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"network interceptor \"</span> + interceptor</span><br><span class=\"line\">          + <span class=\"string\">\" must call proceed() exactly once\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 保证拦截器返回的响应不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (response == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"interceptor \"</span> + interceptor + <span class=\"string\">\" returned null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 保证响应的body不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (response.body() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">          <span class=\"string\">\"interceptor \"</span> + interceptor + <span class=\"string\">\" returned a response with no body\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里可以把拦截器理解成工厂模式, 递归执行拦截器抽象的<code>intercept</code>方法, 然后将返回的<code>response</code>再传到下一个拦截器内做处理.再返回看前面的<code>getResponseWithInterceptorChain</code>方法, 可以看出真正请求执行的就在这一块, 根据责任链的设计思想, 将操作分开进行处理.</p>\n<h2 id=\"异步请求\"><a href=\"#异步请求\" class=\"headerlink\" title=\"异步请求\"></a>异步请求</h2><p>现在我们再回头看下异步请求时, 与同步请求有什么区别.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(Callback responseCallback)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (executed) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Already Executed\"</span>);</span><br><span class=\"line\">      executed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    captureCallStackTrace();</span><br><span class=\"line\">    eventListener.callStart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    client.dispatcher().enqueue(<span class=\"keyword\">new</span> AsyncCall(responseCallback));</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>在执行异步调用的时候, okHttp包装了一个<code>AsyncCall</code>对象通过<code>dispatcher</code>进行执行.<code>AsyncCall</code>继承<code>NamedRunnable</code>, 实现了<code>Runnable</code>接口.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(AsyncCall call)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 判断当前异步请求数是否小于最大请求数 以及 同主机的请求数是否小于每个主机的最大请求数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class=\"line\">      runningAsyncCalls.add(call);</span><br><span class=\"line\">      executorService().execute(call);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      readyAsyncCalls.add(call);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到异步请求, 在<code>dispatcher</code>内部会维护两个集合以及一个线程池: <code>runningAsyncCalls</code>表示当前执行的异步请求队列, <code>readyAsyncCalls</code>表示等待执行的异步请求队列.执行内容我们可以看<code>AsyncCall.execute</code>, 他在判断请求是否取消后, 会调用<code>getResponseWithInterceptorChain</code>方法, 后面的请求走到的步骤就与同步相同了.然后通过<code>dispatcher</code>关闭管理.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> signalledCallback = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 责任链执行</span></span><br><span class=\"line\">        Response response = getResponseWithInterceptorChain();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class=\"line\">          signalledCallback = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">          responseCallback.onFailure(RealCall.<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          signalledCallback = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">          responseCallback.onResponse(RealCall.<span class=\"keyword\">this</span>, response);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (signalledCallback) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// Do not signal the callback twice!</span></span><br><span class=\"line\">          Platform.get().log(INFO, <span class=\"string\">\"Callback failure for \"</span> + toLoggableString(), e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          eventListener.callFailed(RealCall.<span class=\"keyword\">this</span>, e);</span><br><span class=\"line\">          responseCallback.onFailure(RealCall.<span class=\"keyword\">this</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        client.dispatcher().finished(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">promoteCalls</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class=\"keyword\">return</span>; <span class=\"comment\">// Already running max capacity.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (readyAsyncCalls.isEmpty()) <span class=\"keyword\">return</span>; <span class=\"comment\">// No ready calls to promote.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class=\"line\">      AsyncCall call = i.next();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class=\"line\">        i.remove();</span><br><span class=\"line\">        runningAsyncCalls.add(call);</span><br><span class=\"line\">        executorService().execute(call);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class=\"keyword\">return</span>; <span class=\"comment\">// Reached max capacity.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>这里唯一的区别是, 异步请求调到<code>Dispatcher.finished</code>的时候, 会调到<code>promoteCalls</code>方法, 他用来判断调度当前异步请求数是否超过最大请求, 如果没有, 则会从异步请求等待队列中获取出来再进行请求执行.由此, <code>Dispatch</code>才做到了内部针对于异步请求的线程管理, 实现了对应策略下同时请求的最大化.</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本篇主要了解同步请求和异步请求的主干流程, 可以看出异步请求和同步请求的区别, 就在于, 异步请求真正执行是通过<code>Dispatcher</code>进行管理与执行, 虽然同步请求也用到了<code>Dispatcher</code>, 但它主要是用来做同步请求队列的管理.两类请求真正的请求网络的处理, 都是通过调用<code>getResponseWithInterceptorChain</code>方法进行处理.</p>"},{"title":"AppPlugin源码解析","date":"2018-07-05T16:00:00.000Z","_content":"之前为了优化内部的Route, 去看了下`TransformAPI`, 然后就顺便看了下`AppPlugin`的源码.\n本篇源码基于android gradle 3.0.1的版本.\n<!--more-->\n### 总入口\n我们直接从入口`apply`开始看, 他调到了父类`BasePlugin`的apply方法.\n``` java\nprotected void apply(@NonNull Project project) {\n        // 一些基础path和插件版本的校验\n        // 以及一些流程记录的初始化\n        ...\n\n        // 真正执行的是configureProject方法\n        // 项目配置\n        threadRecorder.record(\n                ExecutionType.BASE_PLUGIN_PROJECT_CONFIGURE,\n                project.getPath(),\n                null,\n                this::configureProject);\n\n        threadRecorder.record(\n                ExecutionType.BASE_PLUGIN_PROJECT_BASE_EXTENSION_CREATION,\n                project.getPath(),\n                null,\n                this::configureExtension);\n\n        threadRecorder.record(\n                ExecutionType.BASE_PLUGIN_PROJECT_TASKS_CREATION,\n                project.getPath(),\n                null,\n                this::createTasks);\n    }\n\npublic interface Recorder {\n  ...\n  // record方法用来执行block, 然后将执行结果记录\n    void record(\n            @NonNull ExecutionType executionType,\n            @NonNull String projectPath,\n            @Nullable String variant,\n            @NonNull VoidBlock block);\n          }\n```\n`apply`入口的代码非常简洁, 主要执行就三个方法, `configureProject`, `configureExtension`和`createTasks`, 看方法名可以猜到, 他们的作用应该是配置Project, 配置插件的Extensions, 并且创建任务(task).\n### configureProject\n``` java\nprivate void configureProject() {\n        extraModelInfo = new ExtraModelInfo(projectOptions, project.getLogger());\n        checkGradleVersion();\n\n        sdkHandler = new SdkHandler(project, getLogger());\n\n        // sdk, dependence的下载\n        if (!project.getGradle().getStartParameter().isOffline()\n                && projectOptions.get(BooleanOption.ENABLE_SDK_DOWNLOAD)\n                && !projectOptions.get(BooleanOption.IDE_INVOKED_FROM_IDE)) {\n            SdkLibData sdkLibData = SdkLibData.download(getDownloader(), getSettingsController());\n            sdkHandler.setSdkLibData(sdkLibData);\n        }\n\n        // 构建androidBuilder\n        androidBuilder = new AndroidBuilder(\n                project == project.getRootProject() ? project.getName() : project.getPath(),\n                creator,\n                new GradleProcessExecutor(project),\n                new GradleJavaProcessExecutor(project),\n                extraModelInfo,\n                getLogger(),\n                isVerbose());\n        dataBindingBuilder = new DataBindingBuilder();\n        dataBindingBuilder.setPrintMachineReadableOutput(\n                extraModelInfo.getErrorFormatMode() ==\n                        ExtraModelInfo.ErrorFormatMode.MACHINE_PARSABLE);\n\n        // Apply the Java and Jacoco plugins.\n        // JavaBasePlugin, 用于编译java代码成class, 并组装成一个jar文件\n        project.getPlugins().apply(JavaBasePlugin.class);\n        project.getPlugins().apply(JacocoPlugin.class);\n\n        // 设置assmble task的描述\n        project.getTasks()\n                .getByName(\"assemble\")\n                .setDescription(\n                        \"Assembles all variants of all applications and secondary packages.\");\n\n        // 注册编译监听\n        // 会在每个project build结束后调用到, 而不单是当前的project\n        project.getGradle()\n                .addBuildListener(\n                        new BuildListener() {\n                            @Override\n                            public void buildStarted(Gradle gradle) {\n                                TaskInputHelper.enableBypass();\n                            }\n\n                            @Override\n                            public void settingsEvaluated(Settings settings) {}\n\n                            @Override\n                            public void projectsLoaded(Gradle gradle) {}\n\n                            @Override\n                            public void projectsEvaluated(Gradle gradle) {}\n\n                            @Override\n                            public void buildFinished(BuildResult buildResult) {\n                                // 复合构建时不会多次重复清除\n                                if (buildResult.getGradle().getParent() != null) {\n                                    return;\n                                }\n                                // 清除dex缓存\n                                ExecutorSingleton.shutdown();\n                                sdkHandler.unload();\n                                threadRecorder.record(\n                                        ExecutionType.BASE_PLUGIN_BUILD_FINISHED,\n                                        project.getPath(),\n                                        null,\n                                        () -> {\n                                            PreDexCache.getCache()\n                                                    .clear(\n                                                            FileUtils.join(\n                                                                    project.getRootProject()\n                                                                            .getBuildDir(),\n                                                                    FD_INTERMEDIATES,\n                                                                    \"dex-cache\",\n                                                                    \"cache.xml\"),\n                                                            getLogger());\n                                            Main.clearInternTables();\n                                        });\n                            }\n                        });\n\n        // 注册taskGraph构建完成时的回调\n        project.getGradle()\n                .getTaskGraph()\n                .addTaskExecutionGraphListener(\n                        taskGraph -> {\n                            TaskInputHelper.disableBypass();\n                            // 遍历所有task, 如果是dexTransform, 则读取对应的dexTransform的缓存\n                            for (Task task : taskGraph.getAllTasks()) {\n                                if (task instanceof TransformTask) {\n                                    Transform transform = ((TransformTask) task).getTransform();\n                                    if (transform instanceof DexTransform) {\n                                        PreDexCache.getCache()\n                                                .load(\n                                                        FileUtils.join(\n                                                                project.getRootProject()\n                                                                        .getBuildDir(),\n                                                                FD_INTERMEDIATES,\n                                                                \"dex-cache\",\n                                                                \"cache.xml\"));\n                                        break;\n                                    }\n                                }\n                            }\n                        });\n    }\n```\n看代码我们可以梳理`configureProject`流程如下\n1. 校验gradle版本\n2. 下载dependence\n3. 构建`androidBuilder`\n4. 如果有设置`dataBinding`, 则会构建`dataBindingBuilder`(这个不在本篇重点)\n5. 分别引用`JavaBasePlugin`和`JacocoPlugin`插件, 分别用于编译java代码成class和用于检查测试用例的覆盖率\n6. 注册taskGraph构建准备时的回调, 在准备完成时读取DexTransform的dex-cache缓存\n7. 注册编译完成时的回调, 进行dex缓存的清除工作\n### configureExtension\n\n``` java\nprivate void configureExtension() {\n        // 分别创建buildType, ProductFlavor, SigningConfig, BaseVariantOutput对应存储的集合对象, 设置默认的Extensions\n        final NamedDomainObjectContainer<BuildType> buildTypeContainer =\n                project.container(\n                        BuildType.class,\n                        new BuildTypeFactory(instantiator, project, extraModelInfo));\n        final NamedDomainObjectContainer<ProductFlavor> productFlavorContainer =\n                project.container(\n                        ProductFlavor.class,\n                        new ProductFlavorFactory(\n                                instantiator, project, project.getLogger(), extraModelInfo));\n        final NamedDomainObjectContainer<SigningConfig> signingConfigContainer =\n                project.container(SigningConfig.class, new SigningConfigFactory(instantiator));\n\n        final NamedDomainObjectContainer<BaseVariantOutput> buildOutputs =\n                project.container(BaseVariantOutput.class);\n        // 设置project的buildOutputs属性的扩展为buildOutputs\n        project.getExtensions().add(\"buildOutputs\", buildOutputs);\n        // 在appPlugin中实现, 创建android扩展属性\n        extension =\n                createExtension(\n                        project,\n                        projectOptions,\n                        instantiator,\n                        androidBuilder,\n                        sdkHandler,\n                        buildTypeContainer,\n                        productFlavorContainer,\n                        signingConfigContainer,\n                        buildOutputs,\n                        extraModelInfo);\n\n        // ndk处理器实例化\n        ndkHandler =\n                new NdkHandler(\n                        project.getRootDir(),\n                        null, /* compileSkdVersion, this will be set in afterEvaluate */\n                        \"gcc\",\n                        \"\" /*toolchainVersion*/,\n                        false /* useUnifiedHeaders */);\n\n\n        @Nullable\n        FileCache buildCache = BuildCacheUtils.createBuildCacheIfEnabled(project, projectOptions);\n\n        GlobalScope globalScope =\n                new GlobalScope(\n                        project,\n                        projectOptions,\n                        androidBuilder,\n                        extension,\n                        sdkHandler,\n                        ndkHandler,\n                        registry,\n                        buildCache);\n        // ApplicationVariantFactory\n        variantFactory = createVariantFactory(globalScope, instantiator, androidBuilder, extension);\n\n        // ApplicationTaskManager, 管理application的任务创建\n        taskManager =\n                createTaskManager(\n                        globalScope,\n                        project,\n                        projectOptions,\n                        androidBuilder,\n                        dataBindingBuilder,\n                        extension,\n                        sdkHandler,\n                        ndkHandler,\n                        registry,\n                        threadRecorder);\n\n        // 变体的创建和管理的管理器\n        variantManager =\n                new VariantManager(\n                        globalScope,\n                        project,\n                        projectOptions,\n                        androidBuilder,\n                        extension,\n                        variantFactory,\n                        taskManager,\n                        threadRecorder);\n        // 注册自定义工具模型, 和native工具模型\n        registerModels(registry, globalScope, variantManager, extension, extraModelInfo);\n\n        // map the whenObjectAdded callbacks on the containers.\n        signingConfigContainer.whenObjectAdded(variantManager::addSigningConfig);\n\n        buildTypeContainer.whenObjectAdded(\n                buildType -> {\n                    SigningConfig signingConfig =\n                            signingConfigContainer.findByName(BuilderConstants.DEBUG);\n                    buildType.init(signingConfig);\n                    variantManager.addBuildType(buildType);\n                });\n\n        productFlavorContainer.whenObjectAdded(variantManager::addProductFlavor);\n\n        // map whenObjectRemoved on the containers to throw an exception.\n        signingConfigContainer.whenObjectRemoved(\n                new UnsupportedAction(\"Removing signingConfigs is not supported.\"));\n        buildTypeContainer.whenObjectRemoved(\n                new UnsupportedAction(\"Removing build types is not supported.\"));\n        productFlavorContainer.whenObjectRemoved(\n                new UnsupportedAction(\"Removing product flavors is not supported.\"));\n\n        // create default Objects, signingConfig first as its used by the BuildTypes.\n        variantFactory.createDefaultComponents(\n                buildTypeContainer, productFlavorContainer, signingConfigContainer);\n    }\n```\n`configureExtension`主要处理了`extension`\n1. 分别创建buildType, ProductFlavor, SigningConfig, BaseVariantOutput对应存储的集合对象\n2. 创建android Extension, `createExtension`是个抽象方法, 具体实现代码可以看`AppPlugin`里, 在我们的工程配置gradle文件里, 就是我们熟悉的android闭包里的配置\n``` java\nprotected BaseExtension createExtension(\n            @NonNull Project project,\n            @NonNull ProjectOptions projectOptions,\n            @NonNull Instantiator instantiator,\n            @NonNull AndroidBuilder androidBuilder,\n            @NonNull SdkHandler sdkHandler,\n            @NonNull NamedDomainObjectContainer<BuildType> buildTypeContainer,\n            @NonNull NamedDomainObjectContainer<ProductFlavor> productFlavorContainer,\n            @NonNull NamedDomainObjectContainer<SigningConfig> signingConfigContainer,\n            @NonNull NamedDomainObjectContainer<BaseVariantOutput> buildOutputs,\n            @NonNull ExtraModelInfo extraModelInfo) {\n        return project.getExtensions()\n                .create(\n                        \"android\",\n                        AppExtension.class,\n                        project,\n                        projectOptions,\n                        instantiator,\n                        androidBuilder,\n                        sdkHandler,\n                        buildTypeContainer,\n                        productFlavorContainer,\n                        signingConfigContainer,\n                        buildOutputs,\n                        extraModelInfo);\n    }\n```\n3. 分别创建`taskManager`和`variantManager`, 看名字就可以知道他负责的分别是task和variant\n4. 针对签名配置signingConfig, buildType, productFlavor 注册新增时候的监听, 对应添加到variantManager中做管理. 同时, 他们是不支持删除的.\n5. 创建默认的variant\n\n### createTasks\n\n``` java\nprivate void createTasks() {\n        threadRecorder.record(\n                ExecutionType.TASK_MANAGER_CREATE_TASKS,\n                project.getPath(),\n                null,\n                // 在before evaluate新增部分tasks\n                () ->\n                        taskManager.createTasksBeforeEvaluate(\n                                new TaskContainerAdaptor(project.getTasks())));\n\n        project.afterEvaluate(\n                project ->\n                        threadRecorder.record(\n                                ExecutionType.BASE_PLUGIN_CREATE_ANDROID_TASKS,\n                                project.getPath(),\n                                null,\n                                () -> createAndroidTasks(false)));\n    }\n```\n在`createTask`阶段, 首先会在配置收集之前(即在apply plugin)阶段会创建一些task, 这里`TaskContainerAdaptor`可以理解为对task的又一层管理封装.\n\n在配置收集获取所有task之后, 我们会调用到`createAndroidTasks`\n在执行真正的创建tasks之前, 主要是对extension内一些配置进行校验, 譬如针对buildToolsVersion, compileSdkVersion是否指定, 是否另外引用了JavaPlugin等等, 这里的代码可以自行看源码了解\n``` java\nfinal void createAndroidTasks(boolean force) {\n        ...\n        threadRecorder.record(\n                ExecutionType.VARIANT_MANAGER_CREATE_ANDROID_TASKS,\n                project.getPath(),\n                null,\n                // 根据variant创建tasks\n                () -> {\n                    variantManager.createAndroidTasks();\n                    ApiObjectFactory apiObjectFactory =\n                            new ApiObjectFactory(\n                                    androidBuilder,\n                                    extension,\n                                    variantFactory,\n                                    instantiator,\n                                    project.getObjects());\n                    for (VariantScope variantScope : variantManager.getVariantScopes()) {\n                        BaseVariantData variantData = variantScope.getVariantData();\n                        apiObjectFactory.create(variantData);\n                    }\n                });\n        ...\n    }\n```\n这里我们可以主要看下`variantManager.createAndroidTasks()`方法内容, 这里根据variant创建对应的tasks\n可以看到具体流程如下:\n1. 校验是否引用apt插件(这在3.0里使用annotationProcessor来声明注解处理器)\n2. 填充收集所以variant\n3. 根据variant创建对应的tasks\n\n``` java\npublic void createAndroidTasks() {\n        variantFactory.validateModel(this);\n        // 校验是否引用apt插件, 如果有, 抛出异常\n        variantFactory.preVariantWork(project);\n\n        final TaskFactory tasks = new TaskContainerAdaptor(project.getTasks());\n        if (variantScopes.isEmpty()) {\n            recorder.record(\n                    ExecutionType.VARIANT_MANAGER_CREATE_VARIANTS,\n                    project.getPath(),\n                    null /*variantName*/,\n                    // 填充所有variant\n                    this::populateVariantDataList);\n        }\n\n        // Create top level test tasks.\n        recorder.record(\n                ExecutionType.VARIANT_MANAGER_CREATE_TESTS_TASKS,\n                project.getPath(),\n                null /*variantName*/,\n                // 创建测试tasks\n                () -> taskManager.createTopLevelTestTasks(tasks, !productFlavors.isEmpty()));\n\n        for (final VariantScope variantScope : variantScopes) {\n            recorder.record(\n                    ExecutionType.VARIANT_MANAGER_CREATE_TASKS_FOR_VARIANT,\n                    project.getPath(),\n                    variantScope.getFullVariantName(),\n                    // 根据variant创建不同的tasks, 创建assemble任务也在这里\n                    () -> createTasksForVariantData(tasks, variantScope));\n        }\n\n        taskManager.createReportTasks(tasks, variantScopes);\n    }\n```\n### 总结\n最后我们总结下, `appPlugin` `apply`的整体流程(当然, 因为他执行的是父类的`apply`, 所以流程适用于`libraryPlugin`)\n1. project的配置\n      1. 检验gradle版本\n      2. 下载dependence\n      3. 构建`androidBuilder`\n      4. 引用`JavaBasePlugin`和`JacocoPlugin`\n      5. 定义编译过程的回调, 负责处理dex-cache的加载和清除工作\n2. extension的配置\n      1. 创建和配置extension\n      2. 创建taskManager和variantManager\n      3. 配置签名设置, buildType, productFlavor, 供后续task以及编译时使用\n3. 创建task(任务)\n      1. 一些extension设置的检验\n      2. 编译task的创建\n","source":"_posts/AppPlugin源码解析.md","raw":"title: AppPlugin源码解析\ndate: 2018-07-06 00:00:00\ncategories:  \n- 源码解析\ntags:\n- Android\n- 源码解析\n---\n之前为了优化内部的Route, 去看了下`TransformAPI`, 然后就顺便看了下`AppPlugin`的源码.\n本篇源码基于android gradle 3.0.1的版本.\n<!--more-->\n### 总入口\n我们直接从入口`apply`开始看, 他调到了父类`BasePlugin`的apply方法.\n``` java\nprotected void apply(@NonNull Project project) {\n        // 一些基础path和插件版本的校验\n        // 以及一些流程记录的初始化\n        ...\n\n        // 真正执行的是configureProject方法\n        // 项目配置\n        threadRecorder.record(\n                ExecutionType.BASE_PLUGIN_PROJECT_CONFIGURE,\n                project.getPath(),\n                null,\n                this::configureProject);\n\n        threadRecorder.record(\n                ExecutionType.BASE_PLUGIN_PROJECT_BASE_EXTENSION_CREATION,\n                project.getPath(),\n                null,\n                this::configureExtension);\n\n        threadRecorder.record(\n                ExecutionType.BASE_PLUGIN_PROJECT_TASKS_CREATION,\n                project.getPath(),\n                null,\n                this::createTasks);\n    }\n\npublic interface Recorder {\n  ...\n  // record方法用来执行block, 然后将执行结果记录\n    void record(\n            @NonNull ExecutionType executionType,\n            @NonNull String projectPath,\n            @Nullable String variant,\n            @NonNull VoidBlock block);\n          }\n```\n`apply`入口的代码非常简洁, 主要执行就三个方法, `configureProject`, `configureExtension`和`createTasks`, 看方法名可以猜到, 他们的作用应该是配置Project, 配置插件的Extensions, 并且创建任务(task).\n### configureProject\n``` java\nprivate void configureProject() {\n        extraModelInfo = new ExtraModelInfo(projectOptions, project.getLogger());\n        checkGradleVersion();\n\n        sdkHandler = new SdkHandler(project, getLogger());\n\n        // sdk, dependence的下载\n        if (!project.getGradle().getStartParameter().isOffline()\n                && projectOptions.get(BooleanOption.ENABLE_SDK_DOWNLOAD)\n                && !projectOptions.get(BooleanOption.IDE_INVOKED_FROM_IDE)) {\n            SdkLibData sdkLibData = SdkLibData.download(getDownloader(), getSettingsController());\n            sdkHandler.setSdkLibData(sdkLibData);\n        }\n\n        // 构建androidBuilder\n        androidBuilder = new AndroidBuilder(\n                project == project.getRootProject() ? project.getName() : project.getPath(),\n                creator,\n                new GradleProcessExecutor(project),\n                new GradleJavaProcessExecutor(project),\n                extraModelInfo,\n                getLogger(),\n                isVerbose());\n        dataBindingBuilder = new DataBindingBuilder();\n        dataBindingBuilder.setPrintMachineReadableOutput(\n                extraModelInfo.getErrorFormatMode() ==\n                        ExtraModelInfo.ErrorFormatMode.MACHINE_PARSABLE);\n\n        // Apply the Java and Jacoco plugins.\n        // JavaBasePlugin, 用于编译java代码成class, 并组装成一个jar文件\n        project.getPlugins().apply(JavaBasePlugin.class);\n        project.getPlugins().apply(JacocoPlugin.class);\n\n        // 设置assmble task的描述\n        project.getTasks()\n                .getByName(\"assemble\")\n                .setDescription(\n                        \"Assembles all variants of all applications and secondary packages.\");\n\n        // 注册编译监听\n        // 会在每个project build结束后调用到, 而不单是当前的project\n        project.getGradle()\n                .addBuildListener(\n                        new BuildListener() {\n                            @Override\n                            public void buildStarted(Gradle gradle) {\n                                TaskInputHelper.enableBypass();\n                            }\n\n                            @Override\n                            public void settingsEvaluated(Settings settings) {}\n\n                            @Override\n                            public void projectsLoaded(Gradle gradle) {}\n\n                            @Override\n                            public void projectsEvaluated(Gradle gradle) {}\n\n                            @Override\n                            public void buildFinished(BuildResult buildResult) {\n                                // 复合构建时不会多次重复清除\n                                if (buildResult.getGradle().getParent() != null) {\n                                    return;\n                                }\n                                // 清除dex缓存\n                                ExecutorSingleton.shutdown();\n                                sdkHandler.unload();\n                                threadRecorder.record(\n                                        ExecutionType.BASE_PLUGIN_BUILD_FINISHED,\n                                        project.getPath(),\n                                        null,\n                                        () -> {\n                                            PreDexCache.getCache()\n                                                    .clear(\n                                                            FileUtils.join(\n                                                                    project.getRootProject()\n                                                                            .getBuildDir(),\n                                                                    FD_INTERMEDIATES,\n                                                                    \"dex-cache\",\n                                                                    \"cache.xml\"),\n                                                            getLogger());\n                                            Main.clearInternTables();\n                                        });\n                            }\n                        });\n\n        // 注册taskGraph构建完成时的回调\n        project.getGradle()\n                .getTaskGraph()\n                .addTaskExecutionGraphListener(\n                        taskGraph -> {\n                            TaskInputHelper.disableBypass();\n                            // 遍历所有task, 如果是dexTransform, 则读取对应的dexTransform的缓存\n                            for (Task task : taskGraph.getAllTasks()) {\n                                if (task instanceof TransformTask) {\n                                    Transform transform = ((TransformTask) task).getTransform();\n                                    if (transform instanceof DexTransform) {\n                                        PreDexCache.getCache()\n                                                .load(\n                                                        FileUtils.join(\n                                                                project.getRootProject()\n                                                                        .getBuildDir(),\n                                                                FD_INTERMEDIATES,\n                                                                \"dex-cache\",\n                                                                \"cache.xml\"));\n                                        break;\n                                    }\n                                }\n                            }\n                        });\n    }\n```\n看代码我们可以梳理`configureProject`流程如下\n1. 校验gradle版本\n2. 下载dependence\n3. 构建`androidBuilder`\n4. 如果有设置`dataBinding`, 则会构建`dataBindingBuilder`(这个不在本篇重点)\n5. 分别引用`JavaBasePlugin`和`JacocoPlugin`插件, 分别用于编译java代码成class和用于检查测试用例的覆盖率\n6. 注册taskGraph构建准备时的回调, 在准备完成时读取DexTransform的dex-cache缓存\n7. 注册编译完成时的回调, 进行dex缓存的清除工作\n### configureExtension\n\n``` java\nprivate void configureExtension() {\n        // 分别创建buildType, ProductFlavor, SigningConfig, BaseVariantOutput对应存储的集合对象, 设置默认的Extensions\n        final NamedDomainObjectContainer<BuildType> buildTypeContainer =\n                project.container(\n                        BuildType.class,\n                        new BuildTypeFactory(instantiator, project, extraModelInfo));\n        final NamedDomainObjectContainer<ProductFlavor> productFlavorContainer =\n                project.container(\n                        ProductFlavor.class,\n                        new ProductFlavorFactory(\n                                instantiator, project, project.getLogger(), extraModelInfo));\n        final NamedDomainObjectContainer<SigningConfig> signingConfigContainer =\n                project.container(SigningConfig.class, new SigningConfigFactory(instantiator));\n\n        final NamedDomainObjectContainer<BaseVariantOutput> buildOutputs =\n                project.container(BaseVariantOutput.class);\n        // 设置project的buildOutputs属性的扩展为buildOutputs\n        project.getExtensions().add(\"buildOutputs\", buildOutputs);\n        // 在appPlugin中实现, 创建android扩展属性\n        extension =\n                createExtension(\n                        project,\n                        projectOptions,\n                        instantiator,\n                        androidBuilder,\n                        sdkHandler,\n                        buildTypeContainer,\n                        productFlavorContainer,\n                        signingConfigContainer,\n                        buildOutputs,\n                        extraModelInfo);\n\n        // ndk处理器实例化\n        ndkHandler =\n                new NdkHandler(\n                        project.getRootDir(),\n                        null, /* compileSkdVersion, this will be set in afterEvaluate */\n                        \"gcc\",\n                        \"\" /*toolchainVersion*/,\n                        false /* useUnifiedHeaders */);\n\n\n        @Nullable\n        FileCache buildCache = BuildCacheUtils.createBuildCacheIfEnabled(project, projectOptions);\n\n        GlobalScope globalScope =\n                new GlobalScope(\n                        project,\n                        projectOptions,\n                        androidBuilder,\n                        extension,\n                        sdkHandler,\n                        ndkHandler,\n                        registry,\n                        buildCache);\n        // ApplicationVariantFactory\n        variantFactory = createVariantFactory(globalScope, instantiator, androidBuilder, extension);\n\n        // ApplicationTaskManager, 管理application的任务创建\n        taskManager =\n                createTaskManager(\n                        globalScope,\n                        project,\n                        projectOptions,\n                        androidBuilder,\n                        dataBindingBuilder,\n                        extension,\n                        sdkHandler,\n                        ndkHandler,\n                        registry,\n                        threadRecorder);\n\n        // 变体的创建和管理的管理器\n        variantManager =\n                new VariantManager(\n                        globalScope,\n                        project,\n                        projectOptions,\n                        androidBuilder,\n                        extension,\n                        variantFactory,\n                        taskManager,\n                        threadRecorder);\n        // 注册自定义工具模型, 和native工具模型\n        registerModels(registry, globalScope, variantManager, extension, extraModelInfo);\n\n        // map the whenObjectAdded callbacks on the containers.\n        signingConfigContainer.whenObjectAdded(variantManager::addSigningConfig);\n\n        buildTypeContainer.whenObjectAdded(\n                buildType -> {\n                    SigningConfig signingConfig =\n                            signingConfigContainer.findByName(BuilderConstants.DEBUG);\n                    buildType.init(signingConfig);\n                    variantManager.addBuildType(buildType);\n                });\n\n        productFlavorContainer.whenObjectAdded(variantManager::addProductFlavor);\n\n        // map whenObjectRemoved on the containers to throw an exception.\n        signingConfigContainer.whenObjectRemoved(\n                new UnsupportedAction(\"Removing signingConfigs is not supported.\"));\n        buildTypeContainer.whenObjectRemoved(\n                new UnsupportedAction(\"Removing build types is not supported.\"));\n        productFlavorContainer.whenObjectRemoved(\n                new UnsupportedAction(\"Removing product flavors is not supported.\"));\n\n        // create default Objects, signingConfig first as its used by the BuildTypes.\n        variantFactory.createDefaultComponents(\n                buildTypeContainer, productFlavorContainer, signingConfigContainer);\n    }\n```\n`configureExtension`主要处理了`extension`\n1. 分别创建buildType, ProductFlavor, SigningConfig, BaseVariantOutput对应存储的集合对象\n2. 创建android Extension, `createExtension`是个抽象方法, 具体实现代码可以看`AppPlugin`里, 在我们的工程配置gradle文件里, 就是我们熟悉的android闭包里的配置\n``` java\nprotected BaseExtension createExtension(\n            @NonNull Project project,\n            @NonNull ProjectOptions projectOptions,\n            @NonNull Instantiator instantiator,\n            @NonNull AndroidBuilder androidBuilder,\n            @NonNull SdkHandler sdkHandler,\n            @NonNull NamedDomainObjectContainer<BuildType> buildTypeContainer,\n            @NonNull NamedDomainObjectContainer<ProductFlavor> productFlavorContainer,\n            @NonNull NamedDomainObjectContainer<SigningConfig> signingConfigContainer,\n            @NonNull NamedDomainObjectContainer<BaseVariantOutput> buildOutputs,\n            @NonNull ExtraModelInfo extraModelInfo) {\n        return project.getExtensions()\n                .create(\n                        \"android\",\n                        AppExtension.class,\n                        project,\n                        projectOptions,\n                        instantiator,\n                        androidBuilder,\n                        sdkHandler,\n                        buildTypeContainer,\n                        productFlavorContainer,\n                        signingConfigContainer,\n                        buildOutputs,\n                        extraModelInfo);\n    }\n```\n3. 分别创建`taskManager`和`variantManager`, 看名字就可以知道他负责的分别是task和variant\n4. 针对签名配置signingConfig, buildType, productFlavor 注册新增时候的监听, 对应添加到variantManager中做管理. 同时, 他们是不支持删除的.\n5. 创建默认的variant\n\n### createTasks\n\n``` java\nprivate void createTasks() {\n        threadRecorder.record(\n                ExecutionType.TASK_MANAGER_CREATE_TASKS,\n                project.getPath(),\n                null,\n                // 在before evaluate新增部分tasks\n                () ->\n                        taskManager.createTasksBeforeEvaluate(\n                                new TaskContainerAdaptor(project.getTasks())));\n\n        project.afterEvaluate(\n                project ->\n                        threadRecorder.record(\n                                ExecutionType.BASE_PLUGIN_CREATE_ANDROID_TASKS,\n                                project.getPath(),\n                                null,\n                                () -> createAndroidTasks(false)));\n    }\n```\n在`createTask`阶段, 首先会在配置收集之前(即在apply plugin)阶段会创建一些task, 这里`TaskContainerAdaptor`可以理解为对task的又一层管理封装.\n\n在配置收集获取所有task之后, 我们会调用到`createAndroidTasks`\n在执行真正的创建tasks之前, 主要是对extension内一些配置进行校验, 譬如针对buildToolsVersion, compileSdkVersion是否指定, 是否另外引用了JavaPlugin等等, 这里的代码可以自行看源码了解\n``` java\nfinal void createAndroidTasks(boolean force) {\n        ...\n        threadRecorder.record(\n                ExecutionType.VARIANT_MANAGER_CREATE_ANDROID_TASKS,\n                project.getPath(),\n                null,\n                // 根据variant创建tasks\n                () -> {\n                    variantManager.createAndroidTasks();\n                    ApiObjectFactory apiObjectFactory =\n                            new ApiObjectFactory(\n                                    androidBuilder,\n                                    extension,\n                                    variantFactory,\n                                    instantiator,\n                                    project.getObjects());\n                    for (VariantScope variantScope : variantManager.getVariantScopes()) {\n                        BaseVariantData variantData = variantScope.getVariantData();\n                        apiObjectFactory.create(variantData);\n                    }\n                });\n        ...\n    }\n```\n这里我们可以主要看下`variantManager.createAndroidTasks()`方法内容, 这里根据variant创建对应的tasks\n可以看到具体流程如下:\n1. 校验是否引用apt插件(这在3.0里使用annotationProcessor来声明注解处理器)\n2. 填充收集所以variant\n3. 根据variant创建对应的tasks\n\n``` java\npublic void createAndroidTasks() {\n        variantFactory.validateModel(this);\n        // 校验是否引用apt插件, 如果有, 抛出异常\n        variantFactory.preVariantWork(project);\n\n        final TaskFactory tasks = new TaskContainerAdaptor(project.getTasks());\n        if (variantScopes.isEmpty()) {\n            recorder.record(\n                    ExecutionType.VARIANT_MANAGER_CREATE_VARIANTS,\n                    project.getPath(),\n                    null /*variantName*/,\n                    // 填充所有variant\n                    this::populateVariantDataList);\n        }\n\n        // Create top level test tasks.\n        recorder.record(\n                ExecutionType.VARIANT_MANAGER_CREATE_TESTS_TASKS,\n                project.getPath(),\n                null /*variantName*/,\n                // 创建测试tasks\n                () -> taskManager.createTopLevelTestTasks(tasks, !productFlavors.isEmpty()));\n\n        for (final VariantScope variantScope : variantScopes) {\n            recorder.record(\n                    ExecutionType.VARIANT_MANAGER_CREATE_TASKS_FOR_VARIANT,\n                    project.getPath(),\n                    variantScope.getFullVariantName(),\n                    // 根据variant创建不同的tasks, 创建assemble任务也在这里\n                    () -> createTasksForVariantData(tasks, variantScope));\n        }\n\n        taskManager.createReportTasks(tasks, variantScopes);\n    }\n```\n### 总结\n最后我们总结下, `appPlugin` `apply`的整体流程(当然, 因为他执行的是父类的`apply`, 所以流程适用于`libraryPlugin`)\n1. project的配置\n      1. 检验gradle版本\n      2. 下载dependence\n      3. 构建`androidBuilder`\n      4. 引用`JavaBasePlugin`和`JacocoPlugin`\n      5. 定义编译过程的回调, 负责处理dex-cache的加载和清除工作\n2. extension的配置\n      1. 创建和配置extension\n      2. 创建taskManager和variantManager\n      3. 配置签名设置, buildType, productFlavor, 供后续task以及编译时使用\n3. 创建task(任务)\n      1. 一些extension设置的检验\n      2. 编译task的创建\n","slug":"AppPlugin源码解析","published":1,"updated":"2018-07-09T01:36:56.709Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjld5ah47002bcqs6it11wyo1","content":"<p>之前为了优化内部的Route, 去看了下<code>TransformAPI</code>, 然后就顺便看了下<code>AppPlugin</code>的源码.<br>本篇源码基于android gradle 3.0.1的版本.<br><a id=\"more\"></a></p>\n<h3 id=\"总入口\"><a href=\"#总入口\" class=\"headerlink\" title=\"总入口\"></a>总入口</h3><p>我们直接从入口<code>apply</code>开始看, 他调到了父类<code>BasePlugin</code>的apply方法.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">apply</span><span class=\"params\">(@NonNull Project project)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 一些基础path和插件版本的校验</span></span><br><span class=\"line\">        <span class=\"comment\">// 以及一些流程记录的初始化</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 真正执行的是configureProject方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 项目配置</span></span><br><span class=\"line\">        threadRecorder.record(</span><br><span class=\"line\">                ExecutionType.BASE_PLUGIN_PROJECT_CONFIGURE,</span><br><span class=\"line\">                project.getPath(),</span><br><span class=\"line\">                <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                <span class=\"keyword\">this</span>::configureProject);</span><br><span class=\"line\"></span><br><span class=\"line\">        threadRecorder.record(</span><br><span class=\"line\">                ExecutionType.BASE_PLUGIN_PROJECT_BASE_EXTENSION_CREATION,</span><br><span class=\"line\">                project.getPath(),</span><br><span class=\"line\">                <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                <span class=\"keyword\">this</span>::configureExtension);</span><br><span class=\"line\"></span><br><span class=\"line\">        threadRecorder.record(</span><br><span class=\"line\">                ExecutionType.BASE_PLUGIN_PROJECT_TASKS_CREATION,</span><br><span class=\"line\">                project.getPath(),</span><br><span class=\"line\">                <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                <span class=\"keyword\">this</span>::createTasks);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Recorder</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// record方法用来执行block, 然后将执行结果记录</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">record</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull ExecutionType executionType,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull String projectPath,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @Nullable String variant,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull VoidBlock block)</span></span>;</span><br><span class=\"line\">          &#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>apply</code>入口的代码非常简洁, 主要执行就三个方法, <code>configureProject</code>, <code>configureExtension</code>和<code>createTasks</code>, 看方法名可以猜到, 他们的作用应该是配置Project, 配置插件的Extensions, 并且创建任务(task).</p>\n<h3 id=\"configureProject\"><a href=\"#configureProject\" class=\"headerlink\" title=\"configureProject\"></a>configureProject</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">configureProject</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        extraModelInfo = <span class=\"keyword\">new</span> ExtraModelInfo(projectOptions, project.getLogger());</span><br><span class=\"line\">        checkGradleVersion();</span><br><span class=\"line\"></span><br><span class=\"line\">        sdkHandler = <span class=\"keyword\">new</span> SdkHandler(project, getLogger());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// sdk, dependence的下载</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!project.getGradle().getStartParameter().isOffline()</span><br><span class=\"line\">                &amp;&amp; projectOptions.get(BooleanOption.ENABLE_SDK_DOWNLOAD)</span><br><span class=\"line\">                &amp;&amp; !projectOptions.get(BooleanOption.IDE_INVOKED_FROM_IDE)) &#123;</span><br><span class=\"line\">            SdkLibData sdkLibData = SdkLibData.download(getDownloader(), getSettingsController());</span><br><span class=\"line\">            sdkHandler.setSdkLibData(sdkLibData);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 构建androidBuilder</span></span><br><span class=\"line\">        androidBuilder = <span class=\"keyword\">new</span> AndroidBuilder(</span><br><span class=\"line\">                project == project.getRootProject() ? project.getName() : project.getPath(),</span><br><span class=\"line\">                creator,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> GradleProcessExecutor(project),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> GradleJavaProcessExecutor(project),</span><br><span class=\"line\">                extraModelInfo,</span><br><span class=\"line\">                getLogger(),</span><br><span class=\"line\">                isVerbose());</span><br><span class=\"line\">        dataBindingBuilder = <span class=\"keyword\">new</span> DataBindingBuilder();</span><br><span class=\"line\">        dataBindingBuilder.setPrintMachineReadableOutput(</span><br><span class=\"line\">                extraModelInfo.getErrorFormatMode() ==</span><br><span class=\"line\">                        ExtraModelInfo.ErrorFormatMode.MACHINE_PARSABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Apply the Java and Jacoco plugins.</span></span><br><span class=\"line\">        <span class=\"comment\">// JavaBasePlugin, 用于编译java代码成class, 并组装成一个jar文件</span></span><br><span class=\"line\">        project.getPlugins().apply(JavaBasePlugin.class);</span><br><span class=\"line\">        project.getPlugins().apply(JacocoPlugin.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置assmble task的描述</span></span><br><span class=\"line\">        project.getTasks()</span><br><span class=\"line\">                .getByName(<span class=\"string\">\"assemble\"</span>)</span><br><span class=\"line\">                .setDescription(</span><br><span class=\"line\">                        <span class=\"string\">\"Assembles all variants of all applications and secondary packages.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 注册编译监听</span></span><br><span class=\"line\">        <span class=\"comment\">// 会在每个project build结束后调用到, 而不单是当前的project</span></span><br><span class=\"line\">        project.getGradle()</span><br><span class=\"line\">                .addBuildListener(</span><br><span class=\"line\">                        <span class=\"keyword\">new</span> BuildListener() &#123;</span><br><span class=\"line\">                            <span class=\"meta\">@Override</span></span><br><span class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildStarted</span><span class=\"params\">(Gradle gradle)</span> </span>&#123;</span><br><span class=\"line\">                                TaskInputHelper.enableBypass();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                            <span class=\"meta\">@Override</span></span><br><span class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">settingsEvaluated</span><span class=\"params\">(Settings settings)</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                            <span class=\"meta\">@Override</span></span><br><span class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">projectsLoaded</span><span class=\"params\">(Gradle gradle)</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                            <span class=\"meta\">@Override</span></span><br><span class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">projectsEvaluated</span><span class=\"params\">(Gradle gradle)</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                            <span class=\"meta\">@Override</span></span><br><span class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildFinished</span><span class=\"params\">(BuildResult buildResult)</span> </span>&#123;</span><br><span class=\"line\">                                <span class=\"comment\">// 复合构建时不会多次重复清除</span></span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (buildResult.getGradle().getParent() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                <span class=\"comment\">// 清除dex缓存</span></span><br><span class=\"line\">                                ExecutorSingleton.shutdown();</span><br><span class=\"line\">                                sdkHandler.unload();</span><br><span class=\"line\">                                threadRecorder.record(</span><br><span class=\"line\">                                        ExecutionType.BASE_PLUGIN_BUILD_FINISHED,</span><br><span class=\"line\">                                        project.getPath(),</span><br><span class=\"line\">                                        <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                                        () -&gt; &#123;</span><br><span class=\"line\">                                            PreDexCache.getCache()</span><br><span class=\"line\">                                                    .clear(</span><br><span class=\"line\">                                                            FileUtils.join(</span><br><span class=\"line\">                                                                    project.getRootProject()</span><br><span class=\"line\">                                                                            .getBuildDir(),</span><br><span class=\"line\">                                                                    FD_INTERMEDIATES,</span><br><span class=\"line\">                                                                    <span class=\"string\">\"dex-cache\"</span>,</span><br><span class=\"line\">                                                                    <span class=\"string\">\"cache.xml\"</span>),</span><br><span class=\"line\">                                                            getLogger());</span><br><span class=\"line\">                                            Main.clearInternTables();</span><br><span class=\"line\">                                        &#125;);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 注册taskGraph构建完成时的回调</span></span><br><span class=\"line\">        project.getGradle()</span><br><span class=\"line\">                .getTaskGraph()</span><br><span class=\"line\">                .addTaskExecutionGraphListener(</span><br><span class=\"line\">                        taskGraph -&gt; &#123;</span><br><span class=\"line\">                            TaskInputHelper.disableBypass();</span><br><span class=\"line\">                            <span class=\"comment\">// 遍历所有task, 如果是dexTransform, 则读取对应的dexTransform的缓存</span></span><br><span class=\"line\">                            <span class=\"keyword\">for</span> (Task task : taskGraph.getAllTasks()) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (task <span class=\"keyword\">instanceof</span> TransformTask) &#123;</span><br><span class=\"line\">                                    Transform transform = ((TransformTask) task).getTransform();</span><br><span class=\"line\">                                    <span class=\"keyword\">if</span> (transform <span class=\"keyword\">instanceof</span> DexTransform) &#123;</span><br><span class=\"line\">                                        PreDexCache.getCache()</span><br><span class=\"line\">                                                .load(</span><br><span class=\"line\">                                                        FileUtils.join(</span><br><span class=\"line\">                                                                project.getRootProject()</span><br><span class=\"line\">                                                                        .getBuildDir(),</span><br><span class=\"line\">                                                                FD_INTERMEDIATES,</span><br><span class=\"line\">                                                                <span class=\"string\">\"dex-cache\"</span>,</span><br><span class=\"line\">                                                                <span class=\"string\">\"cache.xml\"</span>));</span><br><span class=\"line\">                                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>看代码我们可以梳理<code>configureProject</code>流程如下</p>\n<ol>\n<li>校验gradle版本</li>\n<li>下载dependence</li>\n<li>构建<code>androidBuilder</code></li>\n<li>如果有设置<code>dataBinding</code>, 则会构建<code>dataBindingBuilder</code>(这个不在本篇重点)</li>\n<li>分别引用<code>JavaBasePlugin</code>和<code>JacocoPlugin</code>插件, 分别用于编译java代码成class和用于检查测试用例的覆盖率</li>\n<li>注册taskGraph构建准备时的回调, 在准备完成时读取DexTransform的dex-cache缓存</li>\n<li>注册编译完成时的回调, 进行dex缓存的清除工作<h3 id=\"configureExtension\"><a href=\"#configureExtension\" class=\"headerlink\" title=\"configureExtension\"></a>configureExtension</h3></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">configureExtension</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 分别创建buildType, ProductFlavor, SigningConfig, BaseVariantOutput对应存储的集合对象, 设置默认的Extensions</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> NamedDomainObjectContainer&lt;BuildType&gt; buildTypeContainer =</span><br><span class=\"line\">                project.container(</span><br><span class=\"line\">                        BuildType.class,</span><br><span class=\"line\">                        <span class=\"keyword\">new</span> BuildTypeFactory(instantiator, project, extraModelInfo));</span><br><span class=\"line\">        <span class=\"keyword\">final</span> NamedDomainObjectContainer&lt;ProductFlavor&gt; productFlavorContainer =</span><br><span class=\"line\">                project.container(</span><br><span class=\"line\">                        ProductFlavor.class,</span><br><span class=\"line\">                        <span class=\"keyword\">new</span> ProductFlavorFactory(</span><br><span class=\"line\">                                instantiator, project, project.getLogger(), extraModelInfo));</span><br><span class=\"line\">        <span class=\"keyword\">final</span> NamedDomainObjectContainer&lt;SigningConfig&gt; signingConfigContainer =</span><br><span class=\"line\">                project.container(SigningConfig.class, <span class=\"keyword\">new</span> SigningConfigFactory(instantiator));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> NamedDomainObjectContainer&lt;BaseVariantOutput&gt; buildOutputs =</span><br><span class=\"line\">                project.container(BaseVariantOutput.class);</span><br><span class=\"line\">        <span class=\"comment\">// 设置project的buildOutputs属性的扩展为buildOutputs</span></span><br><span class=\"line\">        project.getExtensions().add(<span class=\"string\">\"buildOutputs\"</span>, buildOutputs);</span><br><span class=\"line\">        <span class=\"comment\">// 在appPlugin中实现, 创建android扩展属性</span></span><br><span class=\"line\">        extension =</span><br><span class=\"line\">                createExtension(</span><br><span class=\"line\">                        project,</span><br><span class=\"line\">                        projectOptions,</span><br><span class=\"line\">                        instantiator,</span><br><span class=\"line\">                        androidBuilder,</span><br><span class=\"line\">                        sdkHandler,</span><br><span class=\"line\">                        buildTypeContainer,</span><br><span class=\"line\">                        productFlavorContainer,</span><br><span class=\"line\">                        signingConfigContainer,</span><br><span class=\"line\">                        buildOutputs,</span><br><span class=\"line\">                        extraModelInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ndk处理器实例化</span></span><br><span class=\"line\">        ndkHandler =</span><br><span class=\"line\">                <span class=\"keyword\">new</span> NdkHandler(</span><br><span class=\"line\">                        project.getRootDir(),</span><br><span class=\"line\">                        <span class=\"keyword\">null</span>, <span class=\"comment\">/* compileSkdVersion, this will be set in afterEvaluate */</span></span><br><span class=\"line\">                        <span class=\"string\">\"gcc\"</span>,</span><br><span class=\"line\">                        <span class=\"string\">\"\"</span> <span class=\"comment\">/*toolchainVersion*/</span>,</span><br><span class=\"line\">                        <span class=\"keyword\">false</span> <span class=\"comment\">/* useUnifiedHeaders */</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">        FileCache buildCache = BuildCacheUtils.createBuildCacheIfEnabled(project, projectOptions);</span><br><span class=\"line\"></span><br><span class=\"line\">        GlobalScope globalScope =</span><br><span class=\"line\">                <span class=\"keyword\">new</span> GlobalScope(</span><br><span class=\"line\">                        project,</span><br><span class=\"line\">                        projectOptions,</span><br><span class=\"line\">                        androidBuilder,</span><br><span class=\"line\">                        extension,</span><br><span class=\"line\">                        sdkHandler,</span><br><span class=\"line\">                        ndkHandler,</span><br><span class=\"line\">                        registry,</span><br><span class=\"line\">                        buildCache);</span><br><span class=\"line\">        <span class=\"comment\">// ApplicationVariantFactory</span></span><br><span class=\"line\">        variantFactory = createVariantFactory(globalScope, instantiator, androidBuilder, extension);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ApplicationTaskManager, 管理application的任务创建</span></span><br><span class=\"line\">        taskManager =</span><br><span class=\"line\">                createTaskManager(</span><br><span class=\"line\">                        globalScope,</span><br><span class=\"line\">                        project,</span><br><span class=\"line\">                        projectOptions,</span><br><span class=\"line\">                        androidBuilder,</span><br><span class=\"line\">                        dataBindingBuilder,</span><br><span class=\"line\">                        extension,</span><br><span class=\"line\">                        sdkHandler,</span><br><span class=\"line\">                        ndkHandler,</span><br><span class=\"line\">                        registry,</span><br><span class=\"line\">                        threadRecorder);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 变体的创建和管理的管理器</span></span><br><span class=\"line\">        variantManager =</span><br><span class=\"line\">                <span class=\"keyword\">new</span> VariantManager(</span><br><span class=\"line\">                        globalScope,</span><br><span class=\"line\">                        project,</span><br><span class=\"line\">                        projectOptions,</span><br><span class=\"line\">                        androidBuilder,</span><br><span class=\"line\">                        extension,</span><br><span class=\"line\">                        variantFactory,</span><br><span class=\"line\">                        taskManager,</span><br><span class=\"line\">                        threadRecorder);</span><br><span class=\"line\">        <span class=\"comment\">// 注册自定义工具模型, 和native工具模型</span></span><br><span class=\"line\">        registerModels(registry, globalScope, variantManager, extension, extraModelInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// map the whenObjectAdded callbacks on the containers.</span></span><br><span class=\"line\">        signingConfigContainer.whenObjectAdded(variantManager::addSigningConfig);</span><br><span class=\"line\"></span><br><span class=\"line\">        buildTypeContainer.whenObjectAdded(</span><br><span class=\"line\">                buildType -&gt; &#123;</span><br><span class=\"line\">                    SigningConfig signingConfig =</span><br><span class=\"line\">                            signingConfigContainer.findByName(BuilderConstants.DEBUG);</span><br><span class=\"line\">                    buildType.init(signingConfig);</span><br><span class=\"line\">                    variantManager.addBuildType(buildType);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        productFlavorContainer.whenObjectAdded(variantManager::addProductFlavor);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// map whenObjectRemoved on the containers to throw an exception.</span></span><br><span class=\"line\">        signingConfigContainer.whenObjectRemoved(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UnsupportedAction(<span class=\"string\">\"Removing signingConfigs is not supported.\"</span>));</span><br><span class=\"line\">        buildTypeContainer.whenObjectRemoved(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UnsupportedAction(<span class=\"string\">\"Removing build types is not supported.\"</span>));</span><br><span class=\"line\">        productFlavorContainer.whenObjectRemoved(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UnsupportedAction(<span class=\"string\">\"Removing product flavors is not supported.\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// create default Objects, signingConfig first as its used by the BuildTypes.</span></span><br><span class=\"line\">        variantFactory.createDefaultComponents(</span><br><span class=\"line\">                buildTypeContainer, productFlavorContainer, signingConfigContainer);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><code>configureExtension</code>主要处理了<code>extension</code></p>\n<ol>\n<li>分别创建buildType, ProductFlavor, SigningConfig, BaseVariantOutput对应存储的集合对象</li>\n<li><p>创建android Extension, <code>createExtension</code>是个抽象方法, 具体实现代码可以看<code>AppPlugin</code>里, 在我们的工程配置gradle文件里, 就是我们熟悉的android闭包里的配置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> BaseExtension <span class=\"title\">createExtension</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull Project project,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull ProjectOptions projectOptions,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull Instantiator instantiator,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull AndroidBuilder androidBuilder,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull SdkHandler sdkHandler,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull NamedDomainObjectContainer&lt;BuildType&gt; buildTypeContainer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull NamedDomainObjectContainer&lt;ProductFlavor&gt; productFlavorContainer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull NamedDomainObjectContainer&lt;SigningConfig&gt; signingConfigContainer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull NamedDomainObjectContainer&lt;BaseVariantOutput&gt; buildOutputs,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull ExtraModelInfo extraModelInfo)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> project.getExtensions()</span><br><span class=\"line\">                .create(</span><br><span class=\"line\">                        <span class=\"string\">\"android\"</span>,</span><br><span class=\"line\">                        AppExtension.class,</span><br><span class=\"line\">                        project,</span><br><span class=\"line\">                        projectOptions,</span><br><span class=\"line\">                        instantiator,</span><br><span class=\"line\">                        androidBuilder,</span><br><span class=\"line\">                        sdkHandler,</span><br><span class=\"line\">                        buildTypeContainer,</span><br><span class=\"line\">                        productFlavorContainer,</span><br><span class=\"line\">                        signingConfigContainer,</span><br><span class=\"line\">                        buildOutputs,</span><br><span class=\"line\">                        extraModelInfo);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>分别创建<code>taskManager</code>和<code>variantManager</code>, 看名字就可以知道他负责的分别是task和variant</p>\n</li>\n<li>针对签名配置signingConfig, buildType, productFlavor 注册新增时候的监听, 对应添加到variantManager中做管理. 同时, 他们是不支持删除的.</li>\n<li>创建默认的variant</li>\n</ol>\n<h3 id=\"createTasks\"><a href=\"#createTasks\" class=\"headerlink\" title=\"createTasks\"></a>createTasks</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">createTasks</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        threadRecorder.record(</span><br><span class=\"line\">                ExecutionType.TASK_MANAGER_CREATE_TASKS,</span><br><span class=\"line\">                project.getPath(),</span><br><span class=\"line\">                <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                <span class=\"comment\">// 在before evaluate新增部分tasks</span></span><br><span class=\"line\">                () -&gt;</span><br><span class=\"line\">                        taskManager.createTasksBeforeEvaluate(</span><br><span class=\"line\">                                <span class=\"keyword\">new</span> TaskContainerAdaptor(project.getTasks())));</span><br><span class=\"line\"></span><br><span class=\"line\">        project.afterEvaluate(</span><br><span class=\"line\">                project -&gt;</span><br><span class=\"line\">                        threadRecorder.record(</span><br><span class=\"line\">                                ExecutionType.BASE_PLUGIN_CREATE_ANDROID_TASKS,</span><br><span class=\"line\">                                project.getPath(),</span><br><span class=\"line\">                                <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                                () -&gt; createAndroidTasks(<span class=\"keyword\">false</span>)));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>createTask</code>阶段, 首先会在配置收集之前(即在apply plugin)阶段会创建一些task, 这里<code>TaskContainerAdaptor</code>可以理解为对task的又一层管理封装.</p>\n<p>在配置收集获取所有task之后, 我们会调用到<code>createAndroidTasks</code><br>在执行真正的创建tasks之前, 主要是对extension内一些配置进行校验, 譬如针对buildToolsVersion, compileSdkVersion是否指定, 是否另外引用了JavaPlugin等等, 这里的代码可以自行看源码了解<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">createAndroidTasks</span><span class=\"params\">(<span class=\"keyword\">boolean</span> force)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        threadRecorder.record(</span><br><span class=\"line\">                ExecutionType.VARIANT_MANAGER_CREATE_ANDROID_TASKS,</span><br><span class=\"line\">                project.getPath(),</span><br><span class=\"line\">                <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                <span class=\"comment\">// 根据variant创建tasks</span></span><br><span class=\"line\">                () -&gt; &#123;</span><br><span class=\"line\">                    variantManager.createAndroidTasks();</span><br><span class=\"line\">                    ApiObjectFactory apiObjectFactory =</span><br><span class=\"line\">                            <span class=\"keyword\">new</span> ApiObjectFactory(</span><br><span class=\"line\">                                    androidBuilder,</span><br><span class=\"line\">                                    extension,</span><br><span class=\"line\">                                    variantFactory,</span><br><span class=\"line\">                                    instantiator,</span><br><span class=\"line\">                                    project.getObjects());</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (VariantScope variantScope : variantManager.getVariantScopes()) &#123;</span><br><span class=\"line\">                        BaseVariantData variantData = variantScope.getVariantData();</span><br><span class=\"line\">                        apiObjectFactory.create(variantData);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里我们可以主要看下<code>variantManager.createAndroidTasks()</code>方法内容, 这里根据variant创建对应的tasks<br>可以看到具体流程如下:</p>\n<ol>\n<li>校验是否引用apt插件(这在3.0里使用annotationProcessor来声明注解处理器)</li>\n<li>填充收集所以variant</li>\n<li>根据variant创建对应的tasks</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">createAndroidTasks</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        variantFactory.validateModel(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 校验是否引用apt插件, 如果有, 抛出异常</span></span><br><span class=\"line\">        variantFactory.preVariantWork(project);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> TaskFactory tasks = <span class=\"keyword\">new</span> TaskContainerAdaptor(project.getTasks());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (variantScopes.isEmpty()) &#123;</span><br><span class=\"line\">            recorder.record(</span><br><span class=\"line\">                    ExecutionType.VARIANT_MANAGER_CREATE_VARIANTS,</span><br><span class=\"line\">                    project.getPath(),</span><br><span class=\"line\">                    <span class=\"keyword\">null</span> <span class=\"comment\">/*variantName*/</span>,</span><br><span class=\"line\">                    <span class=\"comment\">// 填充所有variant</span></span><br><span class=\"line\">                    <span class=\"keyword\">this</span>::populateVariantDataList);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Create top level test tasks.</span></span><br><span class=\"line\">        recorder.record(</span><br><span class=\"line\">                ExecutionType.VARIANT_MANAGER_CREATE_TESTS_TASKS,</span><br><span class=\"line\">                project.getPath(),</span><br><span class=\"line\">                <span class=\"keyword\">null</span> <span class=\"comment\">/*variantName*/</span>,</span><br><span class=\"line\">                <span class=\"comment\">// 创建测试tasks</span></span><br><span class=\"line\">                () -&gt; taskManager.createTopLevelTestTasks(tasks, !productFlavors.isEmpty()));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">final</span> VariantScope variantScope : variantScopes) &#123;</span><br><span class=\"line\">            recorder.record(</span><br><span class=\"line\">                    ExecutionType.VARIANT_MANAGER_CREATE_TASKS_FOR_VARIANT,</span><br><span class=\"line\">                    project.getPath(),</span><br><span class=\"line\">                    variantScope.getFullVariantName(),</span><br><span class=\"line\">                    <span class=\"comment\">// 根据variant创建不同的tasks, 创建assemble任务也在这里</span></span><br><span class=\"line\">                    () -&gt; createTasksForVariantData(tasks, variantScope));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        taskManager.createReportTasks(tasks, variantScopes);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>最后我们总结下, <code>appPlugin</code> <code>apply</code>的整体流程(当然, 因为他执行的是父类的<code>apply</code>, 所以流程适用于<code>libraryPlugin</code>)</p>\n<ol>\n<li>project的配置<ol>\n<li>检验gradle版本</li>\n<li>下载dependence</li>\n<li>构建<code>androidBuilder</code></li>\n<li>引用<code>JavaBasePlugin</code>和<code>JacocoPlugin</code></li>\n<li>定义编译过程的回调, 负责处理dex-cache的加载和清除工作</li>\n</ol>\n</li>\n<li>extension的配置<ol>\n<li>创建和配置extension</li>\n<li>创建taskManager和variantManager</li>\n<li>配置签名设置, buildType, productFlavor, 供后续task以及编译时使用</li>\n</ol>\n</li>\n<li>创建task(任务)<ol>\n<li>一些extension设置的检验</li>\n<li>编译task的创建</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>之前为了优化内部的Route, 去看了下<code>TransformAPI</code>, 然后就顺便看了下<code>AppPlugin</code>的源码.<br>本篇源码基于android gradle 3.0.1的版本.<br>","more":"</p>\n<h3 id=\"总入口\"><a href=\"#总入口\" class=\"headerlink\" title=\"总入口\"></a>总入口</h3><p>我们直接从入口<code>apply</code>开始看, 他调到了父类<code>BasePlugin</code>的apply方法.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">apply</span><span class=\"params\">(@NonNull Project project)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 一些基础path和插件版本的校验</span></span><br><span class=\"line\">        <span class=\"comment\">// 以及一些流程记录的初始化</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 真正执行的是configureProject方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 项目配置</span></span><br><span class=\"line\">        threadRecorder.record(</span><br><span class=\"line\">                ExecutionType.BASE_PLUGIN_PROJECT_CONFIGURE,</span><br><span class=\"line\">                project.getPath(),</span><br><span class=\"line\">                <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                <span class=\"keyword\">this</span>::configureProject);</span><br><span class=\"line\"></span><br><span class=\"line\">        threadRecorder.record(</span><br><span class=\"line\">                ExecutionType.BASE_PLUGIN_PROJECT_BASE_EXTENSION_CREATION,</span><br><span class=\"line\">                project.getPath(),</span><br><span class=\"line\">                <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                <span class=\"keyword\">this</span>::configureExtension);</span><br><span class=\"line\"></span><br><span class=\"line\">        threadRecorder.record(</span><br><span class=\"line\">                ExecutionType.BASE_PLUGIN_PROJECT_TASKS_CREATION,</span><br><span class=\"line\">                project.getPath(),</span><br><span class=\"line\">                <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                <span class=\"keyword\">this</span>::createTasks);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Recorder</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// record方法用来执行block, 然后将执行结果记录</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">record</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull ExecutionType executionType,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull String projectPath,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @Nullable String variant,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull VoidBlock block)</span></span>;</span><br><span class=\"line\">          &#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>apply</code>入口的代码非常简洁, 主要执行就三个方法, <code>configureProject</code>, <code>configureExtension</code>和<code>createTasks</code>, 看方法名可以猜到, 他们的作用应该是配置Project, 配置插件的Extensions, 并且创建任务(task).</p>\n<h3 id=\"configureProject\"><a href=\"#configureProject\" class=\"headerlink\" title=\"configureProject\"></a>configureProject</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">configureProject</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        extraModelInfo = <span class=\"keyword\">new</span> ExtraModelInfo(projectOptions, project.getLogger());</span><br><span class=\"line\">        checkGradleVersion();</span><br><span class=\"line\"></span><br><span class=\"line\">        sdkHandler = <span class=\"keyword\">new</span> SdkHandler(project, getLogger());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// sdk, dependence的下载</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!project.getGradle().getStartParameter().isOffline()</span><br><span class=\"line\">                &amp;&amp; projectOptions.get(BooleanOption.ENABLE_SDK_DOWNLOAD)</span><br><span class=\"line\">                &amp;&amp; !projectOptions.get(BooleanOption.IDE_INVOKED_FROM_IDE)) &#123;</span><br><span class=\"line\">            SdkLibData sdkLibData = SdkLibData.download(getDownloader(), getSettingsController());</span><br><span class=\"line\">            sdkHandler.setSdkLibData(sdkLibData);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 构建androidBuilder</span></span><br><span class=\"line\">        androidBuilder = <span class=\"keyword\">new</span> AndroidBuilder(</span><br><span class=\"line\">                project == project.getRootProject() ? project.getName() : project.getPath(),</span><br><span class=\"line\">                creator,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> GradleProcessExecutor(project),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> GradleJavaProcessExecutor(project),</span><br><span class=\"line\">                extraModelInfo,</span><br><span class=\"line\">                getLogger(),</span><br><span class=\"line\">                isVerbose());</span><br><span class=\"line\">        dataBindingBuilder = <span class=\"keyword\">new</span> DataBindingBuilder();</span><br><span class=\"line\">        dataBindingBuilder.setPrintMachineReadableOutput(</span><br><span class=\"line\">                extraModelInfo.getErrorFormatMode() ==</span><br><span class=\"line\">                        ExtraModelInfo.ErrorFormatMode.MACHINE_PARSABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Apply the Java and Jacoco plugins.</span></span><br><span class=\"line\">        <span class=\"comment\">// JavaBasePlugin, 用于编译java代码成class, 并组装成一个jar文件</span></span><br><span class=\"line\">        project.getPlugins().apply(JavaBasePlugin.class);</span><br><span class=\"line\">        project.getPlugins().apply(JacocoPlugin.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置assmble task的描述</span></span><br><span class=\"line\">        project.getTasks()</span><br><span class=\"line\">                .getByName(<span class=\"string\">\"assemble\"</span>)</span><br><span class=\"line\">                .setDescription(</span><br><span class=\"line\">                        <span class=\"string\">\"Assembles all variants of all applications and secondary packages.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 注册编译监听</span></span><br><span class=\"line\">        <span class=\"comment\">// 会在每个project build结束后调用到, 而不单是当前的project</span></span><br><span class=\"line\">        project.getGradle()</span><br><span class=\"line\">                .addBuildListener(</span><br><span class=\"line\">                        <span class=\"keyword\">new</span> BuildListener() &#123;</span><br><span class=\"line\">                            <span class=\"meta\">@Override</span></span><br><span class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildStarted</span><span class=\"params\">(Gradle gradle)</span> </span>&#123;</span><br><span class=\"line\">                                TaskInputHelper.enableBypass();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                            <span class=\"meta\">@Override</span></span><br><span class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">settingsEvaluated</span><span class=\"params\">(Settings settings)</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                            <span class=\"meta\">@Override</span></span><br><span class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">projectsLoaded</span><span class=\"params\">(Gradle gradle)</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                            <span class=\"meta\">@Override</span></span><br><span class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">projectsEvaluated</span><span class=\"params\">(Gradle gradle)</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                            <span class=\"meta\">@Override</span></span><br><span class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildFinished</span><span class=\"params\">(BuildResult buildResult)</span> </span>&#123;</span><br><span class=\"line\">                                <span class=\"comment\">// 复合构建时不会多次重复清除</span></span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (buildResult.getGradle().getParent() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                <span class=\"comment\">// 清除dex缓存</span></span><br><span class=\"line\">                                ExecutorSingleton.shutdown();</span><br><span class=\"line\">                                sdkHandler.unload();</span><br><span class=\"line\">                                threadRecorder.record(</span><br><span class=\"line\">                                        ExecutionType.BASE_PLUGIN_BUILD_FINISHED,</span><br><span class=\"line\">                                        project.getPath(),</span><br><span class=\"line\">                                        <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                                        () -&gt; &#123;</span><br><span class=\"line\">                                            PreDexCache.getCache()</span><br><span class=\"line\">                                                    .clear(</span><br><span class=\"line\">                                                            FileUtils.join(</span><br><span class=\"line\">                                                                    project.getRootProject()</span><br><span class=\"line\">                                                                            .getBuildDir(),</span><br><span class=\"line\">                                                                    FD_INTERMEDIATES,</span><br><span class=\"line\">                                                                    <span class=\"string\">\"dex-cache\"</span>,</span><br><span class=\"line\">                                                                    <span class=\"string\">\"cache.xml\"</span>),</span><br><span class=\"line\">                                                            getLogger());</span><br><span class=\"line\">                                            Main.clearInternTables();</span><br><span class=\"line\">                                        &#125;);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 注册taskGraph构建完成时的回调</span></span><br><span class=\"line\">        project.getGradle()</span><br><span class=\"line\">                .getTaskGraph()</span><br><span class=\"line\">                .addTaskExecutionGraphListener(</span><br><span class=\"line\">                        taskGraph -&gt; &#123;</span><br><span class=\"line\">                            TaskInputHelper.disableBypass();</span><br><span class=\"line\">                            <span class=\"comment\">// 遍历所有task, 如果是dexTransform, 则读取对应的dexTransform的缓存</span></span><br><span class=\"line\">                            <span class=\"keyword\">for</span> (Task task : taskGraph.getAllTasks()) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (task <span class=\"keyword\">instanceof</span> TransformTask) &#123;</span><br><span class=\"line\">                                    Transform transform = ((TransformTask) task).getTransform();</span><br><span class=\"line\">                                    <span class=\"keyword\">if</span> (transform <span class=\"keyword\">instanceof</span> DexTransform) &#123;</span><br><span class=\"line\">                                        PreDexCache.getCache()</span><br><span class=\"line\">                                                .load(</span><br><span class=\"line\">                                                        FileUtils.join(</span><br><span class=\"line\">                                                                project.getRootProject()</span><br><span class=\"line\">                                                                        .getBuildDir(),</span><br><span class=\"line\">                                                                FD_INTERMEDIATES,</span><br><span class=\"line\">                                                                <span class=\"string\">\"dex-cache\"</span>,</span><br><span class=\"line\">                                                                <span class=\"string\">\"cache.xml\"</span>));</span><br><span class=\"line\">                                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>看代码我们可以梳理<code>configureProject</code>流程如下</p>\n<ol>\n<li>校验gradle版本</li>\n<li>下载dependence</li>\n<li>构建<code>androidBuilder</code></li>\n<li>如果有设置<code>dataBinding</code>, 则会构建<code>dataBindingBuilder</code>(这个不在本篇重点)</li>\n<li>分别引用<code>JavaBasePlugin</code>和<code>JacocoPlugin</code>插件, 分别用于编译java代码成class和用于检查测试用例的覆盖率</li>\n<li>注册taskGraph构建准备时的回调, 在准备完成时读取DexTransform的dex-cache缓存</li>\n<li>注册编译完成时的回调, 进行dex缓存的清除工作<h3 id=\"configureExtension\"><a href=\"#configureExtension\" class=\"headerlink\" title=\"configureExtension\"></a>configureExtension</h3></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">configureExtension</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 分别创建buildType, ProductFlavor, SigningConfig, BaseVariantOutput对应存储的集合对象, 设置默认的Extensions</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> NamedDomainObjectContainer&lt;BuildType&gt; buildTypeContainer =</span><br><span class=\"line\">                project.container(</span><br><span class=\"line\">                        BuildType.class,</span><br><span class=\"line\">                        <span class=\"keyword\">new</span> BuildTypeFactory(instantiator, project, extraModelInfo));</span><br><span class=\"line\">        <span class=\"keyword\">final</span> NamedDomainObjectContainer&lt;ProductFlavor&gt; productFlavorContainer =</span><br><span class=\"line\">                project.container(</span><br><span class=\"line\">                        ProductFlavor.class,</span><br><span class=\"line\">                        <span class=\"keyword\">new</span> ProductFlavorFactory(</span><br><span class=\"line\">                                instantiator, project, project.getLogger(), extraModelInfo));</span><br><span class=\"line\">        <span class=\"keyword\">final</span> NamedDomainObjectContainer&lt;SigningConfig&gt; signingConfigContainer =</span><br><span class=\"line\">                project.container(SigningConfig.class, <span class=\"keyword\">new</span> SigningConfigFactory(instantiator));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> NamedDomainObjectContainer&lt;BaseVariantOutput&gt; buildOutputs =</span><br><span class=\"line\">                project.container(BaseVariantOutput.class);</span><br><span class=\"line\">        <span class=\"comment\">// 设置project的buildOutputs属性的扩展为buildOutputs</span></span><br><span class=\"line\">        project.getExtensions().add(<span class=\"string\">\"buildOutputs\"</span>, buildOutputs);</span><br><span class=\"line\">        <span class=\"comment\">// 在appPlugin中实现, 创建android扩展属性</span></span><br><span class=\"line\">        extension =</span><br><span class=\"line\">                createExtension(</span><br><span class=\"line\">                        project,</span><br><span class=\"line\">                        projectOptions,</span><br><span class=\"line\">                        instantiator,</span><br><span class=\"line\">                        androidBuilder,</span><br><span class=\"line\">                        sdkHandler,</span><br><span class=\"line\">                        buildTypeContainer,</span><br><span class=\"line\">                        productFlavorContainer,</span><br><span class=\"line\">                        signingConfigContainer,</span><br><span class=\"line\">                        buildOutputs,</span><br><span class=\"line\">                        extraModelInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ndk处理器实例化</span></span><br><span class=\"line\">        ndkHandler =</span><br><span class=\"line\">                <span class=\"keyword\">new</span> NdkHandler(</span><br><span class=\"line\">                        project.getRootDir(),</span><br><span class=\"line\">                        <span class=\"keyword\">null</span>, <span class=\"comment\">/* compileSkdVersion, this will be set in afterEvaluate */</span></span><br><span class=\"line\">                        <span class=\"string\">\"gcc\"</span>,</span><br><span class=\"line\">                        <span class=\"string\">\"\"</span> <span class=\"comment\">/*toolchainVersion*/</span>,</span><br><span class=\"line\">                        <span class=\"keyword\">false</span> <span class=\"comment\">/* useUnifiedHeaders */</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">        FileCache buildCache = BuildCacheUtils.createBuildCacheIfEnabled(project, projectOptions);</span><br><span class=\"line\"></span><br><span class=\"line\">        GlobalScope globalScope =</span><br><span class=\"line\">                <span class=\"keyword\">new</span> GlobalScope(</span><br><span class=\"line\">                        project,</span><br><span class=\"line\">                        projectOptions,</span><br><span class=\"line\">                        androidBuilder,</span><br><span class=\"line\">                        extension,</span><br><span class=\"line\">                        sdkHandler,</span><br><span class=\"line\">                        ndkHandler,</span><br><span class=\"line\">                        registry,</span><br><span class=\"line\">                        buildCache);</span><br><span class=\"line\">        <span class=\"comment\">// ApplicationVariantFactory</span></span><br><span class=\"line\">        variantFactory = createVariantFactory(globalScope, instantiator, androidBuilder, extension);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ApplicationTaskManager, 管理application的任务创建</span></span><br><span class=\"line\">        taskManager =</span><br><span class=\"line\">                createTaskManager(</span><br><span class=\"line\">                        globalScope,</span><br><span class=\"line\">                        project,</span><br><span class=\"line\">                        projectOptions,</span><br><span class=\"line\">                        androidBuilder,</span><br><span class=\"line\">                        dataBindingBuilder,</span><br><span class=\"line\">                        extension,</span><br><span class=\"line\">                        sdkHandler,</span><br><span class=\"line\">                        ndkHandler,</span><br><span class=\"line\">                        registry,</span><br><span class=\"line\">                        threadRecorder);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 变体的创建和管理的管理器</span></span><br><span class=\"line\">        variantManager =</span><br><span class=\"line\">                <span class=\"keyword\">new</span> VariantManager(</span><br><span class=\"line\">                        globalScope,</span><br><span class=\"line\">                        project,</span><br><span class=\"line\">                        projectOptions,</span><br><span class=\"line\">                        androidBuilder,</span><br><span class=\"line\">                        extension,</span><br><span class=\"line\">                        variantFactory,</span><br><span class=\"line\">                        taskManager,</span><br><span class=\"line\">                        threadRecorder);</span><br><span class=\"line\">        <span class=\"comment\">// 注册自定义工具模型, 和native工具模型</span></span><br><span class=\"line\">        registerModels(registry, globalScope, variantManager, extension, extraModelInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// map the whenObjectAdded callbacks on the containers.</span></span><br><span class=\"line\">        signingConfigContainer.whenObjectAdded(variantManager::addSigningConfig);</span><br><span class=\"line\"></span><br><span class=\"line\">        buildTypeContainer.whenObjectAdded(</span><br><span class=\"line\">                buildType -&gt; &#123;</span><br><span class=\"line\">                    SigningConfig signingConfig =</span><br><span class=\"line\">                            signingConfigContainer.findByName(BuilderConstants.DEBUG);</span><br><span class=\"line\">                    buildType.init(signingConfig);</span><br><span class=\"line\">                    variantManager.addBuildType(buildType);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        productFlavorContainer.whenObjectAdded(variantManager::addProductFlavor);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// map whenObjectRemoved on the containers to throw an exception.</span></span><br><span class=\"line\">        signingConfigContainer.whenObjectRemoved(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UnsupportedAction(<span class=\"string\">\"Removing signingConfigs is not supported.\"</span>));</span><br><span class=\"line\">        buildTypeContainer.whenObjectRemoved(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UnsupportedAction(<span class=\"string\">\"Removing build types is not supported.\"</span>));</span><br><span class=\"line\">        productFlavorContainer.whenObjectRemoved(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UnsupportedAction(<span class=\"string\">\"Removing product flavors is not supported.\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// create default Objects, signingConfig first as its used by the BuildTypes.</span></span><br><span class=\"line\">        variantFactory.createDefaultComponents(</span><br><span class=\"line\">                buildTypeContainer, productFlavorContainer, signingConfigContainer);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><code>configureExtension</code>主要处理了<code>extension</code></p>\n<ol>\n<li>分别创建buildType, ProductFlavor, SigningConfig, BaseVariantOutput对应存储的集合对象</li>\n<li><p>创建android Extension, <code>createExtension</code>是个抽象方法, 具体实现代码可以看<code>AppPlugin</code>里, 在我们的工程配置gradle文件里, 就是我们熟悉的android闭包里的配置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> BaseExtension <span class=\"title\">createExtension</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull Project project,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull ProjectOptions projectOptions,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull Instantiator instantiator,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull AndroidBuilder androidBuilder,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull SdkHandler sdkHandler,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull NamedDomainObjectContainer&lt;BuildType&gt; buildTypeContainer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull NamedDomainObjectContainer&lt;ProductFlavor&gt; productFlavorContainer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull NamedDomainObjectContainer&lt;SigningConfig&gt; signingConfigContainer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull NamedDomainObjectContainer&lt;BaseVariantOutput&gt; buildOutputs,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull ExtraModelInfo extraModelInfo)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> project.getExtensions()</span><br><span class=\"line\">                .create(</span><br><span class=\"line\">                        <span class=\"string\">\"android\"</span>,</span><br><span class=\"line\">                        AppExtension.class,</span><br><span class=\"line\">                        project,</span><br><span class=\"line\">                        projectOptions,</span><br><span class=\"line\">                        instantiator,</span><br><span class=\"line\">                        androidBuilder,</span><br><span class=\"line\">                        sdkHandler,</span><br><span class=\"line\">                        buildTypeContainer,</span><br><span class=\"line\">                        productFlavorContainer,</span><br><span class=\"line\">                        signingConfigContainer,</span><br><span class=\"line\">                        buildOutputs,</span><br><span class=\"line\">                        extraModelInfo);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>分别创建<code>taskManager</code>和<code>variantManager</code>, 看名字就可以知道他负责的分别是task和variant</p>\n</li>\n<li>针对签名配置signingConfig, buildType, productFlavor 注册新增时候的监听, 对应添加到variantManager中做管理. 同时, 他们是不支持删除的.</li>\n<li>创建默认的variant</li>\n</ol>\n<h3 id=\"createTasks\"><a href=\"#createTasks\" class=\"headerlink\" title=\"createTasks\"></a>createTasks</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">createTasks</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        threadRecorder.record(</span><br><span class=\"line\">                ExecutionType.TASK_MANAGER_CREATE_TASKS,</span><br><span class=\"line\">                project.getPath(),</span><br><span class=\"line\">                <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                <span class=\"comment\">// 在before evaluate新增部分tasks</span></span><br><span class=\"line\">                () -&gt;</span><br><span class=\"line\">                        taskManager.createTasksBeforeEvaluate(</span><br><span class=\"line\">                                <span class=\"keyword\">new</span> TaskContainerAdaptor(project.getTasks())));</span><br><span class=\"line\"></span><br><span class=\"line\">        project.afterEvaluate(</span><br><span class=\"line\">                project -&gt;</span><br><span class=\"line\">                        threadRecorder.record(</span><br><span class=\"line\">                                ExecutionType.BASE_PLUGIN_CREATE_ANDROID_TASKS,</span><br><span class=\"line\">                                project.getPath(),</span><br><span class=\"line\">                                <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                                () -&gt; createAndroidTasks(<span class=\"keyword\">false</span>)));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>createTask</code>阶段, 首先会在配置收集之前(即在apply plugin)阶段会创建一些task, 这里<code>TaskContainerAdaptor</code>可以理解为对task的又一层管理封装.</p>\n<p>在配置收集获取所有task之后, 我们会调用到<code>createAndroidTasks</code><br>在执行真正的创建tasks之前, 主要是对extension内一些配置进行校验, 譬如针对buildToolsVersion, compileSdkVersion是否指定, 是否另外引用了JavaPlugin等等, 这里的代码可以自行看源码了解<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">createAndroidTasks</span><span class=\"params\">(<span class=\"keyword\">boolean</span> force)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        threadRecorder.record(</span><br><span class=\"line\">                ExecutionType.VARIANT_MANAGER_CREATE_ANDROID_TASKS,</span><br><span class=\"line\">                project.getPath(),</span><br><span class=\"line\">                <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                <span class=\"comment\">// 根据variant创建tasks</span></span><br><span class=\"line\">                () -&gt; &#123;</span><br><span class=\"line\">                    variantManager.createAndroidTasks();</span><br><span class=\"line\">                    ApiObjectFactory apiObjectFactory =</span><br><span class=\"line\">                            <span class=\"keyword\">new</span> ApiObjectFactory(</span><br><span class=\"line\">                                    androidBuilder,</span><br><span class=\"line\">                                    extension,</span><br><span class=\"line\">                                    variantFactory,</span><br><span class=\"line\">                                    instantiator,</span><br><span class=\"line\">                                    project.getObjects());</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (VariantScope variantScope : variantManager.getVariantScopes()) &#123;</span><br><span class=\"line\">                        BaseVariantData variantData = variantScope.getVariantData();</span><br><span class=\"line\">                        apiObjectFactory.create(variantData);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里我们可以主要看下<code>variantManager.createAndroidTasks()</code>方法内容, 这里根据variant创建对应的tasks<br>可以看到具体流程如下:</p>\n<ol>\n<li>校验是否引用apt插件(这在3.0里使用annotationProcessor来声明注解处理器)</li>\n<li>填充收集所以variant</li>\n<li>根据variant创建对应的tasks</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">createAndroidTasks</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        variantFactory.validateModel(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 校验是否引用apt插件, 如果有, 抛出异常</span></span><br><span class=\"line\">        variantFactory.preVariantWork(project);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> TaskFactory tasks = <span class=\"keyword\">new</span> TaskContainerAdaptor(project.getTasks());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (variantScopes.isEmpty()) &#123;</span><br><span class=\"line\">            recorder.record(</span><br><span class=\"line\">                    ExecutionType.VARIANT_MANAGER_CREATE_VARIANTS,</span><br><span class=\"line\">                    project.getPath(),</span><br><span class=\"line\">                    <span class=\"keyword\">null</span> <span class=\"comment\">/*variantName*/</span>,</span><br><span class=\"line\">                    <span class=\"comment\">// 填充所有variant</span></span><br><span class=\"line\">                    <span class=\"keyword\">this</span>::populateVariantDataList);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Create top level test tasks.</span></span><br><span class=\"line\">        recorder.record(</span><br><span class=\"line\">                ExecutionType.VARIANT_MANAGER_CREATE_TESTS_TASKS,</span><br><span class=\"line\">                project.getPath(),</span><br><span class=\"line\">                <span class=\"keyword\">null</span> <span class=\"comment\">/*variantName*/</span>,</span><br><span class=\"line\">                <span class=\"comment\">// 创建测试tasks</span></span><br><span class=\"line\">                () -&gt; taskManager.createTopLevelTestTasks(tasks, !productFlavors.isEmpty()));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">final</span> VariantScope variantScope : variantScopes) &#123;</span><br><span class=\"line\">            recorder.record(</span><br><span class=\"line\">                    ExecutionType.VARIANT_MANAGER_CREATE_TASKS_FOR_VARIANT,</span><br><span class=\"line\">                    project.getPath(),</span><br><span class=\"line\">                    variantScope.getFullVariantName(),</span><br><span class=\"line\">                    <span class=\"comment\">// 根据variant创建不同的tasks, 创建assemble任务也在这里</span></span><br><span class=\"line\">                    () -&gt; createTasksForVariantData(tasks, variantScope));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        taskManager.createReportTasks(tasks, variantScopes);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>最后我们总结下, <code>appPlugin</code> <code>apply</code>的整体流程(当然, 因为他执行的是父类的<code>apply</code>, 所以流程适用于<code>libraryPlugin</code>)</p>\n<ol>\n<li>project的配置<ol>\n<li>检验gradle版本</li>\n<li>下载dependence</li>\n<li>构建<code>androidBuilder</code></li>\n<li>引用<code>JavaBasePlugin</code>和<code>JacocoPlugin</code></li>\n<li>定义编译过程的回调, 负责处理dex-cache的加载和清除工作</li>\n</ol>\n</li>\n<li>extension的配置<ol>\n<li>创建和配置extension</li>\n<li>创建taskManager和variantManager</li>\n<li>配置签名设置, buildType, productFlavor, 供后续task以及编译时使用</li>\n</ol>\n</li>\n<li>创建task(任务)<ol>\n<li>一些extension设置的检验</li>\n<li>编译task的创建</li>\n</ol>\n</li>\n</ol>"},{"title":"EventBus源码解析","date":"2018-03-29T16:00:00.000Z","_content":"### 前言\n前期加班加点赶项目, 趁着刚上线空两天,赶紧看下`EventBus`做个\"思维复健\"\n### 使用\n`EventBus`的使用非常简单, 如果使用默认的`EventBus`, 我们一般只会使用到以下三个API\n1. 绑定\n``` java\nEventBus.getDefault().regisiter(this);\n```\n2. 发送信息\n``` java\nEventBus.getDefault().post(new Event());\n```\n3. 解绑\n``` java\nEventBus.getDefault().unregisiter(this);\n```\n<!-- more -->\n### EventBus.getDefault()\n`EventBus`内部维护了一个单例, 通过`getDefault`我们可以获取默认单例来进行绑定和发送动作, 但是当我们需要进行一些关于log, 是否未有订阅者情况的响应处理时, 我们可以通过`EventBusBuilder`通过构建者模式来进行配置处理,本篇解析仅分析默认情况下的流程代码\n### 绑定\n老规矩, 我们先上代码\n``` java\npublic void register(Object subscriber) {\n        Class<?> subscriberClass = subscriber.getClass();\n        // 获取对应subscriber类的订阅方法\n        List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);\n        synchronized (this) {\n            // 遍历执行订阅\n            for (SubscriberMethod subscriberMethod : subscriberMethods) {\n                subscribe(subscriber, subscriberMethod);\n            }\n        }\n    }\n```\n我们根据传递的订阅者来获取相关的订阅方法, 然后遍历执行订阅的动作. 我们首先看下如果查找订阅者的所有订阅方法\n``` java\nList<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {\n        // 从缓存中查找订阅方法\n        List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);\n        // 缓存中有, 直接返回\n        if (subscriberMethods != null) {\n            return subscriberMethods;\n        }\n        // 查找注册方法, 默认false\n        if (ignoreGeneratedIndex) {\n            // 使用反射查找\n            subscriberMethods = findUsingReflection(subscriberClass);\n        } else {\n            // 使用注解器生成的类查找\n            subscriberMethods = findUsingInfo(subscriberClass);\n        }\n        // 如果没有订阅方法, 则抛出异常\n        if (subscriberMethods.isEmpty()) {\n            throw new EventBusException(\"Subscriber \" + subscriberClass\n                    + \" and its super classes have no public methods with the @Subscribe annotation\");\n        } else {\n            // 否则加入缓存中\n            METHOD_CACHE.put(subscriberClass, subscriberMethods);\n            return subscriberMethods;\n        }\n    }\n```\n我们知道`EventBus`3.0版本后通过`@Subscribe`注解来标注对应的订阅方法, 可以看到通过`findUsingInfo`方法查询订阅方法, 如果没有订阅方法, 会抛出异常, 而如果找到了, 则会加入缓存`METHOD_CACHE`进行内部维护, 这个方法可以优化部分性能, 减少反射带来的性能问题.\n我们在往`findUsingInfo`里看, 会发现如果找不到相关订阅者信息的时候, 仍会通过反射来寻找.\n``` java\nprivate List<SubscriberMethod> findUsingInfo(Class<?> subscriberClass) {\n        FindState findState = prepareFindState();\n        findState.initForSubscriber(subscriberClass);\n        while (findState.clazz != null) {\n            findState.subscriberInfo = getSubscriberInfo(findState);\n            if (findState.subscriberInfo != null) {\n                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();\n                // 遍历订阅者方法\n                for (SubscriberMethod subscriberMethod : array) {\n                    if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {\n                        findState.subscriberMethods.add(subscriberMethod);\n                    }\n                }\n            } else {\n                // 没有订阅信息, 从反射来找\n                findUsingReflectionInSingleClass(findState);\n            }\n            findState.moveToSuperclass();\n        }\n        return getMethodsAndRelease(findState);\n    }\n```\n我们回头去看`subscribe`订阅动作的执行代码\n``` java\n/**\n     * 订阅动作\n     * @param subscriber         订阅者(类似订阅的Activity之类)\n     * @param subscriberMethod   订阅事件方法, 比如加了@Subscribe注解的方法\n     */\n    private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {\n        // 订阅事件的类, 比如平常传递的自己写的EventLogin等等..\n        Class<?> eventType = subscriberMethod.eventType;\n        Subscription newSubscription = new Subscription(subscriber, subscriberMethod);\n        // 获取与eventType有关的订阅事件的队列\n        CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);\n        // 如果为空\n        if (subscriptions == null) {\n            // 初始队列\n            subscriptions = new CopyOnWriteArrayList<>();\n            subscriptionsByEventType.put(eventType, subscriptions);\n        } else {\n            // 如果管理的订阅队列存在新的订阅事件, 则抛出已注册事件的异常\n            if (subscriptions.contains(newSubscription)) {\n                throw new EventBusException(\"Subscriber \" + subscriber.getClass() + \" already registered to event \"\n                        + eventType);\n            }\n        }\n        int size = subscriptions.size();\n        // 遍历订阅的事件\n        for (int i = 0; i <= size; i++) {\n            // 根据优先级, 插入订阅事件\n            if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {\n                subscriptions.add(i, newSubscription);\n                break;\n            }\n        }\n        // 以订阅者为key, value为订阅事件的类的队列\n        List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);\n        if (subscribedEvents == null) {\n            subscribedEvents = new ArrayList<>();\n            typesBySubscriber.put(subscriber, subscribedEvents);\n        }\n        subscribedEvents.add(eventType);\n        // 是否粘性事件\n        if (subscriberMethod.sticky) {\n            // 是否分发订阅了响应事件类父类事件的方法, 默认为true\n            if (eventInheritance) {\n                // Existing sticky events of all subclasses of eventType have to be considered.\n                // Note: Iterating over all events may be inefficient with lots of sticky events,\n                // thus data structure should be changed to allow a more efficient lookup\n                // (e.g. an additional map storing sub classes of super classes: Class -> List<Class>).\n                // stickyEvents 粘性事件集合, key为eventType的类, value是eventType对象\n                Set<Map.Entry<Class<?>, Object>> entries = stickyEvents.entrySet();\n                for (Map.Entry<Class<?>, Object> entry : entries) {\n                    // 获取候选eventType\n                    Class<?> candidateEventType = entry.getKey();\n                    // native方法, 应该是判断当前注册eventType与候选缓存的eventType是否匹配\n                    if (eventType.isAssignableFrom(candidateEventType)) {\n                        // 如果匹配, 校验并发送订阅\n                        Object stickyEvent = entry.getValue();\n                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);\n                    }\n                }\n            } else {\n                Object stickyEvent = stickyEvents.get(eventType);\n                checkPostStickyEventToSubscription(newSubscription, stickyEvent);\n            }\n        }\n    }\n```\n相关注释都在代码里, 这块的流程我们可以梳理成以下步骤:\n1. 获取我们订阅时间传输的类`EventType`, 初始化内部维护的两个集合, 分别是`subscriptionsByEventType`和`typesBySubscriber`, 根据命名我们也可以理解, 一个是根据`eventType`区分的订阅者队列, 一个是根据`subscriber`(订阅者)区分的`eventType`队列, 分别向对应的集合内添加对应新的订阅者和订阅事件\n2. 根据是否粘性事件判断是否需要调用`checkPostStickyEventToSubscription`直接发送信息给订阅者\n3. `checkPostStickyEventToSubscription`内部判断事件是否被中断来判断是否会调用到`postToSubscription`, 就是发送信息给订阅者\n\n## 发送信息\n``` java\n/**\n     * 事件发送\n     */\n    /** Posts the given event to the event bus. */\n    public void post(Object event) {\n        // currentPostingThreadState 为ThreadLocal对象\n        // 获取当前线程的发送状态\n        PostingThreadState postingState = currentPostingThreadState.get();\n        // 获取当前线程的事件发送队列\n        List<Object> eventQueue = postingState.eventQueue;\n        // 添加事件\n        eventQueue.add(event);\n        // 如果不在发送中\n        if (!postingState.isPosting) {\n            // 判断是否在主线程\n            postingState.isMainThread = isMainThread();\n            // 修改发送中状态\n            postingState.isPosting = true;\n            if (postingState.canceled) {\n                throw new EventBusException(\"Internal error. Abort state was not reset\");\n            }\n            try {\n                // 遍历发送队列事件\n                while (!eventQueue.isEmpty()) {\n                    // 从队头开始发送, 同时移除队列中的对应事件\n                    postSingleEvent(eventQueue.remove(0), postingState);\n                }\n            } finally {\n                // 修改发送中状态, 修改主线程判断\n                postingState.isPosting = false;\n                postingState.isMainThread = false;\n            }\n        }\n    }\n```\n由于在业务场景中, 无法判断发送信息在什么线程下执行的, 所以内部维护的`currentPostingThreadState`是一个`ThreadLocal`对象, 它可以保证当前线程的数据不会被其他线程共享.在`post`中, 我们就能看到`EventBus`会根据当前线程, 将事件发送给当前线程的队列中, 然后遍历执行`postSingleEvent`进行单个事件的发送, 同时移除掉队列中已发送的事件\n``` java\n/**\n     * 发送单个事件\n     * @param event\n     * @param postingState\n     * @throws Error\n     */\n    private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {\n        // event 是对应eventType的实例\n        Class<?> eventClass = event.getClass();\n        // 默认没有找到订阅者\n        boolean subscriptionFound = false;\n        // 默认true, 判断是否触发eventType的父类或接口的订阅\n        if (eventInheritance) {\n            // 查找获取所有eventType的父类和接口\n            List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);\n            int countTypes = eventTypes.size();\n            // 循环发送\n            for (int h = 0; h < countTypes; h++) {\n                Class<?> clazz = eventTypes.get(h);\n                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);\n            }\n        } else {\n            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);\n        }\n        // 如果没有找到订阅者\n        if (!subscriptionFound) {\n            if (logNoSubscriberMessages) {\n                logger.log(Level.FINE, \"No subscribers registered for event \" + eventClass);\n            }\n            // 如果我们的builder配置了sendNoSubscriberEvent(默认为true)\n            if (sendNoSubscriberEvent && eventClass != NoSubscriberEvent.class &&\n                    eventClass != SubscriberExceptionEvent.class) {\n                // 会发送一个NoSubscriberEvent的事件, 如果需要判断无订阅者时候的触发情况, 可以接收这个事件做处理\n                post(new NoSubscriberEvent(this, event));\n            }\n        }\n    }\n```\n这里的流程我们可以分成两步:\n1. 通过`postSingleEventForEventType`根据`eventType`查找对应的订阅者, 如果找到, 则发送事件\n2. 如果没有找到订阅者, 根据构造器内我们通过`sendNoSubscriberEvent`的配置, 来判断是否需要发送一个无订阅者响应事件\n\n``` java\nprivate boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {\n        CopyOnWriteArrayList<Subscription> subscriptions;\n        synchronized (this) {\n            // 根据eventType获取订阅者\n            subscriptions = subscriptionsByEventType.get(eventClass);\n        }\n        if (subscriptions != null && !subscriptions.isEmpty()) {\n            for (Subscription subscription : subscriptions) {\n                postingState.event = event;\n                postingState.subscription = subscription;\n                boolean aborted = false;\n                try {\n                    // 发送给订阅者\n                    postToSubscription(subscription, event, postingState.isMainThread);\n                    aborted = postingState.canceled;\n                } finally {\n                    postingState.event = null;\n                    postingState.subscription = null;\n                    postingState.canceled = false;\n                }\n                if (aborted) {\n                    break;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n```\n`postSingleEventForEventType`方法就执行了上面的第一步动作, 如果找到了订阅者, 就会返回true; 否则, 返回false.最终我们通过调用`postToSubscription`将事件发送给订阅者.\n咱们继续往下走.\n``` java\n/**\n     * 订阅发布\n     * @param subscription 新注册的订阅者\n     * @param event eventType\n     * @param isMainThread 是否主线程\n     */\n    private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {\n        // 订阅方法的指定线程\n        switch (subscription.subscriberMethod.threadMode) {\n            // 相同线程内\n            case POSTING:\n                invokeSubscriber(subscription, event);\n                break;\n            // 主线程内, 不阻塞\n            case MAIN:\n                if (isMainThread) {\n                    // 订阅者的调用\n                    invokeSubscriber(subscription, event);\n                } else {\n                    // 通过handler处理\n                    mainThreadPoster.enqueue(subscription, event);\n                }\n                break;\n            // 主线程, 阻塞\n            case MAIN_ORDERED:\n                if (mainThreadPoster != null) {\n                    mainThreadPoster.enqueue(subscription, event);\n                } else {\n                    // temporary: technically not correct as poster not decoupled from subscriber\n                    invokeSubscriber(subscription, event);\n                }\n                break;\n            // 后台线程,\n            case BACKGROUND:\n                if (isMainThread) {\n                    // 实现了Runnable\n                    backgroundPoster.enqueue(subscription, event);\n                } else {\n                    invokeSubscriber(subscription, event);\n                }\n                break;\n            // 异步线程\n            case ASYNC:\n                asyncPoster.enqueue(subscription, event);\n                break;\n            default:\n                throw new IllegalStateException(\"Unknown thread mode: \" + subscription.subscriberMethod.threadMode);\n        }\n    }\n```\n默认的线程模式一般是`POSTING`会走发送信息时所在的线程, 这样避免了线程切换所存在的可能开销.我们首先看下`invokeSubscriber`方法, 它的作用就是做到了订阅者的调用\n``` java\nvoid invokeSubscriber(Subscription subscription, Object event) {\n        try {\n            // 订阅方法的调用\n            subscription.subscriberMethod.method.invoke(subscription.subscriber, event);\n        } catch (InvocationTargetException e) {\n            handleSubscriberException(subscription, event, e.getCause());\n        } catch (IllegalAccessException e) {\n            throw new IllegalStateException(\"Unexpected exception\", e);\n        }\n    }\n```\n其实可以看出, 这里就是获取订阅方法, 通过反射将事件作为参数调用.\n\n我们看下走UI线程的流程, 在判断当前线程非主线程的情况下, 我们会调用到`mainThreadPoster.enqueue(subscription, event);`,\n首先, 我们回到`EventBus`的构造函数中, 找到`mainThreadPoster`的相关申明\n``` java\nmainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null;\n```\n\n``` java\npublic interface MainThreadSupport {\n\n    boolean isMainThread();\n\n    Poster createPoster(EventBus eventBus);\n\n    class AndroidHandlerMainThreadSupport implements MainThreadSupport {\n\n        private final Looper looper;\n\n        public AndroidHandlerMainThreadSupport(Looper looper) {\n            this.looper = looper;\n        }\n\n        @Override\n        public boolean isMainThread() {\n            return looper == Looper.myLooper();\n        }\n\n        @Override\n        public Poster createPoster(EventBus eventBus) {\n            return new HandlerPoster(eventBus, looper, 10);\n        }\n    }\n\n}\n```\n可以看到他是个`HandlerPoster`对象, 然后再回来看`HandlerPoster.enqueue`对应的代码\n``` java\npublic void enqueue(Subscription subscription, Object event) {\n        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);\n        synchronized (this) {\n            queue.enqueue(pendingPost);\n            if (!handlerActive) {\n                handlerActive = true;\n                if (!sendMessage(obtainMessage())) {\n                    throw new EventBusException(\"Could not send handler message\");\n                }\n            }\n        }\n    }\n```\n这里首先维护了内部的`PendingPost`, 并且将对应的`pendingPost`加入执行队列中.`HandlerPoster`继承于`Handler`, 根据他前面传入的Looper可以判定保证信息的执行是在主线程中做处理的, 现在我们看下`handleMessage`的处理\n``` java\n@Override\n    public void handleMessage(Message msg) {\n        boolean rescheduled = false;\n        try {\n            long started = SystemClock.uptimeMillis();\n            while (true) {\n                PendingPost pendingPost = queue.poll();\n                if (pendingPost == null) {\n                    synchronized (this) {\n                        // Check again, this time in synchronized\n                        pendingPost = queue.poll();\n                        if (pendingPost == null) {\n                            handlerActive = false;\n                            return;\n                        }\n                    }\n                }\n                // 调用订阅者\n                eventBus.invokeSubscriber(pendingPost);\n                long timeInMethod = SystemClock.uptimeMillis() - started;\n                if (timeInMethod >= maxMillisInsideHandleMessage) {\n                    if (!sendMessage(obtainMessage())) {\n                        throw new EventBusException(\"Could not send handler message\");\n                    }\n                    rescheduled = true;\n                    return;\n                }\n            }\n        } finally {\n            handlerActive = rescheduled;\n        }\n    }\n```\n这里做的处理, 主要就是调用了`EventBus`对象的`invokeSubscriber`方法, 最终走到了订阅者的方法的执行.\n至于其他的几个线程模式, 查看对应的`POST`也可以大致知道他的原理, 这里就暂且不表了.\n### 解绑\n相对前面的, 其实解绑的逻辑就非常简单了, 我们先看代码\n``` java\n/**\n     * 解绑\n     */\n    /** Unregisters the given subscriber from all event classes. */\n    public synchronized void unregister(Object subscriber) {\n        // 根据订阅者获取对应的eventType\n        List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);\n        // 如果不为空\n        if (subscribedTypes != null) {\n            // 遍历解绑\n            for (Class<?> eventType : subscribedTypes) {\n                unsubscribeByEventType(subscriber, eventType);\n            }\n            // 移除相关的eventType\n            typesBySubscriber.remove(subscriber);\n        } else {\n            logger.log(Level.WARNING, \"Subscriber to unregister was not registered before: \" + subscriber.getClass());\n        }\n    }\n```\n我们在绑定相关的解析中, 已经知道其实内部管理订阅事件和订阅者是通过`typesBySubscriber`和`subscriptionsByEventType`来实现的, 而这里就是移除掉与对应订阅者相关的对象即可.\n","source":"_posts/EventBus源码解析.md","raw":"title: EventBus源码解析\ndate: 2018-03-30 00:00:00\ncategories:\n- 源码解析\ntags:\n- android\n- 源码解析\n---\n### 前言\n前期加班加点赶项目, 趁着刚上线空两天,赶紧看下`EventBus`做个\"思维复健\"\n### 使用\n`EventBus`的使用非常简单, 如果使用默认的`EventBus`, 我们一般只会使用到以下三个API\n1. 绑定\n``` java\nEventBus.getDefault().regisiter(this);\n```\n2. 发送信息\n``` java\nEventBus.getDefault().post(new Event());\n```\n3. 解绑\n``` java\nEventBus.getDefault().unregisiter(this);\n```\n<!-- more -->\n### EventBus.getDefault()\n`EventBus`内部维护了一个单例, 通过`getDefault`我们可以获取默认单例来进行绑定和发送动作, 但是当我们需要进行一些关于log, 是否未有订阅者情况的响应处理时, 我们可以通过`EventBusBuilder`通过构建者模式来进行配置处理,本篇解析仅分析默认情况下的流程代码\n### 绑定\n老规矩, 我们先上代码\n``` java\npublic void register(Object subscriber) {\n        Class<?> subscriberClass = subscriber.getClass();\n        // 获取对应subscriber类的订阅方法\n        List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);\n        synchronized (this) {\n            // 遍历执行订阅\n            for (SubscriberMethod subscriberMethod : subscriberMethods) {\n                subscribe(subscriber, subscriberMethod);\n            }\n        }\n    }\n```\n我们根据传递的订阅者来获取相关的订阅方法, 然后遍历执行订阅的动作. 我们首先看下如果查找订阅者的所有订阅方法\n``` java\nList<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {\n        // 从缓存中查找订阅方法\n        List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);\n        // 缓存中有, 直接返回\n        if (subscriberMethods != null) {\n            return subscriberMethods;\n        }\n        // 查找注册方法, 默认false\n        if (ignoreGeneratedIndex) {\n            // 使用反射查找\n            subscriberMethods = findUsingReflection(subscriberClass);\n        } else {\n            // 使用注解器生成的类查找\n            subscriberMethods = findUsingInfo(subscriberClass);\n        }\n        // 如果没有订阅方法, 则抛出异常\n        if (subscriberMethods.isEmpty()) {\n            throw new EventBusException(\"Subscriber \" + subscriberClass\n                    + \" and its super classes have no public methods with the @Subscribe annotation\");\n        } else {\n            // 否则加入缓存中\n            METHOD_CACHE.put(subscriberClass, subscriberMethods);\n            return subscriberMethods;\n        }\n    }\n```\n我们知道`EventBus`3.0版本后通过`@Subscribe`注解来标注对应的订阅方法, 可以看到通过`findUsingInfo`方法查询订阅方法, 如果没有订阅方法, 会抛出异常, 而如果找到了, 则会加入缓存`METHOD_CACHE`进行内部维护, 这个方法可以优化部分性能, 减少反射带来的性能问题.\n我们在往`findUsingInfo`里看, 会发现如果找不到相关订阅者信息的时候, 仍会通过反射来寻找.\n``` java\nprivate List<SubscriberMethod> findUsingInfo(Class<?> subscriberClass) {\n        FindState findState = prepareFindState();\n        findState.initForSubscriber(subscriberClass);\n        while (findState.clazz != null) {\n            findState.subscriberInfo = getSubscriberInfo(findState);\n            if (findState.subscriberInfo != null) {\n                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();\n                // 遍历订阅者方法\n                for (SubscriberMethod subscriberMethod : array) {\n                    if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {\n                        findState.subscriberMethods.add(subscriberMethod);\n                    }\n                }\n            } else {\n                // 没有订阅信息, 从反射来找\n                findUsingReflectionInSingleClass(findState);\n            }\n            findState.moveToSuperclass();\n        }\n        return getMethodsAndRelease(findState);\n    }\n```\n我们回头去看`subscribe`订阅动作的执行代码\n``` java\n/**\n     * 订阅动作\n     * @param subscriber         订阅者(类似订阅的Activity之类)\n     * @param subscriberMethod   订阅事件方法, 比如加了@Subscribe注解的方法\n     */\n    private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {\n        // 订阅事件的类, 比如平常传递的自己写的EventLogin等等..\n        Class<?> eventType = subscriberMethod.eventType;\n        Subscription newSubscription = new Subscription(subscriber, subscriberMethod);\n        // 获取与eventType有关的订阅事件的队列\n        CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);\n        // 如果为空\n        if (subscriptions == null) {\n            // 初始队列\n            subscriptions = new CopyOnWriteArrayList<>();\n            subscriptionsByEventType.put(eventType, subscriptions);\n        } else {\n            // 如果管理的订阅队列存在新的订阅事件, 则抛出已注册事件的异常\n            if (subscriptions.contains(newSubscription)) {\n                throw new EventBusException(\"Subscriber \" + subscriber.getClass() + \" already registered to event \"\n                        + eventType);\n            }\n        }\n        int size = subscriptions.size();\n        // 遍历订阅的事件\n        for (int i = 0; i <= size; i++) {\n            // 根据优先级, 插入订阅事件\n            if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {\n                subscriptions.add(i, newSubscription);\n                break;\n            }\n        }\n        // 以订阅者为key, value为订阅事件的类的队列\n        List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);\n        if (subscribedEvents == null) {\n            subscribedEvents = new ArrayList<>();\n            typesBySubscriber.put(subscriber, subscribedEvents);\n        }\n        subscribedEvents.add(eventType);\n        // 是否粘性事件\n        if (subscriberMethod.sticky) {\n            // 是否分发订阅了响应事件类父类事件的方法, 默认为true\n            if (eventInheritance) {\n                // Existing sticky events of all subclasses of eventType have to be considered.\n                // Note: Iterating over all events may be inefficient with lots of sticky events,\n                // thus data structure should be changed to allow a more efficient lookup\n                // (e.g. an additional map storing sub classes of super classes: Class -> List<Class>).\n                // stickyEvents 粘性事件集合, key为eventType的类, value是eventType对象\n                Set<Map.Entry<Class<?>, Object>> entries = stickyEvents.entrySet();\n                for (Map.Entry<Class<?>, Object> entry : entries) {\n                    // 获取候选eventType\n                    Class<?> candidateEventType = entry.getKey();\n                    // native方法, 应该是判断当前注册eventType与候选缓存的eventType是否匹配\n                    if (eventType.isAssignableFrom(candidateEventType)) {\n                        // 如果匹配, 校验并发送订阅\n                        Object stickyEvent = entry.getValue();\n                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);\n                    }\n                }\n            } else {\n                Object stickyEvent = stickyEvents.get(eventType);\n                checkPostStickyEventToSubscription(newSubscription, stickyEvent);\n            }\n        }\n    }\n```\n相关注释都在代码里, 这块的流程我们可以梳理成以下步骤:\n1. 获取我们订阅时间传输的类`EventType`, 初始化内部维护的两个集合, 分别是`subscriptionsByEventType`和`typesBySubscriber`, 根据命名我们也可以理解, 一个是根据`eventType`区分的订阅者队列, 一个是根据`subscriber`(订阅者)区分的`eventType`队列, 分别向对应的集合内添加对应新的订阅者和订阅事件\n2. 根据是否粘性事件判断是否需要调用`checkPostStickyEventToSubscription`直接发送信息给订阅者\n3. `checkPostStickyEventToSubscription`内部判断事件是否被中断来判断是否会调用到`postToSubscription`, 就是发送信息给订阅者\n\n## 发送信息\n``` java\n/**\n     * 事件发送\n     */\n    /** Posts the given event to the event bus. */\n    public void post(Object event) {\n        // currentPostingThreadState 为ThreadLocal对象\n        // 获取当前线程的发送状态\n        PostingThreadState postingState = currentPostingThreadState.get();\n        // 获取当前线程的事件发送队列\n        List<Object> eventQueue = postingState.eventQueue;\n        // 添加事件\n        eventQueue.add(event);\n        // 如果不在发送中\n        if (!postingState.isPosting) {\n            // 判断是否在主线程\n            postingState.isMainThread = isMainThread();\n            // 修改发送中状态\n            postingState.isPosting = true;\n            if (postingState.canceled) {\n                throw new EventBusException(\"Internal error. Abort state was not reset\");\n            }\n            try {\n                // 遍历发送队列事件\n                while (!eventQueue.isEmpty()) {\n                    // 从队头开始发送, 同时移除队列中的对应事件\n                    postSingleEvent(eventQueue.remove(0), postingState);\n                }\n            } finally {\n                // 修改发送中状态, 修改主线程判断\n                postingState.isPosting = false;\n                postingState.isMainThread = false;\n            }\n        }\n    }\n```\n由于在业务场景中, 无法判断发送信息在什么线程下执行的, 所以内部维护的`currentPostingThreadState`是一个`ThreadLocal`对象, 它可以保证当前线程的数据不会被其他线程共享.在`post`中, 我们就能看到`EventBus`会根据当前线程, 将事件发送给当前线程的队列中, 然后遍历执行`postSingleEvent`进行单个事件的发送, 同时移除掉队列中已发送的事件\n``` java\n/**\n     * 发送单个事件\n     * @param event\n     * @param postingState\n     * @throws Error\n     */\n    private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {\n        // event 是对应eventType的实例\n        Class<?> eventClass = event.getClass();\n        // 默认没有找到订阅者\n        boolean subscriptionFound = false;\n        // 默认true, 判断是否触发eventType的父类或接口的订阅\n        if (eventInheritance) {\n            // 查找获取所有eventType的父类和接口\n            List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);\n            int countTypes = eventTypes.size();\n            // 循环发送\n            for (int h = 0; h < countTypes; h++) {\n                Class<?> clazz = eventTypes.get(h);\n                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);\n            }\n        } else {\n            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);\n        }\n        // 如果没有找到订阅者\n        if (!subscriptionFound) {\n            if (logNoSubscriberMessages) {\n                logger.log(Level.FINE, \"No subscribers registered for event \" + eventClass);\n            }\n            // 如果我们的builder配置了sendNoSubscriberEvent(默认为true)\n            if (sendNoSubscriberEvent && eventClass != NoSubscriberEvent.class &&\n                    eventClass != SubscriberExceptionEvent.class) {\n                // 会发送一个NoSubscriberEvent的事件, 如果需要判断无订阅者时候的触发情况, 可以接收这个事件做处理\n                post(new NoSubscriberEvent(this, event));\n            }\n        }\n    }\n```\n这里的流程我们可以分成两步:\n1. 通过`postSingleEventForEventType`根据`eventType`查找对应的订阅者, 如果找到, 则发送事件\n2. 如果没有找到订阅者, 根据构造器内我们通过`sendNoSubscriberEvent`的配置, 来判断是否需要发送一个无订阅者响应事件\n\n``` java\nprivate boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {\n        CopyOnWriteArrayList<Subscription> subscriptions;\n        synchronized (this) {\n            // 根据eventType获取订阅者\n            subscriptions = subscriptionsByEventType.get(eventClass);\n        }\n        if (subscriptions != null && !subscriptions.isEmpty()) {\n            for (Subscription subscription : subscriptions) {\n                postingState.event = event;\n                postingState.subscription = subscription;\n                boolean aborted = false;\n                try {\n                    // 发送给订阅者\n                    postToSubscription(subscription, event, postingState.isMainThread);\n                    aborted = postingState.canceled;\n                } finally {\n                    postingState.event = null;\n                    postingState.subscription = null;\n                    postingState.canceled = false;\n                }\n                if (aborted) {\n                    break;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n```\n`postSingleEventForEventType`方法就执行了上面的第一步动作, 如果找到了订阅者, 就会返回true; 否则, 返回false.最终我们通过调用`postToSubscription`将事件发送给订阅者.\n咱们继续往下走.\n``` java\n/**\n     * 订阅发布\n     * @param subscription 新注册的订阅者\n     * @param event eventType\n     * @param isMainThread 是否主线程\n     */\n    private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {\n        // 订阅方法的指定线程\n        switch (subscription.subscriberMethod.threadMode) {\n            // 相同线程内\n            case POSTING:\n                invokeSubscriber(subscription, event);\n                break;\n            // 主线程内, 不阻塞\n            case MAIN:\n                if (isMainThread) {\n                    // 订阅者的调用\n                    invokeSubscriber(subscription, event);\n                } else {\n                    // 通过handler处理\n                    mainThreadPoster.enqueue(subscription, event);\n                }\n                break;\n            // 主线程, 阻塞\n            case MAIN_ORDERED:\n                if (mainThreadPoster != null) {\n                    mainThreadPoster.enqueue(subscription, event);\n                } else {\n                    // temporary: technically not correct as poster not decoupled from subscriber\n                    invokeSubscriber(subscription, event);\n                }\n                break;\n            // 后台线程,\n            case BACKGROUND:\n                if (isMainThread) {\n                    // 实现了Runnable\n                    backgroundPoster.enqueue(subscription, event);\n                } else {\n                    invokeSubscriber(subscription, event);\n                }\n                break;\n            // 异步线程\n            case ASYNC:\n                asyncPoster.enqueue(subscription, event);\n                break;\n            default:\n                throw new IllegalStateException(\"Unknown thread mode: \" + subscription.subscriberMethod.threadMode);\n        }\n    }\n```\n默认的线程模式一般是`POSTING`会走发送信息时所在的线程, 这样避免了线程切换所存在的可能开销.我们首先看下`invokeSubscriber`方法, 它的作用就是做到了订阅者的调用\n``` java\nvoid invokeSubscriber(Subscription subscription, Object event) {\n        try {\n            // 订阅方法的调用\n            subscription.subscriberMethod.method.invoke(subscription.subscriber, event);\n        } catch (InvocationTargetException e) {\n            handleSubscriberException(subscription, event, e.getCause());\n        } catch (IllegalAccessException e) {\n            throw new IllegalStateException(\"Unexpected exception\", e);\n        }\n    }\n```\n其实可以看出, 这里就是获取订阅方法, 通过反射将事件作为参数调用.\n\n我们看下走UI线程的流程, 在判断当前线程非主线程的情况下, 我们会调用到`mainThreadPoster.enqueue(subscription, event);`,\n首先, 我们回到`EventBus`的构造函数中, 找到`mainThreadPoster`的相关申明\n``` java\nmainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null;\n```\n\n``` java\npublic interface MainThreadSupport {\n\n    boolean isMainThread();\n\n    Poster createPoster(EventBus eventBus);\n\n    class AndroidHandlerMainThreadSupport implements MainThreadSupport {\n\n        private final Looper looper;\n\n        public AndroidHandlerMainThreadSupport(Looper looper) {\n            this.looper = looper;\n        }\n\n        @Override\n        public boolean isMainThread() {\n            return looper == Looper.myLooper();\n        }\n\n        @Override\n        public Poster createPoster(EventBus eventBus) {\n            return new HandlerPoster(eventBus, looper, 10);\n        }\n    }\n\n}\n```\n可以看到他是个`HandlerPoster`对象, 然后再回来看`HandlerPoster.enqueue`对应的代码\n``` java\npublic void enqueue(Subscription subscription, Object event) {\n        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);\n        synchronized (this) {\n            queue.enqueue(pendingPost);\n            if (!handlerActive) {\n                handlerActive = true;\n                if (!sendMessage(obtainMessage())) {\n                    throw new EventBusException(\"Could not send handler message\");\n                }\n            }\n        }\n    }\n```\n这里首先维护了内部的`PendingPost`, 并且将对应的`pendingPost`加入执行队列中.`HandlerPoster`继承于`Handler`, 根据他前面传入的Looper可以判定保证信息的执行是在主线程中做处理的, 现在我们看下`handleMessage`的处理\n``` java\n@Override\n    public void handleMessage(Message msg) {\n        boolean rescheduled = false;\n        try {\n            long started = SystemClock.uptimeMillis();\n            while (true) {\n                PendingPost pendingPost = queue.poll();\n                if (pendingPost == null) {\n                    synchronized (this) {\n                        // Check again, this time in synchronized\n                        pendingPost = queue.poll();\n                        if (pendingPost == null) {\n                            handlerActive = false;\n                            return;\n                        }\n                    }\n                }\n                // 调用订阅者\n                eventBus.invokeSubscriber(pendingPost);\n                long timeInMethod = SystemClock.uptimeMillis() - started;\n                if (timeInMethod >= maxMillisInsideHandleMessage) {\n                    if (!sendMessage(obtainMessage())) {\n                        throw new EventBusException(\"Could not send handler message\");\n                    }\n                    rescheduled = true;\n                    return;\n                }\n            }\n        } finally {\n            handlerActive = rescheduled;\n        }\n    }\n```\n这里做的处理, 主要就是调用了`EventBus`对象的`invokeSubscriber`方法, 最终走到了订阅者的方法的执行.\n至于其他的几个线程模式, 查看对应的`POST`也可以大致知道他的原理, 这里就暂且不表了.\n### 解绑\n相对前面的, 其实解绑的逻辑就非常简单了, 我们先看代码\n``` java\n/**\n     * 解绑\n     */\n    /** Unregisters the given subscriber from all event classes. */\n    public synchronized void unregister(Object subscriber) {\n        // 根据订阅者获取对应的eventType\n        List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);\n        // 如果不为空\n        if (subscribedTypes != null) {\n            // 遍历解绑\n            for (Class<?> eventType : subscribedTypes) {\n                unsubscribeByEventType(subscriber, eventType);\n            }\n            // 移除相关的eventType\n            typesBySubscriber.remove(subscriber);\n        } else {\n            logger.log(Level.WARNING, \"Subscriber to unregister was not registered before: \" + subscriber.getClass());\n        }\n    }\n```\n我们在绑定相关的解析中, 已经知道其实内部管理订阅事件和订阅者是通过`typesBySubscriber`和`subscriptionsByEventType`来实现的, 而这里就是移除掉与对应订阅者相关的对象即可.\n","slug":"EventBus源码解析","published":1,"updated":"2018-05-07T02:03:50.325Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjld5ah48002ccqs6cocmnt6e","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>前期加班加点赶项目, 趁着刚上线空两天,赶紧看下<code>EventBus</code>做个”思维复健”</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p><code>EventBus</code>的使用非常简单, 如果使用默认的<code>EventBus</code>, 我们一般只会使用到以下三个API</p>\n<ol>\n<li><p>绑定</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBus.getDefault().regisiter(<span class=\"keyword\">this</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>发送信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBus.getDefault().post(<span class=\"keyword\">new</span> Event());</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解绑</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBus.getDefault().unregisiter(<span class=\"keyword\">this</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<a id=\"more\"></a>\n<h3 id=\"EventBus-getDefault\"><a href=\"#EventBus-getDefault\" class=\"headerlink\" title=\"EventBus.getDefault()\"></a>EventBus.getDefault()</h3><p><code>EventBus</code>内部维护了一个单例, 通过<code>getDefault</code>我们可以获取默认单例来进行绑定和发送动作, 但是当我们需要进行一些关于log, 是否未有订阅者情况的响应处理时, 我们可以通过<code>EventBusBuilder</code>通过构建者模式来进行配置处理,本篇解析仅分析默认情况下的流程代码</p>\n<h3 id=\"绑定\"><a href=\"#绑定\" class=\"headerlink\" title=\"绑定\"></a>绑定</h3><p>老规矩, 我们先上代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(Object subscriber)</span> </span>&#123;</span><br><span class=\"line\">        Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class=\"line\">        <span class=\"comment\">// 获取对应subscriber类的订阅方法</span></span><br><span class=\"line\">        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 遍历执行订阅</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class=\"line\">                subscribe(subscriber, subscriberMethod);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们根据传递的订阅者来获取相关的订阅方法, 然后遍历执行订阅的动作. 我们首先看下如果查找订阅者的所有订阅方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">List&lt;SubscriberMethod&gt; <span class=\"title\">findSubscriberMethods</span><span class=\"params\">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从缓存中查找订阅方法</span></span><br><span class=\"line\">        List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class=\"line\">        <span class=\"comment\">// 缓存中有, 直接返回</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscriberMethods != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> subscriberMethods;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 查找注册方法, 默认false</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用反射查找</span></span><br><span class=\"line\">            subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用注解器生成的类查找</span></span><br><span class=\"line\">            subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果没有订阅方法, 则抛出异常</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(<span class=\"string\">\"Subscriber \"</span> + subscriberClass</span><br><span class=\"line\">                    + <span class=\"string\">\" and its super classes have no public methods with the @Subscribe annotation\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 否则加入缓存中</span></span><br><span class=\"line\">            METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> subscriberMethods;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们知道<code>EventBus</code>3.0版本后通过<code>@Subscribe</code>注解来标注对应的订阅方法, 可以看到通过<code>findUsingInfo</code>方法查询订阅方法, 如果没有订阅方法, 会抛出异常, 而如果找到了, 则会加入缓存<code>METHOD_CACHE</code>进行内部维护, 这个方法可以优化部分性能, 减少反射带来的性能问题.<br>我们在往<code>findUsingInfo</code>里看, 会发现如果找不到相关订阅者信息的时候, 仍会通过反射来寻找.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> List&lt;SubscriberMethod&gt; <span class=\"title\">findUsingInfo</span><span class=\"params\">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class=\"line\">        FindState findState = prepareFindState();</span><br><span class=\"line\">        findState.initForSubscriber(subscriberClass);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (findState.clazz != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (findState.subscriberInfo != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class=\"line\">                <span class=\"comment\">// 遍历订阅者方法</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class=\"line\">                        findState.subscriberMethods.add(subscriberMethod);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 没有订阅信息, 从反射来找</span></span><br><span class=\"line\">                findUsingReflectionInSingleClass(findState);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            findState.moveToSuperclass();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getMethodsAndRelease(findState);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们回头去看<code>subscribe</code>订阅动作的执行代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 订阅动作</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> subscriber         订阅者(类似订阅的Activity之类)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> subscriberMethod   订阅事件方法, 比如加了<span class=\"doctag\">@Subscribe</span>注解的方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 订阅事件的类, 比如平常传递的自己写的EventLogin等等..</span></span><br><span class=\"line\">        Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class=\"line\">        Subscription newSubscription = <span class=\"keyword\">new</span> Subscription(subscriber, subscriberMethod);</span><br><span class=\"line\">        <span class=\"comment\">// 获取与eventType有关的订阅事件的队列</span></span><br><span class=\"line\">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class=\"line\">        <span class=\"comment\">// 如果为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscriptions == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 初始队列</span></span><br><span class=\"line\">            subscriptions = <span class=\"keyword\">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class=\"line\">            subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果管理的订阅队列存在新的订阅事件, 则抛出已注册事件的异常</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(<span class=\"string\">\"Subscriber \"</span> + subscriber.getClass() + <span class=\"string\">\" already registered to event \"</span></span><br><span class=\"line\">                        + eventType);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> size = subscriptions.size();</span><br><span class=\"line\">        <span class=\"comment\">// 遍历订阅的事件</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= size; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 根据优先级, 插入订阅事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class=\"line\">                subscriptions.add(i, newSubscription);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 以订阅者为key, value为订阅事件的类的队列</span></span><br><span class=\"line\">        List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscribedEvents == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            subscribedEvents = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">            typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        subscribedEvents.add(eventType);</span><br><span class=\"line\">        <span class=\"comment\">// 是否粘性事件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscriberMethod.sticky) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 是否分发订阅了响应事件类父类事件的方法, 默认为true</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (eventInheritance) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Existing sticky events of all subclasses of eventType have to be considered.</span></span><br><span class=\"line\">                <span class=\"comment\">// Note: Iterating over all events may be inefficient with lots of sticky events,</span></span><br><span class=\"line\">                <span class=\"comment\">// thus data structure should be changed to allow a more efficient lookup</span></span><br><span class=\"line\">                <span class=\"comment\">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></span><br><span class=\"line\">                <span class=\"comment\">// stickyEvents 粘性事件集合, key为eventType的类, value是eventType对象</span></span><br><span class=\"line\">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 获取候选eventType</span></span><br><span class=\"line\">                    Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class=\"line\">                    <span class=\"comment\">// native方法, 应该是判断当前注册eventType与候选缓存的eventType是否匹配</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 如果匹配, 校验并发送订阅</span></span><br><span class=\"line\">                        Object stickyEvent = entry.getValue();</span><br><span class=\"line\">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                Object stickyEvent = stickyEvents.get(eventType);</span><br><span class=\"line\">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>相关注释都在代码里, 这块的流程我们可以梳理成以下步骤:</p>\n<ol>\n<li>获取我们订阅时间传输的类<code>EventType</code>, 初始化内部维护的两个集合, 分别是<code>subscriptionsByEventType</code>和<code>typesBySubscriber</code>, 根据命名我们也可以理解, 一个是根据<code>eventType</code>区分的订阅者队列, 一个是根据<code>subscriber</code>(订阅者)区分的<code>eventType</code>队列, 分别向对应的集合内添加对应新的订阅者和订阅事件</li>\n<li>根据是否粘性事件判断是否需要调用<code>checkPostStickyEventToSubscription</code>直接发送信息给订阅者</li>\n<li><code>checkPostStickyEventToSubscription</code>内部判断事件是否被中断来判断是否会调用到<code>postToSubscription</code>, 就是发送信息给订阅者</li>\n</ol>\n<h2 id=\"发送信息\"><a href=\"#发送信息\" class=\"headerlink\" title=\"发送信息\"></a>发送信息</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 事件发送</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"comment\">/** Posts the given event to the event bus. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">post</span><span class=\"params\">(Object event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// currentPostingThreadState 为ThreadLocal对象</span></span><br><span class=\"line\">        <span class=\"comment\">// 获取当前线程的发送状态</span></span><br><span class=\"line\">        PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前线程的事件发送队列</span></span><br><span class=\"line\">        List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class=\"line\">        <span class=\"comment\">// 添加事件</span></span><br><span class=\"line\">        eventQueue.add(event);</span><br><span class=\"line\">        <span class=\"comment\">// 如果不在发送中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!postingState.isPosting) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断是否在主线程</span></span><br><span class=\"line\">            postingState.isMainThread = isMainThread();</span><br><span class=\"line\">            <span class=\"comment\">// 修改发送中状态</span></span><br><span class=\"line\">            postingState.isPosting = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (postingState.canceled) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(<span class=\"string\">\"Internal error. Abort state was not reset\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 遍历发送队列事件</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 从队头开始发送, 同时移除队列中的对应事件</span></span><br><span class=\"line\">                    postSingleEvent(eventQueue.remove(<span class=\"number\">0</span>), postingState);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 修改发送中状态, 修改主线程判断</span></span><br><span class=\"line\">                postingState.isPosting = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                postingState.isMainThread = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>由于在业务场景中, 无法判断发送信息在什么线程下执行的, 所以内部维护的<code>currentPostingThreadState</code>是一个<code>ThreadLocal</code>对象, 它可以保证当前线程的数据不会被其他线程共享.在<code>post</code>中, 我们就能看到<code>EventBus</code>会根据当前线程, 将事件发送给当前线程的队列中, 然后遍历执行<code>postSingleEvent</code>进行单个事件的发送, 同时移除掉队列中已发送的事件<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 发送单个事件</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> event</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> postingState</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Error</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">postSingleEvent</span><span class=\"params\">(Object event, PostingThreadState postingState)</span> <span class=\"keyword\">throws</span> Error </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// event 是对应eventType的实例</span></span><br><span class=\"line\">        Class&lt;?&gt; eventClass = event.getClass();</span><br><span class=\"line\">        <span class=\"comment\">// 默认没有找到订阅者</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> subscriptionFound = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 默认true, 判断是否触发eventType的父类或接口的订阅</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (eventInheritance) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 查找获取所有eventType的父类和接口</span></span><br><span class=\"line\">            List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> countTypes = eventTypes.size();</span><br><span class=\"line\">            <span class=\"comment\">// 循环发送</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> h = <span class=\"number\">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class=\"line\">                Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class=\"line\">                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果没有找到订阅者</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!subscriptionFound) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (logNoSubscriberMessages) &#123;</span><br><span class=\"line\">                logger.log(Level.FINE, <span class=\"string\">\"No subscribers registered for event \"</span> + eventClass);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果我们的builder配置了sendNoSubscriberEvent(默认为true)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class=\"line\">                    eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 会发送一个NoSubscriberEvent的事件, 如果需要判断无订阅者时候的触发情况, 可以接收这个事件做处理</span></span><br><span class=\"line\">                post(<span class=\"keyword\">new</span> NoSubscriberEvent(<span class=\"keyword\">this</span>, event));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的流程我们可以分成两步:</p>\n<ol>\n<li>通过<code>postSingleEventForEventType</code>根据<code>eventType</code>查找对应的订阅者, 如果找到, 则发送事件</li>\n<li>如果没有找到订阅者, 根据构造器内我们通过<code>sendNoSubscriberEvent</code>的配置, 来判断是否需要发送一个无订阅者响应事件</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">postSingleEventForEventType</span><span class=\"params\">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class=\"line\">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 根据eventType获取订阅者</span></span><br><span class=\"line\">            subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscriptions != <span class=\"keyword\">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class=\"line\">                postingState.event = event;</span><br><span class=\"line\">                postingState.subscription = subscription;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> aborted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 发送给订阅者</span></span><br><span class=\"line\">                    postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class=\"line\">                    aborted = postingState.canceled;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    postingState.event = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    postingState.subscription = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    postingState.canceled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (aborted) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><code>postSingleEventForEventType</code>方法就执行了上面的第一步动作, 如果找到了订阅者, 就会返回true; 否则, 返回false.最终我们通过调用<code>postToSubscription</code>将事件发送给订阅者.<br>咱们继续往下走.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 订阅发布</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> subscription 新注册的订阅者</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> event eventType</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> isMainThread 是否主线程</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">postToSubscription</span><span class=\"params\">(Subscription subscription, Object event, <span class=\"keyword\">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 订阅方法的指定线程</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 相同线程内</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> POSTING:</span><br><span class=\"line\">                invokeSubscriber(subscription, event);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 主线程内, 不阻塞</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> MAIN:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isMainThread) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 订阅者的调用</span></span><br><span class=\"line\">                    invokeSubscriber(subscription, event);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 通过handler处理</span></span><br><span class=\"line\">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 主线程, 阻塞</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> MAIN_ORDERED:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mainThreadPoster != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// temporary: technically not correct as poster not decoupled from subscriber</span></span><br><span class=\"line\">                    invokeSubscriber(subscription, event);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 后台线程,</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> BACKGROUND:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isMainThread) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 实现了Runnable</span></span><br><span class=\"line\">                    backgroundPoster.enqueue(subscription, event);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    invokeSubscriber(subscription, event);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 异步线程</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> ASYNC:</span><br><span class=\"line\">                asyncPoster.enqueue(subscription, event);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Unknown thread mode: \"</span> + subscription.subscriberMethod.threadMode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>默认的线程模式一般是<code>POSTING</code>会走发送信息时所在的线程, 这样避免了线程切换所存在的可能开销.我们首先看下<code>invokeSubscriber</code>方法, 它的作用就是做到了订阅者的调用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">invokeSubscriber</span><span class=\"params\">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 订阅方法的调用</span></span><br><span class=\"line\">            subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InvocationTargetException e) &#123;</span><br><span class=\"line\">            handleSubscriberException(subscription, event, e.getCause());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Unexpected exception\"</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>其实可以看出, 这里就是获取订阅方法, 通过反射将事件作为参数调用.</p>\n<p>我们看下走UI线程的流程, 在判断当前线程非主线程的情况下, 我们会调用到<code>mainThreadPoster.enqueue(subscription, event);</code>,<br>首先, 我们回到<code>EventBus</code>的构造函数中, 找到<code>mainThreadPoster</code>的相关申明<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mainThreadPoster = mainThreadSupport != <span class=\"keyword\">null</span> ? mainThreadSupport.createPoster(<span class=\"keyword\">this</span>) : <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MainThreadSupport</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isMainThread</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Poster <span class=\"title\">createPoster</span><span class=\"params\">(EventBus eventBus)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AndroidHandlerMainThreadSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">MainThreadSupport</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Looper looper;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AndroidHandlerMainThreadSupport</span><span class=\"params\">(Looper looper)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.looper = looper;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMainThread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> looper == Looper.myLooper();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Poster <span class=\"title\">createPoster</span><span class=\"params\">(EventBus eventBus)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> HandlerPoster(eventBus, looper, <span class=\"number\">10</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到他是个<code>HandlerPoster</code>对象, 然后再回来看<code>HandlerPoster.enqueue</code>对应的代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class=\"line\">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            queue.enqueue(pendingPost);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!handlerActive) &#123;</span><br><span class=\"line\">                handlerActive = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(<span class=\"string\">\"Could not send handler message\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里首先维护了内部的<code>PendingPost</code>, 并且将对应的<code>pendingPost</code>加入执行队列中.<code>HandlerPoster</code>继承于<code>Handler</code>, 根据他前面传入的Looper可以判定保证信息的执行是在主线程中做处理的, 现在我们看下<code>handleMessage</code>的处理<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> rescheduled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> started = SystemClock.uptimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                PendingPost pendingPost = queue.poll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (pendingPost == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// Check again, this time in synchronized</span></span><br><span class=\"line\">                        pendingPost = queue.poll();</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (pendingPost == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            handlerActive = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 调用订阅者</span></span><br><span class=\"line\">                eventBus.invokeSubscriber(pendingPost);</span><br><span class=\"line\">                <span class=\"keyword\">long</span> timeInMethod = SystemClock.uptimeMillis() - started;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(<span class=\"string\">\"Could not send handler message\"</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    rescheduled = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            handlerActive = rescheduled;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里做的处理, 主要就是调用了<code>EventBus</code>对象的<code>invokeSubscriber</code>方法, 最终走到了订阅者的方法的执行.<br>至于其他的几个线程模式, 查看对应的<code>POST</code>也可以大致知道他的原理, 这里就暂且不表了.</p>\n<h3 id=\"解绑\"><a href=\"#解绑\" class=\"headerlink\" title=\"解绑\"></a>解绑</h3><p>相对前面的, 其实解绑的逻辑就非常简单了, 我们先看代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 解绑</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"comment\">/** Unregisters the given subscriber from all event classes. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">unregister</span><span class=\"params\">(Object subscriber)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据订阅者获取对应的eventType</span></span><br><span class=\"line\">        List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class=\"line\">        <span class=\"comment\">// 如果不为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscribedTypes != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 遍历解绑</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class=\"line\">                unsubscribeByEventType(subscriber, eventType);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 移除相关的eventType</span></span><br><span class=\"line\">            typesBySubscriber.remove(subscriber);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            logger.log(Level.WARNING, <span class=\"string\">\"Subscriber to unregister was not registered before: \"</span> + subscriber.getClass());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们在绑定相关的解析中, 已经知道其实内部管理订阅事件和订阅者是通过<code>typesBySubscriber</code>和<code>subscriptionsByEventType</code>来实现的, 而这里就是移除掉与对应订阅者相关的对象即可.</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>前期加班加点赶项目, 趁着刚上线空两天,赶紧看下<code>EventBus</code>做个”思维复健”</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p><code>EventBus</code>的使用非常简单, 如果使用默认的<code>EventBus</code>, 我们一般只会使用到以下三个API</p>\n<ol>\n<li><p>绑定</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBus.getDefault().regisiter(<span class=\"keyword\">this</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>发送信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBus.getDefault().post(<span class=\"keyword\">new</span> Event());</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解绑</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBus.getDefault().unregisiter(<span class=\"keyword\">this</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>","more":"<h3 id=\"EventBus-getDefault\"><a href=\"#EventBus-getDefault\" class=\"headerlink\" title=\"EventBus.getDefault()\"></a>EventBus.getDefault()</h3><p><code>EventBus</code>内部维护了一个单例, 通过<code>getDefault</code>我们可以获取默认单例来进行绑定和发送动作, 但是当我们需要进行一些关于log, 是否未有订阅者情况的响应处理时, 我们可以通过<code>EventBusBuilder</code>通过构建者模式来进行配置处理,本篇解析仅分析默认情况下的流程代码</p>\n<h3 id=\"绑定\"><a href=\"#绑定\" class=\"headerlink\" title=\"绑定\"></a>绑定</h3><p>老规矩, 我们先上代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(Object subscriber)</span> </span>&#123;</span><br><span class=\"line\">        Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class=\"line\">        <span class=\"comment\">// 获取对应subscriber类的订阅方法</span></span><br><span class=\"line\">        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 遍历执行订阅</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class=\"line\">                subscribe(subscriber, subscriberMethod);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们根据传递的订阅者来获取相关的订阅方法, 然后遍历执行订阅的动作. 我们首先看下如果查找订阅者的所有订阅方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">List&lt;SubscriberMethod&gt; <span class=\"title\">findSubscriberMethods</span><span class=\"params\">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从缓存中查找订阅方法</span></span><br><span class=\"line\">        List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class=\"line\">        <span class=\"comment\">// 缓存中有, 直接返回</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscriberMethods != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> subscriberMethods;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 查找注册方法, 默认false</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用反射查找</span></span><br><span class=\"line\">            subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用注解器生成的类查找</span></span><br><span class=\"line\">            subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果没有订阅方法, 则抛出异常</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(<span class=\"string\">\"Subscriber \"</span> + subscriberClass</span><br><span class=\"line\">                    + <span class=\"string\">\" and its super classes have no public methods with the @Subscribe annotation\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 否则加入缓存中</span></span><br><span class=\"line\">            METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> subscriberMethods;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们知道<code>EventBus</code>3.0版本后通过<code>@Subscribe</code>注解来标注对应的订阅方法, 可以看到通过<code>findUsingInfo</code>方法查询订阅方法, 如果没有订阅方法, 会抛出异常, 而如果找到了, 则会加入缓存<code>METHOD_CACHE</code>进行内部维护, 这个方法可以优化部分性能, 减少反射带来的性能问题.<br>我们在往<code>findUsingInfo</code>里看, 会发现如果找不到相关订阅者信息的时候, 仍会通过反射来寻找.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> List&lt;SubscriberMethod&gt; <span class=\"title\">findUsingInfo</span><span class=\"params\">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class=\"line\">        FindState findState = prepareFindState();</span><br><span class=\"line\">        findState.initForSubscriber(subscriberClass);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (findState.clazz != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (findState.subscriberInfo != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class=\"line\">                <span class=\"comment\">// 遍历订阅者方法</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class=\"line\">                        findState.subscriberMethods.add(subscriberMethod);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 没有订阅信息, 从反射来找</span></span><br><span class=\"line\">                findUsingReflectionInSingleClass(findState);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            findState.moveToSuperclass();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getMethodsAndRelease(findState);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们回头去看<code>subscribe</code>订阅动作的执行代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 订阅动作</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> subscriber         订阅者(类似订阅的Activity之类)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> subscriberMethod   订阅事件方法, 比如加了<span class=\"doctag\">@Subscribe</span>注解的方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 订阅事件的类, 比如平常传递的自己写的EventLogin等等..</span></span><br><span class=\"line\">        Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class=\"line\">        Subscription newSubscription = <span class=\"keyword\">new</span> Subscription(subscriber, subscriberMethod);</span><br><span class=\"line\">        <span class=\"comment\">// 获取与eventType有关的订阅事件的队列</span></span><br><span class=\"line\">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class=\"line\">        <span class=\"comment\">// 如果为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscriptions == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 初始队列</span></span><br><span class=\"line\">            subscriptions = <span class=\"keyword\">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class=\"line\">            subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果管理的订阅队列存在新的订阅事件, 则抛出已注册事件的异常</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(<span class=\"string\">\"Subscriber \"</span> + subscriber.getClass() + <span class=\"string\">\" already registered to event \"</span></span><br><span class=\"line\">                        + eventType);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> size = subscriptions.size();</span><br><span class=\"line\">        <span class=\"comment\">// 遍历订阅的事件</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= size; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 根据优先级, 插入订阅事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class=\"line\">                subscriptions.add(i, newSubscription);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 以订阅者为key, value为订阅事件的类的队列</span></span><br><span class=\"line\">        List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscribedEvents == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            subscribedEvents = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">            typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        subscribedEvents.add(eventType);</span><br><span class=\"line\">        <span class=\"comment\">// 是否粘性事件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscriberMethod.sticky) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 是否分发订阅了响应事件类父类事件的方法, 默认为true</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (eventInheritance) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Existing sticky events of all subclasses of eventType have to be considered.</span></span><br><span class=\"line\">                <span class=\"comment\">// Note: Iterating over all events may be inefficient with lots of sticky events,</span></span><br><span class=\"line\">                <span class=\"comment\">// thus data structure should be changed to allow a more efficient lookup</span></span><br><span class=\"line\">                <span class=\"comment\">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></span><br><span class=\"line\">                <span class=\"comment\">// stickyEvents 粘性事件集合, key为eventType的类, value是eventType对象</span></span><br><span class=\"line\">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 获取候选eventType</span></span><br><span class=\"line\">                    Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class=\"line\">                    <span class=\"comment\">// native方法, 应该是判断当前注册eventType与候选缓存的eventType是否匹配</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 如果匹配, 校验并发送订阅</span></span><br><span class=\"line\">                        Object stickyEvent = entry.getValue();</span><br><span class=\"line\">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                Object stickyEvent = stickyEvents.get(eventType);</span><br><span class=\"line\">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>相关注释都在代码里, 这块的流程我们可以梳理成以下步骤:</p>\n<ol>\n<li>获取我们订阅时间传输的类<code>EventType</code>, 初始化内部维护的两个集合, 分别是<code>subscriptionsByEventType</code>和<code>typesBySubscriber</code>, 根据命名我们也可以理解, 一个是根据<code>eventType</code>区分的订阅者队列, 一个是根据<code>subscriber</code>(订阅者)区分的<code>eventType</code>队列, 分别向对应的集合内添加对应新的订阅者和订阅事件</li>\n<li>根据是否粘性事件判断是否需要调用<code>checkPostStickyEventToSubscription</code>直接发送信息给订阅者</li>\n<li><code>checkPostStickyEventToSubscription</code>内部判断事件是否被中断来判断是否会调用到<code>postToSubscription</code>, 就是发送信息给订阅者</li>\n</ol>\n<h2 id=\"发送信息\"><a href=\"#发送信息\" class=\"headerlink\" title=\"发送信息\"></a>发送信息</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 事件发送</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"comment\">/** Posts the given event to the event bus. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">post</span><span class=\"params\">(Object event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// currentPostingThreadState 为ThreadLocal对象</span></span><br><span class=\"line\">        <span class=\"comment\">// 获取当前线程的发送状态</span></span><br><span class=\"line\">        PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前线程的事件发送队列</span></span><br><span class=\"line\">        List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class=\"line\">        <span class=\"comment\">// 添加事件</span></span><br><span class=\"line\">        eventQueue.add(event);</span><br><span class=\"line\">        <span class=\"comment\">// 如果不在发送中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!postingState.isPosting) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断是否在主线程</span></span><br><span class=\"line\">            postingState.isMainThread = isMainThread();</span><br><span class=\"line\">            <span class=\"comment\">// 修改发送中状态</span></span><br><span class=\"line\">            postingState.isPosting = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (postingState.canceled) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(<span class=\"string\">\"Internal error. Abort state was not reset\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 遍历发送队列事件</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 从队头开始发送, 同时移除队列中的对应事件</span></span><br><span class=\"line\">                    postSingleEvent(eventQueue.remove(<span class=\"number\">0</span>), postingState);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 修改发送中状态, 修改主线程判断</span></span><br><span class=\"line\">                postingState.isPosting = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                postingState.isMainThread = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>由于在业务场景中, 无法判断发送信息在什么线程下执行的, 所以内部维护的<code>currentPostingThreadState</code>是一个<code>ThreadLocal</code>对象, 它可以保证当前线程的数据不会被其他线程共享.在<code>post</code>中, 我们就能看到<code>EventBus</code>会根据当前线程, 将事件发送给当前线程的队列中, 然后遍历执行<code>postSingleEvent</code>进行单个事件的发送, 同时移除掉队列中已发送的事件<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 发送单个事件</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> event</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> postingState</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Error</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">postSingleEvent</span><span class=\"params\">(Object event, PostingThreadState postingState)</span> <span class=\"keyword\">throws</span> Error </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// event 是对应eventType的实例</span></span><br><span class=\"line\">        Class&lt;?&gt; eventClass = event.getClass();</span><br><span class=\"line\">        <span class=\"comment\">// 默认没有找到订阅者</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> subscriptionFound = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 默认true, 判断是否触发eventType的父类或接口的订阅</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (eventInheritance) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 查找获取所有eventType的父类和接口</span></span><br><span class=\"line\">            List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> countTypes = eventTypes.size();</span><br><span class=\"line\">            <span class=\"comment\">// 循环发送</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> h = <span class=\"number\">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class=\"line\">                Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class=\"line\">                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果没有找到订阅者</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!subscriptionFound) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (logNoSubscriberMessages) &#123;</span><br><span class=\"line\">                logger.log(Level.FINE, <span class=\"string\">\"No subscribers registered for event \"</span> + eventClass);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果我们的builder配置了sendNoSubscriberEvent(默认为true)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class=\"line\">                    eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 会发送一个NoSubscriberEvent的事件, 如果需要判断无订阅者时候的触发情况, 可以接收这个事件做处理</span></span><br><span class=\"line\">                post(<span class=\"keyword\">new</span> NoSubscriberEvent(<span class=\"keyword\">this</span>, event));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的流程我们可以分成两步:</p>\n<ol>\n<li>通过<code>postSingleEventForEventType</code>根据<code>eventType</code>查找对应的订阅者, 如果找到, 则发送事件</li>\n<li>如果没有找到订阅者, 根据构造器内我们通过<code>sendNoSubscriberEvent</code>的配置, 来判断是否需要发送一个无订阅者响应事件</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">postSingleEventForEventType</span><span class=\"params\">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class=\"line\">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 根据eventType获取订阅者</span></span><br><span class=\"line\">            subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscriptions != <span class=\"keyword\">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class=\"line\">                postingState.event = event;</span><br><span class=\"line\">                postingState.subscription = subscription;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> aborted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 发送给订阅者</span></span><br><span class=\"line\">                    postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class=\"line\">                    aborted = postingState.canceled;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    postingState.event = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    postingState.subscription = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    postingState.canceled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (aborted) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><code>postSingleEventForEventType</code>方法就执行了上面的第一步动作, 如果找到了订阅者, 就会返回true; 否则, 返回false.最终我们通过调用<code>postToSubscription</code>将事件发送给订阅者.<br>咱们继续往下走.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 订阅发布</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> subscription 新注册的订阅者</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> event eventType</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> isMainThread 是否主线程</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">postToSubscription</span><span class=\"params\">(Subscription subscription, Object event, <span class=\"keyword\">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 订阅方法的指定线程</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 相同线程内</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> POSTING:</span><br><span class=\"line\">                invokeSubscriber(subscription, event);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 主线程内, 不阻塞</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> MAIN:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isMainThread) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 订阅者的调用</span></span><br><span class=\"line\">                    invokeSubscriber(subscription, event);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 通过handler处理</span></span><br><span class=\"line\">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 主线程, 阻塞</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> MAIN_ORDERED:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mainThreadPoster != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// temporary: technically not correct as poster not decoupled from subscriber</span></span><br><span class=\"line\">                    invokeSubscriber(subscription, event);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 后台线程,</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> BACKGROUND:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isMainThread) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 实现了Runnable</span></span><br><span class=\"line\">                    backgroundPoster.enqueue(subscription, event);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    invokeSubscriber(subscription, event);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 异步线程</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> ASYNC:</span><br><span class=\"line\">                asyncPoster.enqueue(subscription, event);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Unknown thread mode: \"</span> + subscription.subscriberMethod.threadMode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>默认的线程模式一般是<code>POSTING</code>会走发送信息时所在的线程, 这样避免了线程切换所存在的可能开销.我们首先看下<code>invokeSubscriber</code>方法, 它的作用就是做到了订阅者的调用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">invokeSubscriber</span><span class=\"params\">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 订阅方法的调用</span></span><br><span class=\"line\">            subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InvocationTargetException e) &#123;</span><br><span class=\"line\">            handleSubscriberException(subscription, event, e.getCause());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Unexpected exception\"</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>其实可以看出, 这里就是获取订阅方法, 通过反射将事件作为参数调用.</p>\n<p>我们看下走UI线程的流程, 在判断当前线程非主线程的情况下, 我们会调用到<code>mainThreadPoster.enqueue(subscription, event);</code>,<br>首先, 我们回到<code>EventBus</code>的构造函数中, 找到<code>mainThreadPoster</code>的相关申明<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mainThreadPoster = mainThreadSupport != <span class=\"keyword\">null</span> ? mainThreadSupport.createPoster(<span class=\"keyword\">this</span>) : <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MainThreadSupport</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isMainThread</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Poster <span class=\"title\">createPoster</span><span class=\"params\">(EventBus eventBus)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AndroidHandlerMainThreadSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">MainThreadSupport</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Looper looper;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AndroidHandlerMainThreadSupport</span><span class=\"params\">(Looper looper)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.looper = looper;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMainThread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> looper == Looper.myLooper();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Poster <span class=\"title\">createPoster</span><span class=\"params\">(EventBus eventBus)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> HandlerPoster(eventBus, looper, <span class=\"number\">10</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到他是个<code>HandlerPoster</code>对象, 然后再回来看<code>HandlerPoster.enqueue</code>对应的代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class=\"line\">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            queue.enqueue(pendingPost);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!handlerActive) &#123;</span><br><span class=\"line\">                handlerActive = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(<span class=\"string\">\"Could not send handler message\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里首先维护了内部的<code>PendingPost</code>, 并且将对应的<code>pendingPost</code>加入执行队列中.<code>HandlerPoster</code>继承于<code>Handler</code>, 根据他前面传入的Looper可以判定保证信息的执行是在主线程中做处理的, 现在我们看下<code>handleMessage</code>的处理<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> rescheduled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> started = SystemClock.uptimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                PendingPost pendingPost = queue.poll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (pendingPost == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// Check again, this time in synchronized</span></span><br><span class=\"line\">                        pendingPost = queue.poll();</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (pendingPost == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            handlerActive = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 调用订阅者</span></span><br><span class=\"line\">                eventBus.invokeSubscriber(pendingPost);</span><br><span class=\"line\">                <span class=\"keyword\">long</span> timeInMethod = SystemClock.uptimeMillis() - started;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(<span class=\"string\">\"Could not send handler message\"</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    rescheduled = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            handlerActive = rescheduled;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里做的处理, 主要就是调用了<code>EventBus</code>对象的<code>invokeSubscriber</code>方法, 最终走到了订阅者的方法的执行.<br>至于其他的几个线程模式, 查看对应的<code>POST</code>也可以大致知道他的原理, 这里就暂且不表了.</p>\n<h3 id=\"解绑\"><a href=\"#解绑\" class=\"headerlink\" title=\"解绑\"></a>解绑</h3><p>相对前面的, 其实解绑的逻辑就非常简单了, 我们先看代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 解绑</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"comment\">/** Unregisters the given subscriber from all event classes. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">unregister</span><span class=\"params\">(Object subscriber)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据订阅者获取对应的eventType</span></span><br><span class=\"line\">        List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class=\"line\">        <span class=\"comment\">// 如果不为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subscribedTypes != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 遍历解绑</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class=\"line\">                unsubscribeByEventType(subscriber, eventType);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 移除相关的eventType</span></span><br><span class=\"line\">            typesBySubscriber.remove(subscriber);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            logger.log(Level.WARNING, <span class=\"string\">\"Subscriber to unregister was not registered before: \"</span> + subscriber.getClass());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们在绑定相关的解析中, 已经知道其实内部管理订阅事件和订阅者是通过<code>typesBySubscriber</code>和<code>subscriptionsByEventType</code>来实现的, 而这里就是移除掉与对应订阅者相关的对象即可.</p>"},{"title":"okHttp3源码解析(二)-ConnectInterceptor","date":"2018-08-23T16:00:00.000Z","_content":"## 前言\n上文简单概括了下`okHttp3`请求的整体流程, 本篇主要看下`ConnectInterceptor`的主要工作内容\n<!-- more -->\n## 正文\n已知拦截器链都是从各拦截器的`intercept`方法开始调用, 那么我们从`ConnectInterceptor`的`intercept`代码开始看起\n``` java\n@Override public Response intercept(Chain chain) throws IOException {\n    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n    Request request = realChain.request();\n    // 从RetryAndFollowUpInterceptor获取\n    StreamAllocation streamAllocation = realChain.streamAllocation();\n\n    // 判断请求是不是GET方法, 不是的情况下,需要进行有效监测\n    boolean doExtensiveHealthChecks = !request.method().equals(\"GET\");\n    // 新建HttpCodec\n    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);\n    RealConnection connection = streamAllocation.connection();\n\n    return realChain.proceed(request, streamAllocation, httpCodec, connection);\n  }\n```\n我们可以看到, 获取连接的拦截器内, 主要只有三个步骤:\n1. 初始化`HttpCodec`\n2. 通过`streamAllocation`获取连接\n3. 将`httpCodec`和`connection`作为参数带到下个拦截器的调用方法中\n\n这里`HttpCodec`我们可以大概了解下, 它是个抽象类, 有`Http1Codec`和`Http2Codec`实现它, 分别根据Http/1.1,和Http/2做针对请求响应不同的编解码处理.\n\n而`StreamAllocation`对象是在`RetryAndFollowUpInterceptor`中新建获取到的, 它做了`Streams`, `Connections`, `Calls`的关系管理.这里要注意的是`Streams`表示的是逻辑层面的连接(流), 每个连接(`Connection`)都定义了可以并发请求的连接(`Streams`), HTTP/1.x每次只能携带一次, HTTP/2可以携带多次.\n\n回头我们看下`streamAllocation.newStream`做了什么\n``` java\npublic HttpCodec newStream(\n      OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) {\n    int connectTimeout = chain.connectTimeoutMillis();\n    int readTimeout = chain.readTimeoutMillis();\n    int writeTimeout = chain.writeTimeoutMillis();\n    int pingIntervalMillis = client.pingIntervalMillis();\n    boolean connectionRetryEnabled = client.retryOnConnectionFailure();\n\n    try {\n      // 遍历查找健康可用的连接\n      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,\n          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);\n      // HttpCodec初始化\n      HttpCodec resultCodec = resultConnection.newCodec(client, chain, this);\n\n      synchronized (connectionPool) {\n        codec = resultCodec;\n        return resultCodec;\n      }\n    } catch (IOException e) {\n      throw new RouteException(e);\n    }\n  }\n```\n可以看到它这里也就做了三个动作\n1. 配置连接超时, 读取超时, 写超时的时间.\n2. 查找健康可用的连接\n3. 根据可用连接初始化`HttpCodec`\n\n继续往下看:\n``` java\nprivate RealConnection findHealthyConnection(int connectTimeout, int readTimeout,\n      int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled,\n      boolean doExtensiveHealthChecks) throws IOException {\n    while (true) {\n      // 查找连接, 更加倾向连接池内已存在的连接, 否则会重新构建\n      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,\n          pingIntervalMillis, connectionRetryEnabled);\n\n      // If this is a brand new connection, we can skip the extensive health checks.\n      // 如果是全新的连接, 则跳过可用检查, 直接返回\n      synchronized (connectionPool) {\n        if (candidate.successCount == 0) {\n          return candidate;\n        }\n      }\n\n      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it\n      // isn't, take it out of the pool and start again.\n      // 判断是否是可用连接\n      if (!candidate.isHealthy(doExtensiveHealthChecks)) {\n        // 禁止新流创建\n        noNewStreams();\n        continue;\n      }\n\n      return candidate;\n    }\n  }\n```\n1. 循环查找连接\n2. 如果是全新的连接, 则跳过检查, 直接返回\n3. 判断是否可用连接, 如果不是, 则禁止新流创建\n\n继续看`findConnection`方法\n``` java\n/**\n   * Returns a connection to host a new stream. This prefers the existing connection if it exists,\n   * then the pool, finally building a new connection.\n   */\n  private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,\n      int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {\n    // 从连接池中找到连接\n    boolean foundPooledConnection = false;\n    // 实际需要返回的连接\n    RealConnection result = null;\n    // 对应找到的路由\n    Route selectedRoute = null;\n    // 对应可释放的连接\n    Connection releasedConnection;\n    // 需要关闭的socket\n    Socket toClose;\n    synchronized (connectionPool) {\n      // 异常判断\n      // 判断是否连接已经被释放, codec是否为空, 请求是否被取消\n      if (released) throw new IllegalStateException(\"released\");\n      if (codec != null) throw new IllegalStateException(\"codec != null\");\n      if (canceled) throw new IOException(\"Canceled\");\n\n      // 尝试寻找已经存在的连接来使用.\n      // 但是需要注意的是, 已存在的连接可能已经无法再创建新的流\n      // Attempt to use an already-allocated connection. We need to be careful here because our\n      // already-allocated connection may have been restricted from creating new streams.\n      releasedConnection = this.connection;\n      // toClose如果无法创建流, 需要关闭的socket\n      toClose = releaseIfNoNewStreams();\n      if (this.connection != null) {\n        // We had an already-allocated connection and it's good.\n        // 如果当前连接不为空, 就说明这个连接是可以用的\n        result = this.connection;\n        releasedConnection = null;\n      }\n      if (!reportedAcquired) {\n        // If the connection was never reported acquired, don't report it as released!\n        releasedConnection = null;\n      }\n      // 如果没有现成的连接\n      if (result == null) {\n        // Attempt to get a connection from the pool.\n        // 尝试从连接池中获取\n        Internal.instance.get(connectionPool, address, this, null);\n        // 如果有复用的连接\n        if (connection != null) {\n          // 表示找到连接池可复用的连接\n          foundPooledConnection = true;\n          result = connection;\n        } else {\n          selectedRoute = route;\n        }\n      }\n    }\n    // 关闭socket\n    closeQuietly(toClose);\n\n    if (releasedConnection != null) {\n      eventListener.connectionReleased(call, releasedConnection);\n    }\n    if (foundPooledConnection) {\n      eventListener.connectionAcquired(call, result);\n    }\n    if (result != null) {\n      // If we found an already-allocated or pooled connection, we're done.\n      // 如果有存在已分配的连接或者是连接池内可复用的连接, 则直接返回该连接对象\n      return result;\n    }\n\n    // If we need a route selection, make one. This is a blocking operation.\n    boolean newRouteSelection = false;\n    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {\n      newRouteSelection = true;\n      // 切换路由\n      routeSelection = routeSelector.next();\n    }\n\n    synchronized (connectionPool) {\n      if (canceled) throw new IOException(\"Canceled\");\n\n      if (newRouteSelection) {\n        // Now that we have a set of IP addresses, make another attempt at getting a connection from\n        // the pool. This could match due to connection coalescing.\n        List<Route> routes = routeSelection.getAll();\n        for (int i = 0, size = routes.size(); i < size; i++) {\n          Route route = routes.get(i);\n          // 获取可复用的连接\n          Internal.instance.get(connectionPool, address, this, route);\n          // 如果存在可复用连接\n          if (connection != null) {\n            foundPooledConnection = true;\n            result = connection;\n            this.route = route;\n            break;\n          }\n        }\n      }\n      // 如果没有找到可复用的连接\n      if (!foundPooledConnection) {\n        // 如果当前路由为空\n        if (selectedRoute == null) {\n          selectedRoute = routeSelection.next();\n        }\n\n        // Create a connection and assign it to this allocation immediately. This makes it possible\n        // for an asynchronous cancel() to interrupt the handshake we're about to do.\n        route = selectedRoute;\n        refusedStreamCount = 0;\n        // 创建新的连接\n        result = new RealConnection(connectionPool, selectedRoute);\n        acquire(result, false);\n      }\n    }\n\n    // If we found a pooled connection on the 2nd time around, we're done.\n    // 如果第二次有找到, 则返回复用的连接\n    if (foundPooledConnection) {\n      eventListener.connectionAcquired(call, result);\n      return result;\n    }\n\n    // Do TCP + TLS handshakes. This is a blocking operation.\n    // 做三次握手\n    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,\n        connectionRetryEnabled, call, eventListener);\n    // 将该路由从错误缓存记录中移除\n    routeDatabase().connected(result.route());\n\n    Socket socket = null;\n    synchronized (connectionPool) {\n      reportedAcquired = true;\n\n      // Pool the connection.\n      // 在连接池中添加该连接\n      Internal.instance.put(connectionPool, result);\n\n      // If another multiplexed connection to the same address was created concurrently, then\n      // release this connection and acquire that one.\n      // 如果有其他复数连接到相同地址, 则删除重复连接\n      if (result.isMultiplexed()) {\n        socket = Internal.instance.deduplicate(connectionPool, address, this);\n        result = connection;\n      }\n    }\n    closeQuietly(socket);\n\n    eventListener.connectionAcquired(call, result);\n    return result;\n  }\n```\n其实看方法注释, 我们大概可以知道这里做的就是返回一个连接, 首先会从连接池中来, 如果连接池中没有对应连接, 则再重新新建一个连接.\n\n具体的注释都在代码里了, 我们再看下其中几个调用方法.\n首先我们将即将要释放的连接指向当前的连接, 通过调用`releaseIfNoNewStreams`方法, 返回需要关闭的socket\n我们来看下`releaseIfNoNewStreams`方法的代码\n``` java\n/**\n   * 如果当前连接无法新建流, 释放当前连接, 并且返回需要关闭的socket\n   * 由于http2复数请求会使用同一个连接, 所以可能存在当前连接限制后续的请求\n   */\n  private Socket releaseIfNoNewStreams() {\n    // 断言锁持有\n    assert (Thread.holdsLock(connectionPool));\n    RealConnection allocatedConnection = this.connection;\n    // 当当前连接不为空, 而且没有新的流被创建\n    if (allocatedConnection != null && allocatedConnection.noNewStreams) {\n      return deallocate(false, false, true);\n    }\n    // 正常情况, 没有需要被关闭的socket返回\n    return null;\n  }\n```\n可以看到只有当当前连接存在, 而且不允许有新的流产生的时候, 才会返回执行`deallocate(false, false, true)`后的结果, 正常的情况下, 没有需要被关闭的socket返回\n关于`deallocate`方法, 可以看下面的代码\n``` java\nprivate Socket deallocate(boolean noNewStreams, boolean released, boolean streamFinished) {\n    assert (Thread.holdsLock(connectionPool));\n\n    if (streamFinished) {\n      this.codec = null;\n    }\n    if (released) {\n      this.released = true;\n    }\n    Socket socket = null;\n    if (connection != null) {\n      if (noNewStreams) {\n        connection.noNewStreams = true;\n      }\n      if (this.codec == null && (this.released || connection.noNewStreams)) {\n        // 释放连接\n        release(connection);\n        // 如果这个连接的当前的流为空\n        if (connection.allocations.isEmpty()) {\n          // 当连接的流为0时候的记录时间戳\n          connection.idleAtNanos = System.nanoTime();\n          // 判断连接是否闲置\n          if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {\n            // 如果闲置, 则返回需要关闭的socket\n            socket = connection.socket();\n          }\n        }\n        // 回收\n        connection = null;\n      }\n    }\n    return socket;\n  }\n\n  private void release(RealConnection connection) {\n    for (int i = 0, size = connection.allocations.size(); i < size; i++) {\n      Reference<StreamAllocation> reference = connection.allocations.get(i);\n      if (reference.get() == this) {\n        connection.allocations.remove(i);\n        return;\n      }\n    }\n    throw new IllegalStateException();\n  }\n```\n可以看到这里具体做的就是, 编解码类对象`codec`赋值为null, 调用`release`释放连接, 当这个`connection`没有连接流的时候, 一并判断连接是否闲置, 如果闲置, 则返回对应的`socket`, 并将当前的`connection`赋值为null.而这里的`release`方法主要做的就是移除连接对应流引用的移除.\n\n我们回头去看`findConnection`方法内下一步\n``` java\nif (this.connection != null) {\n        // We had an already-allocated connection and it's good.\n        // 如果当前连接不为空, 就说明这个连接是可以用的\n        result = this.connection;\n        releasedConnection = null;\n      }\n```\n我们知道前面调用`releaseIfNoNewStreams`的时候, 如果有返回socket, 那么connection也会被置为null, 所以这里connection不为空, 说明就是现在的连接是可以用的, 那么需要释放连接的对象就为null, 没必要被释放.\n``` java\n// 如果没有现成的连接\n      if (result == null) {\n        // Attempt to get a connection from the pool.\n        // 尝试从连接池中获取\n        Internal.instance.get(connectionPool, address, this, null);\n        // 如果有复用的连接\n        if (connection != null) {\n          // 表示找到连接池可复用的连接\n          foundPooledConnection = true;\n          result = connection;\n        } else {\n          selectedRoute = route;\n        }\n      }\n```\n而如果没有可用的连接, 那么就会从连接池中尝试获取\n``` java\n  /**\n   * 返回一个可重用的连接, 如果没有对应连接存在, 则返回null\n   */\n  @Nullable RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {\n    // 断言锁的持有\n    assert (Thread.holdsLock(this));\n    // 遍历\n    for (RealConnection connection : connections) {\n      // 判断连接是否可复用\n      if (connection.isEligible(address, route)) {\n        streamAllocation.acquire(connection, true);\n        return connection;\n      }\n    }\n    return null;\n  }\n  public void acquire(RealConnection connection, boolean reportedAcquired) {\n    assert (Thread.holdsLock(connectionPool));\n    if (this.connection != null) throw new IllegalStateException();\n\n    this.connection = connection;\n    this.reportedAcquired = reportedAcquired;\n    // 添加一个流的引用\n    connection.allocations.add(new StreamAllocationReference(this, callStackTrace));\n  }\n```\n可以看到, 如果当前连接池中有连接可复用, 则会将新的流引用添加在`connection.allocations`中.\n``` java\n// 关闭socket\n    closeQuietly(toClose);\n\n    if (releasedConnection != null) {\n      eventListener.connectionReleased(call, releasedConnection);\n    }\n    if (foundPooledConnection) {\n      eventListener.connectionAcquired(call, result);\n    }\n    if (result != null) {\n      // If we found an already-allocated or pooled connection, we're done.\n      // 如果有存在已分配的连接或者是连接池内可复用的连接, 则直接返回该连接对象\n      return result;\n    }\n```\n再回到主方法内, 不论是否有找到可用的连接, 都会关闭socket, 然后根据是否存在需要释放的连接, 回调`eventListener.connectionReleased`, 并根据是否找到连接池内可用连接, 回调`eventListener.connectionAcquired`.当有实际可用的连接的时候, 那么直接返回该连接对象.\n``` java\nboolean newRouteSelection = false;\n    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {\n      newRouteSelection = true;\n      // 切换路由\n      routeSelection = routeSelector.next();\n    }\n\n    synchronized (connectionPool) {\n      if (canceled) throw new IOException(\"Canceled\");\n\n      if (newRouteSelection) {\n        // Now that we have a set of IP addresses, make another attempt at getting a connection from\n        // the pool. This could match due to connection coalescing.\n        List<Route> routes = routeSelection.getAll();\n        for (int i = 0, size = routes.size(); i < size; i++) {\n          Route route = routes.get(i);\n          // 获取可复用的连接\n          Internal.instance.get(connectionPool, address, this, route);\n          // 如果存在可复用连接\n          if (connection != null) {\n            foundPooledConnection = true;\n            result = connection;\n            this.route = route;\n            break;\n          }\n        }\n      }\n      // 如果没有找到可复用的连接\n      if (!foundPooledConnection) {\n        // 如果当前路由为空\n        if (selectedRoute == null) {\n          selectedRoute = routeSelection.next();\n        }\n\n        // Create a connection and assign it to this allocation immediately. This makes it possible\n        // for an asynchronous cancel() to interrupt the handshake we're about to do.\n        route = selectedRoute;\n        refusedStreamCount = 0;\n        // 创建新的连接\n        result = new RealConnection(connectionPool, selectedRoute);\n        acquire(result, false);\n      }\n    }\n    // If we found a pooled connection on the 2nd time around, we're done.\n    // 如果第二次有找到, 则返回复用的连接\n    if (foundPooledConnection) {\n      eventListener.connectionAcquired(call, result);\n      return result;\n    }\n```\n当仍然没有找到连接的时候, 那么就会切换路由, 再次从连接池内找对应路由可复用的连接, 如果有找到, 则返回这次复用的连接对象.\n\n``` java\n// Do TCP + TLS handshakes. This is a blocking operation.\n    // 做三次握手\n    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,\n        connectionRetryEnabled, call, eventListener);\n    // 将该路由从错误缓存记录中移除\n    routeDatabase().connected(result.route());\n\n    Socket socket = null;\n    synchronized (connectionPool) {\n      reportedAcquired = true;\n\n      // Pool the connection.\n      // 在连接池中添加该连接\n      Internal.instance.put(connectionPool, result);\n\n      // If another multiplexed connection to the same address was created concurrently, then\n      // release this connection and acquire that one.\n      // 如果有其他复数连接到相同地址, 则删除重复连接\n      if (result.isMultiplexed()) {\n        socket = Internal.instance.deduplicate(connectionPool, address, this);\n        result = connection;\n      }\n    }\n    closeQuietly(socket);\n\n    eventListener.connectionAcquired(call, result);\n    return result;\n```\n但如果这次仍然没有找到对应可用的连接, 则只好新建连接, 并将流引用加到对应的`conection`对象中, 然后做三次握手, 并将对应的路由从错误缓存中移除.\n最后还做了重复连接的去重的工作, 然后再返回这个新建的连接对象.\n\n截止至此, 寻找可用连接的代码分析就完成了.\n\n回头再看下`HttpCodec的初始化`\n``` java\npublic HttpCodec newCodec(OkHttpClient client, Interceptor.Chain chain,\n      StreamAllocation streamAllocation) throws SocketException {\n    if (http2Connection != null) {\n      return new Http2Codec(client, chain, streamAllocation, http2Connection);\n    } else {\n      socket.setSoTimeout(chain.readTimeoutMillis());\n      source.timeout().timeout(chain.readTimeoutMillis(), MILLISECONDS);\n      sink.timeout().timeout(chain.writeTimeoutMillis(), MILLISECONDS);\n      return new Http1Codec(client, streamAllocation, source, sink);\n    }\n  }\n```\n主要就是根据判断是Http1还是Http2来判断新建哪个编解码类.\n## 总结\n可以看出, `ConnectionInterceptor`拦截器, 主要做的是,\n1. 获取当前连接(`connection`), 如果不可用, 则从连接池中获取可复用连接, 如果仍然获取不到, 则新建连接\n2. 通过连接, 生成`HttpCodec`对象\n","source":"_posts/okHttp源码解析(二)-ConnectInterceptor.md","raw":"title: okHttp3源码解析(二)-ConnectInterceptor\ndate: 2018-08-24 00:00:00\ncategories:\n- 源码解析\ntags:\n- 源码解析\n- okHttp3\n---\n## 前言\n上文简单概括了下`okHttp3`请求的整体流程, 本篇主要看下`ConnectInterceptor`的主要工作内容\n<!-- more -->\n## 正文\n已知拦截器链都是从各拦截器的`intercept`方法开始调用, 那么我们从`ConnectInterceptor`的`intercept`代码开始看起\n``` java\n@Override public Response intercept(Chain chain) throws IOException {\n    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n    Request request = realChain.request();\n    // 从RetryAndFollowUpInterceptor获取\n    StreamAllocation streamAllocation = realChain.streamAllocation();\n\n    // 判断请求是不是GET方法, 不是的情况下,需要进行有效监测\n    boolean doExtensiveHealthChecks = !request.method().equals(\"GET\");\n    // 新建HttpCodec\n    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);\n    RealConnection connection = streamAllocation.connection();\n\n    return realChain.proceed(request, streamAllocation, httpCodec, connection);\n  }\n```\n我们可以看到, 获取连接的拦截器内, 主要只有三个步骤:\n1. 初始化`HttpCodec`\n2. 通过`streamAllocation`获取连接\n3. 将`httpCodec`和`connection`作为参数带到下个拦截器的调用方法中\n\n这里`HttpCodec`我们可以大概了解下, 它是个抽象类, 有`Http1Codec`和`Http2Codec`实现它, 分别根据Http/1.1,和Http/2做针对请求响应不同的编解码处理.\n\n而`StreamAllocation`对象是在`RetryAndFollowUpInterceptor`中新建获取到的, 它做了`Streams`, `Connections`, `Calls`的关系管理.这里要注意的是`Streams`表示的是逻辑层面的连接(流), 每个连接(`Connection`)都定义了可以并发请求的连接(`Streams`), HTTP/1.x每次只能携带一次, HTTP/2可以携带多次.\n\n回头我们看下`streamAllocation.newStream`做了什么\n``` java\npublic HttpCodec newStream(\n      OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) {\n    int connectTimeout = chain.connectTimeoutMillis();\n    int readTimeout = chain.readTimeoutMillis();\n    int writeTimeout = chain.writeTimeoutMillis();\n    int pingIntervalMillis = client.pingIntervalMillis();\n    boolean connectionRetryEnabled = client.retryOnConnectionFailure();\n\n    try {\n      // 遍历查找健康可用的连接\n      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,\n          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);\n      // HttpCodec初始化\n      HttpCodec resultCodec = resultConnection.newCodec(client, chain, this);\n\n      synchronized (connectionPool) {\n        codec = resultCodec;\n        return resultCodec;\n      }\n    } catch (IOException e) {\n      throw new RouteException(e);\n    }\n  }\n```\n可以看到它这里也就做了三个动作\n1. 配置连接超时, 读取超时, 写超时的时间.\n2. 查找健康可用的连接\n3. 根据可用连接初始化`HttpCodec`\n\n继续往下看:\n``` java\nprivate RealConnection findHealthyConnection(int connectTimeout, int readTimeout,\n      int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled,\n      boolean doExtensiveHealthChecks) throws IOException {\n    while (true) {\n      // 查找连接, 更加倾向连接池内已存在的连接, 否则会重新构建\n      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,\n          pingIntervalMillis, connectionRetryEnabled);\n\n      // If this is a brand new connection, we can skip the extensive health checks.\n      // 如果是全新的连接, 则跳过可用检查, 直接返回\n      synchronized (connectionPool) {\n        if (candidate.successCount == 0) {\n          return candidate;\n        }\n      }\n\n      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it\n      // isn't, take it out of the pool and start again.\n      // 判断是否是可用连接\n      if (!candidate.isHealthy(doExtensiveHealthChecks)) {\n        // 禁止新流创建\n        noNewStreams();\n        continue;\n      }\n\n      return candidate;\n    }\n  }\n```\n1. 循环查找连接\n2. 如果是全新的连接, 则跳过检查, 直接返回\n3. 判断是否可用连接, 如果不是, 则禁止新流创建\n\n继续看`findConnection`方法\n``` java\n/**\n   * Returns a connection to host a new stream. This prefers the existing connection if it exists,\n   * then the pool, finally building a new connection.\n   */\n  private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,\n      int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {\n    // 从连接池中找到连接\n    boolean foundPooledConnection = false;\n    // 实际需要返回的连接\n    RealConnection result = null;\n    // 对应找到的路由\n    Route selectedRoute = null;\n    // 对应可释放的连接\n    Connection releasedConnection;\n    // 需要关闭的socket\n    Socket toClose;\n    synchronized (connectionPool) {\n      // 异常判断\n      // 判断是否连接已经被释放, codec是否为空, 请求是否被取消\n      if (released) throw new IllegalStateException(\"released\");\n      if (codec != null) throw new IllegalStateException(\"codec != null\");\n      if (canceled) throw new IOException(\"Canceled\");\n\n      // 尝试寻找已经存在的连接来使用.\n      // 但是需要注意的是, 已存在的连接可能已经无法再创建新的流\n      // Attempt to use an already-allocated connection. We need to be careful here because our\n      // already-allocated connection may have been restricted from creating new streams.\n      releasedConnection = this.connection;\n      // toClose如果无法创建流, 需要关闭的socket\n      toClose = releaseIfNoNewStreams();\n      if (this.connection != null) {\n        // We had an already-allocated connection and it's good.\n        // 如果当前连接不为空, 就说明这个连接是可以用的\n        result = this.connection;\n        releasedConnection = null;\n      }\n      if (!reportedAcquired) {\n        // If the connection was never reported acquired, don't report it as released!\n        releasedConnection = null;\n      }\n      // 如果没有现成的连接\n      if (result == null) {\n        // Attempt to get a connection from the pool.\n        // 尝试从连接池中获取\n        Internal.instance.get(connectionPool, address, this, null);\n        // 如果有复用的连接\n        if (connection != null) {\n          // 表示找到连接池可复用的连接\n          foundPooledConnection = true;\n          result = connection;\n        } else {\n          selectedRoute = route;\n        }\n      }\n    }\n    // 关闭socket\n    closeQuietly(toClose);\n\n    if (releasedConnection != null) {\n      eventListener.connectionReleased(call, releasedConnection);\n    }\n    if (foundPooledConnection) {\n      eventListener.connectionAcquired(call, result);\n    }\n    if (result != null) {\n      // If we found an already-allocated or pooled connection, we're done.\n      // 如果有存在已分配的连接或者是连接池内可复用的连接, 则直接返回该连接对象\n      return result;\n    }\n\n    // If we need a route selection, make one. This is a blocking operation.\n    boolean newRouteSelection = false;\n    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {\n      newRouteSelection = true;\n      // 切换路由\n      routeSelection = routeSelector.next();\n    }\n\n    synchronized (connectionPool) {\n      if (canceled) throw new IOException(\"Canceled\");\n\n      if (newRouteSelection) {\n        // Now that we have a set of IP addresses, make another attempt at getting a connection from\n        // the pool. This could match due to connection coalescing.\n        List<Route> routes = routeSelection.getAll();\n        for (int i = 0, size = routes.size(); i < size; i++) {\n          Route route = routes.get(i);\n          // 获取可复用的连接\n          Internal.instance.get(connectionPool, address, this, route);\n          // 如果存在可复用连接\n          if (connection != null) {\n            foundPooledConnection = true;\n            result = connection;\n            this.route = route;\n            break;\n          }\n        }\n      }\n      // 如果没有找到可复用的连接\n      if (!foundPooledConnection) {\n        // 如果当前路由为空\n        if (selectedRoute == null) {\n          selectedRoute = routeSelection.next();\n        }\n\n        // Create a connection and assign it to this allocation immediately. This makes it possible\n        // for an asynchronous cancel() to interrupt the handshake we're about to do.\n        route = selectedRoute;\n        refusedStreamCount = 0;\n        // 创建新的连接\n        result = new RealConnection(connectionPool, selectedRoute);\n        acquire(result, false);\n      }\n    }\n\n    // If we found a pooled connection on the 2nd time around, we're done.\n    // 如果第二次有找到, 则返回复用的连接\n    if (foundPooledConnection) {\n      eventListener.connectionAcquired(call, result);\n      return result;\n    }\n\n    // Do TCP + TLS handshakes. This is a blocking operation.\n    // 做三次握手\n    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,\n        connectionRetryEnabled, call, eventListener);\n    // 将该路由从错误缓存记录中移除\n    routeDatabase().connected(result.route());\n\n    Socket socket = null;\n    synchronized (connectionPool) {\n      reportedAcquired = true;\n\n      // Pool the connection.\n      // 在连接池中添加该连接\n      Internal.instance.put(connectionPool, result);\n\n      // If another multiplexed connection to the same address was created concurrently, then\n      // release this connection and acquire that one.\n      // 如果有其他复数连接到相同地址, 则删除重复连接\n      if (result.isMultiplexed()) {\n        socket = Internal.instance.deduplicate(connectionPool, address, this);\n        result = connection;\n      }\n    }\n    closeQuietly(socket);\n\n    eventListener.connectionAcquired(call, result);\n    return result;\n  }\n```\n其实看方法注释, 我们大概可以知道这里做的就是返回一个连接, 首先会从连接池中来, 如果连接池中没有对应连接, 则再重新新建一个连接.\n\n具体的注释都在代码里了, 我们再看下其中几个调用方法.\n首先我们将即将要释放的连接指向当前的连接, 通过调用`releaseIfNoNewStreams`方法, 返回需要关闭的socket\n我们来看下`releaseIfNoNewStreams`方法的代码\n``` java\n/**\n   * 如果当前连接无法新建流, 释放当前连接, 并且返回需要关闭的socket\n   * 由于http2复数请求会使用同一个连接, 所以可能存在当前连接限制后续的请求\n   */\n  private Socket releaseIfNoNewStreams() {\n    // 断言锁持有\n    assert (Thread.holdsLock(connectionPool));\n    RealConnection allocatedConnection = this.connection;\n    // 当当前连接不为空, 而且没有新的流被创建\n    if (allocatedConnection != null && allocatedConnection.noNewStreams) {\n      return deallocate(false, false, true);\n    }\n    // 正常情况, 没有需要被关闭的socket返回\n    return null;\n  }\n```\n可以看到只有当当前连接存在, 而且不允许有新的流产生的时候, 才会返回执行`deallocate(false, false, true)`后的结果, 正常的情况下, 没有需要被关闭的socket返回\n关于`deallocate`方法, 可以看下面的代码\n``` java\nprivate Socket deallocate(boolean noNewStreams, boolean released, boolean streamFinished) {\n    assert (Thread.holdsLock(connectionPool));\n\n    if (streamFinished) {\n      this.codec = null;\n    }\n    if (released) {\n      this.released = true;\n    }\n    Socket socket = null;\n    if (connection != null) {\n      if (noNewStreams) {\n        connection.noNewStreams = true;\n      }\n      if (this.codec == null && (this.released || connection.noNewStreams)) {\n        // 释放连接\n        release(connection);\n        // 如果这个连接的当前的流为空\n        if (connection.allocations.isEmpty()) {\n          // 当连接的流为0时候的记录时间戳\n          connection.idleAtNanos = System.nanoTime();\n          // 判断连接是否闲置\n          if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {\n            // 如果闲置, 则返回需要关闭的socket\n            socket = connection.socket();\n          }\n        }\n        // 回收\n        connection = null;\n      }\n    }\n    return socket;\n  }\n\n  private void release(RealConnection connection) {\n    for (int i = 0, size = connection.allocations.size(); i < size; i++) {\n      Reference<StreamAllocation> reference = connection.allocations.get(i);\n      if (reference.get() == this) {\n        connection.allocations.remove(i);\n        return;\n      }\n    }\n    throw new IllegalStateException();\n  }\n```\n可以看到这里具体做的就是, 编解码类对象`codec`赋值为null, 调用`release`释放连接, 当这个`connection`没有连接流的时候, 一并判断连接是否闲置, 如果闲置, 则返回对应的`socket`, 并将当前的`connection`赋值为null.而这里的`release`方法主要做的就是移除连接对应流引用的移除.\n\n我们回头去看`findConnection`方法内下一步\n``` java\nif (this.connection != null) {\n        // We had an already-allocated connection and it's good.\n        // 如果当前连接不为空, 就说明这个连接是可以用的\n        result = this.connection;\n        releasedConnection = null;\n      }\n```\n我们知道前面调用`releaseIfNoNewStreams`的时候, 如果有返回socket, 那么connection也会被置为null, 所以这里connection不为空, 说明就是现在的连接是可以用的, 那么需要释放连接的对象就为null, 没必要被释放.\n``` java\n// 如果没有现成的连接\n      if (result == null) {\n        // Attempt to get a connection from the pool.\n        // 尝试从连接池中获取\n        Internal.instance.get(connectionPool, address, this, null);\n        // 如果有复用的连接\n        if (connection != null) {\n          // 表示找到连接池可复用的连接\n          foundPooledConnection = true;\n          result = connection;\n        } else {\n          selectedRoute = route;\n        }\n      }\n```\n而如果没有可用的连接, 那么就会从连接池中尝试获取\n``` java\n  /**\n   * 返回一个可重用的连接, 如果没有对应连接存在, 则返回null\n   */\n  @Nullable RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {\n    // 断言锁的持有\n    assert (Thread.holdsLock(this));\n    // 遍历\n    for (RealConnection connection : connections) {\n      // 判断连接是否可复用\n      if (connection.isEligible(address, route)) {\n        streamAllocation.acquire(connection, true);\n        return connection;\n      }\n    }\n    return null;\n  }\n  public void acquire(RealConnection connection, boolean reportedAcquired) {\n    assert (Thread.holdsLock(connectionPool));\n    if (this.connection != null) throw new IllegalStateException();\n\n    this.connection = connection;\n    this.reportedAcquired = reportedAcquired;\n    // 添加一个流的引用\n    connection.allocations.add(new StreamAllocationReference(this, callStackTrace));\n  }\n```\n可以看到, 如果当前连接池中有连接可复用, 则会将新的流引用添加在`connection.allocations`中.\n``` java\n// 关闭socket\n    closeQuietly(toClose);\n\n    if (releasedConnection != null) {\n      eventListener.connectionReleased(call, releasedConnection);\n    }\n    if (foundPooledConnection) {\n      eventListener.connectionAcquired(call, result);\n    }\n    if (result != null) {\n      // If we found an already-allocated or pooled connection, we're done.\n      // 如果有存在已分配的连接或者是连接池内可复用的连接, 则直接返回该连接对象\n      return result;\n    }\n```\n再回到主方法内, 不论是否有找到可用的连接, 都会关闭socket, 然后根据是否存在需要释放的连接, 回调`eventListener.connectionReleased`, 并根据是否找到连接池内可用连接, 回调`eventListener.connectionAcquired`.当有实际可用的连接的时候, 那么直接返回该连接对象.\n``` java\nboolean newRouteSelection = false;\n    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {\n      newRouteSelection = true;\n      // 切换路由\n      routeSelection = routeSelector.next();\n    }\n\n    synchronized (connectionPool) {\n      if (canceled) throw new IOException(\"Canceled\");\n\n      if (newRouteSelection) {\n        // Now that we have a set of IP addresses, make another attempt at getting a connection from\n        // the pool. This could match due to connection coalescing.\n        List<Route> routes = routeSelection.getAll();\n        for (int i = 0, size = routes.size(); i < size; i++) {\n          Route route = routes.get(i);\n          // 获取可复用的连接\n          Internal.instance.get(connectionPool, address, this, route);\n          // 如果存在可复用连接\n          if (connection != null) {\n            foundPooledConnection = true;\n            result = connection;\n            this.route = route;\n            break;\n          }\n        }\n      }\n      // 如果没有找到可复用的连接\n      if (!foundPooledConnection) {\n        // 如果当前路由为空\n        if (selectedRoute == null) {\n          selectedRoute = routeSelection.next();\n        }\n\n        // Create a connection and assign it to this allocation immediately. This makes it possible\n        // for an asynchronous cancel() to interrupt the handshake we're about to do.\n        route = selectedRoute;\n        refusedStreamCount = 0;\n        // 创建新的连接\n        result = new RealConnection(connectionPool, selectedRoute);\n        acquire(result, false);\n      }\n    }\n    // If we found a pooled connection on the 2nd time around, we're done.\n    // 如果第二次有找到, 则返回复用的连接\n    if (foundPooledConnection) {\n      eventListener.connectionAcquired(call, result);\n      return result;\n    }\n```\n当仍然没有找到连接的时候, 那么就会切换路由, 再次从连接池内找对应路由可复用的连接, 如果有找到, 则返回这次复用的连接对象.\n\n``` java\n// Do TCP + TLS handshakes. This is a blocking operation.\n    // 做三次握手\n    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,\n        connectionRetryEnabled, call, eventListener);\n    // 将该路由从错误缓存记录中移除\n    routeDatabase().connected(result.route());\n\n    Socket socket = null;\n    synchronized (connectionPool) {\n      reportedAcquired = true;\n\n      // Pool the connection.\n      // 在连接池中添加该连接\n      Internal.instance.put(connectionPool, result);\n\n      // If another multiplexed connection to the same address was created concurrently, then\n      // release this connection and acquire that one.\n      // 如果有其他复数连接到相同地址, 则删除重复连接\n      if (result.isMultiplexed()) {\n        socket = Internal.instance.deduplicate(connectionPool, address, this);\n        result = connection;\n      }\n    }\n    closeQuietly(socket);\n\n    eventListener.connectionAcquired(call, result);\n    return result;\n```\n但如果这次仍然没有找到对应可用的连接, 则只好新建连接, 并将流引用加到对应的`conection`对象中, 然后做三次握手, 并将对应的路由从错误缓存中移除.\n最后还做了重复连接的去重的工作, 然后再返回这个新建的连接对象.\n\n截止至此, 寻找可用连接的代码分析就完成了.\n\n回头再看下`HttpCodec的初始化`\n``` java\npublic HttpCodec newCodec(OkHttpClient client, Interceptor.Chain chain,\n      StreamAllocation streamAllocation) throws SocketException {\n    if (http2Connection != null) {\n      return new Http2Codec(client, chain, streamAllocation, http2Connection);\n    } else {\n      socket.setSoTimeout(chain.readTimeoutMillis());\n      source.timeout().timeout(chain.readTimeoutMillis(), MILLISECONDS);\n      sink.timeout().timeout(chain.writeTimeoutMillis(), MILLISECONDS);\n      return new Http1Codec(client, streamAllocation, source, sink);\n    }\n  }\n```\n主要就是根据判断是Http1还是Http2来判断新建哪个编解码类.\n## 总结\n可以看出, `ConnectionInterceptor`拦截器, 主要做的是,\n1. 获取当前连接(`connection`), 如果不可用, 则从连接池中获取可复用连接, 如果仍然获取不到, 则新建连接\n2. 通过连接, 生成`HttpCodec`对象\n","slug":"okHttp源码解析(二)-ConnectInterceptor","published":1,"updated":"2018-08-24T13:37:13.854Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjld5ah49002ecqs6ofbi28kc","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上文简单概括了下<code>okHttp3</code>请求的整体流程, 本篇主要看下<code>ConnectInterceptor</code>的主要工作内容<br><a id=\"more\"></a></p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>已知拦截器链都是从各拦截器的<code>intercept</code>方法开始调用, 那么我们从<code>ConnectInterceptor</code>的<code>intercept</code>代码开始看起<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class=\"line\">    Request request = realChain.request();</span><br><span class=\"line\">    <span class=\"comment\">// 从RetryAndFollowUpInterceptor获取</span></span><br><span class=\"line\">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 判断请求是不是GET方法, 不是的情况下,需要进行有效监测</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class=\"string\">\"GET\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 新建HttpCodec</span></span><br><span class=\"line\">    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br><span class=\"line\">    RealConnection connection = streamAllocation.connection();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以看到, 获取连接的拦截器内, 主要只有三个步骤:</p>\n<ol>\n<li>初始化<code>HttpCodec</code></li>\n<li>通过<code>streamAllocation</code>获取连接</li>\n<li>将<code>httpCodec</code>和<code>connection</code>作为参数带到下个拦截器的调用方法中</li>\n</ol>\n<p>这里<code>HttpCodec</code>我们可以大概了解下, 它是个抽象类, 有<code>Http1Codec</code>和<code>Http2Codec</code>实现它, 分别根据Http/1.1,和Http/2做针对请求响应不同的编解码处理.</p>\n<p>而<code>StreamAllocation</code>对象是在<code>RetryAndFollowUpInterceptor</code>中新建获取到的, 它做了<code>Streams</code>, <code>Connections</code>, <code>Calls</code>的关系管理.这里要注意的是<code>Streams</code>表示的是逻辑层面的连接(流), 每个连接(<code>Connection</code>)都定义了可以并发请求的连接(<code>Streams</code>), HTTP/1.x每次只能携带一次, HTTP/2可以携带多次.</p>\n<p>回头我们看下<code>streamAllocation.newStream</code>做了什么<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> HttpCodec <span class=\"title\">newStream</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      OkHttpClient client, Interceptor.Chain chain, <span class=\"keyword\">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> connectTimeout = chain.connectTimeoutMillis();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> readTimeout = chain.readTimeoutMillis();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> writeTimeout = chain.writeTimeoutMillis();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pingIntervalMillis = client.pingIntervalMillis();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> connectionRetryEnabled = client.retryOnConnectionFailure();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 遍历查找健康可用的连接</span></span><br><span class=\"line\">      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class=\"line\">          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class=\"line\">      <span class=\"comment\">// HttpCodec初始化</span></span><br><span class=\"line\">      HttpCodec resultCodec = resultConnection.newCodec(client, chain, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">        codec = resultCodec;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> resultCodec;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RouteException(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到它这里也就做了三个动作</p>\n<ol>\n<li>配置连接超时, 读取超时, 写超时的时间.</li>\n<li>查找健康可用的连接</li>\n<li>根据可用连接初始化<code>HttpCodec</code></li>\n</ol>\n<p>继续往下看:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> RealConnection <span class=\"title\">findHealthyConnection</span><span class=\"params\">(<span class=\"keyword\">int</span> connectTimeout, <span class=\"keyword\">int</span> readTimeout,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">int</span> writeTimeout, <span class=\"keyword\">int</span> pingIntervalMillis, <span class=\"keyword\">boolean</span> connectionRetryEnabled,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> doExtensiveHealthChecks)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 查找连接, 更加倾向连接池内已存在的连接, 否则会重新构建</span></span><br><span class=\"line\">      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</span><br><span class=\"line\">          pingIntervalMillis, connectionRetryEnabled);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// If this is a brand new connection, we can skip the extensive health checks.</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果是全新的连接, 则跳过可用检查, 直接返回</span></span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (candidate.successCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> candidate;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Do a (potentially slow) check to confirm that the pooled connection is still good. If it</span></span><br><span class=\"line\">      <span class=\"comment\">// isn't, take it out of the pool and start again.</span></span><br><span class=\"line\">      <span class=\"comment\">// 判断是否是可用连接</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 禁止新流创建</span></span><br><span class=\"line\">        noNewStreams();</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> candidate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>循环查找连接</li>\n<li>如果是全新的连接, 则跳过检查, 直接返回</li>\n<li>判断是否可用连接, 如果不是, 则禁止新流创建</li>\n</ol>\n<p>继续看<code>findConnection</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Returns a connection to host a new stream. This prefers the existing connection if it exists,</span></span><br><span class=\"line\"><span class=\"comment\">   * then the pool, finally building a new connection.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> RealConnection <span class=\"title\">findConnection</span><span class=\"params\">(<span class=\"keyword\">int</span> connectTimeout, <span class=\"keyword\">int</span> readTimeout, <span class=\"keyword\">int</span> writeTimeout,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">int</span> pingIntervalMillis, <span class=\"keyword\">boolean</span> connectionRetryEnabled)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从连接池中找到连接</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> foundPooledConnection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 实际需要返回的连接</span></span><br><span class=\"line\">    RealConnection result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 对应找到的路由</span></span><br><span class=\"line\">    Route selectedRoute = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 对应可释放的连接</span></span><br><span class=\"line\">    Connection releasedConnection;</span><br><span class=\"line\">    <span class=\"comment\">// 需要关闭的socket</span></span><br><span class=\"line\">    Socket toClose;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 异常判断</span></span><br><span class=\"line\">      <span class=\"comment\">// 判断是否连接已经被释放, codec是否为空, 请求是否被取消</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (released) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"released\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (codec != <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"codec != null\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (canceled) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 尝试寻找已经存在的连接来使用.</span></span><br><span class=\"line\">      <span class=\"comment\">// 但是需要注意的是, 已存在的连接可能已经无法再创建新的流</span></span><br><span class=\"line\">      <span class=\"comment\">// Attempt to use an already-allocated connection. We need to be careful here because our</span></span><br><span class=\"line\">      <span class=\"comment\">// already-allocated connection may have been restricted from creating new streams.</span></span><br><span class=\"line\">      releasedConnection = <span class=\"keyword\">this</span>.connection;</span><br><span class=\"line\">      <span class=\"comment\">// toClose如果无法创建流, 需要关闭的socket</span></span><br><span class=\"line\">      toClose = releaseIfNoNewStreams();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// We had an already-allocated connection and it's good.</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果当前连接不为空, 就说明这个连接是可以用的</span></span><br><span class=\"line\">        result = <span class=\"keyword\">this</span>.connection;</span><br><span class=\"line\">        releasedConnection = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!reportedAcquired) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If the connection was never reported acquired, don't report it as released!</span></span><br><span class=\"line\">        releasedConnection = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 如果没有现成的连接</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Attempt to get a connection from the pool.</span></span><br><span class=\"line\">        <span class=\"comment\">// 尝试从连接池中获取</span></span><br><span class=\"line\">        Internal.instance.get(connectionPool, address, <span class=\"keyword\">this</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 如果有复用的连接</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 表示找到连接池可复用的连接</span></span><br><span class=\"line\">          foundPooledConnection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">          result = connection;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          selectedRoute = route;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 关闭socket</span></span><br><span class=\"line\">    closeQuietly(toClose);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (releasedConnection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      eventListener.connectionReleased(call, releasedConnection);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (foundPooledConnection) &#123;</span><br><span class=\"line\">      eventListener.connectionAcquired(call, result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// If we found an already-allocated or pooled connection, we're done.</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果有存在已分配的连接或者是连接池内可复用的连接, 则直接返回该连接对象</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we need a route selection, make one. This is a blocking operation.</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> newRouteSelection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (selectedRoute == <span class=\"keyword\">null</span> &amp;&amp; (routeSelection == <span class=\"keyword\">null</span> || !routeSelection.hasNext())) &#123;</span><br><span class=\"line\">      newRouteSelection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 切换路由</span></span><br><span class=\"line\">      routeSelection = routeSelector.next();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (canceled) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newRouteSelection) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span></span><br><span class=\"line\">        <span class=\"comment\">// the pool. This could match due to connection coalescing.</span></span><br><span class=\"line\">        List&lt;Route&gt; routes = routeSelection.getAll();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = routes.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">          Route route = routes.get(i);</span><br><span class=\"line\">          <span class=\"comment\">// 获取可复用的连接</span></span><br><span class=\"line\">          Internal.instance.get(connectionPool, address, <span class=\"keyword\">this</span>, route);</span><br><span class=\"line\">          <span class=\"comment\">// 如果存在可复用连接</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            foundPooledConnection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            result = connection;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.route = route;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 如果没有找到可复用的连接</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!foundPooledConnection) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前路由为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selectedRoute == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          selectedRoute = routeSelection.next();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Create a connection and assign it to this allocation immediately. This makes it possible</span></span><br><span class=\"line\">        <span class=\"comment\">// for an asynchronous cancel() to interrupt the handshake we're about to do.</span></span><br><span class=\"line\">        route = selectedRoute;</span><br><span class=\"line\">        refusedStreamCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 创建新的连接</span></span><br><span class=\"line\">        result = <span class=\"keyword\">new</span> RealConnection(connectionPool, selectedRoute);</span><br><span class=\"line\">        acquire(result, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we found a pooled connection on the 2nd time around, we're done.</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果第二次有找到, 则返回复用的连接</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (foundPooledConnection) &#123;</span><br><span class=\"line\">      eventListener.connectionAcquired(call, result);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Do TCP + TLS handshakes. This is a blocking operation.</span></span><br><span class=\"line\">    <span class=\"comment\">// 做三次握手</span></span><br><span class=\"line\">    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,</span><br><span class=\"line\">        connectionRetryEnabled, call, eventListener);</span><br><span class=\"line\">    <span class=\"comment\">// 将该路由从错误缓存记录中移除</span></span><br><span class=\"line\">    routeDatabase().connected(result.route());</span><br><span class=\"line\"></span><br><span class=\"line\">    Socket socket = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      reportedAcquired = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Pool the connection.</span></span><br><span class=\"line\">      <span class=\"comment\">// 在连接池中添加该连接</span></span><br><span class=\"line\">      Internal.instance.put(connectionPool, result);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// If another multiplexed connection to the same address was created concurrently, then</span></span><br><span class=\"line\">      <span class=\"comment\">// release this connection and acquire that one.</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果有其他复数连接到相同地址, 则删除重复连接</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result.isMultiplexed()) &#123;</span><br><span class=\"line\">        socket = Internal.instance.deduplicate(connectionPool, address, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        result = connection;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    closeQuietly(socket);</span><br><span class=\"line\"></span><br><span class=\"line\">    eventListener.connectionAcquired(call, result);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>其实看方法注释, 我们大概可以知道这里做的就是返回一个连接, 首先会从连接池中来, 如果连接池中没有对应连接, 则再重新新建一个连接.</p>\n<p>具体的注释都在代码里了, 我们再看下其中几个调用方法.<br>首先我们将即将要释放的连接指向当前的连接, 通过调用<code>releaseIfNoNewStreams</code>方法, 返回需要关闭的socket<br>我们来看下<code>releaseIfNoNewStreams</code>方法的代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 如果当前连接无法新建流, 释放当前连接, 并且返回需要关闭的socket</span></span><br><span class=\"line\"><span class=\"comment\">   * 由于http2复数请求会使用同一个连接, 所以可能存在当前连接限制后续的请求</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> Socket <span class=\"title\">releaseIfNoNewStreams</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 断言锁持有</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> (Thread.holdsLock(connectionPool));</span><br><span class=\"line\">    RealConnection allocatedConnection = <span class=\"keyword\">this</span>.connection;</span><br><span class=\"line\">    <span class=\"comment\">// 当当前连接不为空, 而且没有新的流被创建</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allocatedConnection != <span class=\"keyword\">null</span> &amp;&amp; allocatedConnection.noNewStreams) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> deallocate(<span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 正常情况, 没有需要被关闭的socket返回</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到只有当当前连接存在, 而且不允许有新的流产生的时候, 才会返回执行<code>deallocate(false, false, true)</code>后的结果, 正常的情况下, 没有需要被关闭的socket返回<br>关于<code>deallocate</code>方法, 可以看下面的代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Socket <span class=\"title\">deallocate</span><span class=\"params\">(<span class=\"keyword\">boolean</span> noNewStreams, <span class=\"keyword\">boolean</span> released, <span class=\"keyword\">boolean</span> streamFinished)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> (Thread.holdsLock(connectionPool));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (streamFinished) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.codec = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (released) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.released = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Socket socket = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (noNewStreams) &#123;</span><br><span class=\"line\">        connection.noNewStreams = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.codec == <span class=\"keyword\">null</span> &amp;&amp; (<span class=\"keyword\">this</span>.released || connection.noNewStreams)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 释放连接</span></span><br><span class=\"line\">        release(connection);</span><br><span class=\"line\">        <span class=\"comment\">// 如果这个连接的当前的流为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (connection.allocations.isEmpty()) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 当连接的流为0时候的记录时间戳</span></span><br><span class=\"line\">          connection.idleAtNanos = System.nanoTime();</span><br><span class=\"line\">          <span class=\"comment\">// 判断连接是否闲置</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (Internal.instance.connectionBecameIdle(connectionPool, connection)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果闲置, 则返回需要关闭的socket</span></span><br><span class=\"line\">            socket = connection.socket();</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 回收</span></span><br><span class=\"line\">        connection = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> socket;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">release</span><span class=\"params\">(RealConnection connection)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = connection.allocations.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">      Reference&lt;StreamAllocation&gt; reference = connection.allocations.get(i);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (reference.get() == <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        connection.allocations.remove(i);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到这里具体做的就是, 编解码类对象<code>codec</code>赋值为null, 调用<code>release</code>释放连接, 当这个<code>connection</code>没有连接流的时候, 一并判断连接是否闲置, 如果闲置, 则返回对应的<code>socket</code>, 并将当前的<code>connection</code>赋值为null.而这里的<code>release</code>方法主要做的就是移除连接对应流引用的移除.</p>\n<p>我们回头去看<code>findConnection</code>方法内下一步<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// We had an already-allocated connection and it's good.</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果当前连接不为空, 就说明这个连接是可以用的</span></span><br><span class=\"line\">        result = <span class=\"keyword\">this</span>.connection;</span><br><span class=\"line\">        releasedConnection = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们知道前面调用<code>releaseIfNoNewStreams</code>的时候, 如果有返回socket, 那么connection也会被置为null, 所以这里connection不为空, 说明就是现在的连接是可以用的, 那么需要释放连接的对象就为null, 没必要被释放.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果没有现成的连接</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Attempt to get a connection from the pool.</span></span><br><span class=\"line\">        <span class=\"comment\">// 尝试从连接池中获取</span></span><br><span class=\"line\">        Internal.instance.get(connectionPool, address, <span class=\"keyword\">this</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 如果有复用的连接</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 表示找到连接池可复用的连接</span></span><br><span class=\"line\">          foundPooledConnection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">          result = connection;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          selectedRoute = route;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure></p>\n<p>而如果没有可用的连接, 那么就会从连接池中尝试获取<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回一个可重用的连接, 如果没有对应连接存在, 则返回null</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Nullable</span> <span class=\"function\">RealConnection <span class=\"title\">get</span><span class=\"params\">(Address address, StreamAllocation streamAllocation, Route route)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 断言锁的持有</span></span><br><span class=\"line\">  <span class=\"keyword\">assert</span> (Thread.holdsLock(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">  <span class=\"comment\">// 遍历</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (RealConnection connection : connections) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断连接是否可复用</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connection.isEligible(address, route)) &#123;</span><br><span class=\"line\">      streamAllocation.acquire(connection, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> connection;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(RealConnection connection, <span class=\"keyword\">boolean</span> reportedAcquired)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span> (Thread.holdsLock(connectionPool));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.connection != <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.connection = connection;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.reportedAcquired = reportedAcquired;</span><br><span class=\"line\">  <span class=\"comment\">// 添加一个流的引用</span></span><br><span class=\"line\">  connection.allocations.add(<span class=\"keyword\">new</span> StreamAllocationReference(<span class=\"keyword\">this</span>, callStackTrace));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到, 如果当前连接池中有连接可复用, 则会将新的流引用添加在<code>connection.allocations</code>中.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 关闭socket</span></span><br><span class=\"line\">    closeQuietly(toClose);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (releasedConnection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      eventListener.connectionReleased(call, releasedConnection);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (foundPooledConnection) &#123;</span><br><span class=\"line\">      eventListener.connectionAcquired(call, result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// If we found an already-allocated or pooled connection, we're done.</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果有存在已分配的连接或者是连接池内可复用的连接, 则直接返回该连接对象</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>再回到主方法内, 不论是否有找到可用的连接, 都会关闭socket, 然后根据是否存在需要释放的连接, 回调<code>eventListener.connectionReleased</code>, 并根据是否找到连接池内可用连接, 回调<code>eventListener.connectionAcquired</code>.当有实际可用的连接的时候, 那么直接返回该连接对象.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">boolean</span> newRouteSelection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (selectedRoute == <span class=\"keyword\">null</span> &amp;&amp; (routeSelection == <span class=\"keyword\">null</span> || !routeSelection.hasNext())) &#123;</span><br><span class=\"line\">      newRouteSelection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 切换路由</span></span><br><span class=\"line\">      routeSelection = routeSelector.next();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (canceled) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newRouteSelection) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span></span><br><span class=\"line\">        <span class=\"comment\">// the pool. This could match due to connection coalescing.</span></span><br><span class=\"line\">        List&lt;Route&gt; routes = routeSelection.getAll();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = routes.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">          Route route = routes.get(i);</span><br><span class=\"line\">          <span class=\"comment\">// 获取可复用的连接</span></span><br><span class=\"line\">          Internal.instance.get(connectionPool, address, <span class=\"keyword\">this</span>, route);</span><br><span class=\"line\">          <span class=\"comment\">// 如果存在可复用连接</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            foundPooledConnection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            result = connection;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.route = route;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 如果没有找到可复用的连接</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!foundPooledConnection) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前路由为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selectedRoute == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          selectedRoute = routeSelection.next();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Create a connection and assign it to this allocation immediately. This makes it possible</span></span><br><span class=\"line\">        <span class=\"comment\">// for an asynchronous cancel() to interrupt the handshake we're about to do.</span></span><br><span class=\"line\">        route = selectedRoute;</span><br><span class=\"line\">        refusedStreamCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 创建新的连接</span></span><br><span class=\"line\">        result = <span class=\"keyword\">new</span> RealConnection(connectionPool, selectedRoute);</span><br><span class=\"line\">        acquire(result, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// If we found a pooled connection on the 2nd time around, we're done.</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果第二次有找到, 则返回复用的连接</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (foundPooledConnection) &#123;</span><br><span class=\"line\">      eventListener.connectionAcquired(call, result);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>当仍然没有找到连接的时候, 那么就会切换路由, 再次从连接池内找对应路由可复用的连接, 如果有找到, 则返回这次复用的连接对象.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Do TCP + TLS handshakes. This is a blocking operation.</span></span><br><span class=\"line\">    <span class=\"comment\">// 做三次握手</span></span><br><span class=\"line\">    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,</span><br><span class=\"line\">        connectionRetryEnabled, call, eventListener);</span><br><span class=\"line\">    <span class=\"comment\">// 将该路由从错误缓存记录中移除</span></span><br><span class=\"line\">    routeDatabase().connected(result.route());</span><br><span class=\"line\"></span><br><span class=\"line\">    Socket socket = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      reportedAcquired = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Pool the connection.</span></span><br><span class=\"line\">      <span class=\"comment\">// 在连接池中添加该连接</span></span><br><span class=\"line\">      Internal.instance.put(connectionPool, result);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// If another multiplexed connection to the same address was created concurrently, then</span></span><br><span class=\"line\">      <span class=\"comment\">// release this connection and acquire that one.</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果有其他复数连接到相同地址, 则删除重复连接</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result.isMultiplexed()) &#123;</span><br><span class=\"line\">        socket = Internal.instance.deduplicate(connectionPool, address, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        result = connection;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    closeQuietly(socket);</span><br><span class=\"line\"></span><br><span class=\"line\">    eventListener.connectionAcquired(call, result);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br></pre></td></tr></table></figure>\n<p>但如果这次仍然没有找到对应可用的连接, 则只好新建连接, 并将流引用加到对应的<code>conection</code>对象中, 然后做三次握手, 并将对应的路由从错误缓存中移除.<br>最后还做了重复连接的去重的工作, 然后再返回这个新建的连接对象.</p>\n<p>截止至此, 寻找可用连接的代码分析就完成了.</p>\n<p>回头再看下<code>HttpCodec的初始化</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> HttpCodec <span class=\"title\">newCodec</span><span class=\"params\">(OkHttpClient client, Interceptor.Chain chain,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      StreamAllocation streamAllocation)</span> <span class=\"keyword\">throws</span> SocketException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (http2Connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Http2Codec(client, chain, streamAllocation, http2Connection);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      socket.setSoTimeout(chain.readTimeoutMillis());</span><br><span class=\"line\">      source.timeout().timeout(chain.readTimeoutMillis(), MILLISECONDS);</span><br><span class=\"line\">      sink.timeout().timeout(chain.writeTimeoutMillis(), MILLISECONDS);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Http1Codec(client, streamAllocation, source, sink);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>主要就是根据判断是Http1还是Http2来判断新建哪个编解码类.</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>可以看出, <code>ConnectionInterceptor</code>拦截器, 主要做的是,</p>\n<ol>\n<li>获取当前连接(<code>connection</code>), 如果不可用, 则从连接池中获取可复用连接, 如果仍然获取不到, 则新建连接</li>\n<li>通过连接, 生成<code>HttpCodec</code>对象</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上文简单概括了下<code>okHttp3</code>请求的整体流程, 本篇主要看下<code>ConnectInterceptor</code>的主要工作内容<br>","more":"</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>已知拦截器链都是从各拦截器的<code>intercept</code>方法开始调用, 那么我们从<code>ConnectInterceptor</code>的<code>intercept</code>代码开始看起<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class=\"line\">    Request request = realChain.request();</span><br><span class=\"line\">    <span class=\"comment\">// 从RetryAndFollowUpInterceptor获取</span></span><br><span class=\"line\">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 判断请求是不是GET方法, 不是的情况下,需要进行有效监测</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class=\"string\">\"GET\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 新建HttpCodec</span></span><br><span class=\"line\">    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br><span class=\"line\">    RealConnection connection = streamAllocation.connection();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以看到, 获取连接的拦截器内, 主要只有三个步骤:</p>\n<ol>\n<li>初始化<code>HttpCodec</code></li>\n<li>通过<code>streamAllocation</code>获取连接</li>\n<li>将<code>httpCodec</code>和<code>connection</code>作为参数带到下个拦截器的调用方法中</li>\n</ol>\n<p>这里<code>HttpCodec</code>我们可以大概了解下, 它是个抽象类, 有<code>Http1Codec</code>和<code>Http2Codec</code>实现它, 分别根据Http/1.1,和Http/2做针对请求响应不同的编解码处理.</p>\n<p>而<code>StreamAllocation</code>对象是在<code>RetryAndFollowUpInterceptor</code>中新建获取到的, 它做了<code>Streams</code>, <code>Connections</code>, <code>Calls</code>的关系管理.这里要注意的是<code>Streams</code>表示的是逻辑层面的连接(流), 每个连接(<code>Connection</code>)都定义了可以并发请求的连接(<code>Streams</code>), HTTP/1.x每次只能携带一次, HTTP/2可以携带多次.</p>\n<p>回头我们看下<code>streamAllocation.newStream</code>做了什么<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> HttpCodec <span class=\"title\">newStream</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      OkHttpClient client, Interceptor.Chain chain, <span class=\"keyword\">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> connectTimeout = chain.connectTimeoutMillis();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> readTimeout = chain.readTimeoutMillis();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> writeTimeout = chain.writeTimeoutMillis();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pingIntervalMillis = client.pingIntervalMillis();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> connectionRetryEnabled = client.retryOnConnectionFailure();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 遍历查找健康可用的连接</span></span><br><span class=\"line\">      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class=\"line\">          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class=\"line\">      <span class=\"comment\">// HttpCodec初始化</span></span><br><span class=\"line\">      HttpCodec resultCodec = resultConnection.newCodec(client, chain, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">        codec = resultCodec;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> resultCodec;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RouteException(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到它这里也就做了三个动作</p>\n<ol>\n<li>配置连接超时, 读取超时, 写超时的时间.</li>\n<li>查找健康可用的连接</li>\n<li>根据可用连接初始化<code>HttpCodec</code></li>\n</ol>\n<p>继续往下看:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> RealConnection <span class=\"title\">findHealthyConnection</span><span class=\"params\">(<span class=\"keyword\">int</span> connectTimeout, <span class=\"keyword\">int</span> readTimeout,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">int</span> writeTimeout, <span class=\"keyword\">int</span> pingIntervalMillis, <span class=\"keyword\">boolean</span> connectionRetryEnabled,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> doExtensiveHealthChecks)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 查找连接, 更加倾向连接池内已存在的连接, 否则会重新构建</span></span><br><span class=\"line\">      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</span><br><span class=\"line\">          pingIntervalMillis, connectionRetryEnabled);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// If this is a brand new connection, we can skip the extensive health checks.</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果是全新的连接, 则跳过可用检查, 直接返回</span></span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (candidate.successCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> candidate;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Do a (potentially slow) check to confirm that the pooled connection is still good. If it</span></span><br><span class=\"line\">      <span class=\"comment\">// isn't, take it out of the pool and start again.</span></span><br><span class=\"line\">      <span class=\"comment\">// 判断是否是可用连接</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 禁止新流创建</span></span><br><span class=\"line\">        noNewStreams();</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> candidate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>循环查找连接</li>\n<li>如果是全新的连接, 则跳过检查, 直接返回</li>\n<li>判断是否可用连接, 如果不是, 则禁止新流创建</li>\n</ol>\n<p>继续看<code>findConnection</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Returns a connection to host a new stream. This prefers the existing connection if it exists,</span></span><br><span class=\"line\"><span class=\"comment\">   * then the pool, finally building a new connection.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> RealConnection <span class=\"title\">findConnection</span><span class=\"params\">(<span class=\"keyword\">int</span> connectTimeout, <span class=\"keyword\">int</span> readTimeout, <span class=\"keyword\">int</span> writeTimeout,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">int</span> pingIntervalMillis, <span class=\"keyword\">boolean</span> connectionRetryEnabled)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从连接池中找到连接</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> foundPooledConnection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 实际需要返回的连接</span></span><br><span class=\"line\">    RealConnection result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 对应找到的路由</span></span><br><span class=\"line\">    Route selectedRoute = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 对应可释放的连接</span></span><br><span class=\"line\">    Connection releasedConnection;</span><br><span class=\"line\">    <span class=\"comment\">// 需要关闭的socket</span></span><br><span class=\"line\">    Socket toClose;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 异常判断</span></span><br><span class=\"line\">      <span class=\"comment\">// 判断是否连接已经被释放, codec是否为空, 请求是否被取消</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (released) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"released\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (codec != <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"codec != null\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (canceled) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 尝试寻找已经存在的连接来使用.</span></span><br><span class=\"line\">      <span class=\"comment\">// 但是需要注意的是, 已存在的连接可能已经无法再创建新的流</span></span><br><span class=\"line\">      <span class=\"comment\">// Attempt to use an already-allocated connection. We need to be careful here because our</span></span><br><span class=\"line\">      <span class=\"comment\">// already-allocated connection may have been restricted from creating new streams.</span></span><br><span class=\"line\">      releasedConnection = <span class=\"keyword\">this</span>.connection;</span><br><span class=\"line\">      <span class=\"comment\">// toClose如果无法创建流, 需要关闭的socket</span></span><br><span class=\"line\">      toClose = releaseIfNoNewStreams();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// We had an already-allocated connection and it's good.</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果当前连接不为空, 就说明这个连接是可以用的</span></span><br><span class=\"line\">        result = <span class=\"keyword\">this</span>.connection;</span><br><span class=\"line\">        releasedConnection = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!reportedAcquired) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If the connection was never reported acquired, don't report it as released!</span></span><br><span class=\"line\">        releasedConnection = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 如果没有现成的连接</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Attempt to get a connection from the pool.</span></span><br><span class=\"line\">        <span class=\"comment\">// 尝试从连接池中获取</span></span><br><span class=\"line\">        Internal.instance.get(connectionPool, address, <span class=\"keyword\">this</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 如果有复用的连接</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 表示找到连接池可复用的连接</span></span><br><span class=\"line\">          foundPooledConnection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">          result = connection;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          selectedRoute = route;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 关闭socket</span></span><br><span class=\"line\">    closeQuietly(toClose);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (releasedConnection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      eventListener.connectionReleased(call, releasedConnection);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (foundPooledConnection) &#123;</span><br><span class=\"line\">      eventListener.connectionAcquired(call, result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// If we found an already-allocated or pooled connection, we're done.</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果有存在已分配的连接或者是连接池内可复用的连接, 则直接返回该连接对象</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we need a route selection, make one. This is a blocking operation.</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> newRouteSelection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (selectedRoute == <span class=\"keyword\">null</span> &amp;&amp; (routeSelection == <span class=\"keyword\">null</span> || !routeSelection.hasNext())) &#123;</span><br><span class=\"line\">      newRouteSelection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 切换路由</span></span><br><span class=\"line\">      routeSelection = routeSelector.next();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (canceled) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newRouteSelection) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span></span><br><span class=\"line\">        <span class=\"comment\">// the pool. This could match due to connection coalescing.</span></span><br><span class=\"line\">        List&lt;Route&gt; routes = routeSelection.getAll();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = routes.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">          Route route = routes.get(i);</span><br><span class=\"line\">          <span class=\"comment\">// 获取可复用的连接</span></span><br><span class=\"line\">          Internal.instance.get(connectionPool, address, <span class=\"keyword\">this</span>, route);</span><br><span class=\"line\">          <span class=\"comment\">// 如果存在可复用连接</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            foundPooledConnection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            result = connection;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.route = route;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 如果没有找到可复用的连接</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!foundPooledConnection) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前路由为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selectedRoute == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          selectedRoute = routeSelection.next();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Create a connection and assign it to this allocation immediately. This makes it possible</span></span><br><span class=\"line\">        <span class=\"comment\">// for an asynchronous cancel() to interrupt the handshake we're about to do.</span></span><br><span class=\"line\">        route = selectedRoute;</span><br><span class=\"line\">        refusedStreamCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 创建新的连接</span></span><br><span class=\"line\">        result = <span class=\"keyword\">new</span> RealConnection(connectionPool, selectedRoute);</span><br><span class=\"line\">        acquire(result, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we found a pooled connection on the 2nd time around, we're done.</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果第二次有找到, 则返回复用的连接</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (foundPooledConnection) &#123;</span><br><span class=\"line\">      eventListener.connectionAcquired(call, result);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Do TCP + TLS handshakes. This is a blocking operation.</span></span><br><span class=\"line\">    <span class=\"comment\">// 做三次握手</span></span><br><span class=\"line\">    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,</span><br><span class=\"line\">        connectionRetryEnabled, call, eventListener);</span><br><span class=\"line\">    <span class=\"comment\">// 将该路由从错误缓存记录中移除</span></span><br><span class=\"line\">    routeDatabase().connected(result.route());</span><br><span class=\"line\"></span><br><span class=\"line\">    Socket socket = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      reportedAcquired = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Pool the connection.</span></span><br><span class=\"line\">      <span class=\"comment\">// 在连接池中添加该连接</span></span><br><span class=\"line\">      Internal.instance.put(connectionPool, result);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// If another multiplexed connection to the same address was created concurrently, then</span></span><br><span class=\"line\">      <span class=\"comment\">// release this connection and acquire that one.</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果有其他复数连接到相同地址, 则删除重复连接</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result.isMultiplexed()) &#123;</span><br><span class=\"line\">        socket = Internal.instance.deduplicate(connectionPool, address, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        result = connection;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    closeQuietly(socket);</span><br><span class=\"line\"></span><br><span class=\"line\">    eventListener.connectionAcquired(call, result);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>其实看方法注释, 我们大概可以知道这里做的就是返回一个连接, 首先会从连接池中来, 如果连接池中没有对应连接, 则再重新新建一个连接.</p>\n<p>具体的注释都在代码里了, 我们再看下其中几个调用方法.<br>首先我们将即将要释放的连接指向当前的连接, 通过调用<code>releaseIfNoNewStreams</code>方法, 返回需要关闭的socket<br>我们来看下<code>releaseIfNoNewStreams</code>方法的代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 如果当前连接无法新建流, 释放当前连接, 并且返回需要关闭的socket</span></span><br><span class=\"line\"><span class=\"comment\">   * 由于http2复数请求会使用同一个连接, 所以可能存在当前连接限制后续的请求</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> Socket <span class=\"title\">releaseIfNoNewStreams</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 断言锁持有</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> (Thread.holdsLock(connectionPool));</span><br><span class=\"line\">    RealConnection allocatedConnection = <span class=\"keyword\">this</span>.connection;</span><br><span class=\"line\">    <span class=\"comment\">// 当当前连接不为空, 而且没有新的流被创建</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allocatedConnection != <span class=\"keyword\">null</span> &amp;&amp; allocatedConnection.noNewStreams) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> deallocate(<span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 正常情况, 没有需要被关闭的socket返回</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到只有当当前连接存在, 而且不允许有新的流产生的时候, 才会返回执行<code>deallocate(false, false, true)</code>后的结果, 正常的情况下, 没有需要被关闭的socket返回<br>关于<code>deallocate</code>方法, 可以看下面的代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Socket <span class=\"title\">deallocate</span><span class=\"params\">(<span class=\"keyword\">boolean</span> noNewStreams, <span class=\"keyword\">boolean</span> released, <span class=\"keyword\">boolean</span> streamFinished)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> (Thread.holdsLock(connectionPool));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (streamFinished) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.codec = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (released) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.released = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Socket socket = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (noNewStreams) &#123;</span><br><span class=\"line\">        connection.noNewStreams = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.codec == <span class=\"keyword\">null</span> &amp;&amp; (<span class=\"keyword\">this</span>.released || connection.noNewStreams)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 释放连接</span></span><br><span class=\"line\">        release(connection);</span><br><span class=\"line\">        <span class=\"comment\">// 如果这个连接的当前的流为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (connection.allocations.isEmpty()) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 当连接的流为0时候的记录时间戳</span></span><br><span class=\"line\">          connection.idleAtNanos = System.nanoTime();</span><br><span class=\"line\">          <span class=\"comment\">// 判断连接是否闲置</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (Internal.instance.connectionBecameIdle(connectionPool, connection)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果闲置, 则返回需要关闭的socket</span></span><br><span class=\"line\">            socket = connection.socket();</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 回收</span></span><br><span class=\"line\">        connection = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> socket;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">release</span><span class=\"params\">(RealConnection connection)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = connection.allocations.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">      Reference&lt;StreamAllocation&gt; reference = connection.allocations.get(i);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (reference.get() == <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        connection.allocations.remove(i);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到这里具体做的就是, 编解码类对象<code>codec</code>赋值为null, 调用<code>release</code>释放连接, 当这个<code>connection</code>没有连接流的时候, 一并判断连接是否闲置, 如果闲置, 则返回对应的<code>socket</code>, 并将当前的<code>connection</code>赋值为null.而这里的<code>release</code>方法主要做的就是移除连接对应流引用的移除.</p>\n<p>我们回头去看<code>findConnection</code>方法内下一步<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// We had an already-allocated connection and it's good.</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果当前连接不为空, 就说明这个连接是可以用的</span></span><br><span class=\"line\">        result = <span class=\"keyword\">this</span>.connection;</span><br><span class=\"line\">        releasedConnection = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们知道前面调用<code>releaseIfNoNewStreams</code>的时候, 如果有返回socket, 那么connection也会被置为null, 所以这里connection不为空, 说明就是现在的连接是可以用的, 那么需要释放连接的对象就为null, 没必要被释放.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果没有现成的连接</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Attempt to get a connection from the pool.</span></span><br><span class=\"line\">        <span class=\"comment\">// 尝试从连接池中获取</span></span><br><span class=\"line\">        Internal.instance.get(connectionPool, address, <span class=\"keyword\">this</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 如果有复用的连接</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 表示找到连接池可复用的连接</span></span><br><span class=\"line\">          foundPooledConnection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">          result = connection;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          selectedRoute = route;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure></p>\n<p>而如果没有可用的连接, 那么就会从连接池中尝试获取<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回一个可重用的连接, 如果没有对应连接存在, 则返回null</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Nullable</span> <span class=\"function\">RealConnection <span class=\"title\">get</span><span class=\"params\">(Address address, StreamAllocation streamAllocation, Route route)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 断言锁的持有</span></span><br><span class=\"line\">  <span class=\"keyword\">assert</span> (Thread.holdsLock(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">  <span class=\"comment\">// 遍历</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (RealConnection connection : connections) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断连接是否可复用</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connection.isEligible(address, route)) &#123;</span><br><span class=\"line\">      streamAllocation.acquire(connection, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> connection;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(RealConnection connection, <span class=\"keyword\">boolean</span> reportedAcquired)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span> (Thread.holdsLock(connectionPool));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.connection != <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.connection = connection;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.reportedAcquired = reportedAcquired;</span><br><span class=\"line\">  <span class=\"comment\">// 添加一个流的引用</span></span><br><span class=\"line\">  connection.allocations.add(<span class=\"keyword\">new</span> StreamAllocationReference(<span class=\"keyword\">this</span>, callStackTrace));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到, 如果当前连接池中有连接可复用, 则会将新的流引用添加在<code>connection.allocations</code>中.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 关闭socket</span></span><br><span class=\"line\">    closeQuietly(toClose);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (releasedConnection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      eventListener.connectionReleased(call, releasedConnection);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (foundPooledConnection) &#123;</span><br><span class=\"line\">      eventListener.connectionAcquired(call, result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// If we found an already-allocated or pooled connection, we're done.</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果有存在已分配的连接或者是连接池内可复用的连接, 则直接返回该连接对象</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>再回到主方法内, 不论是否有找到可用的连接, 都会关闭socket, 然后根据是否存在需要释放的连接, 回调<code>eventListener.connectionReleased</code>, 并根据是否找到连接池内可用连接, 回调<code>eventListener.connectionAcquired</code>.当有实际可用的连接的时候, 那么直接返回该连接对象.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">boolean</span> newRouteSelection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (selectedRoute == <span class=\"keyword\">null</span> &amp;&amp; (routeSelection == <span class=\"keyword\">null</span> || !routeSelection.hasNext())) &#123;</span><br><span class=\"line\">      newRouteSelection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 切换路由</span></span><br><span class=\"line\">      routeSelection = routeSelector.next();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (canceled) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newRouteSelection) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span></span><br><span class=\"line\">        <span class=\"comment\">// the pool. This could match due to connection coalescing.</span></span><br><span class=\"line\">        List&lt;Route&gt; routes = routeSelection.getAll();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = routes.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">          Route route = routes.get(i);</span><br><span class=\"line\">          <span class=\"comment\">// 获取可复用的连接</span></span><br><span class=\"line\">          Internal.instance.get(connectionPool, address, <span class=\"keyword\">this</span>, route);</span><br><span class=\"line\">          <span class=\"comment\">// 如果存在可复用连接</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            foundPooledConnection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            result = connection;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.route = route;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 如果没有找到可复用的连接</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!foundPooledConnection) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前路由为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selectedRoute == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          selectedRoute = routeSelection.next();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Create a connection and assign it to this allocation immediately. This makes it possible</span></span><br><span class=\"line\">        <span class=\"comment\">// for an asynchronous cancel() to interrupt the handshake we're about to do.</span></span><br><span class=\"line\">        route = selectedRoute;</span><br><span class=\"line\">        refusedStreamCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 创建新的连接</span></span><br><span class=\"line\">        result = <span class=\"keyword\">new</span> RealConnection(connectionPool, selectedRoute);</span><br><span class=\"line\">        acquire(result, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// If we found a pooled connection on the 2nd time around, we're done.</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果第二次有找到, 则返回复用的连接</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (foundPooledConnection) &#123;</span><br><span class=\"line\">      eventListener.connectionAcquired(call, result);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>当仍然没有找到连接的时候, 那么就会切换路由, 再次从连接池内找对应路由可复用的连接, 如果有找到, 则返回这次复用的连接对象.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Do TCP + TLS handshakes. This is a blocking operation.</span></span><br><span class=\"line\">    <span class=\"comment\">// 做三次握手</span></span><br><span class=\"line\">    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,</span><br><span class=\"line\">        connectionRetryEnabled, call, eventListener);</span><br><span class=\"line\">    <span class=\"comment\">// 将该路由从错误缓存记录中移除</span></span><br><span class=\"line\">    routeDatabase().connected(result.route());</span><br><span class=\"line\"></span><br><span class=\"line\">    Socket socket = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      reportedAcquired = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Pool the connection.</span></span><br><span class=\"line\">      <span class=\"comment\">// 在连接池中添加该连接</span></span><br><span class=\"line\">      Internal.instance.put(connectionPool, result);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// If another multiplexed connection to the same address was created concurrently, then</span></span><br><span class=\"line\">      <span class=\"comment\">// release this connection and acquire that one.</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果有其他复数连接到相同地址, 则删除重复连接</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result.isMultiplexed()) &#123;</span><br><span class=\"line\">        socket = Internal.instance.deduplicate(connectionPool, address, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        result = connection;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    closeQuietly(socket);</span><br><span class=\"line\"></span><br><span class=\"line\">    eventListener.connectionAcquired(call, result);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br></pre></td></tr></table></figure>\n<p>但如果这次仍然没有找到对应可用的连接, 则只好新建连接, 并将流引用加到对应的<code>conection</code>对象中, 然后做三次握手, 并将对应的路由从错误缓存中移除.<br>最后还做了重复连接的去重的工作, 然后再返回这个新建的连接对象.</p>\n<p>截止至此, 寻找可用连接的代码分析就完成了.</p>\n<p>回头再看下<code>HttpCodec的初始化</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> HttpCodec <span class=\"title\">newCodec</span><span class=\"params\">(OkHttpClient client, Interceptor.Chain chain,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      StreamAllocation streamAllocation)</span> <span class=\"keyword\">throws</span> SocketException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (http2Connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Http2Codec(client, chain, streamAllocation, http2Connection);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      socket.setSoTimeout(chain.readTimeoutMillis());</span><br><span class=\"line\">      source.timeout().timeout(chain.readTimeoutMillis(), MILLISECONDS);</span><br><span class=\"line\">      sink.timeout().timeout(chain.writeTimeoutMillis(), MILLISECONDS);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Http1Codec(client, streamAllocation, source, sink);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>主要就是根据判断是Http1还是Http2来判断新建哪个编解码类.</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>可以看出, <code>ConnectionInterceptor</code>拦截器, 主要做的是,</p>\n<ol>\n<li>获取当前连接(<code>connection</code>), 如果不可用, 则从连接池中获取可复用连接, 如果仍然获取不到, 则新建连接</li>\n<li>通过连接, 生成<code>HttpCodec</code>对象</li>\n</ol>"},{"title":"ARouter源码解析","date":"2018-05-17T16:00:00.000Z","_content":"如果应用项目要做模块化, 必然绕不开为了模块间跳转解耦而做的处理, 我们都知道一般都会采用路由模式, 本篇主要解析阿里的开源路由框架`ARouter`, 源码地址可见[Github](https://github.com/alibaba/ARouter),本篇分析版本为api`1.3.1`\n<!--more-->\n## 初始化\n感谢源码自带Demo, 我们直接从他的整个使用流程开始看起.忽略掉Log模式和Debug模式的开启, 首先我们需要初始化`ARouter`\n``` java\nARouter.init(getApplication());\n```\n它内部实际调用的是`LogisticsCenter.init(Context context, ThreadPoolExecutor tpe)`\n``` java\npublic synchronized static void init(Context context, ThreadPoolExecutor tpe) throws HandlerException {\n        mContext = context;\n        executor = tpe;\n\n        try {\n            long startInit = System.currentTimeMillis();\n            //billy.qi modified at 2017-12-06\n            //load by plugin first\n            loadRouterMap();\n            if (registerByPlugin) {\n                logger.info(TAG, \"Load router map by arouter-auto-register plugin.\");\n            } else {\n                Set<String> routerMap;\n\n                // It will rebuild router map every times when debuggable.\n                if (ARouter.debuggable() || PackageUtils.isNewVersion(context)) {\n                    logger.info(TAG, \"Run with debug mode or new install, rebuild router map.\");\n                    // These class was generated by arouter-compiler.\n                    // 通过arouter-compiler生成\n                    routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);\n                    if (!routerMap.isEmpty()) {\n                        context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply();\n                    }\n\n                    // 当router map更新的时候保存新的版本号\n                    PackageUtils.updateVersion(context);    // Save new version name when router map update finishes.\n                } else {\n                    logger.info(TAG, \"Load router map from cache.\");\n                    routerMap = new HashSet<>(context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).getStringSet(AROUTER_SP_KEY_MAP, new HashSet<String>()));\n                }\n\n                logger.info(TAG, \"Find router map finished, map size = \" + routerMap.size() + \", cost \" + (System.currentTimeMillis() - startInit) + \" ms.\");\n                startInit = System.currentTimeMillis();\n\n                for (String className : routerMap) {\n                    if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) {\n                        // This one of root elements, load root.\n                        ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex);\n                    } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) {\n                        // Load interceptorMeta\n                        ((IInterceptorGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex);\n                    } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) {\n                        // Load providerIndex\n                        ((IProviderGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex);\n                    }\n                }\n            }\n\n            logger.info(TAG, \"Load root element finished, cost \" + (System.currentTimeMillis() - startInit) + \" ms.\");\n\n            if (Warehouse.groupsIndex.size() == 0) {\n                logger.error(TAG, \"No mapping files were found, check your configuration please!\");\n            }\n\n            if (ARouter.debuggable()) {\n                logger.debug(TAG, String.format(Locale.getDefault(), \"LogisticsCenter has already been loaded, GroupIndex[%d], InterceptorIndex[%d], ProviderIndex[%d]\", Warehouse.groupsIndex.size(), Warehouse.interceptorsIndex.size(), Warehouse.providersIndex.size()));\n            }\n        } catch (Exception e) {\n            throw new HandlerException(TAG + \"ARouter init logistics center exception! [\" + e.getMessage() + \"]\");\n        }\n    }\n```\n这里`loadRouterMap()`方法就是将是否通过插件注册的tag初始化为`false`, 我们主要看正常流程下的注册, 所以关注点在`else`的代码块中.对于`routerMap`从上下文我们可以看出, 他是`APT`自动生成的类名集合.\n\n在`Debug`模式下, 当每次更新路由缓存的版本的时候, 都会从指定包名`com.alibaba.android.arouter.routes`收集所有的className, 如果不为空 则更新磁盘缓存.\n\n而非`Debug`模式下, 不做收集, 直接获取磁盘缓存, 如果没有则new一个空集合.\n\n然后通过反射新建对应类实例并调用`load`方法.我们可以看下`debug`模式下, `APT`生成类文件下的`load`函数具体执行了什么\n``` java\npublic class ARouter$$Group$$arouter implements IRouteGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> atlas) {\n    atlas.put(\"/arouter/service/autowired\", RouteMeta.build(RouteType.PROVIDER, AutowiredServiceImpl.class, \"/arouter/service/autowired\", \"arouter\", null, -1, -2147483648));\n    atlas.put(\"/arouter/service/interceptor\", RouteMeta.build(RouteType.PROVIDER, InterceptorServiceImpl.class, \"/arouter/service/interceptor\", \"arouter\", null, -1, -2147483648));\n  }\n}\n\npublic class ARouter$$Providers$$arouterapi implements IProviderGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> providers) {\n    providers.put(\"com.alibaba.android.arouter.facade.service.AutowiredService\", RouteMeta.build(RouteType.PROVIDER, AutowiredServiceImpl.class, \"/arouter/service/autowired\", \"arouter\", null, -1, -2147483648));\n    providers.put(\"com.alibaba.android.arouter.facade.service.InterceptorService\", RouteMeta.build(RouteType.PROVIDER, InterceptorServiceImpl.class, \"/arouter/service/interceptor\", \"arouter\", null, -1, -2147483648));\n  }\n}\n\npublic class ARouter$$Root$$arouterapi implements IRouteRoot {\n  @Override\n  public void loadInto(Map<String, Class<? extends IRouteGroup>> routes) {\n    routes.put(\"arouter\", ARouter$$Group$$arouter.class);\n  }\n}\n```\n可以看出所有`loadInto()`方法执行的都是将注解的信息通过`Map`强引用做内存缓存管理.这里`Warehouse.groupsIndex`管理的是组的路由生成文件的内存, `Warehouse.interceptorsIndex`拦截器的索引管理, `Warehouse.providersIndex`服务(不是四大组件, 而是实现了继承`IProvider`接口的对象)索引管理.\n## 跳转\n我们先看下对应的API\n``` java\nARouter.getInstance()\n       .build(\"/test/activity2\")\n       .navigation();\n```\n首先需要`build`一个`Postcard`对象, 他包含了我们传递的跳转信息.\n``` java\nprotected Postcard build(String path) {\n        if (TextUtils.isEmpty(path)) {\n            throw new HandlerException(Consts.TAG + \"Parameter is invalid!\");\n        } else {\n          // 判断是否重写跳转URL, 没有就使用原来的path构建Postcard\n            PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);\n            if (null != pService) {\n                path = pService.forString(path);\n            }\n            return build(path, extractGroup(path));\n        }\n    }\n\nprotected Postcard build(String path, String group) {\n        if (TextUtils.isEmpty(path) || TextUtils.isEmpty(group)) {\n            throw new HandlerException(Consts.TAG + \"Parameter is invalid!\");\n        } else {\n            PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);\n            if (null != pService) {\n                path = pService.forString(path);\n            }\n            return new Postcard(path, group);\n        }\n    }\n```\n然后通过`postcard.navigation()`做跳转工作, 在这个方法内首先会针对我们记载路由信息的`postcard`通过调用`LogisticsCenter.completion(postcard);`进行信息补充完善\n``` java\npublic synchronized static void completion(Postcard postcard) {\n        if (null == postcard) {\n            throw new NoRouteFoundException(TAG + \"No postcard!\");\n        }\n\n        // 通过path获取路由基础信息\n        RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());\n        // 如果没有获取到路由基础信息\n        if (null == routeMeta) {    // Maybe its does't exist, or didn't load.\n            // 则重新通过反射进行加载\n            Class<? extends IRouteGroup> groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());  // Load route meta.\n            if (null == groupMeta) {\n                throw new NoRouteFoundException(TAG + \"There is no route match the path [\" + postcard.getPath() + \"], in group [\" + postcard.getGroup() + \"]\");\n            } else {\n                // Load route and cache it into memory, then delete from metas.\n                try {\n                    if (ARouter.debuggable()) {\n                        logger.debug(TAG, String.format(Locale.getDefault(), \"The group [%s] starts loading, trigger by [%s]\", postcard.getGroup(), postcard.getPath()));\n                    }\n\n                    IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();\n                    iGroupInstance.loadInto(Warehouse.routes);\n                    Warehouse.groupsIndex.remove(postcard.getGroup());\n\n                    if (ARouter.debuggable()) {\n                        logger.debug(TAG, String.format(Locale.getDefault(), \"The group [%s] has already been loaded, trigger by [%s]\", postcard.getGroup(), postcard.getPath()));\n                    }\n                } catch (Exception e) {\n                    throw new HandlerException(TAG + \"Fatal exception when loading group meta. [\" + e.getMessage() + \"]\");\n                }\n\n                // 递归进行路由的完善工作\n                completion(postcard);   // Reload\n            }\n        } else {\n            // 完善postcard信息\n            postcard.setDestination(routeMeta.getDestination());\n            postcard.setType(routeMeta.getType());\n            postcard.setPriority(routeMeta.getPriority());\n            postcard.setExtra(routeMeta.getExtra());\n\n            Uri rawUri = postcard.getUri();\n            if (null != rawUri) {   // Try to set params into bundle.\n                Map<String, String> resultMap = TextUtils.splitQueryParameters(rawUri);\n                Map<String, Integer> paramsType = routeMeta.getParamsType();\n\n                if (MapUtils.isNotEmpty(paramsType)) {\n                    // Set value by its type, just for params which annotation by @Param\n                    for (Map.Entry<String, Integer> params : paramsType.entrySet()) {\n                        setValue(postcard,\n                                params.getValue(),\n                                params.getKey(),\n                                resultMap.get(params.getKey()));\n                    }\n\n                    // Save params name which need auto inject.\n                    postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(new String[]{}));\n                }\n\n                // Save raw uri\n                postcard.withString(ARouter.RAW_URI, rawUri.toString());\n            }\n\n            switch (routeMeta.getType()) {\n                case PROVIDER:  // if the route is provider, should find its instance\n                    // Its provider, so it must implement IProvider\n                    Class<? extends IProvider> providerMeta = (Class<? extends IProvider>) routeMeta.getDestination();\n                    IProvider instance = Warehouse.providers.get(providerMeta);\n                    switch (routeMeta.getType()) {\n                case PROVIDER:  // if the route is provider, should find its instance\n                    // Its provider, so it must implement IProvider\n                    // 如果路由目标是一个provider\n                    // 需要找到目标实例\n                    Class<? extends IProvider> providerMeta = (Class<? extends IProvider>) routeMeta.getDestination();\n                    IProvider instance = Warehouse.providers.get(providerMeta);\n                    if (null == instance) { // There's no instance of this provider\n                        IProvider provider;\n                        try {\n                            provider = providerMeta.getConstructor().newInstance();\n                            provider.init(mContext);\n                            Warehouse.providers.put(providerMeta, provider);\n                            instance = provider;\n                        } catch (Exception e) {\n                            throw new HandlerException(\"Init provider failed! \" + e.getMessage());\n                        }\n                    }\n                    postcard.setProvider(instance);\n                    // provider不会触发拦截器\n                    postcard.greenChannel();    // Provider should skip all of interceptors\n                    break;\n                case FRAGMENT:\n                    // fragment不会触发拦截器\n                    postcard.greenChannel();    // Fragment needn't interceptors\n                default:\n                    break;\n            }\n        }\n    }\n```\n然后再回来看下路由跳转做的事情.\n``` java\n/**\n     * Use router navigation.\n     *\n     * @param context     \n     * @param postcard    路由信息\n     * @param requestCode RequestCode, 默认为-1\n     * @param callback    申明的跳转回调\n     */\nprotected Object navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) {\n        try {\n          // postcard信息完善\n            LogisticsCenter.completion(postcard);\n        } catch (NoRouteFoundException ex) {\n            logger.warning(Consts.TAG, ex.getMessage());\n\n            if (debuggable()) { // Show friendly tips for user.\n                Toast.makeText(mContext, \"There's no route matched!\\n\" +\n                        \" Path = [\" + postcard.getPath() + \"]\\n\" +\n                        \" Group = [\" + postcard.getGroup() + \"]\", Toast.LENGTH_LONG).show();\n            }\n            // 没有找到对应路由信息的回调通知, 如果没有回调, 会通过DegradeService服务进行通知, 但是要根据他发出的进行处理, 需要我们实现DegradeService的接口\n            if (null != callback) {\n                callback.onLost(postcard);\n            } else {    // No callback for this invoke, then we use the global degrade service.\n                DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class);\n                if (null != degradeService) {\n                    degradeService.onLost(context, postcard);\n                }\n            }\n\n            return null;\n        }\n\n        // 回调通知onFound\n        if (null != callback) {\n            callback.onFound(postcard);\n        }\n        // 当需要处理拦截器内容的时候\n        if (!postcard.isGreenChannel()) {   // It must be run in async thread, maybe interceptor cost too mush time made ANR.\n            // 拦截器处理\n            interceptorService.doInterceptions(postcard, new InterceptorCallback() {\n                /**\n                 * Continue process\n                 *\n                 * @param postcard route meta\n                 */\n                @Override\n                public void onContinue(Postcard postcard) {\n                  // 继续跳转\n                    _navigation(context, postcard, requestCode, callback);\n                }\n\n                /**\n                 * Interrupt process, pipeline will be destory when this method called.\n                 *\n                 * @param exception Reson of interrupt.\n                 */\n                @Override\n                public void onInterrupt(Throwable exception) {\n                    if (null != callback) {\n                      // 回调\n                        callback.onInterrupt(postcard);\n                    }\n\n                    logger.info(Consts.TAG, \"Navigation failed, termination by interceptor : \" + exception.getMessage());\n                }\n            });\n        } else {\n            return _navigation(context, postcard, requestCode, callback);\n        }\n\n        return null;\n    }\n```\n拦截器的处理是通过`interceptorService`代理来实现, 我们可以往里面看\n``` java\n@Route(path = \"/arouter/service/interceptor\")\npublic class InterceptorServiceImpl implements InterceptorService {\n    private static boolean interceptorHasInit;\n    private static final Object interceptorInitLock = new Object();\n\n    @Override\n    public void doInterceptions(final Postcard postcard, final InterceptorCallback callback) {\n        if (null != Warehouse.interceptors && Warehouse.interceptors.size() > 0) {\n\n            checkInterceptorsInitStatus();\n\n            if (!interceptorHasInit) {\n                callback.onInterrupt(new HandlerException(\"Interceptors initialization takes too much time.\"));\n                return;\n            }\n            // 通过线程池进行异步管理执行\n            LogisticsCenter.executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    CancelableCountDownLatch interceptorCounter = new CancelableCountDownLatch(Warehouse.interceptors.size());\n                    try {\n                        // 通过interceptorCounter倒数计数器, 一个个执行拥有的拦截器\n                        _excute(0, interceptorCounter, postcard);\n                        // 默认timeout时间是0.3s\n                        interceptorCounter.await(postcard.getTimeout(), TimeUnit.SECONDS);\n                        // 如果在postcard.getTimeout()时间内没有执行完\n                        if (interceptorCounter.getCount() > 0) {    // Cancel the navigation this time, if it hasn't return anythings.\n                            // 取消\n                            callback.onInterrupt(new HandlerException(\"The interceptor processing timed out.\"));\n                        } else if (null != postcard.getTag()) {    // Maybe some exception in the tag.\n                            callback.onInterrupt(new HandlerException(postcard.getTag().toString()));\n                        } else {\n                            // 在没有超时和抛出异常的情况下, 则继续往后执行\n                            callback.onContinue(postcard);\n                        }\n                    } catch (Exception e) {\n                        callback.onInterrupt(e);\n                    }\n                }\n            });\n        } else {\n            callback.onContinue(postcard);\n        }\n    }\n\n    /**\n     * Excute interceptor\n     *\n     * @param index    current interceptor index\n     * @param counter  interceptor counter\n     * @param postcard routeMeta\n     */\n    private static void _excute(final int index, final CancelableCountDownLatch counter, final Postcard postcard) {\n        if (index < Warehouse.interceptors.size()) {\n            IInterceptor iInterceptor = Warehouse.interceptors.get(index);\n            iInterceptor.process(postcard, new InterceptorCallback() {\n                @Override\n                public void onContinue(Postcard postcard) {\n                    // Last interceptor excute over with no exception.\n                    counter.countDown();\n                    // 递归处理\n                    _excute(index + 1, counter, postcard);  // When counter is down, it will be execute continue ,but index bigger than interceptors size, then U know.\n                }\n\n                @Override\n                public void onInterrupt(Throwable exception) {\n                    // Last interceptor excute over with fatal exception.\n\n                    postcard.setTag(null == exception ? new HandlerException(\"No message.\") : exception.getMessage());    // save the exception message for backup.\n                    counter.cancel();\n                    // Be attention, maybe the thread in callback has been changed,\n                    // then the catch block(L207) will be invalid.\n                    // The worst is the thread changed to main thread, then the app will be crash, if you throw this exception!\n//                    if (!Looper.getMainLooper().equals(Looper.myLooper())) {    // You shouldn't throw the exception if the thread is main thread.\n//                        throw new HandlerException(exception.getMessage());\n//                    }\n                }\n            });\n        }\n    }\n\n    @Override\n    public void init(final Context context) {\n        LogisticsCenter.executor.execute(new Runnable() {\n            @Override\n            public void run() {\n                if (MapUtils.isNotEmpty(Warehouse.interceptorsIndex)) {\n                    for (Map.Entry<Integer, Class<? extends IInterceptor>> entry : Warehouse.interceptorsIndex.entrySet()) {\n                        Class<? extends IInterceptor> interceptorClass = entry.getValue();\n                        try {\n                            IInterceptor iInterceptor = interceptorClass.getConstructor().newInstance();\n                            iInterceptor.init(context);\n                            Warehouse.interceptors.add(iInterceptor);\n                        } catch (Exception ex) {\n                            throw new HandlerException(TAG + \"ARouter init interceptor error! name = [\" + interceptorClass.getName() + \"], reason = [\" + ex.getMessage() + \"]\");\n                        }\n                    }\n\n                    interceptorHasInit = true;\n\n                    logger.info(TAG, \"ARouter interceptors init over.\");\n\n                    synchronized (interceptorInitLock) {\n                        interceptorInitLock.notifyAll();\n                    }\n                }\n            }\n        });\n    }\n\n    private static void checkInterceptorsInitStatus() {\n        synchronized (interceptorInitLock) {\n            while (!interceptorHasInit) {\n                try {\n                    interceptorInitLock.wait(10 * 1000);\n                } catch (InterruptedException e) {\n                    throw new HandlerException(TAG + \"Interceptor init cost too much time error! reason = [\" + e.getMessage() + \"]\");\n                }\n            }\n        }\n    }\n}\n```\nok, 在进行了拦截器处理(或者没有拦截器的情况下), 我们走到了`_navigation(context, postcard, requestCode, callback)`, 到这里基本又是熟悉的配方了, 可以看到他最后通过`startActivity`来进行跳转.\n``` java\nprivate Object _navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) {\n        final Context currentContext = null == context ? mContext : context;\n\n        switch (postcard.getType()) {\n            case ACTIVITY:\n                // Build intent\n                final Intent intent = new Intent(currentContext, postcard.getDestination());\n                intent.putExtras(postcard.getExtras());\n\n                // Set flags.\n                int flags = postcard.getFlags();\n                if (-1 != flags) {\n                    intent.setFlags(flags);\n                } else if (!(currentContext instanceof Activity)) {    // Non activity, need less one flag.\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                }\n\n                // Navigation in main looper.\n                new Handler(Looper.getMainLooper()).post(new Runnable() {\n                    @Override\n                    public void run() {\n                        if (requestCode > 0) {  // Need start for result\n                            ActivityCompat.startActivityForResult((Activity) currentContext, intent, requestCode, postcard.getOptionsBundle());\n                        } else {\n                            ActivityCompat.startActivity(currentContext, intent, postcard.getOptionsBundle());\n                        }\n\n                        if ((-1 != postcard.getEnterAnim() && -1 != postcard.getExitAnim()) && currentContext instanceof Activity) {    // Old version.\n                            ((Activity) currentContext).overridePendingTransition(postcard.getEnterAnim(), postcard.getExitAnim());\n                        }\n\n                        if (null != callback) { // Navigation over.\n                            callback.onArrival(postcard);\n                        }\n                    }\n                });\n\n                break;\n            case PROVIDER:\n                return postcard.getProvider();\n            case BOARDCAST:\n            case CONTENT_PROVIDER:\n            case FRAGMENT:\n                Class fragmentMeta = postcard.getDestination();\n                try {\n                    Object instance = fragmentMeta.getConstructor().newInstance();\n                    if (instance instanceof Fragment) {\n                        ((Fragment) instance).setArguments(postcard.getExtras());\n                    } else if (instance instanceof android.support.v4.app.Fragment) {\n                        ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras());\n                    }\n\n                    return instance;\n                } catch (Exception ex) {\n                    logger.error(Consts.TAG, \"Fetch fragment instance error, \" + TextUtils.formatStackTrace(ex.getStackTrace()));\n                }\n            case METHOD:\n            case SERVICE:\n            default:\n                return null;\n        }\n\n        return null;\n    }\n```\n","source":"_posts/ARouter源码解析.md","raw":"title: ARouter源码解析\ndate: 2018-05-18 00:00:00\ncategories:  \n- 源码解析\ntags:\n- Android\n- 源码解析\n---\n如果应用项目要做模块化, 必然绕不开为了模块间跳转解耦而做的处理, 我们都知道一般都会采用路由模式, 本篇主要解析阿里的开源路由框架`ARouter`, 源码地址可见[Github](https://github.com/alibaba/ARouter),本篇分析版本为api`1.3.1`\n<!--more-->\n## 初始化\n感谢源码自带Demo, 我们直接从他的整个使用流程开始看起.忽略掉Log模式和Debug模式的开启, 首先我们需要初始化`ARouter`\n``` java\nARouter.init(getApplication());\n```\n它内部实际调用的是`LogisticsCenter.init(Context context, ThreadPoolExecutor tpe)`\n``` java\npublic synchronized static void init(Context context, ThreadPoolExecutor tpe) throws HandlerException {\n        mContext = context;\n        executor = tpe;\n\n        try {\n            long startInit = System.currentTimeMillis();\n            //billy.qi modified at 2017-12-06\n            //load by plugin first\n            loadRouterMap();\n            if (registerByPlugin) {\n                logger.info(TAG, \"Load router map by arouter-auto-register plugin.\");\n            } else {\n                Set<String> routerMap;\n\n                // It will rebuild router map every times when debuggable.\n                if (ARouter.debuggable() || PackageUtils.isNewVersion(context)) {\n                    logger.info(TAG, \"Run with debug mode or new install, rebuild router map.\");\n                    // These class was generated by arouter-compiler.\n                    // 通过arouter-compiler生成\n                    routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);\n                    if (!routerMap.isEmpty()) {\n                        context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply();\n                    }\n\n                    // 当router map更新的时候保存新的版本号\n                    PackageUtils.updateVersion(context);    // Save new version name when router map update finishes.\n                } else {\n                    logger.info(TAG, \"Load router map from cache.\");\n                    routerMap = new HashSet<>(context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).getStringSet(AROUTER_SP_KEY_MAP, new HashSet<String>()));\n                }\n\n                logger.info(TAG, \"Find router map finished, map size = \" + routerMap.size() + \", cost \" + (System.currentTimeMillis() - startInit) + \" ms.\");\n                startInit = System.currentTimeMillis();\n\n                for (String className : routerMap) {\n                    if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) {\n                        // This one of root elements, load root.\n                        ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex);\n                    } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) {\n                        // Load interceptorMeta\n                        ((IInterceptorGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex);\n                    } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) {\n                        // Load providerIndex\n                        ((IProviderGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex);\n                    }\n                }\n            }\n\n            logger.info(TAG, \"Load root element finished, cost \" + (System.currentTimeMillis() - startInit) + \" ms.\");\n\n            if (Warehouse.groupsIndex.size() == 0) {\n                logger.error(TAG, \"No mapping files were found, check your configuration please!\");\n            }\n\n            if (ARouter.debuggable()) {\n                logger.debug(TAG, String.format(Locale.getDefault(), \"LogisticsCenter has already been loaded, GroupIndex[%d], InterceptorIndex[%d], ProviderIndex[%d]\", Warehouse.groupsIndex.size(), Warehouse.interceptorsIndex.size(), Warehouse.providersIndex.size()));\n            }\n        } catch (Exception e) {\n            throw new HandlerException(TAG + \"ARouter init logistics center exception! [\" + e.getMessage() + \"]\");\n        }\n    }\n```\n这里`loadRouterMap()`方法就是将是否通过插件注册的tag初始化为`false`, 我们主要看正常流程下的注册, 所以关注点在`else`的代码块中.对于`routerMap`从上下文我们可以看出, 他是`APT`自动生成的类名集合.\n\n在`Debug`模式下, 当每次更新路由缓存的版本的时候, 都会从指定包名`com.alibaba.android.arouter.routes`收集所有的className, 如果不为空 则更新磁盘缓存.\n\n而非`Debug`模式下, 不做收集, 直接获取磁盘缓存, 如果没有则new一个空集合.\n\n然后通过反射新建对应类实例并调用`load`方法.我们可以看下`debug`模式下, `APT`生成类文件下的`load`函数具体执行了什么\n``` java\npublic class ARouter$$Group$$arouter implements IRouteGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> atlas) {\n    atlas.put(\"/arouter/service/autowired\", RouteMeta.build(RouteType.PROVIDER, AutowiredServiceImpl.class, \"/arouter/service/autowired\", \"arouter\", null, -1, -2147483648));\n    atlas.put(\"/arouter/service/interceptor\", RouteMeta.build(RouteType.PROVIDER, InterceptorServiceImpl.class, \"/arouter/service/interceptor\", \"arouter\", null, -1, -2147483648));\n  }\n}\n\npublic class ARouter$$Providers$$arouterapi implements IProviderGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> providers) {\n    providers.put(\"com.alibaba.android.arouter.facade.service.AutowiredService\", RouteMeta.build(RouteType.PROVIDER, AutowiredServiceImpl.class, \"/arouter/service/autowired\", \"arouter\", null, -1, -2147483648));\n    providers.put(\"com.alibaba.android.arouter.facade.service.InterceptorService\", RouteMeta.build(RouteType.PROVIDER, InterceptorServiceImpl.class, \"/arouter/service/interceptor\", \"arouter\", null, -1, -2147483648));\n  }\n}\n\npublic class ARouter$$Root$$arouterapi implements IRouteRoot {\n  @Override\n  public void loadInto(Map<String, Class<? extends IRouteGroup>> routes) {\n    routes.put(\"arouter\", ARouter$$Group$$arouter.class);\n  }\n}\n```\n可以看出所有`loadInto()`方法执行的都是将注解的信息通过`Map`强引用做内存缓存管理.这里`Warehouse.groupsIndex`管理的是组的路由生成文件的内存, `Warehouse.interceptorsIndex`拦截器的索引管理, `Warehouse.providersIndex`服务(不是四大组件, 而是实现了继承`IProvider`接口的对象)索引管理.\n## 跳转\n我们先看下对应的API\n``` java\nARouter.getInstance()\n       .build(\"/test/activity2\")\n       .navigation();\n```\n首先需要`build`一个`Postcard`对象, 他包含了我们传递的跳转信息.\n``` java\nprotected Postcard build(String path) {\n        if (TextUtils.isEmpty(path)) {\n            throw new HandlerException(Consts.TAG + \"Parameter is invalid!\");\n        } else {\n          // 判断是否重写跳转URL, 没有就使用原来的path构建Postcard\n            PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);\n            if (null != pService) {\n                path = pService.forString(path);\n            }\n            return build(path, extractGroup(path));\n        }\n    }\n\nprotected Postcard build(String path, String group) {\n        if (TextUtils.isEmpty(path) || TextUtils.isEmpty(group)) {\n            throw new HandlerException(Consts.TAG + \"Parameter is invalid!\");\n        } else {\n            PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);\n            if (null != pService) {\n                path = pService.forString(path);\n            }\n            return new Postcard(path, group);\n        }\n    }\n```\n然后通过`postcard.navigation()`做跳转工作, 在这个方法内首先会针对我们记载路由信息的`postcard`通过调用`LogisticsCenter.completion(postcard);`进行信息补充完善\n``` java\npublic synchronized static void completion(Postcard postcard) {\n        if (null == postcard) {\n            throw new NoRouteFoundException(TAG + \"No postcard!\");\n        }\n\n        // 通过path获取路由基础信息\n        RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());\n        // 如果没有获取到路由基础信息\n        if (null == routeMeta) {    // Maybe its does't exist, or didn't load.\n            // 则重新通过反射进行加载\n            Class<? extends IRouteGroup> groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());  // Load route meta.\n            if (null == groupMeta) {\n                throw new NoRouteFoundException(TAG + \"There is no route match the path [\" + postcard.getPath() + \"], in group [\" + postcard.getGroup() + \"]\");\n            } else {\n                // Load route and cache it into memory, then delete from metas.\n                try {\n                    if (ARouter.debuggable()) {\n                        logger.debug(TAG, String.format(Locale.getDefault(), \"The group [%s] starts loading, trigger by [%s]\", postcard.getGroup(), postcard.getPath()));\n                    }\n\n                    IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();\n                    iGroupInstance.loadInto(Warehouse.routes);\n                    Warehouse.groupsIndex.remove(postcard.getGroup());\n\n                    if (ARouter.debuggable()) {\n                        logger.debug(TAG, String.format(Locale.getDefault(), \"The group [%s] has already been loaded, trigger by [%s]\", postcard.getGroup(), postcard.getPath()));\n                    }\n                } catch (Exception e) {\n                    throw new HandlerException(TAG + \"Fatal exception when loading group meta. [\" + e.getMessage() + \"]\");\n                }\n\n                // 递归进行路由的完善工作\n                completion(postcard);   // Reload\n            }\n        } else {\n            // 完善postcard信息\n            postcard.setDestination(routeMeta.getDestination());\n            postcard.setType(routeMeta.getType());\n            postcard.setPriority(routeMeta.getPriority());\n            postcard.setExtra(routeMeta.getExtra());\n\n            Uri rawUri = postcard.getUri();\n            if (null != rawUri) {   // Try to set params into bundle.\n                Map<String, String> resultMap = TextUtils.splitQueryParameters(rawUri);\n                Map<String, Integer> paramsType = routeMeta.getParamsType();\n\n                if (MapUtils.isNotEmpty(paramsType)) {\n                    // Set value by its type, just for params which annotation by @Param\n                    for (Map.Entry<String, Integer> params : paramsType.entrySet()) {\n                        setValue(postcard,\n                                params.getValue(),\n                                params.getKey(),\n                                resultMap.get(params.getKey()));\n                    }\n\n                    // Save params name which need auto inject.\n                    postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(new String[]{}));\n                }\n\n                // Save raw uri\n                postcard.withString(ARouter.RAW_URI, rawUri.toString());\n            }\n\n            switch (routeMeta.getType()) {\n                case PROVIDER:  // if the route is provider, should find its instance\n                    // Its provider, so it must implement IProvider\n                    Class<? extends IProvider> providerMeta = (Class<? extends IProvider>) routeMeta.getDestination();\n                    IProvider instance = Warehouse.providers.get(providerMeta);\n                    switch (routeMeta.getType()) {\n                case PROVIDER:  // if the route is provider, should find its instance\n                    // Its provider, so it must implement IProvider\n                    // 如果路由目标是一个provider\n                    // 需要找到目标实例\n                    Class<? extends IProvider> providerMeta = (Class<? extends IProvider>) routeMeta.getDestination();\n                    IProvider instance = Warehouse.providers.get(providerMeta);\n                    if (null == instance) { // There's no instance of this provider\n                        IProvider provider;\n                        try {\n                            provider = providerMeta.getConstructor().newInstance();\n                            provider.init(mContext);\n                            Warehouse.providers.put(providerMeta, provider);\n                            instance = provider;\n                        } catch (Exception e) {\n                            throw new HandlerException(\"Init provider failed! \" + e.getMessage());\n                        }\n                    }\n                    postcard.setProvider(instance);\n                    // provider不会触发拦截器\n                    postcard.greenChannel();    // Provider should skip all of interceptors\n                    break;\n                case FRAGMENT:\n                    // fragment不会触发拦截器\n                    postcard.greenChannel();    // Fragment needn't interceptors\n                default:\n                    break;\n            }\n        }\n    }\n```\n然后再回来看下路由跳转做的事情.\n``` java\n/**\n     * Use router navigation.\n     *\n     * @param context     \n     * @param postcard    路由信息\n     * @param requestCode RequestCode, 默认为-1\n     * @param callback    申明的跳转回调\n     */\nprotected Object navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) {\n        try {\n          // postcard信息完善\n            LogisticsCenter.completion(postcard);\n        } catch (NoRouteFoundException ex) {\n            logger.warning(Consts.TAG, ex.getMessage());\n\n            if (debuggable()) { // Show friendly tips for user.\n                Toast.makeText(mContext, \"There's no route matched!\\n\" +\n                        \" Path = [\" + postcard.getPath() + \"]\\n\" +\n                        \" Group = [\" + postcard.getGroup() + \"]\", Toast.LENGTH_LONG).show();\n            }\n            // 没有找到对应路由信息的回调通知, 如果没有回调, 会通过DegradeService服务进行通知, 但是要根据他发出的进行处理, 需要我们实现DegradeService的接口\n            if (null != callback) {\n                callback.onLost(postcard);\n            } else {    // No callback for this invoke, then we use the global degrade service.\n                DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class);\n                if (null != degradeService) {\n                    degradeService.onLost(context, postcard);\n                }\n            }\n\n            return null;\n        }\n\n        // 回调通知onFound\n        if (null != callback) {\n            callback.onFound(postcard);\n        }\n        // 当需要处理拦截器内容的时候\n        if (!postcard.isGreenChannel()) {   // It must be run in async thread, maybe interceptor cost too mush time made ANR.\n            // 拦截器处理\n            interceptorService.doInterceptions(postcard, new InterceptorCallback() {\n                /**\n                 * Continue process\n                 *\n                 * @param postcard route meta\n                 */\n                @Override\n                public void onContinue(Postcard postcard) {\n                  // 继续跳转\n                    _navigation(context, postcard, requestCode, callback);\n                }\n\n                /**\n                 * Interrupt process, pipeline will be destory when this method called.\n                 *\n                 * @param exception Reson of interrupt.\n                 */\n                @Override\n                public void onInterrupt(Throwable exception) {\n                    if (null != callback) {\n                      // 回调\n                        callback.onInterrupt(postcard);\n                    }\n\n                    logger.info(Consts.TAG, \"Navigation failed, termination by interceptor : \" + exception.getMessage());\n                }\n            });\n        } else {\n            return _navigation(context, postcard, requestCode, callback);\n        }\n\n        return null;\n    }\n```\n拦截器的处理是通过`interceptorService`代理来实现, 我们可以往里面看\n``` java\n@Route(path = \"/arouter/service/interceptor\")\npublic class InterceptorServiceImpl implements InterceptorService {\n    private static boolean interceptorHasInit;\n    private static final Object interceptorInitLock = new Object();\n\n    @Override\n    public void doInterceptions(final Postcard postcard, final InterceptorCallback callback) {\n        if (null != Warehouse.interceptors && Warehouse.interceptors.size() > 0) {\n\n            checkInterceptorsInitStatus();\n\n            if (!interceptorHasInit) {\n                callback.onInterrupt(new HandlerException(\"Interceptors initialization takes too much time.\"));\n                return;\n            }\n            // 通过线程池进行异步管理执行\n            LogisticsCenter.executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    CancelableCountDownLatch interceptorCounter = new CancelableCountDownLatch(Warehouse.interceptors.size());\n                    try {\n                        // 通过interceptorCounter倒数计数器, 一个个执行拥有的拦截器\n                        _excute(0, interceptorCounter, postcard);\n                        // 默认timeout时间是0.3s\n                        interceptorCounter.await(postcard.getTimeout(), TimeUnit.SECONDS);\n                        // 如果在postcard.getTimeout()时间内没有执行完\n                        if (interceptorCounter.getCount() > 0) {    // Cancel the navigation this time, if it hasn't return anythings.\n                            // 取消\n                            callback.onInterrupt(new HandlerException(\"The interceptor processing timed out.\"));\n                        } else if (null != postcard.getTag()) {    // Maybe some exception in the tag.\n                            callback.onInterrupt(new HandlerException(postcard.getTag().toString()));\n                        } else {\n                            // 在没有超时和抛出异常的情况下, 则继续往后执行\n                            callback.onContinue(postcard);\n                        }\n                    } catch (Exception e) {\n                        callback.onInterrupt(e);\n                    }\n                }\n            });\n        } else {\n            callback.onContinue(postcard);\n        }\n    }\n\n    /**\n     * Excute interceptor\n     *\n     * @param index    current interceptor index\n     * @param counter  interceptor counter\n     * @param postcard routeMeta\n     */\n    private static void _excute(final int index, final CancelableCountDownLatch counter, final Postcard postcard) {\n        if (index < Warehouse.interceptors.size()) {\n            IInterceptor iInterceptor = Warehouse.interceptors.get(index);\n            iInterceptor.process(postcard, new InterceptorCallback() {\n                @Override\n                public void onContinue(Postcard postcard) {\n                    // Last interceptor excute over with no exception.\n                    counter.countDown();\n                    // 递归处理\n                    _excute(index + 1, counter, postcard);  // When counter is down, it will be execute continue ,but index bigger than interceptors size, then U know.\n                }\n\n                @Override\n                public void onInterrupt(Throwable exception) {\n                    // Last interceptor excute over with fatal exception.\n\n                    postcard.setTag(null == exception ? new HandlerException(\"No message.\") : exception.getMessage());    // save the exception message for backup.\n                    counter.cancel();\n                    // Be attention, maybe the thread in callback has been changed,\n                    // then the catch block(L207) will be invalid.\n                    // The worst is the thread changed to main thread, then the app will be crash, if you throw this exception!\n//                    if (!Looper.getMainLooper().equals(Looper.myLooper())) {    // You shouldn't throw the exception if the thread is main thread.\n//                        throw new HandlerException(exception.getMessage());\n//                    }\n                }\n            });\n        }\n    }\n\n    @Override\n    public void init(final Context context) {\n        LogisticsCenter.executor.execute(new Runnable() {\n            @Override\n            public void run() {\n                if (MapUtils.isNotEmpty(Warehouse.interceptorsIndex)) {\n                    for (Map.Entry<Integer, Class<? extends IInterceptor>> entry : Warehouse.interceptorsIndex.entrySet()) {\n                        Class<? extends IInterceptor> interceptorClass = entry.getValue();\n                        try {\n                            IInterceptor iInterceptor = interceptorClass.getConstructor().newInstance();\n                            iInterceptor.init(context);\n                            Warehouse.interceptors.add(iInterceptor);\n                        } catch (Exception ex) {\n                            throw new HandlerException(TAG + \"ARouter init interceptor error! name = [\" + interceptorClass.getName() + \"], reason = [\" + ex.getMessage() + \"]\");\n                        }\n                    }\n\n                    interceptorHasInit = true;\n\n                    logger.info(TAG, \"ARouter interceptors init over.\");\n\n                    synchronized (interceptorInitLock) {\n                        interceptorInitLock.notifyAll();\n                    }\n                }\n            }\n        });\n    }\n\n    private static void checkInterceptorsInitStatus() {\n        synchronized (interceptorInitLock) {\n            while (!interceptorHasInit) {\n                try {\n                    interceptorInitLock.wait(10 * 1000);\n                } catch (InterruptedException e) {\n                    throw new HandlerException(TAG + \"Interceptor init cost too much time error! reason = [\" + e.getMessage() + \"]\");\n                }\n            }\n        }\n    }\n}\n```\nok, 在进行了拦截器处理(或者没有拦截器的情况下), 我们走到了`_navigation(context, postcard, requestCode, callback)`, 到这里基本又是熟悉的配方了, 可以看到他最后通过`startActivity`来进行跳转.\n``` java\nprivate Object _navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) {\n        final Context currentContext = null == context ? mContext : context;\n\n        switch (postcard.getType()) {\n            case ACTIVITY:\n                // Build intent\n                final Intent intent = new Intent(currentContext, postcard.getDestination());\n                intent.putExtras(postcard.getExtras());\n\n                // Set flags.\n                int flags = postcard.getFlags();\n                if (-1 != flags) {\n                    intent.setFlags(flags);\n                } else if (!(currentContext instanceof Activity)) {    // Non activity, need less one flag.\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                }\n\n                // Navigation in main looper.\n                new Handler(Looper.getMainLooper()).post(new Runnable() {\n                    @Override\n                    public void run() {\n                        if (requestCode > 0) {  // Need start for result\n                            ActivityCompat.startActivityForResult((Activity) currentContext, intent, requestCode, postcard.getOptionsBundle());\n                        } else {\n                            ActivityCompat.startActivity(currentContext, intent, postcard.getOptionsBundle());\n                        }\n\n                        if ((-1 != postcard.getEnterAnim() && -1 != postcard.getExitAnim()) && currentContext instanceof Activity) {    // Old version.\n                            ((Activity) currentContext).overridePendingTransition(postcard.getEnterAnim(), postcard.getExitAnim());\n                        }\n\n                        if (null != callback) { // Navigation over.\n                            callback.onArrival(postcard);\n                        }\n                    }\n                });\n\n                break;\n            case PROVIDER:\n                return postcard.getProvider();\n            case BOARDCAST:\n            case CONTENT_PROVIDER:\n            case FRAGMENT:\n                Class fragmentMeta = postcard.getDestination();\n                try {\n                    Object instance = fragmentMeta.getConstructor().newInstance();\n                    if (instance instanceof Fragment) {\n                        ((Fragment) instance).setArguments(postcard.getExtras());\n                    } else if (instance instanceof android.support.v4.app.Fragment) {\n                        ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras());\n                    }\n\n                    return instance;\n                } catch (Exception ex) {\n                    logger.error(Consts.TAG, \"Fetch fragment instance error, \" + TextUtils.formatStackTrace(ex.getStackTrace()));\n                }\n            case METHOD:\n            case SERVICE:\n            default:\n                return null;\n        }\n\n        return null;\n    }\n```\n","slug":"ARouter源码解析","published":1,"updated":"2018-05-18T07:50:19.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjld5ah5q002ocqs6beoc3jit","content":"<p>如果应用项目要做模块化, 必然绕不开为了模块间跳转解耦而做的处理, 我们都知道一般都会采用路由模式, 本篇主要解析阿里的开源路由框架<code>ARouter</code>, 源码地址可见<a href=\"https://github.com/alibaba/ARouter\" target=\"_blank\" rel=\"noopener\">Github</a>,本篇分析版本为api<code>1.3.1</code><br><a id=\"more\"></a></p>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p>感谢源码自带Demo, 我们直接从他的整个使用流程开始看起.忽略掉Log模式和Debug模式的开启, 首先我们需要初始化<code>ARouter</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ARouter.init(getApplication());</span><br></pre></td></tr></table></figure></p>\n<p>它内部实际调用的是<code>LogisticsCenter.init(Context context, ThreadPoolExecutor tpe)</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Context context, ThreadPoolExecutor tpe)</span> <span class=\"keyword\">throws</span> HandlerException </span>&#123;</span><br><span class=\"line\">        mContext = context;</span><br><span class=\"line\">        executor = tpe;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> startInit = System.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"comment\">//billy.qi modified at 2017-12-06</span></span><br><span class=\"line\">            <span class=\"comment\">//load by plugin first</span></span><br><span class=\"line\">            loadRouterMap();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (registerByPlugin) &#123;</span><br><span class=\"line\">                logger.info(TAG, <span class=\"string\">\"Load router map by arouter-auto-register plugin.\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                Set&lt;String&gt; routerMap;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// It will rebuild router map every times when debuggable.</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ARouter.debuggable() || PackageUtils.isNewVersion(context)) &#123;</span><br><span class=\"line\">                    logger.info(TAG, <span class=\"string\">\"Run with debug mode or new install, rebuild router map.\"</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// These class was generated by arouter-compiler.</span></span><br><span class=\"line\">                    <span class=\"comment\">// 通过arouter-compiler生成</span></span><br><span class=\"line\">                    routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!routerMap.isEmpty()) &#123;</span><br><span class=\"line\">                        context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 当router map更新的时候保存新的版本号</span></span><br><span class=\"line\">                    PackageUtils.updateVersion(context);    <span class=\"comment\">// Save new version name when router map update finishes.</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    logger.info(TAG, <span class=\"string\">\"Load router map from cache.\"</span>);</span><br><span class=\"line\">                    routerMap = <span class=\"keyword\">new</span> HashSet&lt;&gt;(context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).getStringSet(AROUTER_SP_KEY_MAP, <span class=\"keyword\">new</span> HashSet&lt;String&gt;()));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                logger.info(TAG, <span class=\"string\">\"Find router map finished, map size = \"</span> + routerMap.size() + <span class=\"string\">\", cost \"</span> + (System.currentTimeMillis() - startInit) + <span class=\"string\">\" ms.\"</span>);</span><br><span class=\"line\">                startInit = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (String className : routerMap) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// This one of root elements, load root.</span></span><br><span class=\"line\">                        ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// Load interceptorMeta</span></span><br><span class=\"line\">                        ((IInterceptorGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// Load providerIndex</span></span><br><span class=\"line\">                        ((IProviderGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            logger.info(TAG, <span class=\"string\">\"Load root element finished, cost \"</span> + (System.currentTimeMillis() - startInit) + <span class=\"string\">\" ms.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Warehouse.groupsIndex.size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                logger.error(TAG, <span class=\"string\">\"No mapping files were found, check your configuration please!\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ARouter.debuggable()) &#123;</span><br><span class=\"line\">                logger.debug(TAG, String.format(Locale.getDefault(), <span class=\"string\">\"LogisticsCenter has already been loaded, GroupIndex[%d], InterceptorIndex[%d], ProviderIndex[%d]\"</span>, Warehouse.groupsIndex.size(), Warehouse.interceptorsIndex.size(), Warehouse.providersIndex.size()));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> HandlerException(TAG + <span class=\"string\">\"ARouter init logistics center exception! [\"</span> + e.getMessage() + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里<code>loadRouterMap()</code>方法就是将是否通过插件注册的tag初始化为<code>false</code>, 我们主要看正常流程下的注册, 所以关注点在<code>else</code>的代码块中.对于<code>routerMap</code>从上下文我们可以看出, 他是<code>APT</code>自动生成的类名集合.</p>\n<p>在<code>Debug</code>模式下, 当每次更新路由缓存的版本的时候, 都会从指定包名<code>com.alibaba.android.arouter.routes</code>收集所有的className, 如果不为空 则更新磁盘缓存.</p>\n<p>而非<code>Debug</code>模式下, 不做收集, 直接获取磁盘缓存, 如果没有则new一个空集合.</p>\n<p>然后通过反射新建对应类实例并调用<code>load</code>方法.我们可以看下<code>debug</code>模式下, <code>APT</code>生成类文件下的<code>load</code>函数具体执行了什么<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ARouter</span>$$<span class=\"title\">Group</span>$$<span class=\"title\">arouter</span> <span class=\"keyword\">implements</span> <span class=\"title\">IRouteGroup</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadInto</span><span class=\"params\">(Map&lt;String, RouteMeta&gt; atlas)</span> </span>&#123;</span><br><span class=\"line\">    atlas.put(<span class=\"string\">\"/arouter/service/autowired\"</span>, RouteMeta.build(RouteType.PROVIDER, AutowiredServiceImpl.class, <span class=\"string\">\"/arouter/service/autowired\"</span>, <span class=\"string\">\"arouter\"</span>, <span class=\"keyword\">null</span>, -<span class=\"number\">1</span>, -<span class=\"number\">2147483648</span>));</span><br><span class=\"line\">    atlas.put(<span class=\"string\">\"/arouter/service/interceptor\"</span>, RouteMeta.build(RouteType.PROVIDER, InterceptorServiceImpl.class, <span class=\"string\">\"/arouter/service/interceptor\"</span>, <span class=\"string\">\"arouter\"</span>, <span class=\"keyword\">null</span>, -<span class=\"number\">1</span>, -<span class=\"number\">2147483648</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ARouter</span>$$<span class=\"title\">Providers</span>$$<span class=\"title\">arouterapi</span> <span class=\"keyword\">implements</span> <span class=\"title\">IProviderGroup</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadInto</span><span class=\"params\">(Map&lt;String, RouteMeta&gt; providers)</span> </span>&#123;</span><br><span class=\"line\">    providers.put(<span class=\"string\">\"com.alibaba.android.arouter.facade.service.AutowiredService\"</span>, RouteMeta.build(RouteType.PROVIDER, AutowiredServiceImpl.class, <span class=\"string\">\"/arouter/service/autowired\"</span>, <span class=\"string\">\"arouter\"</span>, <span class=\"keyword\">null</span>, -<span class=\"number\">1</span>, -<span class=\"number\">2147483648</span>));</span><br><span class=\"line\">    providers.put(<span class=\"string\">\"com.alibaba.android.arouter.facade.service.InterceptorService\"</span>, RouteMeta.build(RouteType.PROVIDER, InterceptorServiceImpl.class, <span class=\"string\">\"/arouter/service/interceptor\"</span>, <span class=\"string\">\"arouter\"</span>, <span class=\"keyword\">null</span>, -<span class=\"number\">1</span>, -<span class=\"number\">2147483648</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ARouter</span>$$<span class=\"title\">Root</span>$$<span class=\"title\">arouterapi</span> <span class=\"keyword\">implements</span> <span class=\"title\">IRouteRoot</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadInto</span><span class=\"params\">(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes)</span> </span>&#123;</span><br><span class=\"line\">    routes.put(<span class=\"string\">\"arouter\"</span>, ARouter$$Group$$arouter.class);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看出所有<code>loadInto()</code>方法执行的都是将注解的信息通过<code>Map</code>强引用做内存缓存管理.这里<code>Warehouse.groupsIndex</code>管理的是组的路由生成文件的内存, <code>Warehouse.interceptorsIndex</code>拦截器的索引管理, <code>Warehouse.providersIndex</code>服务(不是四大组件, 而是实现了继承<code>IProvider</code>接口的对象)索引管理.</p>\n<h2 id=\"跳转\"><a href=\"#跳转\" class=\"headerlink\" title=\"跳转\"></a>跳转</h2><p>我们先看下对应的API<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ARouter.getInstance()</span><br><span class=\"line\">       .build(<span class=\"string\">\"/test/activity2\"</span>)</span><br><span class=\"line\">       .navigation();</span><br></pre></td></tr></table></figure></p>\n<p>首先需要<code>build</code>一个<code>Postcard</code>对象, 他包含了我们传递的跳转信息.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Postcard <span class=\"title\">build</span><span class=\"params\">(String path)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (TextUtils.isEmpty(path)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> HandlerException(Consts.TAG + <span class=\"string\">\"Parameter is invalid!\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 判断是否重写跳转URL, 没有就使用原来的path构建Postcard</span></span><br><span class=\"line\">            PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != pService) &#123;</span><br><span class=\"line\">                path = pService.forString(path);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> build(path, extractGroup(path));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Postcard <span class=\"title\">build</span><span class=\"params\">(String path, String group)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (TextUtils.isEmpty(path) || TextUtils.isEmpty(group)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> HandlerException(Consts.TAG + <span class=\"string\">\"Parameter is invalid!\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != pService) &#123;</span><br><span class=\"line\">                path = pService.forString(path);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Postcard(path, group);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后通过<code>postcard.navigation()</code>做跳转工作, 在这个方法内首先会针对我们记载路由信息的<code>postcard</code>通过调用<code>LogisticsCenter.completion(postcard);</code>进行信息补充完善<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">completion</span><span class=\"params\">(Postcard postcard)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == postcard) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoRouteFoundException(TAG + <span class=\"string\">\"No postcard!\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 通过path获取路由基础信息</span></span><br><span class=\"line\">        RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());</span><br><span class=\"line\">        <span class=\"comment\">// 如果没有获取到路由基础信息</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == routeMeta) &#123;    <span class=\"comment\">// Maybe its does't exist, or didn't load.</span></span><br><span class=\"line\">            <span class=\"comment\">// 则重新通过反射进行加载</span></span><br><span class=\"line\">            Class&lt;? extends IRouteGroup&gt; groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());  <span class=\"comment\">// Load route meta.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == groupMeta) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoRouteFoundException(TAG + <span class=\"string\">\"There is no route match the path [\"</span> + postcard.getPath() + <span class=\"string\">\"], in group [\"</span> + postcard.getGroup() + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Load route and cache it into memory, then delete from metas.</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (ARouter.debuggable()) &#123;</span><br><span class=\"line\">                        logger.debug(TAG, String.format(Locale.getDefault(), <span class=\"string\">\"The group [%s] starts loading, trigger by [%s]\"</span>, postcard.getGroup(), postcard.getPath()));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();</span><br><span class=\"line\">                    iGroupInstance.loadInto(Warehouse.routes);</span><br><span class=\"line\">                    Warehouse.groupsIndex.remove(postcard.getGroup());</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (ARouter.debuggable()) &#123;</span><br><span class=\"line\">                        logger.debug(TAG, String.format(Locale.getDefault(), <span class=\"string\">\"The group [%s] has already been loaded, trigger by [%s]\"</span>, postcard.getGroup(), postcard.getPath()));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> HandlerException(TAG + <span class=\"string\">\"Fatal exception when loading group meta. [\"</span> + e.getMessage() + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 递归进行路由的完善工作</span></span><br><span class=\"line\">                completion(postcard);   <span class=\"comment\">// Reload</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 完善postcard信息</span></span><br><span class=\"line\">            postcard.setDestination(routeMeta.getDestination());</span><br><span class=\"line\">            postcard.setType(routeMeta.getType());</span><br><span class=\"line\">            postcard.setPriority(routeMeta.getPriority());</span><br><span class=\"line\">            postcard.setExtra(routeMeta.getExtra());</span><br><span class=\"line\"></span><br><span class=\"line\">            Uri rawUri = postcard.getUri();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != rawUri) &#123;   <span class=\"comment\">// Try to set params into bundle.</span></span><br><span class=\"line\">                Map&lt;String, String&gt; resultMap = TextUtils.splitQueryParameters(rawUri);</span><br><span class=\"line\">                Map&lt;String, Integer&gt; paramsType = routeMeta.getParamsType();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (MapUtils.isNotEmpty(paramsType)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Set value by its type, just for params which annotation by @Param</span></span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (Map.Entry&lt;String, Integer&gt; params : paramsType.entrySet()) &#123;</span><br><span class=\"line\">                        setValue(postcard,</span><br><span class=\"line\">                                params.getValue(),</span><br><span class=\"line\">                                params.getKey(),</span><br><span class=\"line\">                                resultMap.get(params.getKey()));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// Save params name which need auto inject.</span></span><br><span class=\"line\">                    postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(<span class=\"keyword\">new</span> String[]&#123;&#125;));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Save raw uri</span></span><br><span class=\"line\">                postcard.withString(ARouter.RAW_URI, rawUri.toString());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (routeMeta.getType()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> PROVIDER:  <span class=\"comment\">// if the route is provider, should find its instance</span></span><br><span class=\"line\">                    <span class=\"comment\">// Its provider, so it must implement IProvider</span></span><br><span class=\"line\">                    Class&lt;? extends IProvider&gt; providerMeta = (Class&lt;? extends IProvider&gt;) routeMeta.getDestination();</span><br><span class=\"line\">                    IProvider instance = Warehouse.providers.get(providerMeta);</span><br><span class=\"line\">                    <span class=\"keyword\">switch</span> (routeMeta.getType()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> PROVIDER:  <span class=\"comment\">// if the route is provider, should find its instance</span></span><br><span class=\"line\">                    <span class=\"comment\">// Its provider, so it must implement IProvider</span></span><br><span class=\"line\">                    <span class=\"comment\">// 如果路由目标是一个provider</span></span><br><span class=\"line\">                    <span class=\"comment\">// 需要找到目标实例</span></span><br><span class=\"line\">                    Class&lt;? extends IProvider&gt; providerMeta = (Class&lt;? extends IProvider&gt;) routeMeta.getDestination();</span><br><span class=\"line\">                    IProvider instance = Warehouse.providers.get(providerMeta);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == instance) &#123; <span class=\"comment\">// There's no instance of this provider</span></span><br><span class=\"line\">                        IProvider provider;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            provider = providerMeta.getConstructor().newInstance();</span><br><span class=\"line\">                            provider.init(mContext);</span><br><span class=\"line\">                            Warehouse.providers.put(providerMeta, provider);</span><br><span class=\"line\">                            instance = provider;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> HandlerException(<span class=\"string\">\"Init provider failed! \"</span> + e.getMessage());</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    postcard.setProvider(instance);</span><br><span class=\"line\">                    <span class=\"comment\">// provider不会触发拦截器</span></span><br><span class=\"line\">                    postcard.greenChannel();    <span class=\"comment\">// Provider should skip all of interceptors</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> FRAGMENT:</span><br><span class=\"line\">                    <span class=\"comment\">// fragment不会触发拦截器</span></span><br><span class=\"line\">                    postcard.greenChannel();    <span class=\"comment\">// Fragment needn't interceptors</span></span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后再回来看下路由跳转做的事情.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Use router navigation.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> context     </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> postcard    路由信息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> requestCode RequestCode, 默认为-1</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> callback    申明的跳转回调</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">navigation</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context, <span class=\"keyword\">final</span> Postcard postcard, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// postcard信息完善</span></span><br><span class=\"line\">            LogisticsCenter.completion(postcard);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoRouteFoundException ex) &#123;</span><br><span class=\"line\">            logger.warning(Consts.TAG, ex.getMessage());</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (debuggable()) &#123; <span class=\"comment\">// Show friendly tips for user.</span></span><br><span class=\"line\">                Toast.makeText(mContext, <span class=\"string\">\"There's no route matched!\\n\"</span> +</span><br><span class=\"line\">                        <span class=\"string\">\" Path = [\"</span> + postcard.getPath() + <span class=\"string\">\"]\\n\"</span> +</span><br><span class=\"line\">                        <span class=\"string\">\" Group = [\"</span> + postcard.getGroup() + <span class=\"string\">\"]\"</span>, Toast.LENGTH_LONG).show();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 没有找到对应路由信息的回调通知, 如果没有回调, 会通过DegradeService服务进行通知, 但是要根据他发出的进行处理, 需要我们实现DegradeService的接口</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != callback) &#123;</span><br><span class=\"line\">                callback.onLost(postcard);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;    <span class=\"comment\">// No callback for this invoke, then we use the global degrade service.</span></span><br><span class=\"line\">                DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != degradeService) &#123;</span><br><span class=\"line\">                    degradeService.onLost(context, postcard);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 回调通知onFound</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != callback) &#123;</span><br><span class=\"line\">            callback.onFound(postcard);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 当需要处理拦截器内容的时候</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!postcard.isGreenChannel()) &#123;   <span class=\"comment\">// It must be run in async thread, maybe interceptor cost too mush time made ANR.</span></span><br><span class=\"line\">            <span class=\"comment\">// 拦截器处理</span></span><br><span class=\"line\">            interceptorService.doInterceptions(postcard, <span class=\"keyword\">new</span> InterceptorCallback() &#123;</span><br><span class=\"line\">                <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">                 * Continue process</span></span><br><span class=\"line\"><span class=\"comment\">                 *</span></span><br><span class=\"line\"><span class=\"comment\">                 * <span class=\"doctag\">@param</span> postcard route meta</span></span><br><span class=\"line\"><span class=\"comment\">                 */</span></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onContinue</span><span class=\"params\">(Postcard postcard)</span> </span>&#123;</span><br><span class=\"line\">                  <span class=\"comment\">// 继续跳转</span></span><br><span class=\"line\">                    _navigation(context, postcard, requestCode, callback);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">                 * Interrupt process, pipeline will be destory when this method called.</span></span><br><span class=\"line\"><span class=\"comment\">                 *</span></span><br><span class=\"line\"><span class=\"comment\">                 * <span class=\"doctag\">@param</span> exception Reson of interrupt.</span></span><br><span class=\"line\"><span class=\"comment\">                 */</span></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onInterrupt</span><span class=\"params\">(Throwable exception)</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != callback) &#123;</span><br><span class=\"line\">                      <span class=\"comment\">// 回调</span></span><br><span class=\"line\">                        callback.onInterrupt(postcard);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    logger.info(Consts.TAG, <span class=\"string\">\"Navigation failed, termination by interceptor : \"</span> + exception.getMessage());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> _navigation(context, postcard, requestCode, callback);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>拦截器的处理是通过<code>interceptorService</code>代理来实现, 我们可以往里面看<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Route</span>(path = <span class=\"string\">\"/arouter/service/interceptor\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InterceptorServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">InterceptorService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> interceptorHasInit;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object interceptorInitLock = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doInterceptions</span><span class=\"params\">(<span class=\"keyword\">final</span> Postcard postcard, <span class=\"keyword\">final</span> InterceptorCallback callback)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != Warehouse.interceptors &amp;&amp; Warehouse.interceptors.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            checkInterceptorsInitStatus();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!interceptorHasInit) &#123;</span><br><span class=\"line\">                callback.onInterrupt(<span class=\"keyword\">new</span> HandlerException(<span class=\"string\">\"Interceptors initialization takes too much time.\"</span>));</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 通过线程池进行异步管理执行</span></span><br><span class=\"line\">            LogisticsCenter.executor.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    CancelableCountDownLatch interceptorCounter = <span class=\"keyword\">new</span> CancelableCountDownLatch(Warehouse.interceptors.size());</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 通过interceptorCounter倒数计数器, 一个个执行拥有的拦截器</span></span><br><span class=\"line\">                        _excute(<span class=\"number\">0</span>, interceptorCounter, postcard);</span><br><span class=\"line\">                        <span class=\"comment\">// 默认timeout时间是0.3s</span></span><br><span class=\"line\">                        interceptorCounter.await(postcard.getTimeout(), TimeUnit.SECONDS);</span><br><span class=\"line\">                        <span class=\"comment\">// 如果在postcard.getTimeout()时间内没有执行完</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (interceptorCounter.getCount() &gt; <span class=\"number\">0</span>) &#123;    <span class=\"comment\">// Cancel the navigation this time, if it hasn't return anythings.</span></span><br><span class=\"line\">                            <span class=\"comment\">// 取消</span></span><br><span class=\"line\">                            callback.onInterrupt(<span class=\"keyword\">new</span> HandlerException(<span class=\"string\">\"The interceptor processing timed out.\"</span>));</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != postcard.getTag()) &#123;    <span class=\"comment\">// Maybe some exception in the tag.</span></span><br><span class=\"line\">                            callback.onInterrupt(<span class=\"keyword\">new</span> HandlerException(postcard.getTag().toString()));</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// 在没有超时和抛出异常的情况下, 则继续往后执行</span></span><br><span class=\"line\">                            callback.onContinue(postcard);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        callback.onInterrupt(e);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            callback.onContinue(postcard);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Excute interceptor</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> index    current interceptor index</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> counter  interceptor counter</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> postcard routeMeta</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">_excute</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> index, <span class=\"keyword\">final</span> CancelableCountDownLatch counter, <span class=\"keyword\">final</span> Postcard postcard)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; Warehouse.interceptors.size()) &#123;</span><br><span class=\"line\">            IInterceptor iInterceptor = Warehouse.interceptors.get(index);</span><br><span class=\"line\">            iInterceptor.process(postcard, <span class=\"keyword\">new</span> InterceptorCallback() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onContinue</span><span class=\"params\">(Postcard postcard)</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Last interceptor excute over with no exception.</span></span><br><span class=\"line\">                    counter.countDown();</span><br><span class=\"line\">                    <span class=\"comment\">// 递归处理</span></span><br><span class=\"line\">                    _excute(index + <span class=\"number\">1</span>, counter, postcard);  <span class=\"comment\">// When counter is down, it will be execute continue ,but index bigger than interceptors size, then U know.</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onInterrupt</span><span class=\"params\">(Throwable exception)</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Last interceptor excute over with fatal exception.</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    postcard.setTag(<span class=\"keyword\">null</span> == exception ? <span class=\"keyword\">new</span> HandlerException(<span class=\"string\">\"No message.\"</span>) : exception.getMessage());    <span class=\"comment\">// save the exception message for backup.</span></span><br><span class=\"line\">                    counter.cancel();</span><br><span class=\"line\">                    <span class=\"comment\">// Be attention, maybe the thread in callback has been changed,</span></span><br><span class=\"line\">                    <span class=\"comment\">// then the catch block(L207) will be invalid.</span></span><br><span class=\"line\">                    <span class=\"comment\">// The worst is the thread changed to main thread, then the app will be crash, if you throw this exception!</span></span><br><span class=\"line\"><span class=\"comment\">//                    if (!Looper.getMainLooper().equals(Looper.myLooper())) &#123;    // You shouldn't throw the exception if the thread is main thread.</span></span><br><span class=\"line\"><span class=\"comment\">//                        throw new HandlerException(exception.getMessage());</span></span><br><span class=\"line\"><span class=\"comment\">//                    &#125;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">        LogisticsCenter.executor.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (MapUtils.isNotEmpty(Warehouse.interceptorsIndex)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (Map.Entry&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; entry : Warehouse.interceptorsIndex.entrySet()) &#123;</span><br><span class=\"line\">                        Class&lt;? extends IInterceptor&gt; interceptorClass = entry.getValue();</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            IInterceptor iInterceptor = interceptorClass.getConstructor().newInstance();</span><br><span class=\"line\">                            iInterceptor.init(context);</span><br><span class=\"line\">                            Warehouse.interceptors.add(iInterceptor);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> HandlerException(TAG + <span class=\"string\">\"ARouter init interceptor error! name = [\"</span> + interceptorClass.getName() + <span class=\"string\">\"], reason = [\"</span> + ex.getMessage() + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    interceptorHasInit = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                    logger.info(TAG, <span class=\"string\">\"ARouter interceptors init over.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">synchronized</span> (interceptorInitLock) &#123;</span><br><span class=\"line\">                        interceptorInitLock.notifyAll();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">checkInterceptorsInitStatus</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (interceptorInitLock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!interceptorHasInit) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    interceptorInitLock.wait(<span class=\"number\">10</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> HandlerException(TAG + <span class=\"string\">\"Interceptor init cost too much time error! reason = [\"</span> + e.getMessage() + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ok, 在进行了拦截器处理(或者没有拦截器的情况下), 我们走到了<code>_navigation(context, postcard, requestCode, callback)</code>, 到这里基本又是熟悉的配方了, 可以看到他最后通过<code>startActivity</code>来进行跳转.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Object <span class=\"title\">_navigation</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context, <span class=\"keyword\">final</span> Postcard postcard, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Context currentContext = <span class=\"keyword\">null</span> == context ? mContext : context;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (postcard.getType()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> ACTIVITY:</span><br><span class=\"line\">                <span class=\"comment\">// Build intent</span></span><br><span class=\"line\">                <span class=\"keyword\">final</span> Intent intent = <span class=\"keyword\">new</span> Intent(currentContext, postcard.getDestination());</span><br><span class=\"line\">                intent.putExtras(postcard.getExtras());</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Set flags.</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> flags = postcard.getFlags();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (-<span class=\"number\">1</span> != flags) &#123;</span><br><span class=\"line\">                    intent.setFlags(flags);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!(currentContext <span class=\"keyword\">instanceof</span> Activity)) &#123;    <span class=\"comment\">// Non activity, need less one flag.</span></span><br><span class=\"line\">                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Navigation in main looper.</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> Handler(Looper.getMainLooper()).post(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (requestCode &gt; <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// Need start for result</span></span><br><span class=\"line\">                            ActivityCompat.startActivityForResult((Activity) currentContext, intent, requestCode, postcard.getOptionsBundle());</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            ActivityCompat.startActivity(currentContext, intent, postcard.getOptionsBundle());</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((-<span class=\"number\">1</span> != postcard.getEnterAnim() &amp;&amp; -<span class=\"number\">1</span> != postcard.getExitAnim()) &amp;&amp; currentContext <span class=\"keyword\">instanceof</span> Activity) &#123;    <span class=\"comment\">// Old version.</span></span><br><span class=\"line\">                            ((Activity) currentContext).overridePendingTransition(postcard.getEnterAnim(), postcard.getExitAnim());</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != callback) &#123; <span class=\"comment\">// Navigation over.</span></span><br><span class=\"line\">                            callback.onArrival(postcard);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> PROVIDER:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> postcard.getProvider();</span><br><span class=\"line\">            <span class=\"keyword\">case</span> BOARDCAST:</span><br><span class=\"line\">            <span class=\"keyword\">case</span> CONTENT_PROVIDER:</span><br><span class=\"line\">            <span class=\"keyword\">case</span> FRAGMENT:</span><br><span class=\"line\">                Class fragmentMeta = postcard.getDestination();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Object instance = fragmentMeta.getConstructor().newInstance();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (instance <span class=\"keyword\">instanceof</span> Fragment) &#123;</span><br><span class=\"line\">                        ((Fragment) instance).setArguments(postcard.getExtras());</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (instance <span class=\"keyword\">instanceof</span> android.support.v4.app.Fragment) &#123;</span><br><span class=\"line\">                        ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">                    logger.error(Consts.TAG, <span class=\"string\">\"Fetch fragment instance error, \"</span> + TextUtils.formatStackTrace(ex.getStackTrace()));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> METHOD:</span><br><span class=\"line\">            <span class=\"keyword\">case</span> SERVICE:</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>如果应用项目要做模块化, 必然绕不开为了模块间跳转解耦而做的处理, 我们都知道一般都会采用路由模式, 本篇主要解析阿里的开源路由框架<code>ARouter</code>, 源码地址可见<a href=\"https://github.com/alibaba/ARouter\" target=\"_blank\" rel=\"noopener\">Github</a>,本篇分析版本为api<code>1.3.1</code><br>","more":"</p>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p>感谢源码自带Demo, 我们直接从他的整个使用流程开始看起.忽略掉Log模式和Debug模式的开启, 首先我们需要初始化<code>ARouter</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ARouter.init(getApplication());</span><br></pre></td></tr></table></figure></p>\n<p>它内部实际调用的是<code>LogisticsCenter.init(Context context, ThreadPoolExecutor tpe)</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Context context, ThreadPoolExecutor tpe)</span> <span class=\"keyword\">throws</span> HandlerException </span>&#123;</span><br><span class=\"line\">        mContext = context;</span><br><span class=\"line\">        executor = tpe;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> startInit = System.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"comment\">//billy.qi modified at 2017-12-06</span></span><br><span class=\"line\">            <span class=\"comment\">//load by plugin first</span></span><br><span class=\"line\">            loadRouterMap();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (registerByPlugin) &#123;</span><br><span class=\"line\">                logger.info(TAG, <span class=\"string\">\"Load router map by arouter-auto-register plugin.\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                Set&lt;String&gt; routerMap;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// It will rebuild router map every times when debuggable.</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ARouter.debuggable() || PackageUtils.isNewVersion(context)) &#123;</span><br><span class=\"line\">                    logger.info(TAG, <span class=\"string\">\"Run with debug mode or new install, rebuild router map.\"</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// These class was generated by arouter-compiler.</span></span><br><span class=\"line\">                    <span class=\"comment\">// 通过arouter-compiler生成</span></span><br><span class=\"line\">                    routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!routerMap.isEmpty()) &#123;</span><br><span class=\"line\">                        context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 当router map更新的时候保存新的版本号</span></span><br><span class=\"line\">                    PackageUtils.updateVersion(context);    <span class=\"comment\">// Save new version name when router map update finishes.</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    logger.info(TAG, <span class=\"string\">\"Load router map from cache.\"</span>);</span><br><span class=\"line\">                    routerMap = <span class=\"keyword\">new</span> HashSet&lt;&gt;(context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).getStringSet(AROUTER_SP_KEY_MAP, <span class=\"keyword\">new</span> HashSet&lt;String&gt;()));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                logger.info(TAG, <span class=\"string\">\"Find router map finished, map size = \"</span> + routerMap.size() + <span class=\"string\">\", cost \"</span> + (System.currentTimeMillis() - startInit) + <span class=\"string\">\" ms.\"</span>);</span><br><span class=\"line\">                startInit = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (String className : routerMap) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// This one of root elements, load root.</span></span><br><span class=\"line\">                        ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// Load interceptorMeta</span></span><br><span class=\"line\">                        ((IInterceptorGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// Load providerIndex</span></span><br><span class=\"line\">                        ((IProviderGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            logger.info(TAG, <span class=\"string\">\"Load root element finished, cost \"</span> + (System.currentTimeMillis() - startInit) + <span class=\"string\">\" ms.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Warehouse.groupsIndex.size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                logger.error(TAG, <span class=\"string\">\"No mapping files were found, check your configuration please!\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ARouter.debuggable()) &#123;</span><br><span class=\"line\">                logger.debug(TAG, String.format(Locale.getDefault(), <span class=\"string\">\"LogisticsCenter has already been loaded, GroupIndex[%d], InterceptorIndex[%d], ProviderIndex[%d]\"</span>, Warehouse.groupsIndex.size(), Warehouse.interceptorsIndex.size(), Warehouse.providersIndex.size()));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> HandlerException(TAG + <span class=\"string\">\"ARouter init logistics center exception! [\"</span> + e.getMessage() + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里<code>loadRouterMap()</code>方法就是将是否通过插件注册的tag初始化为<code>false</code>, 我们主要看正常流程下的注册, 所以关注点在<code>else</code>的代码块中.对于<code>routerMap</code>从上下文我们可以看出, 他是<code>APT</code>自动生成的类名集合.</p>\n<p>在<code>Debug</code>模式下, 当每次更新路由缓存的版本的时候, 都会从指定包名<code>com.alibaba.android.arouter.routes</code>收集所有的className, 如果不为空 则更新磁盘缓存.</p>\n<p>而非<code>Debug</code>模式下, 不做收集, 直接获取磁盘缓存, 如果没有则new一个空集合.</p>\n<p>然后通过反射新建对应类实例并调用<code>load</code>方法.我们可以看下<code>debug</code>模式下, <code>APT</code>生成类文件下的<code>load</code>函数具体执行了什么<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ARouter</span>$$<span class=\"title\">Group</span>$$<span class=\"title\">arouter</span> <span class=\"keyword\">implements</span> <span class=\"title\">IRouteGroup</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadInto</span><span class=\"params\">(Map&lt;String, RouteMeta&gt; atlas)</span> </span>&#123;</span><br><span class=\"line\">    atlas.put(<span class=\"string\">\"/arouter/service/autowired\"</span>, RouteMeta.build(RouteType.PROVIDER, AutowiredServiceImpl.class, <span class=\"string\">\"/arouter/service/autowired\"</span>, <span class=\"string\">\"arouter\"</span>, <span class=\"keyword\">null</span>, -<span class=\"number\">1</span>, -<span class=\"number\">2147483648</span>));</span><br><span class=\"line\">    atlas.put(<span class=\"string\">\"/arouter/service/interceptor\"</span>, RouteMeta.build(RouteType.PROVIDER, InterceptorServiceImpl.class, <span class=\"string\">\"/arouter/service/interceptor\"</span>, <span class=\"string\">\"arouter\"</span>, <span class=\"keyword\">null</span>, -<span class=\"number\">1</span>, -<span class=\"number\">2147483648</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ARouter</span>$$<span class=\"title\">Providers</span>$$<span class=\"title\">arouterapi</span> <span class=\"keyword\">implements</span> <span class=\"title\">IProviderGroup</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadInto</span><span class=\"params\">(Map&lt;String, RouteMeta&gt; providers)</span> </span>&#123;</span><br><span class=\"line\">    providers.put(<span class=\"string\">\"com.alibaba.android.arouter.facade.service.AutowiredService\"</span>, RouteMeta.build(RouteType.PROVIDER, AutowiredServiceImpl.class, <span class=\"string\">\"/arouter/service/autowired\"</span>, <span class=\"string\">\"arouter\"</span>, <span class=\"keyword\">null</span>, -<span class=\"number\">1</span>, -<span class=\"number\">2147483648</span>));</span><br><span class=\"line\">    providers.put(<span class=\"string\">\"com.alibaba.android.arouter.facade.service.InterceptorService\"</span>, RouteMeta.build(RouteType.PROVIDER, InterceptorServiceImpl.class, <span class=\"string\">\"/arouter/service/interceptor\"</span>, <span class=\"string\">\"arouter\"</span>, <span class=\"keyword\">null</span>, -<span class=\"number\">1</span>, -<span class=\"number\">2147483648</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ARouter</span>$$<span class=\"title\">Root</span>$$<span class=\"title\">arouterapi</span> <span class=\"keyword\">implements</span> <span class=\"title\">IRouteRoot</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadInto</span><span class=\"params\">(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes)</span> </span>&#123;</span><br><span class=\"line\">    routes.put(<span class=\"string\">\"arouter\"</span>, ARouter$$Group$$arouter.class);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看出所有<code>loadInto()</code>方法执行的都是将注解的信息通过<code>Map</code>强引用做内存缓存管理.这里<code>Warehouse.groupsIndex</code>管理的是组的路由生成文件的内存, <code>Warehouse.interceptorsIndex</code>拦截器的索引管理, <code>Warehouse.providersIndex</code>服务(不是四大组件, 而是实现了继承<code>IProvider</code>接口的对象)索引管理.</p>\n<h2 id=\"跳转\"><a href=\"#跳转\" class=\"headerlink\" title=\"跳转\"></a>跳转</h2><p>我们先看下对应的API<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ARouter.getInstance()</span><br><span class=\"line\">       .build(<span class=\"string\">\"/test/activity2\"</span>)</span><br><span class=\"line\">       .navigation();</span><br></pre></td></tr></table></figure></p>\n<p>首先需要<code>build</code>一个<code>Postcard</code>对象, 他包含了我们传递的跳转信息.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Postcard <span class=\"title\">build</span><span class=\"params\">(String path)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (TextUtils.isEmpty(path)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> HandlerException(Consts.TAG + <span class=\"string\">\"Parameter is invalid!\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 判断是否重写跳转URL, 没有就使用原来的path构建Postcard</span></span><br><span class=\"line\">            PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != pService) &#123;</span><br><span class=\"line\">                path = pService.forString(path);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> build(path, extractGroup(path));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Postcard <span class=\"title\">build</span><span class=\"params\">(String path, String group)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (TextUtils.isEmpty(path) || TextUtils.isEmpty(group)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> HandlerException(Consts.TAG + <span class=\"string\">\"Parameter is invalid!\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != pService) &#123;</span><br><span class=\"line\">                path = pService.forString(path);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Postcard(path, group);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后通过<code>postcard.navigation()</code>做跳转工作, 在这个方法内首先会针对我们记载路由信息的<code>postcard</code>通过调用<code>LogisticsCenter.completion(postcard);</code>进行信息补充完善<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">completion</span><span class=\"params\">(Postcard postcard)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == postcard) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoRouteFoundException(TAG + <span class=\"string\">\"No postcard!\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 通过path获取路由基础信息</span></span><br><span class=\"line\">        RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());</span><br><span class=\"line\">        <span class=\"comment\">// 如果没有获取到路由基础信息</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == routeMeta) &#123;    <span class=\"comment\">// Maybe its does't exist, or didn't load.</span></span><br><span class=\"line\">            <span class=\"comment\">// 则重新通过反射进行加载</span></span><br><span class=\"line\">            Class&lt;? extends IRouteGroup&gt; groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());  <span class=\"comment\">// Load route meta.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == groupMeta) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoRouteFoundException(TAG + <span class=\"string\">\"There is no route match the path [\"</span> + postcard.getPath() + <span class=\"string\">\"], in group [\"</span> + postcard.getGroup() + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Load route and cache it into memory, then delete from metas.</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (ARouter.debuggable()) &#123;</span><br><span class=\"line\">                        logger.debug(TAG, String.format(Locale.getDefault(), <span class=\"string\">\"The group [%s] starts loading, trigger by [%s]\"</span>, postcard.getGroup(), postcard.getPath()));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();</span><br><span class=\"line\">                    iGroupInstance.loadInto(Warehouse.routes);</span><br><span class=\"line\">                    Warehouse.groupsIndex.remove(postcard.getGroup());</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (ARouter.debuggable()) &#123;</span><br><span class=\"line\">                        logger.debug(TAG, String.format(Locale.getDefault(), <span class=\"string\">\"The group [%s] has already been loaded, trigger by [%s]\"</span>, postcard.getGroup(), postcard.getPath()));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> HandlerException(TAG + <span class=\"string\">\"Fatal exception when loading group meta. [\"</span> + e.getMessage() + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 递归进行路由的完善工作</span></span><br><span class=\"line\">                completion(postcard);   <span class=\"comment\">// Reload</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 完善postcard信息</span></span><br><span class=\"line\">            postcard.setDestination(routeMeta.getDestination());</span><br><span class=\"line\">            postcard.setType(routeMeta.getType());</span><br><span class=\"line\">            postcard.setPriority(routeMeta.getPriority());</span><br><span class=\"line\">            postcard.setExtra(routeMeta.getExtra());</span><br><span class=\"line\"></span><br><span class=\"line\">            Uri rawUri = postcard.getUri();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != rawUri) &#123;   <span class=\"comment\">// Try to set params into bundle.</span></span><br><span class=\"line\">                Map&lt;String, String&gt; resultMap = TextUtils.splitQueryParameters(rawUri);</span><br><span class=\"line\">                Map&lt;String, Integer&gt; paramsType = routeMeta.getParamsType();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (MapUtils.isNotEmpty(paramsType)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Set value by its type, just for params which annotation by @Param</span></span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (Map.Entry&lt;String, Integer&gt; params : paramsType.entrySet()) &#123;</span><br><span class=\"line\">                        setValue(postcard,</span><br><span class=\"line\">                                params.getValue(),</span><br><span class=\"line\">                                params.getKey(),</span><br><span class=\"line\">                                resultMap.get(params.getKey()));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// Save params name which need auto inject.</span></span><br><span class=\"line\">                    postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(<span class=\"keyword\">new</span> String[]&#123;&#125;));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Save raw uri</span></span><br><span class=\"line\">                postcard.withString(ARouter.RAW_URI, rawUri.toString());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (routeMeta.getType()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> PROVIDER:  <span class=\"comment\">// if the route is provider, should find its instance</span></span><br><span class=\"line\">                    <span class=\"comment\">// Its provider, so it must implement IProvider</span></span><br><span class=\"line\">                    Class&lt;? extends IProvider&gt; providerMeta = (Class&lt;? extends IProvider&gt;) routeMeta.getDestination();</span><br><span class=\"line\">                    IProvider instance = Warehouse.providers.get(providerMeta);</span><br><span class=\"line\">                    <span class=\"keyword\">switch</span> (routeMeta.getType()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> PROVIDER:  <span class=\"comment\">// if the route is provider, should find its instance</span></span><br><span class=\"line\">                    <span class=\"comment\">// Its provider, so it must implement IProvider</span></span><br><span class=\"line\">                    <span class=\"comment\">// 如果路由目标是一个provider</span></span><br><span class=\"line\">                    <span class=\"comment\">// 需要找到目标实例</span></span><br><span class=\"line\">                    Class&lt;? extends IProvider&gt; providerMeta = (Class&lt;? extends IProvider&gt;) routeMeta.getDestination();</span><br><span class=\"line\">                    IProvider instance = Warehouse.providers.get(providerMeta);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == instance) &#123; <span class=\"comment\">// There's no instance of this provider</span></span><br><span class=\"line\">                        IProvider provider;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            provider = providerMeta.getConstructor().newInstance();</span><br><span class=\"line\">                            provider.init(mContext);</span><br><span class=\"line\">                            Warehouse.providers.put(providerMeta, provider);</span><br><span class=\"line\">                            instance = provider;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> HandlerException(<span class=\"string\">\"Init provider failed! \"</span> + e.getMessage());</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    postcard.setProvider(instance);</span><br><span class=\"line\">                    <span class=\"comment\">// provider不会触发拦截器</span></span><br><span class=\"line\">                    postcard.greenChannel();    <span class=\"comment\">// Provider should skip all of interceptors</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> FRAGMENT:</span><br><span class=\"line\">                    <span class=\"comment\">// fragment不会触发拦截器</span></span><br><span class=\"line\">                    postcard.greenChannel();    <span class=\"comment\">// Fragment needn't interceptors</span></span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后再回来看下路由跳转做的事情.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Use router navigation.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> context     </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> postcard    路由信息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> requestCode RequestCode, 默认为-1</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> callback    申明的跳转回调</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">navigation</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context, <span class=\"keyword\">final</span> Postcard postcard, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// postcard信息完善</span></span><br><span class=\"line\">            LogisticsCenter.completion(postcard);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoRouteFoundException ex) &#123;</span><br><span class=\"line\">            logger.warning(Consts.TAG, ex.getMessage());</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (debuggable()) &#123; <span class=\"comment\">// Show friendly tips for user.</span></span><br><span class=\"line\">                Toast.makeText(mContext, <span class=\"string\">\"There's no route matched!\\n\"</span> +</span><br><span class=\"line\">                        <span class=\"string\">\" Path = [\"</span> + postcard.getPath() + <span class=\"string\">\"]\\n\"</span> +</span><br><span class=\"line\">                        <span class=\"string\">\" Group = [\"</span> + postcard.getGroup() + <span class=\"string\">\"]\"</span>, Toast.LENGTH_LONG).show();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 没有找到对应路由信息的回调通知, 如果没有回调, 会通过DegradeService服务进行通知, 但是要根据他发出的进行处理, 需要我们实现DegradeService的接口</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != callback) &#123;</span><br><span class=\"line\">                callback.onLost(postcard);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;    <span class=\"comment\">// No callback for this invoke, then we use the global degrade service.</span></span><br><span class=\"line\">                DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != degradeService) &#123;</span><br><span class=\"line\">                    degradeService.onLost(context, postcard);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 回调通知onFound</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != callback) &#123;</span><br><span class=\"line\">            callback.onFound(postcard);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 当需要处理拦截器内容的时候</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!postcard.isGreenChannel()) &#123;   <span class=\"comment\">// It must be run in async thread, maybe interceptor cost too mush time made ANR.</span></span><br><span class=\"line\">            <span class=\"comment\">// 拦截器处理</span></span><br><span class=\"line\">            interceptorService.doInterceptions(postcard, <span class=\"keyword\">new</span> InterceptorCallback() &#123;</span><br><span class=\"line\">                <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">                 * Continue process</span></span><br><span class=\"line\"><span class=\"comment\">                 *</span></span><br><span class=\"line\"><span class=\"comment\">                 * <span class=\"doctag\">@param</span> postcard route meta</span></span><br><span class=\"line\"><span class=\"comment\">                 */</span></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onContinue</span><span class=\"params\">(Postcard postcard)</span> </span>&#123;</span><br><span class=\"line\">                  <span class=\"comment\">// 继续跳转</span></span><br><span class=\"line\">                    _navigation(context, postcard, requestCode, callback);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">                 * Interrupt process, pipeline will be destory when this method called.</span></span><br><span class=\"line\"><span class=\"comment\">                 *</span></span><br><span class=\"line\"><span class=\"comment\">                 * <span class=\"doctag\">@param</span> exception Reson of interrupt.</span></span><br><span class=\"line\"><span class=\"comment\">                 */</span></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onInterrupt</span><span class=\"params\">(Throwable exception)</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != callback) &#123;</span><br><span class=\"line\">                      <span class=\"comment\">// 回调</span></span><br><span class=\"line\">                        callback.onInterrupt(postcard);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    logger.info(Consts.TAG, <span class=\"string\">\"Navigation failed, termination by interceptor : \"</span> + exception.getMessage());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> _navigation(context, postcard, requestCode, callback);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>拦截器的处理是通过<code>interceptorService</code>代理来实现, 我们可以往里面看<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Route</span>(path = <span class=\"string\">\"/arouter/service/interceptor\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InterceptorServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">InterceptorService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> interceptorHasInit;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object interceptorInitLock = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doInterceptions</span><span class=\"params\">(<span class=\"keyword\">final</span> Postcard postcard, <span class=\"keyword\">final</span> InterceptorCallback callback)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != Warehouse.interceptors &amp;&amp; Warehouse.interceptors.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            checkInterceptorsInitStatus();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!interceptorHasInit) &#123;</span><br><span class=\"line\">                callback.onInterrupt(<span class=\"keyword\">new</span> HandlerException(<span class=\"string\">\"Interceptors initialization takes too much time.\"</span>));</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 通过线程池进行异步管理执行</span></span><br><span class=\"line\">            LogisticsCenter.executor.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    CancelableCountDownLatch interceptorCounter = <span class=\"keyword\">new</span> CancelableCountDownLatch(Warehouse.interceptors.size());</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 通过interceptorCounter倒数计数器, 一个个执行拥有的拦截器</span></span><br><span class=\"line\">                        _excute(<span class=\"number\">0</span>, interceptorCounter, postcard);</span><br><span class=\"line\">                        <span class=\"comment\">// 默认timeout时间是0.3s</span></span><br><span class=\"line\">                        interceptorCounter.await(postcard.getTimeout(), TimeUnit.SECONDS);</span><br><span class=\"line\">                        <span class=\"comment\">// 如果在postcard.getTimeout()时间内没有执行完</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (interceptorCounter.getCount() &gt; <span class=\"number\">0</span>) &#123;    <span class=\"comment\">// Cancel the navigation this time, if it hasn't return anythings.</span></span><br><span class=\"line\">                            <span class=\"comment\">// 取消</span></span><br><span class=\"line\">                            callback.onInterrupt(<span class=\"keyword\">new</span> HandlerException(<span class=\"string\">\"The interceptor processing timed out.\"</span>));</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != postcard.getTag()) &#123;    <span class=\"comment\">// Maybe some exception in the tag.</span></span><br><span class=\"line\">                            callback.onInterrupt(<span class=\"keyword\">new</span> HandlerException(postcard.getTag().toString()));</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// 在没有超时和抛出异常的情况下, 则继续往后执行</span></span><br><span class=\"line\">                            callback.onContinue(postcard);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        callback.onInterrupt(e);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            callback.onContinue(postcard);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Excute interceptor</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> index    current interceptor index</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> counter  interceptor counter</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> postcard routeMeta</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">_excute</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> index, <span class=\"keyword\">final</span> CancelableCountDownLatch counter, <span class=\"keyword\">final</span> Postcard postcard)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; Warehouse.interceptors.size()) &#123;</span><br><span class=\"line\">            IInterceptor iInterceptor = Warehouse.interceptors.get(index);</span><br><span class=\"line\">            iInterceptor.process(postcard, <span class=\"keyword\">new</span> InterceptorCallback() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onContinue</span><span class=\"params\">(Postcard postcard)</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Last interceptor excute over with no exception.</span></span><br><span class=\"line\">                    counter.countDown();</span><br><span class=\"line\">                    <span class=\"comment\">// 递归处理</span></span><br><span class=\"line\">                    _excute(index + <span class=\"number\">1</span>, counter, postcard);  <span class=\"comment\">// When counter is down, it will be execute continue ,but index bigger than interceptors size, then U know.</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onInterrupt</span><span class=\"params\">(Throwable exception)</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Last interceptor excute over with fatal exception.</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    postcard.setTag(<span class=\"keyword\">null</span> == exception ? <span class=\"keyword\">new</span> HandlerException(<span class=\"string\">\"No message.\"</span>) : exception.getMessage());    <span class=\"comment\">// save the exception message for backup.</span></span><br><span class=\"line\">                    counter.cancel();</span><br><span class=\"line\">                    <span class=\"comment\">// Be attention, maybe the thread in callback has been changed,</span></span><br><span class=\"line\">                    <span class=\"comment\">// then the catch block(L207) will be invalid.</span></span><br><span class=\"line\">                    <span class=\"comment\">// The worst is the thread changed to main thread, then the app will be crash, if you throw this exception!</span></span><br><span class=\"line\"><span class=\"comment\">//                    if (!Looper.getMainLooper().equals(Looper.myLooper())) &#123;    // You shouldn't throw the exception if the thread is main thread.</span></span><br><span class=\"line\"><span class=\"comment\">//                        throw new HandlerException(exception.getMessage());</span></span><br><span class=\"line\"><span class=\"comment\">//                    &#125;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">        LogisticsCenter.executor.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (MapUtils.isNotEmpty(Warehouse.interceptorsIndex)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (Map.Entry&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; entry : Warehouse.interceptorsIndex.entrySet()) &#123;</span><br><span class=\"line\">                        Class&lt;? extends IInterceptor&gt; interceptorClass = entry.getValue();</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            IInterceptor iInterceptor = interceptorClass.getConstructor().newInstance();</span><br><span class=\"line\">                            iInterceptor.init(context);</span><br><span class=\"line\">                            Warehouse.interceptors.add(iInterceptor);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> HandlerException(TAG + <span class=\"string\">\"ARouter init interceptor error! name = [\"</span> + interceptorClass.getName() + <span class=\"string\">\"], reason = [\"</span> + ex.getMessage() + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    interceptorHasInit = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                    logger.info(TAG, <span class=\"string\">\"ARouter interceptors init over.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">synchronized</span> (interceptorInitLock) &#123;</span><br><span class=\"line\">                        interceptorInitLock.notifyAll();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">checkInterceptorsInitStatus</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (interceptorInitLock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!interceptorHasInit) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    interceptorInitLock.wait(<span class=\"number\">10</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> HandlerException(TAG + <span class=\"string\">\"Interceptor init cost too much time error! reason = [\"</span> + e.getMessage() + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ok, 在进行了拦截器处理(或者没有拦截器的情况下), 我们走到了<code>_navigation(context, postcard, requestCode, callback)</code>, 到这里基本又是熟悉的配方了, 可以看到他最后通过<code>startActivity</code>来进行跳转.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Object <span class=\"title\">_navigation</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context, <span class=\"keyword\">final</span> Postcard postcard, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Context currentContext = <span class=\"keyword\">null</span> == context ? mContext : context;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (postcard.getType()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> ACTIVITY:</span><br><span class=\"line\">                <span class=\"comment\">// Build intent</span></span><br><span class=\"line\">                <span class=\"keyword\">final</span> Intent intent = <span class=\"keyword\">new</span> Intent(currentContext, postcard.getDestination());</span><br><span class=\"line\">                intent.putExtras(postcard.getExtras());</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Set flags.</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> flags = postcard.getFlags();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (-<span class=\"number\">1</span> != flags) &#123;</span><br><span class=\"line\">                    intent.setFlags(flags);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!(currentContext <span class=\"keyword\">instanceof</span> Activity)) &#123;    <span class=\"comment\">// Non activity, need less one flag.</span></span><br><span class=\"line\">                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Navigation in main looper.</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> Handler(Looper.getMainLooper()).post(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (requestCode &gt; <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// Need start for result</span></span><br><span class=\"line\">                            ActivityCompat.startActivityForResult((Activity) currentContext, intent, requestCode, postcard.getOptionsBundle());</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            ActivityCompat.startActivity(currentContext, intent, postcard.getOptionsBundle());</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((-<span class=\"number\">1</span> != postcard.getEnterAnim() &amp;&amp; -<span class=\"number\">1</span> != postcard.getExitAnim()) &amp;&amp; currentContext <span class=\"keyword\">instanceof</span> Activity) &#123;    <span class=\"comment\">// Old version.</span></span><br><span class=\"line\">                            ((Activity) currentContext).overridePendingTransition(postcard.getEnterAnim(), postcard.getExitAnim());</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != callback) &#123; <span class=\"comment\">// Navigation over.</span></span><br><span class=\"line\">                            callback.onArrival(postcard);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> PROVIDER:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> postcard.getProvider();</span><br><span class=\"line\">            <span class=\"keyword\">case</span> BOARDCAST:</span><br><span class=\"line\">            <span class=\"keyword\">case</span> CONTENT_PROVIDER:</span><br><span class=\"line\">            <span class=\"keyword\">case</span> FRAGMENT:</span><br><span class=\"line\">                Class fragmentMeta = postcard.getDestination();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Object instance = fragmentMeta.getConstructor().newInstance();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (instance <span class=\"keyword\">instanceof</span> Fragment) &#123;</span><br><span class=\"line\">                        ((Fragment) instance).setArguments(postcard.getExtras());</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (instance <span class=\"keyword\">instanceof</span> android.support.v4.app.Fragment) &#123;</span><br><span class=\"line\">                        ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">                    logger.error(Consts.TAG, <span class=\"string\">\"Fetch fragment instance error, \"</span> + TextUtils.formatStackTrace(ex.getStackTrace()));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> METHOD:</span><br><span class=\"line\">            <span class=\"keyword\">case</span> SERVICE:</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"okHttp3源码解析(三)-CallServerInterceptor","date":"2018-08-28T16:00:00.000Z","_content":"## 前言\n本篇主要看下`CallServerInterceptor`, 关于他在整个请求中起到的作用, okHttp已经告诉我们, 可以看出它作为责任链中的最后一个环节, 承担了对服务端进行请求的工作.\n> This is the last interceptor in the chain. It makes a network call to the server.\n<!-- more -->\n## 正文\n`okHttp`对于对服务钱的请求与相应, 底层都是通过`okio`对`socket`进行操作.\n老样子, 我们直接上代码\n``` java\n@Override public Response intercept(Chain chain) throws IOException {\n    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n    // 在 ConnectInterceptor创建\n    HttpCodec httpCodec = realChain.httpStream();\n    // 在 RetryAndFollowUpInterceptor创建\n    StreamAllocation streamAllocation = realChain.streamAllocation();\n    // 在 ConnectInterceptor获取\n    RealConnection connection = (RealConnection) realChain.connection();\n    Request request = realChain.request();\n    // 发送请求时间戳为当前时间戳\n    long sentRequestMillis = System.currentTimeMillis();\n\n    realChain.eventListener().requestHeadersStart(realChain.call());\n    // 发送请求头, 通过Okio\n    httpCodec.writeRequestHeaders(request);\n    realChain.eventListener().requestHeadersEnd(realChain.call(), request);\n\n    Response.Builder responseBuilder = null;\n    // GET or HEAD 不需要\n    if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {\n      // If there's a \"Expect: 100-continue\" header on the request, wait for a \"HTTP/1.1 100\n      // Continue\" response before transmitting the request body. If we don't get that, return\n      // what we did get (such as a 4xx response) without ever transmitting the request body.\n      if (\"100-continue\".equalsIgnoreCase(request.header(\"Expect\"))) {\n        // 请求刷新, okio处理\n        httpCodec.flushRequest();\n        realChain.eventListener().responseHeadersStart(realChain.call());\n        // 构建Response.Builder, 当response状态为100, 则返回null\n        responseBuilder = httpCodec.readResponseHeaders(true);\n      }\n\n      if (responseBuilder == null) {\n        // head成功响应的情况下\n        // Write the request body if the \"Expect: 100-continue\" expectation was met.\n        realChain.eventListener().requestBodyStart(realChain.call());\n        long contentLength = request.body().contentLength();\n        // 请求体的输出流\n        CountingSink requestBodyOut =\n            new CountingSink(httpCodec.createRequestBody(request, contentLength));\n        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);\n        // 发送请求体\n        request.body().writeTo(bufferedRequestBody);\n        bufferedRequestBody.close();\n        realChain.eventListener()\n            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);\n      } else if (!connection.isMultiplexed()) {\n        // HTTP/1请求协议, 而且初次握手失败\n        // If the \"Expect: 100-continue\" expectation wasn't met, prevent the HTTP/1 connection\n        // from being reused. Otherwise we're still obligated to transmit the request body to\n        // leave the connection in a consistent state.\n        // 禁止同主机请求新流的分配\n        streamAllocation.noNewStreams();\n      }\n    }\n\n    // flush\n    httpCodec.finishRequest();\n    // 如果是GET请求, 或者需要'100- continue'握手成功的情况下\n    if (responseBuilder == null) {\n      realChain.eventListener().responseHeadersStart(realChain.call());\n      // 构建responseBuilder\n      responseBuilder = httpCodec.readResponseHeaders(false);\n    }\n    // 获取响应\n    Response response = responseBuilder\n        // 原请求\n        .request(request)\n        // 握手情况\n        .handshake(streamAllocation.connection().handshake())\n        // 请求时间\n        .sentRequestAtMillis(sentRequestMillis)\n        // 响应时间\n        .receivedResponseAtMillis(System.currentTimeMillis())\n        .build();\n\n    int code = response.code();\n    if (code == 100) {\n      // server sent a 100-continue even though we did not request one.\n      // try again to read the actual response\n      // 即使我们没有请求, 服务端也会发送一个100-continue\n      // 重新读取真正的响应\n      responseBuilder = httpCodec.readResponseHeaders(false);\n      // 构建response\n      response = responseBuilder\n              .request(request)\n              .handshake(streamAllocation.connection().handshake())\n              .sentRequestAtMillis(sentRequestMillis)\n              .receivedResponseAtMillis(System.currentTimeMillis())\n              .build();\n\n      code = response.code();\n    }\n\n    realChain.eventListener()\n            .responseHeadersEnd(realChain.call(), response);\n\n    if (forWebSocket && code == 101) {\n      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.\n      // 我们需要确保不会反悔一个空的响应体\n      response = response.newBuilder()\n          .body(Util.EMPTY_RESPONSE)\n          .build();\n    } else {\n      response = response.newBuilder()\n          .body(httpCodec.openResponseBody(response))\n          .build();\n    }\n\n    // 如果请求关闭连接, 则关闭\n    if (\"close\".equalsIgnoreCase(response.request().header(\"Connection\"))\n        || \"close\".equalsIgnoreCase(response.header(\"Connection\"))) {\n      streamAllocation.noNewStreams();\n    }\n    // 抛出协议异常\n    // 204: No Content\n    // 205: Reset Content\n    if ((code == 204 || code == 205) && response.body().contentLength() > 0) {\n      throw new ProtocolException(\n          \"HTTP \" + code + \" had non-zero Content-Length: \" + response.body().contentLength());\n    }\n\n    return response;\n  }\n```\n### 请求\n我们来一步步看下代码\n``` java\nRealInterceptorChain realChain = (RealInterceptorChain) chain;\n    // 在 ConnectInterceptor创建\n    HttpCodec httpCodec = realChain.httpStream();\n    // 在 RetryAndFollowUpInterceptor创建\n    StreamAllocation streamAllocation = realChain.streamAllocation();\n    // 在 ConnectInterceptor获取\n    RealConnection connection = (RealConnection) realChain.connection();\n    Request request = realChain.request();\n```\n在`CallServerInterceptor`在, 核心工具类就是`HttpCodec`, 他的初始化我们在上篇[ConnectInterceptor解析](https://xiaozhuanlan.com/topic/5208976413)中可以看到.这里的步骤其实就是工具的准备.\n``` java\nhttpCodec.writeRequestHeaders(request);\n```\n我们以HTTP/1.1协议来看, 那么具体要看`Http1Codec`中的实现\n``` java\n@Override public void writeRequestHeaders(Request request) throws IOException {\n    // requestLine 就是我们请求报文内容的首行, 譬如 \"GET / HTTP/1.1\"\n    String requestLine = RequestLine.get(\n        request, streamAllocation.connection().route().proxy().type());\n    writeRequest(request.headers(), requestLine);\n  }\n\n  final BufferedSink sink;\n  public void writeRequest(Headers headers, String requestLine) throws IOException {\n    if (state != STATE_IDLE) throw new IllegalStateException(\"state: \" + state);\n    sink.writeUtf8(requestLine).writeUtf8(\"\\r\\n\");\n    for (int i = 0, size = headers.size(); i < size; i++) {\n      sink.writeUtf8(headers.name(i))\n          .writeUtf8(\": \")\n          .writeUtf8(headers.value(i))\n          .writeUtf8(\"\\r\\n\");\n    }\n    sink.writeUtf8(\"\\r\\n\");\n    state = STATE_OPEN_REQUEST_BODY;\n  }\n```\n可以看到在`writeRequest`中的方法, 就是针对`BufferedSink`对象的写操作, 在上篇`ConnectInterceptor`中进行三次握手连接的时候, 会进行初始化的工作, 我们会发现他是针对`Socket`的包装, 可以看做是`Socket`的输出流, 所以这里相当于是`Socket`的写入动作, 可以看出来, 这里会请求发送`header`.\n``` java\nif (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {\n      if (\"100-continue\".equalsIgnoreCase(request.header(\"Expect\"))) {\n        // 请求刷新, okio处理\n        httpCodec.flushRequest();\n        realChain.eventListener().responseHeadersStart(realChain.call());\n        // 构建Response.Builder, 当response状态为100, 则返回null\n        responseBuilder = httpCodec.readResponseHeaders(true);\n      }\n\n      if (responseBuilder == null) {\n        // head成功响应的情况下\n        // Write the request body if the \"Expect: 100-continue\" expectation was met.\n        realChain.eventListener().requestBodyStart(realChain.call());\n        long contentLength = request.body().contentLength();\n        // 请求体的输出流\n        CountingSink requestBodyOut =\n            new CountingSink(httpCodec.createRequestBody(request, contentLength));\n        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);\n        // 发送请求体\n        request.body().writeTo(bufferedRequestBody);\n        bufferedRequestBody.close();\n        realChain.eventListener()\n            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);\n      } else if (!connection.isMultiplexed()) {\n        // HTTP/1请求协议, 而且初次握手失败\n        // 禁止同主机请求新流的分配\n        streamAllocation.noNewStreams();\n      }\n    }\n```\n当请求首部字段包含`Expect:100-continue`, 一般在请求上传大容量body或者是需要验证的时候, 这样避免大文件传送失败带来的带宽浪费。所以需要判断请求体不为空的情况下, 并且请求首部包含该字段的情况下, 刷新请求, 构建`responseBuilder`对象, 如果这个时候服务端响应成功, 则`responseBuilder`对象为null, 并进行body的请求;而如果第一次请求头响应失败的情况下, 那么如果是HTTP/1的请求协议下, 就会禁止同host的请求新流的分配.\n### 响应\n以上就是请求的过程, 然后看响应\n``` java\n// 如果是GET请求, 或者需要'100- continue'握手成功的情况下\n    if (responseBuilder == null) {\n      // 构建responseBuilder\n      responseBuilder = httpCodec.readResponseHeaders(false);\n    }\n    // 获取响应\n    Response response = responseBuilder\n        // 原请求\n        .request(request)\n        // 握手情况\n        .handshake(streamAllocation.connection().handshake())\n        // 请求时间\n        .sentRequestAtMillis(sentRequestMillis)\n        // 响应时间\n        .receivedResponseAtMillis(System.currentTimeMillis())\n        .build();\n```\n在请求成功的情况下, 会重新构建`responseBuilder`对象, 通过它来构建响应报文.\n``` java\nint code = response.code();\n    if (code == 100) {\n      // 即使我们没有请求, 服务端也会发送一个100-continue\n      // 重新读取真正的响应\n      responseBuilder = httpCodec.readResponseHeaders(false);\n      // 构建response\n      response = responseBuilder\n              .request(request)\n              .handshake(streamAllocation.connection().handshake())\n              .sentRequestAtMillis(sentRequestMillis)\n              .receivedResponseAtMillis(System.currentTimeMillis())\n              .build();\n\n      code = response.code();\n    }\n```\n如果客户端响应`100`状态码, 这个时候, 我们就需要重新读取获取真正的内容响应.\n\n剩下的代码就是一些异常的处理, 这里就不做分析了.\n","source":"_posts/OkHttp源码解析(三)-CallServerInterceptor.md","raw":"title: okHttp3源码解析(三)-CallServerInterceptor\ndate: 2018-08-29 00:00:00\ncategories:\n- 源码解析\ntags:\n- 源码解析\n- okHttp3\n---\n## 前言\n本篇主要看下`CallServerInterceptor`, 关于他在整个请求中起到的作用, okHttp已经告诉我们, 可以看出它作为责任链中的最后一个环节, 承担了对服务端进行请求的工作.\n> This is the last interceptor in the chain. It makes a network call to the server.\n<!-- more -->\n## 正文\n`okHttp`对于对服务钱的请求与相应, 底层都是通过`okio`对`socket`进行操作.\n老样子, 我们直接上代码\n``` java\n@Override public Response intercept(Chain chain) throws IOException {\n    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n    // 在 ConnectInterceptor创建\n    HttpCodec httpCodec = realChain.httpStream();\n    // 在 RetryAndFollowUpInterceptor创建\n    StreamAllocation streamAllocation = realChain.streamAllocation();\n    // 在 ConnectInterceptor获取\n    RealConnection connection = (RealConnection) realChain.connection();\n    Request request = realChain.request();\n    // 发送请求时间戳为当前时间戳\n    long sentRequestMillis = System.currentTimeMillis();\n\n    realChain.eventListener().requestHeadersStart(realChain.call());\n    // 发送请求头, 通过Okio\n    httpCodec.writeRequestHeaders(request);\n    realChain.eventListener().requestHeadersEnd(realChain.call(), request);\n\n    Response.Builder responseBuilder = null;\n    // GET or HEAD 不需要\n    if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {\n      // If there's a \"Expect: 100-continue\" header on the request, wait for a \"HTTP/1.1 100\n      // Continue\" response before transmitting the request body. If we don't get that, return\n      // what we did get (such as a 4xx response) without ever transmitting the request body.\n      if (\"100-continue\".equalsIgnoreCase(request.header(\"Expect\"))) {\n        // 请求刷新, okio处理\n        httpCodec.flushRequest();\n        realChain.eventListener().responseHeadersStart(realChain.call());\n        // 构建Response.Builder, 当response状态为100, 则返回null\n        responseBuilder = httpCodec.readResponseHeaders(true);\n      }\n\n      if (responseBuilder == null) {\n        // head成功响应的情况下\n        // Write the request body if the \"Expect: 100-continue\" expectation was met.\n        realChain.eventListener().requestBodyStart(realChain.call());\n        long contentLength = request.body().contentLength();\n        // 请求体的输出流\n        CountingSink requestBodyOut =\n            new CountingSink(httpCodec.createRequestBody(request, contentLength));\n        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);\n        // 发送请求体\n        request.body().writeTo(bufferedRequestBody);\n        bufferedRequestBody.close();\n        realChain.eventListener()\n            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);\n      } else if (!connection.isMultiplexed()) {\n        // HTTP/1请求协议, 而且初次握手失败\n        // If the \"Expect: 100-continue\" expectation wasn't met, prevent the HTTP/1 connection\n        // from being reused. Otherwise we're still obligated to transmit the request body to\n        // leave the connection in a consistent state.\n        // 禁止同主机请求新流的分配\n        streamAllocation.noNewStreams();\n      }\n    }\n\n    // flush\n    httpCodec.finishRequest();\n    // 如果是GET请求, 或者需要'100- continue'握手成功的情况下\n    if (responseBuilder == null) {\n      realChain.eventListener().responseHeadersStart(realChain.call());\n      // 构建responseBuilder\n      responseBuilder = httpCodec.readResponseHeaders(false);\n    }\n    // 获取响应\n    Response response = responseBuilder\n        // 原请求\n        .request(request)\n        // 握手情况\n        .handshake(streamAllocation.connection().handshake())\n        // 请求时间\n        .sentRequestAtMillis(sentRequestMillis)\n        // 响应时间\n        .receivedResponseAtMillis(System.currentTimeMillis())\n        .build();\n\n    int code = response.code();\n    if (code == 100) {\n      // server sent a 100-continue even though we did not request one.\n      // try again to read the actual response\n      // 即使我们没有请求, 服务端也会发送一个100-continue\n      // 重新读取真正的响应\n      responseBuilder = httpCodec.readResponseHeaders(false);\n      // 构建response\n      response = responseBuilder\n              .request(request)\n              .handshake(streamAllocation.connection().handshake())\n              .sentRequestAtMillis(sentRequestMillis)\n              .receivedResponseAtMillis(System.currentTimeMillis())\n              .build();\n\n      code = response.code();\n    }\n\n    realChain.eventListener()\n            .responseHeadersEnd(realChain.call(), response);\n\n    if (forWebSocket && code == 101) {\n      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.\n      // 我们需要确保不会反悔一个空的响应体\n      response = response.newBuilder()\n          .body(Util.EMPTY_RESPONSE)\n          .build();\n    } else {\n      response = response.newBuilder()\n          .body(httpCodec.openResponseBody(response))\n          .build();\n    }\n\n    // 如果请求关闭连接, 则关闭\n    if (\"close\".equalsIgnoreCase(response.request().header(\"Connection\"))\n        || \"close\".equalsIgnoreCase(response.header(\"Connection\"))) {\n      streamAllocation.noNewStreams();\n    }\n    // 抛出协议异常\n    // 204: No Content\n    // 205: Reset Content\n    if ((code == 204 || code == 205) && response.body().contentLength() > 0) {\n      throw new ProtocolException(\n          \"HTTP \" + code + \" had non-zero Content-Length: \" + response.body().contentLength());\n    }\n\n    return response;\n  }\n```\n### 请求\n我们来一步步看下代码\n``` java\nRealInterceptorChain realChain = (RealInterceptorChain) chain;\n    // 在 ConnectInterceptor创建\n    HttpCodec httpCodec = realChain.httpStream();\n    // 在 RetryAndFollowUpInterceptor创建\n    StreamAllocation streamAllocation = realChain.streamAllocation();\n    // 在 ConnectInterceptor获取\n    RealConnection connection = (RealConnection) realChain.connection();\n    Request request = realChain.request();\n```\n在`CallServerInterceptor`在, 核心工具类就是`HttpCodec`, 他的初始化我们在上篇[ConnectInterceptor解析](https://xiaozhuanlan.com/topic/5208976413)中可以看到.这里的步骤其实就是工具的准备.\n``` java\nhttpCodec.writeRequestHeaders(request);\n```\n我们以HTTP/1.1协议来看, 那么具体要看`Http1Codec`中的实现\n``` java\n@Override public void writeRequestHeaders(Request request) throws IOException {\n    // requestLine 就是我们请求报文内容的首行, 譬如 \"GET / HTTP/1.1\"\n    String requestLine = RequestLine.get(\n        request, streamAllocation.connection().route().proxy().type());\n    writeRequest(request.headers(), requestLine);\n  }\n\n  final BufferedSink sink;\n  public void writeRequest(Headers headers, String requestLine) throws IOException {\n    if (state != STATE_IDLE) throw new IllegalStateException(\"state: \" + state);\n    sink.writeUtf8(requestLine).writeUtf8(\"\\r\\n\");\n    for (int i = 0, size = headers.size(); i < size; i++) {\n      sink.writeUtf8(headers.name(i))\n          .writeUtf8(\": \")\n          .writeUtf8(headers.value(i))\n          .writeUtf8(\"\\r\\n\");\n    }\n    sink.writeUtf8(\"\\r\\n\");\n    state = STATE_OPEN_REQUEST_BODY;\n  }\n```\n可以看到在`writeRequest`中的方法, 就是针对`BufferedSink`对象的写操作, 在上篇`ConnectInterceptor`中进行三次握手连接的时候, 会进行初始化的工作, 我们会发现他是针对`Socket`的包装, 可以看做是`Socket`的输出流, 所以这里相当于是`Socket`的写入动作, 可以看出来, 这里会请求发送`header`.\n``` java\nif (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {\n      if (\"100-continue\".equalsIgnoreCase(request.header(\"Expect\"))) {\n        // 请求刷新, okio处理\n        httpCodec.flushRequest();\n        realChain.eventListener().responseHeadersStart(realChain.call());\n        // 构建Response.Builder, 当response状态为100, 则返回null\n        responseBuilder = httpCodec.readResponseHeaders(true);\n      }\n\n      if (responseBuilder == null) {\n        // head成功响应的情况下\n        // Write the request body if the \"Expect: 100-continue\" expectation was met.\n        realChain.eventListener().requestBodyStart(realChain.call());\n        long contentLength = request.body().contentLength();\n        // 请求体的输出流\n        CountingSink requestBodyOut =\n            new CountingSink(httpCodec.createRequestBody(request, contentLength));\n        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);\n        // 发送请求体\n        request.body().writeTo(bufferedRequestBody);\n        bufferedRequestBody.close();\n        realChain.eventListener()\n            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);\n      } else if (!connection.isMultiplexed()) {\n        // HTTP/1请求协议, 而且初次握手失败\n        // 禁止同主机请求新流的分配\n        streamAllocation.noNewStreams();\n      }\n    }\n```\n当请求首部字段包含`Expect:100-continue`, 一般在请求上传大容量body或者是需要验证的时候, 这样避免大文件传送失败带来的带宽浪费。所以需要判断请求体不为空的情况下, 并且请求首部包含该字段的情况下, 刷新请求, 构建`responseBuilder`对象, 如果这个时候服务端响应成功, 则`responseBuilder`对象为null, 并进行body的请求;而如果第一次请求头响应失败的情况下, 那么如果是HTTP/1的请求协议下, 就会禁止同host的请求新流的分配.\n### 响应\n以上就是请求的过程, 然后看响应\n``` java\n// 如果是GET请求, 或者需要'100- continue'握手成功的情况下\n    if (responseBuilder == null) {\n      // 构建responseBuilder\n      responseBuilder = httpCodec.readResponseHeaders(false);\n    }\n    // 获取响应\n    Response response = responseBuilder\n        // 原请求\n        .request(request)\n        // 握手情况\n        .handshake(streamAllocation.connection().handshake())\n        // 请求时间\n        .sentRequestAtMillis(sentRequestMillis)\n        // 响应时间\n        .receivedResponseAtMillis(System.currentTimeMillis())\n        .build();\n```\n在请求成功的情况下, 会重新构建`responseBuilder`对象, 通过它来构建响应报文.\n``` java\nint code = response.code();\n    if (code == 100) {\n      // 即使我们没有请求, 服务端也会发送一个100-continue\n      // 重新读取真正的响应\n      responseBuilder = httpCodec.readResponseHeaders(false);\n      // 构建response\n      response = responseBuilder\n              .request(request)\n              .handshake(streamAllocation.connection().handshake())\n              .sentRequestAtMillis(sentRequestMillis)\n              .receivedResponseAtMillis(System.currentTimeMillis())\n              .build();\n\n      code = response.code();\n    }\n```\n如果客户端响应`100`状态码, 这个时候, 我们就需要重新读取获取真正的内容响应.\n\n剩下的代码就是一些异常的处理, 这里就不做分析了.\n","slug":"OkHttp源码解析(三)-CallServerInterceptor","published":1,"updated":"2018-08-29T12:36:46.418Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlf4kn3900001js6vxsupu66","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本篇主要看下<code>CallServerInterceptor</code>, 关于他在整个请求中起到的作用, okHttp已经告诉我们, 可以看出它作为责任链中的最后一个环节, 承担了对服务端进行请求的工作.</p>\n<blockquote>\n<p>This is the last interceptor in the chain. It makes a network call to the server.<br><a id=\"more\"></a></p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p><code>okHttp</code>对于对服务钱的请求与相应, 底层都是通过<code>okio</code>对<code>socket</code>进行操作.<br>老样子, 我们直接上代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class=\"line\">    <span class=\"comment\">// 在 ConnectInterceptor创建</span></span><br><span class=\"line\">    HttpCodec httpCodec = realChain.httpStream();</span><br><span class=\"line\">    <span class=\"comment\">// 在 RetryAndFollowUpInterceptor创建</span></span><br><span class=\"line\">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class=\"line\">    <span class=\"comment\">// 在 ConnectInterceptor获取</span></span><br><span class=\"line\">    RealConnection connection = (RealConnection) realChain.connection();</span><br><span class=\"line\">    Request request = realChain.request();</span><br><span class=\"line\">    <span class=\"comment\">// 发送请求时间戳为当前时间戳</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    realChain.eventListener().requestHeadersStart(realChain.call());</span><br><span class=\"line\">    <span class=\"comment\">// 发送请求头, 通过Okio</span></span><br><span class=\"line\">    httpCodec.writeRequestHeaders(request);</span><br><span class=\"line\">    realChain.eventListener().requestHeadersEnd(realChain.call(), request);</span><br><span class=\"line\"></span><br><span class=\"line\">    Response.Builder responseBuilder = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// GET or HEAD 不需要</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// If there's a \"Expect: 100-continue\" header on the request, wait for a \"HTTP/1.1 100</span></span><br><span class=\"line\">      <span class=\"comment\">// Continue\" response before transmitting the request body. If we don't get that, return</span></span><br><span class=\"line\">      <span class=\"comment\">// what we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"string\">\"100-continue\"</span>.equalsIgnoreCase(request.header(<span class=\"string\">\"Expect\"</span>))) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 请求刷新, okio处理</span></span><br><span class=\"line\">        httpCodec.flushRequest();</span><br><span class=\"line\">        realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class=\"line\">        <span class=\"comment\">// 构建Response.Builder, 当response状态为100, 则返回null</span></span><br><span class=\"line\">        responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (responseBuilder == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// head成功响应的情况下</span></span><br><span class=\"line\">        <span class=\"comment\">// Write the request body if the \"Expect: 100-continue\" expectation was met.</span></span><br><span class=\"line\">        realChain.eventListener().requestBodyStart(realChain.call());</span><br><span class=\"line\">        <span class=\"keyword\">long</span> contentLength = request.body().contentLength();</span><br><span class=\"line\">        <span class=\"comment\">// 请求体的输出流</span></span><br><span class=\"line\">        CountingSink requestBodyOut =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> CountingSink(httpCodec.createRequestBody(request, contentLength));</span><br><span class=\"line\">        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class=\"line\">        <span class=\"comment\">// 发送请求体</span></span><br><span class=\"line\">        request.body().writeTo(bufferedRequestBody);</span><br><span class=\"line\">        bufferedRequestBody.close();</span><br><span class=\"line\">        realChain.eventListener()</span><br><span class=\"line\">            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!connection.isMultiplexed()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// HTTP/1请求协议, 而且初次握手失败</span></span><br><span class=\"line\">        <span class=\"comment\">// If the \"Expect: 100-continue\" expectation wasn't met, prevent the HTTP/1 connection</span></span><br><span class=\"line\">        <span class=\"comment\">// from being reused. Otherwise we're still obligated to transmit the request body to</span></span><br><span class=\"line\">        <span class=\"comment\">// leave the connection in a consistent state.</span></span><br><span class=\"line\">        <span class=\"comment\">// 禁止同主机请求新流的分配</span></span><br><span class=\"line\">        streamAllocation.noNewStreams();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// flush</span></span><br><span class=\"line\">    httpCodec.finishRequest();</span><br><span class=\"line\">    <span class=\"comment\">// 如果是GET请求, 或者需要'100- continue'握手成功的情况下</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (responseBuilder == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class=\"line\">      <span class=\"comment\">// 构建responseBuilder</span></span><br><span class=\"line\">      responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 获取响应</span></span><br><span class=\"line\">    Response response = responseBuilder</span><br><span class=\"line\">        <span class=\"comment\">// 原请求</span></span><br><span class=\"line\">        .request(request)</span><br><span class=\"line\">        <span class=\"comment\">// 握手情况</span></span><br><span class=\"line\">        .handshake(streamAllocation.connection().handshake())</span><br><span class=\"line\">        <span class=\"comment\">// 请求时间</span></span><br><span class=\"line\">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class=\"line\">        <span class=\"comment\">// 响应时间</span></span><br><span class=\"line\">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> code = response.code();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (code == <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// server sent a 100-continue even though we did not request one.</span></span><br><span class=\"line\">      <span class=\"comment\">// try again to read the actual response</span></span><br><span class=\"line\">      <span class=\"comment\">// 即使我们没有请求, 服务端也会发送一个100-continue</span></span><br><span class=\"line\">      <span class=\"comment\">// 重新读取真正的响应</span></span><br><span class=\"line\">      responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 构建response</span></span><br><span class=\"line\">      response = responseBuilder</span><br><span class=\"line\">              .request(request)</span><br><span class=\"line\">              .handshake(streamAllocation.connection().handshake())</span><br><span class=\"line\">              .sentRequestAtMillis(sentRequestMillis)</span><br><span class=\"line\">              .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class=\"line\">              .build();</span><br><span class=\"line\"></span><br><span class=\"line\">      code = response.code();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    realChain.eventListener()</span><br><span class=\"line\">            .responseHeadersEnd(realChain.call(), response);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (forWebSocket &amp;&amp; code == <span class=\"number\">101</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class=\"line\">      <span class=\"comment\">// 我们需要确保不会反悔一个空的响应体</span></span><br><span class=\"line\">      response = response.newBuilder()</span><br><span class=\"line\">          .body(Util.EMPTY_RESPONSE)</span><br><span class=\"line\">          .build();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      response = response.newBuilder()</span><br><span class=\"line\">          .body(httpCodec.openResponseBody(response))</span><br><span class=\"line\">          .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果请求关闭连接, 则关闭</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">\"close\"</span>.equalsIgnoreCase(response.request().header(<span class=\"string\">\"Connection\"</span>))</span><br><span class=\"line\">        || <span class=\"string\">\"close\"</span>.equalsIgnoreCase(response.header(<span class=\"string\">\"Connection\"</span>))) &#123;</span><br><span class=\"line\">      streamAllocation.noNewStreams();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 抛出协议异常</span></span><br><span class=\"line\">    <span class=\"comment\">// 204: No Content</span></span><br><span class=\"line\">    <span class=\"comment\">// 205: Reset Content</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((code == <span class=\"number\">204</span> || code == <span class=\"number\">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ProtocolException(</span><br><span class=\"line\">          <span class=\"string\">\"HTTP \"</span> + code + <span class=\"string\">\" had non-zero Content-Length: \"</span> + response.body().contentLength());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h3><p>我们来一步步看下代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class=\"line\">    <span class=\"comment\">// 在 ConnectInterceptor创建</span></span><br><span class=\"line\">    HttpCodec httpCodec = realChain.httpStream();</span><br><span class=\"line\">    <span class=\"comment\">// 在 RetryAndFollowUpInterceptor创建</span></span><br><span class=\"line\">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class=\"line\">    <span class=\"comment\">// 在 ConnectInterceptor获取</span></span><br><span class=\"line\">    RealConnection connection = (RealConnection) realChain.connection();</span><br><span class=\"line\">    Request request = realChain.request();</span><br></pre></td></tr></table></figure></p>\n<p>在<code>CallServerInterceptor</code>在, 核心工具类就是<code>HttpCodec</code>, 他的初始化我们在上篇<a href=\"https://xiaozhuanlan.com/topic/5208976413\" target=\"_blank\" rel=\"noopener\">ConnectInterceptor解析</a>中可以看到.这里的步骤其实就是工具的准备.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">httpCodec.writeRequestHeaders(request);</span><br></pre></td></tr></table></figure></p>\n<p>我们以HTTP/1.1协议来看, 那么具体要看<code>Http1Codec</code>中的实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">writeRequestHeaders</span><span class=\"params\">(Request request)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// requestLine 就是我们请求报文内容的首行, 譬如 \"GET / HTTP/1.1\"</span></span><br><span class=\"line\">    String requestLine = RequestLine.get(</span><br><span class=\"line\">        request, streamAllocation.connection().route().proxy().type());</span><br><span class=\"line\">    writeRequest(request.headers(), requestLine);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">final</span> BufferedSink sink;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">writeRequest</span><span class=\"params\">(Headers headers, String requestLine)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state != STATE_IDLE) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"state: \"</span> + state);</span><br><span class=\"line\">    sink.writeUtf8(requestLine).writeUtf8(<span class=\"string\">\"\\r\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = headers.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">      sink.writeUtf8(headers.name(i))</span><br><span class=\"line\">          .writeUtf8(<span class=\"string\">\": \"</span>)</span><br><span class=\"line\">          .writeUtf8(headers.value(i))</span><br><span class=\"line\">          .writeUtf8(<span class=\"string\">\"\\r\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sink.writeUtf8(<span class=\"string\">\"\\r\\n\"</span>);</span><br><span class=\"line\">    state = STATE_OPEN_REQUEST_BODY;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到在<code>writeRequest</code>中的方法, 就是针对<code>BufferedSink</code>对象的写操作, 在上篇<code>ConnectInterceptor</code>中进行三次握手连接的时候, 会进行初始化的工作, 我们会发现他是针对<code>Socket</code>的包装, 可以看做是<code>Socket</code>的输出流, 所以这里相当于是<code>Socket</code>的写入动作, 可以看出来, 这里会请求发送<code>header</code>.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"string\">\"100-continue\"</span>.equalsIgnoreCase(request.header(<span class=\"string\">\"Expect\"</span>))) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 请求刷新, okio处理</span></span><br><span class=\"line\">        httpCodec.flushRequest();</span><br><span class=\"line\">        realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class=\"line\">        <span class=\"comment\">// 构建Response.Builder, 当response状态为100, 则返回null</span></span><br><span class=\"line\">        responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (responseBuilder == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// head成功响应的情况下</span></span><br><span class=\"line\">        <span class=\"comment\">// Write the request body if the \"Expect: 100-continue\" expectation was met.</span></span><br><span class=\"line\">        realChain.eventListener().requestBodyStart(realChain.call());</span><br><span class=\"line\">        <span class=\"keyword\">long</span> contentLength = request.body().contentLength();</span><br><span class=\"line\">        <span class=\"comment\">// 请求体的输出流</span></span><br><span class=\"line\">        CountingSink requestBodyOut =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> CountingSink(httpCodec.createRequestBody(request, contentLength));</span><br><span class=\"line\">        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class=\"line\">        <span class=\"comment\">// 发送请求体</span></span><br><span class=\"line\">        request.body().writeTo(bufferedRequestBody);</span><br><span class=\"line\">        bufferedRequestBody.close();</span><br><span class=\"line\">        realChain.eventListener()</span><br><span class=\"line\">            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!connection.isMultiplexed()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// HTTP/1请求协议, 而且初次握手失败</span></span><br><span class=\"line\">        <span class=\"comment\">// 禁止同主机请求新流的分配</span></span><br><span class=\"line\">        streamAllocation.noNewStreams();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>当请求首部字段包含<code>Expect:100-continue</code>, 一般在请求上传大容量body或者是需要验证的时候, 这样避免大文件传送失败带来的带宽浪费。所以需要判断请求体不为空的情况下, 并且请求首部包含该字段的情况下, 刷新请求, 构建<code>responseBuilder</code>对象, 如果这个时候服务端响应成功, 则<code>responseBuilder</code>对象为null, 并进行body的请求;而如果第一次请求头响应失败的情况下, 那么如果是HTTP/1的请求协议下, 就会禁止同host的请求新流的分配.</p>\n<h3 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h3><p>以上就是请求的过程, 然后看响应<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果是GET请求, 或者需要'100- continue'握手成功的情况下</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (responseBuilder == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 构建responseBuilder</span></span><br><span class=\"line\">      responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 获取响应</span></span><br><span class=\"line\">    Response response = responseBuilder</span><br><span class=\"line\">        <span class=\"comment\">// 原请求</span></span><br><span class=\"line\">        .request(request)</span><br><span class=\"line\">        <span class=\"comment\">// 握手情况</span></span><br><span class=\"line\">        .handshake(streamAllocation.connection().handshake())</span><br><span class=\"line\">        <span class=\"comment\">// 请求时间</span></span><br><span class=\"line\">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class=\"line\">        <span class=\"comment\">// 响应时间</span></span><br><span class=\"line\">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure></p>\n<p>在请求成功的情况下, 会重新构建<code>responseBuilder</code>对象, 通过它来构建响应报文.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> code = response.code();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (code == <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 即使我们没有请求, 服务端也会发送一个100-continue</span></span><br><span class=\"line\">      <span class=\"comment\">// 重新读取真正的响应</span></span><br><span class=\"line\">      responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 构建response</span></span><br><span class=\"line\">      response = responseBuilder</span><br><span class=\"line\">              .request(request)</span><br><span class=\"line\">              .handshake(streamAllocation.connection().handshake())</span><br><span class=\"line\">              .sentRequestAtMillis(sentRequestMillis)</span><br><span class=\"line\">              .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class=\"line\">              .build();</span><br><span class=\"line\"></span><br><span class=\"line\">      code = response.code();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果客户端响应<code>100</code>状态码, 这个时候, 我们就需要重新读取获取真正的内容响应.</p>\n<p>剩下的代码就是一些异常的处理, 这里就不做分析了.</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本篇主要看下<code>CallServerInterceptor</code>, 关于他在整个请求中起到的作用, okHttp已经告诉我们, 可以看出它作为责任链中的最后一个环节, 承担了对服务端进行请求的工作.</p>\n<blockquote>\n<p>This is the last interceptor in the chain. It makes a network call to the server.<br>","more":"</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p><code>okHttp</code>对于对服务钱的请求与相应, 底层都是通过<code>okio</code>对<code>socket</code>进行操作.<br>老样子, 我们直接上代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class=\"line\">    <span class=\"comment\">// 在 ConnectInterceptor创建</span></span><br><span class=\"line\">    HttpCodec httpCodec = realChain.httpStream();</span><br><span class=\"line\">    <span class=\"comment\">// 在 RetryAndFollowUpInterceptor创建</span></span><br><span class=\"line\">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class=\"line\">    <span class=\"comment\">// 在 ConnectInterceptor获取</span></span><br><span class=\"line\">    RealConnection connection = (RealConnection) realChain.connection();</span><br><span class=\"line\">    Request request = realChain.request();</span><br><span class=\"line\">    <span class=\"comment\">// 发送请求时间戳为当前时间戳</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    realChain.eventListener().requestHeadersStart(realChain.call());</span><br><span class=\"line\">    <span class=\"comment\">// 发送请求头, 通过Okio</span></span><br><span class=\"line\">    httpCodec.writeRequestHeaders(request);</span><br><span class=\"line\">    realChain.eventListener().requestHeadersEnd(realChain.call(), request);</span><br><span class=\"line\"></span><br><span class=\"line\">    Response.Builder responseBuilder = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// GET or HEAD 不需要</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// If there's a \"Expect: 100-continue\" header on the request, wait for a \"HTTP/1.1 100</span></span><br><span class=\"line\">      <span class=\"comment\">// Continue\" response before transmitting the request body. If we don't get that, return</span></span><br><span class=\"line\">      <span class=\"comment\">// what we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"string\">\"100-continue\"</span>.equalsIgnoreCase(request.header(<span class=\"string\">\"Expect\"</span>))) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 请求刷新, okio处理</span></span><br><span class=\"line\">        httpCodec.flushRequest();</span><br><span class=\"line\">        realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class=\"line\">        <span class=\"comment\">// 构建Response.Builder, 当response状态为100, 则返回null</span></span><br><span class=\"line\">        responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (responseBuilder == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// head成功响应的情况下</span></span><br><span class=\"line\">        <span class=\"comment\">// Write the request body if the \"Expect: 100-continue\" expectation was met.</span></span><br><span class=\"line\">        realChain.eventListener().requestBodyStart(realChain.call());</span><br><span class=\"line\">        <span class=\"keyword\">long</span> contentLength = request.body().contentLength();</span><br><span class=\"line\">        <span class=\"comment\">// 请求体的输出流</span></span><br><span class=\"line\">        CountingSink requestBodyOut =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> CountingSink(httpCodec.createRequestBody(request, contentLength));</span><br><span class=\"line\">        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class=\"line\">        <span class=\"comment\">// 发送请求体</span></span><br><span class=\"line\">        request.body().writeTo(bufferedRequestBody);</span><br><span class=\"line\">        bufferedRequestBody.close();</span><br><span class=\"line\">        realChain.eventListener()</span><br><span class=\"line\">            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!connection.isMultiplexed()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// HTTP/1请求协议, 而且初次握手失败</span></span><br><span class=\"line\">        <span class=\"comment\">// If the \"Expect: 100-continue\" expectation wasn't met, prevent the HTTP/1 connection</span></span><br><span class=\"line\">        <span class=\"comment\">// from being reused. Otherwise we're still obligated to transmit the request body to</span></span><br><span class=\"line\">        <span class=\"comment\">// leave the connection in a consistent state.</span></span><br><span class=\"line\">        <span class=\"comment\">// 禁止同主机请求新流的分配</span></span><br><span class=\"line\">        streamAllocation.noNewStreams();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// flush</span></span><br><span class=\"line\">    httpCodec.finishRequest();</span><br><span class=\"line\">    <span class=\"comment\">// 如果是GET请求, 或者需要'100- continue'握手成功的情况下</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (responseBuilder == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class=\"line\">      <span class=\"comment\">// 构建responseBuilder</span></span><br><span class=\"line\">      responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 获取响应</span></span><br><span class=\"line\">    Response response = responseBuilder</span><br><span class=\"line\">        <span class=\"comment\">// 原请求</span></span><br><span class=\"line\">        .request(request)</span><br><span class=\"line\">        <span class=\"comment\">// 握手情况</span></span><br><span class=\"line\">        .handshake(streamAllocation.connection().handshake())</span><br><span class=\"line\">        <span class=\"comment\">// 请求时间</span></span><br><span class=\"line\">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class=\"line\">        <span class=\"comment\">// 响应时间</span></span><br><span class=\"line\">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> code = response.code();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (code == <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// server sent a 100-continue even though we did not request one.</span></span><br><span class=\"line\">      <span class=\"comment\">// try again to read the actual response</span></span><br><span class=\"line\">      <span class=\"comment\">// 即使我们没有请求, 服务端也会发送一个100-continue</span></span><br><span class=\"line\">      <span class=\"comment\">// 重新读取真正的响应</span></span><br><span class=\"line\">      responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 构建response</span></span><br><span class=\"line\">      response = responseBuilder</span><br><span class=\"line\">              .request(request)</span><br><span class=\"line\">              .handshake(streamAllocation.connection().handshake())</span><br><span class=\"line\">              .sentRequestAtMillis(sentRequestMillis)</span><br><span class=\"line\">              .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class=\"line\">              .build();</span><br><span class=\"line\"></span><br><span class=\"line\">      code = response.code();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    realChain.eventListener()</span><br><span class=\"line\">            .responseHeadersEnd(realChain.call(), response);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (forWebSocket &amp;&amp; code == <span class=\"number\">101</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class=\"line\">      <span class=\"comment\">// 我们需要确保不会反悔一个空的响应体</span></span><br><span class=\"line\">      response = response.newBuilder()</span><br><span class=\"line\">          .body(Util.EMPTY_RESPONSE)</span><br><span class=\"line\">          .build();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      response = response.newBuilder()</span><br><span class=\"line\">          .body(httpCodec.openResponseBody(response))</span><br><span class=\"line\">          .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果请求关闭连接, 则关闭</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">\"close\"</span>.equalsIgnoreCase(response.request().header(<span class=\"string\">\"Connection\"</span>))</span><br><span class=\"line\">        || <span class=\"string\">\"close\"</span>.equalsIgnoreCase(response.header(<span class=\"string\">\"Connection\"</span>))) &#123;</span><br><span class=\"line\">      streamAllocation.noNewStreams();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 抛出协议异常</span></span><br><span class=\"line\">    <span class=\"comment\">// 204: No Content</span></span><br><span class=\"line\">    <span class=\"comment\">// 205: Reset Content</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((code == <span class=\"number\">204</span> || code == <span class=\"number\">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ProtocolException(</span><br><span class=\"line\">          <span class=\"string\">\"HTTP \"</span> + code + <span class=\"string\">\" had non-zero Content-Length: \"</span> + response.body().contentLength());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h3><p>我们来一步步看下代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class=\"line\">    <span class=\"comment\">// 在 ConnectInterceptor创建</span></span><br><span class=\"line\">    HttpCodec httpCodec = realChain.httpStream();</span><br><span class=\"line\">    <span class=\"comment\">// 在 RetryAndFollowUpInterceptor创建</span></span><br><span class=\"line\">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class=\"line\">    <span class=\"comment\">// 在 ConnectInterceptor获取</span></span><br><span class=\"line\">    RealConnection connection = (RealConnection) realChain.connection();</span><br><span class=\"line\">    Request request = realChain.request();</span><br></pre></td></tr></table></figure></p>\n<p>在<code>CallServerInterceptor</code>在, 核心工具类就是<code>HttpCodec</code>, 他的初始化我们在上篇<a href=\"https://xiaozhuanlan.com/topic/5208976413\" target=\"_blank\" rel=\"noopener\">ConnectInterceptor解析</a>中可以看到.这里的步骤其实就是工具的准备.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">httpCodec.writeRequestHeaders(request);</span><br></pre></td></tr></table></figure></p>\n<p>我们以HTTP/1.1协议来看, 那么具体要看<code>Http1Codec</code>中的实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">writeRequestHeaders</span><span class=\"params\">(Request request)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// requestLine 就是我们请求报文内容的首行, 譬如 \"GET / HTTP/1.1\"</span></span><br><span class=\"line\">    String requestLine = RequestLine.get(</span><br><span class=\"line\">        request, streamAllocation.connection().route().proxy().type());</span><br><span class=\"line\">    writeRequest(request.headers(), requestLine);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">final</span> BufferedSink sink;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">writeRequest</span><span class=\"params\">(Headers headers, String requestLine)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state != STATE_IDLE) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"state: \"</span> + state);</span><br><span class=\"line\">    sink.writeUtf8(requestLine).writeUtf8(<span class=\"string\">\"\\r\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = headers.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">      sink.writeUtf8(headers.name(i))</span><br><span class=\"line\">          .writeUtf8(<span class=\"string\">\": \"</span>)</span><br><span class=\"line\">          .writeUtf8(headers.value(i))</span><br><span class=\"line\">          .writeUtf8(<span class=\"string\">\"\\r\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sink.writeUtf8(<span class=\"string\">\"\\r\\n\"</span>);</span><br><span class=\"line\">    state = STATE_OPEN_REQUEST_BODY;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到在<code>writeRequest</code>中的方法, 就是针对<code>BufferedSink</code>对象的写操作, 在上篇<code>ConnectInterceptor</code>中进行三次握手连接的时候, 会进行初始化的工作, 我们会发现他是针对<code>Socket</code>的包装, 可以看做是<code>Socket</code>的输出流, 所以这里相当于是<code>Socket</code>的写入动作, 可以看出来, 这里会请求发送<code>header</code>.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"string\">\"100-continue\"</span>.equalsIgnoreCase(request.header(<span class=\"string\">\"Expect\"</span>))) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 请求刷新, okio处理</span></span><br><span class=\"line\">        httpCodec.flushRequest();</span><br><span class=\"line\">        realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class=\"line\">        <span class=\"comment\">// 构建Response.Builder, 当response状态为100, 则返回null</span></span><br><span class=\"line\">        responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (responseBuilder == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// head成功响应的情况下</span></span><br><span class=\"line\">        <span class=\"comment\">// Write the request body if the \"Expect: 100-continue\" expectation was met.</span></span><br><span class=\"line\">        realChain.eventListener().requestBodyStart(realChain.call());</span><br><span class=\"line\">        <span class=\"keyword\">long</span> contentLength = request.body().contentLength();</span><br><span class=\"line\">        <span class=\"comment\">// 请求体的输出流</span></span><br><span class=\"line\">        CountingSink requestBodyOut =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> CountingSink(httpCodec.createRequestBody(request, contentLength));</span><br><span class=\"line\">        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class=\"line\">        <span class=\"comment\">// 发送请求体</span></span><br><span class=\"line\">        request.body().writeTo(bufferedRequestBody);</span><br><span class=\"line\">        bufferedRequestBody.close();</span><br><span class=\"line\">        realChain.eventListener()</span><br><span class=\"line\">            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!connection.isMultiplexed()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// HTTP/1请求协议, 而且初次握手失败</span></span><br><span class=\"line\">        <span class=\"comment\">// 禁止同主机请求新流的分配</span></span><br><span class=\"line\">        streamAllocation.noNewStreams();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>当请求首部字段包含<code>Expect:100-continue</code>, 一般在请求上传大容量body或者是需要验证的时候, 这样避免大文件传送失败带来的带宽浪费。所以需要判断请求体不为空的情况下, 并且请求首部包含该字段的情况下, 刷新请求, 构建<code>responseBuilder</code>对象, 如果这个时候服务端响应成功, 则<code>responseBuilder</code>对象为null, 并进行body的请求;而如果第一次请求头响应失败的情况下, 那么如果是HTTP/1的请求协议下, 就会禁止同host的请求新流的分配.</p>\n<h3 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h3><p>以上就是请求的过程, 然后看响应<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果是GET请求, 或者需要'100- continue'握手成功的情况下</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (responseBuilder == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 构建responseBuilder</span></span><br><span class=\"line\">      responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 获取响应</span></span><br><span class=\"line\">    Response response = responseBuilder</span><br><span class=\"line\">        <span class=\"comment\">// 原请求</span></span><br><span class=\"line\">        .request(request)</span><br><span class=\"line\">        <span class=\"comment\">// 握手情况</span></span><br><span class=\"line\">        .handshake(streamAllocation.connection().handshake())</span><br><span class=\"line\">        <span class=\"comment\">// 请求时间</span></span><br><span class=\"line\">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class=\"line\">        <span class=\"comment\">// 响应时间</span></span><br><span class=\"line\">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure></p>\n<p>在请求成功的情况下, 会重新构建<code>responseBuilder</code>对象, 通过它来构建响应报文.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> code = response.code();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (code == <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 即使我们没有请求, 服务端也会发送一个100-continue</span></span><br><span class=\"line\">      <span class=\"comment\">// 重新读取真正的响应</span></span><br><span class=\"line\">      responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 构建response</span></span><br><span class=\"line\">      response = responseBuilder</span><br><span class=\"line\">              .request(request)</span><br><span class=\"line\">              .handshake(streamAllocation.connection().handshake())</span><br><span class=\"line\">              .sentRequestAtMillis(sentRequestMillis)</span><br><span class=\"line\">              .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class=\"line\">              .build();</span><br><span class=\"line\"></span><br><span class=\"line\">      code = response.code();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果客户端响应<code>100</code>状态码, 这个时候, 我们就需要重新读取获取真正的内容响应.</p>\n<p>剩下的代码就是一些异常的处理, 这里就不做分析了.</p>"}],"PostAsset":[{"_id":"source/_posts/基于as3.0 多aar打包发布/demopic.png","slug":"demopic.png","post":"cjld5agvi000acqs67zhlpq4j","modified":0,"renderable":0},{"_id":"source/_posts/记录一次Gradle的踩坑/Gradle执行时序.png","slug":"Gradle执行时序.png","post":"cjld5agvm000ecqs6ih6kwgb8","modified":0,"renderable":0},{"_id":"source/_posts/谈谈GC和引用/gc.png","slug":"gc.png","post":"cjld5agvr000fcqs6hxsdbyb3","modified":0,"renderable":0},{"_id":"source/_posts/HashMap源码解析1/put.jpg","slug":"put.jpg","post":"cjld5ah2r001dcqs62z151ef2","modified":0,"renderable":0},{"_id":"source/_posts/RxJava2源码解析1/rxjava实现原理.jpg","slug":"rxjava实现原理.jpg","post":"cjld5ah2x001icqs6ehyxk4sm","modified":0,"renderable":0},{"_id":"source/_posts/okHttp源码解析(一)/requestbuilder.png","slug":"requestbuilder.png","post":"cjld5ah33001pcqs6giprir9u","modified":0,"renderable":0},{"_id":"source/_posts/Glide源码解析1/decodeJob流程图.png","slug":"decodeJob流程图.png","post":"cjld5ah2n001bcqs61fceydo7","modified":0,"renderable":0},{"_id":"source/_posts/Glide源码解析1/glide_load时序图.png","slug":"glide_load时序图.png","post":"cjld5ah2n001bcqs61fceydo7","modified":0,"renderable":0},{"_id":"source/_posts/Kotlin零散二三点/Kotlin.png","slug":"Kotlin.png","post":"cjld5ah2u001ecqs64emaoazo","modified":0,"renderable":0},{"_id":"source/_posts/Kotlin零散二三点/let.png","slug":"let.png","post":"cjld5ah2u001ecqs64emaoazo","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjld5agvg0009cqs6rkgvfaj1","category_id":"cjld5agvb0004cqs6akdxw7zv","_id":"cjld5agvs000gcqs64lef43l4"},{"post_id":"cjld5agv10001cqs653z70aox","category_id":"cjld5agvb0004cqs6akdxw7zv","_id":"cjld5agvu000jcqs6joqg54r4"},{"post_id":"cjld5agvi000acqs67zhlpq4j","category_id":"cjld5agvb0004cqs6akdxw7zv","_id":"cjld5agvu000kcqs6v9ax6srz"},{"post_id":"cjld5agv70003cqs63issg43f","category_id":"cjld5agvj000bcqs6iiogr0xv","_id":"cjld5agvw000ncqs60hmr8yj2"},{"post_id":"cjld5agve0007cqs6o74enm3t","category_id":"cjld5agvb0004cqs6akdxw7zv","_id":"cjld5agvw000qcqs6r2z9suv5"},{"post_id":"cjld5agvm000ecqs6ih6kwgb8","category_id":"cjld5agvu000lcqs6o398exjd","_id":"cjld5agvx000tcqs6i6fv1h95"},{"post_id":"cjld5agvr000fcqs6hxsdbyb3","category_id":"cjld5agvx000scqs695xomylw","_id":"cjld5agvy000xcqs6ju25wzhy"},{"post_id":"cjld5ah2h001acqs6sxqrxsaz","category_id":"cjld5agvj000bcqs6iiogr0xv","_id":"cjld5ah2w001gcqs6yriv7rys"},{"post_id":"cjld5ah2r001dcqs62z151ef2","category_id":"cjld5agvj000bcqs6iiogr0xv","_id":"cjld5ah32001mcqs6o5uvieay"},{"post_id":"cjld5ah2x001icqs6ehyxk4sm","category_id":"cjld5agvj000bcqs6iiogr0xv","_id":"cjld5ah35001rcqs6xsydqhck"},{"post_id":"cjld5ah2n001bcqs61fceydo7","category_id":"cjld5agvb0004cqs6akdxw7zv","_id":"cjld5ah36001tcqs6omg0mzgu"},{"post_id":"cjld5ah2n001bcqs61fceydo7","category_id":"cjld5ah2v001fcqs6utybz8b4","_id":"cjld5ah36001wcqs6ievdp2kn"},{"post_id":"cjld5ah30001lcqs6d4jj48ah","category_id":"cjld5agvj000bcqs6iiogr0xv","_id":"cjld5ah37001ycqs64anmhyu4"},{"post_id":"cjld5ah33001pcqs6giprir9u","category_id":"cjld5agvj000bcqs6iiogr0xv","_id":"cjld5ah370021cqs6ts7fohlx"},{"post_id":"cjld5ah2u001ecqs64emaoazo","category_id":"cjld5ah33001ncqs6uyv5510g","_id":"cjld5ah380023cqs6nfp2v56t"},{"post_id":"cjld5ah47002bcqs6it11wyo1","category_id":"cjld5agvj000bcqs6iiogr0xv","_id":"cjld5ah4a002gcqs6xgub555t"},{"post_id":"cjld5ah48002ccqs6cocmnt6e","category_id":"cjld5agvj000bcqs6iiogr0xv","_id":"cjld5ah4b002icqs6ougxjieg"},{"post_id":"cjld5ah49002ecqs6ofbi28kc","category_id":"cjld5agvj000bcqs6iiogr0xv","_id":"cjld5ah4b002kcqs6vhbsm2i8"},{"post_id":"cjld5ah5q002ocqs6beoc3jit","category_id":"cjld5agvj000bcqs6iiogr0xv","_id":"cjld5ah5v002rcqs69j61d43w"},{"post_id":"cjlf4kn3900001js6vxsupu66","category_id":"cjld5agvj000bcqs6iiogr0xv","_id":"cjlf4kn3h00031js61wwd9vtx"}],"PostTag":[{"post_id":"cjld5agv10001cqs653z70aox","tag_id":"cjld5agvd0005cqs6sl7d6u0v","_id":"cjld5agvm000dcqs6ip3wdknt"},{"post_id":"cjld5agv70003cqs63issg43f","tag_id":"cjld5agvd0005cqs6sl7d6u0v","_id":"cjld5agvw000ocqs6o4h79yz3"},{"post_id":"cjld5agv70003cqs63issg43f","tag_id":"cjld5agvt000hcqs6j46cysj0","_id":"cjld5agvw000pcqs6ytgvg5ss"},{"post_id":"cjld5agve0007cqs6o74enm3t","tag_id":"cjld5agvd0005cqs6sl7d6u0v","_id":"cjld5agvx000vcqs6ioj6m1oh"},{"post_id":"cjld5agve0007cqs6o74enm3t","tag_id":"cjld5agvx000rcqs68s6znd4u","_id":"cjld5agvy000wcqs6dhbyxyse"},{"post_id":"cjld5agvg0009cqs6rkgvfaj1","tag_id":"cjld5agvx000ucqs6hfrpe6ri","_id":"cjld5agvy000zcqs6vfxqbupu"},{"post_id":"cjld5agvg0009cqs6rkgvfaj1","tag_id":"cjld5agvd0005cqs6sl7d6u0v","_id":"cjld5agvy0010cqs61xdwxicf"},{"post_id":"cjld5agvi000acqs67zhlpq4j","tag_id":"cjld5agvd0005cqs6sl7d6u0v","_id":"cjld5agvz0012cqs62at6m07a"},{"post_id":"cjld5agvi000acqs67zhlpq4j","tag_id":"cjld5agvy000ycqs697dmnqiu","_id":"cjld5agvz0013cqs65gvzqy7j"},{"post_id":"cjld5agvm000ecqs6ih6kwgb8","tag_id":"cjld5agvd0005cqs6sl7d6u0v","_id":"cjld5agvz0015cqs6imij4l0u"},{"post_id":"cjld5agvm000ecqs6ih6kwgb8","tag_id":"cjld5agvy000ycqs697dmnqiu","_id":"cjld5agw00016cqs6js8c641t"},{"post_id":"cjld5agvr000fcqs6hxsdbyb3","tag_id":"cjld5agvz0014cqs6jxx543sn","_id":"cjld5agw00018cqs68lq6eihd"},{"post_id":"cjld5agvr000fcqs6hxsdbyb3","tag_id":"cjld5agw00017cqs6tof30g1y","_id":"cjld5agw00019cqs64p2afbf4"},{"post_id":"cjld5ah2r001dcqs62z151ef2","tag_id":"cjld5agvt000hcqs6j46cysj0","_id":"cjld5ah2x001hcqs6z6zacy7e"},{"post_id":"cjld5ah2h001acqs6sxqrxsaz","tag_id":"cjld5ah2q001ccqs6ic77wxr1","_id":"cjld5ah30001kcqs64ey8a0t2"},{"post_id":"cjld5ah2h001acqs6sxqrxsaz","tag_id":"cjld5agvt000hcqs6j46cysj0","_id":"cjld5ah33001ocqs6tw96yfbo"},{"post_id":"cjld5ah2n001bcqs61fceydo7","tag_id":"cjld5agvd0005cqs6sl7d6u0v","_id":"cjld5ah35001scqs6opsspbnw"},{"post_id":"cjld5ah2n001bcqs61fceydo7","tag_id":"cjld5ah2y001jcqs6eagfhqvx","_id":"cjld5ah36001ucqs6hh6ylsma"},{"post_id":"cjld5ah2n001bcqs61fceydo7","tag_id":"cjld5agvt000hcqs6j46cysj0","_id":"cjld5ah36001xcqs64kvvvqy9"},{"post_id":"cjld5ah2u001ecqs64emaoazo","tag_id":"cjld5agvd0005cqs6sl7d6u0v","_id":"cjld5ah37001zcqs6qlgo6rnm"},{"post_id":"cjld5ah2u001ecqs64emaoazo","tag_id":"cjld5ah34001qcqs69e25dghx","_id":"cjld5ah370022cqs6u3j20ms1"},{"post_id":"cjld5ah2x001icqs6ehyxk4sm","tag_id":"cjld5agvt000hcqs6j46cysj0","_id":"cjld5ah380024cqs67lpdqnx7"},{"post_id":"cjld5ah2x001icqs6ehyxk4sm","tag_id":"cjld5ah36001vcqs6zmy0rclq","_id":"cjld5ah380026cqs6459xa9ex"},{"post_id":"cjld5ah30001lcqs6d4jj48ah","tag_id":"cjld5agvt000hcqs6j46cysj0","_id":"cjld5ah390027cqs6ym29fiie"},{"post_id":"cjld5ah30001lcqs6d4jj48ah","tag_id":"cjld5ah370020cqs62knrq83b","_id":"cjld5ah390028cqs6ksi6jce9"},{"post_id":"cjld5ah33001pcqs6giprir9u","tag_id":"cjld5agvt000hcqs6j46cysj0","_id":"cjld5ah390029cqs6cwr1yl4w"},{"post_id":"cjld5ah33001pcqs6giprir9u","tag_id":"cjld5ah380025cqs6xb11usrh","_id":"cjld5ah3a002acqs6rnjqg6s3"},{"post_id":"cjld5ah48002ccqs6cocmnt6e","tag_id":"cjld5agvd0005cqs6sl7d6u0v","_id":"cjld5ah4a002fcqs6ul6ij43c"},{"post_id":"cjld5ah48002ccqs6cocmnt6e","tag_id":"cjld5agvt000hcqs6j46cysj0","_id":"cjld5ah4b002hcqs6yhmonohu"},{"post_id":"cjld5ah49002ecqs6ofbi28kc","tag_id":"cjld5agvt000hcqs6j46cysj0","_id":"cjld5ah4b002jcqs6vr3c5y4t"},{"post_id":"cjld5ah49002ecqs6ofbi28kc","tag_id":"cjld5ah380025cqs6xb11usrh","_id":"cjld5ah4b002lcqs67f5po37b"},{"post_id":"cjld5ah47002bcqs6it11wyo1","tag_id":"cjld5ah49002dcqs63ny5i8sj","_id":"cjld5ah4b002mcqs6t3p3pnrw"},{"post_id":"cjld5ah47002bcqs6it11wyo1","tag_id":"cjld5agvt000hcqs6j46cysj0","_id":"cjld5ah4c002ncqs6ve7jp353"},{"post_id":"cjld5ah5q002ocqs6beoc3jit","tag_id":"cjld5ah49002dcqs63ny5i8sj","_id":"cjld5ah5u002pcqs6kchwc89l"},{"post_id":"cjld5ah5q002ocqs6beoc3jit","tag_id":"cjld5agvt000hcqs6j46cysj0","_id":"cjld5ah5v002qcqs65fh6p98s"},{"post_id":"cjlf4kn3900001js6vxsupu66","tag_id":"cjld5agvt000hcqs6j46cysj0","_id":"cjlf4kn3g00011js65l52ctro"},{"post_id":"cjlf4kn3900001js6vxsupu66","tag_id":"cjld5ah380025cqs6xb11usrh","_id":"cjlf4kn3h00021js6ib1yh1hm"}],"Tag":[{"name":"android","_id":"cjld5agvd0005cqs6sl7d6u0v"},{"name":"源码解析","_id":"cjld5agvt000hcqs6j46cysj0"},{"name":"ObjectBox","_id":"cjld5agvx000rcqs68s6znd4u"},{"name":"APT","_id":"cjld5agvx000ucqs6hfrpe6ri"},{"name":"gradle","_id":"cjld5agvy000ycqs697dmnqiu"},{"name":"java","_id":"cjld5agvz0014cqs6jxx543sn"},{"name":"JVM","_id":"cjld5agw00017cqs6tof30g1y"},{"name":"Java","_id":"cjld5ah2q001ccqs6ic77wxr1"},{"name":"Glide","_id":"cjld5ah2y001jcqs6eagfhqvx"},{"name":"kotlin","_id":"cjld5ah34001qcqs69e25dghx"},{"name":"RxJava2","_id":"cjld5ah36001vcqs6zmy0rclq"},{"name":"rxJava2","_id":"cjld5ah370020cqs62knrq83b"},{"name":"okHttp3","_id":"cjld5ah380025cqs6xb11usrh"},{"name":"Android","_id":"cjld5ah49002dcqs63ny5i8sj"}]}}