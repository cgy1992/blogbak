<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天晴日无风</title>
  <icon>https://www.gravatar.com/avatar/144ec7bcaa2bae2d1ca43be11798b242</icon>
  <subtitle>燃烧了一颗恒星来相见</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="//litten.me/"/>
  <updated>2017-12-19T08:51:52.727Z</updated>
  <id>//litten.me/</id>
  
  <author>
    <name>天晴日无风</name>
    <email>yutiantina@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用gradle多aar发布私有maven</title>
    <link href="//litten.me/2017/12/19/%E5%9F%BA%E4%BA%8Eas3.0%20%E5%A4%9Aaar%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83/"/>
    <id>//litten.me/2017/12/19/基于as3.0 多aar打包发布/</id>
    <published>2017-12-19T02:53:00.065Z</published>
    <updated>2017-12-19T08:51:52.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了精简目前底层的基础组件库, 拆分出必要依赖项目(有一定精简)和完全的依赖项目,<br>第一想法是在library上构建变种(Variant)版本, 一次发布所有的变种,在研究了一些相关的资料后,<br>最后完美解决<br><a id="more"></a></p><h2 id="基础部署到maven仓库"><a href="#基础部署到maven仓库" class="headerlink" title="基础部署到maven仓库"></a>基础部署到maven仓库</h2><p>我们可以通过gradle部署到远程或者本地的maven仓库,<br>首先添加maven插件, 然后我们通过updaloadArchives任务自动生成POM文件, 并打包部署到指定的仓库中</p><pre><code>  apply plugin: &#39;maven&#39;  // 添加maven插件  uploadArchives {    repositories {        mavenDeployer {            repository(url: &quot;maven仓库地址&quot;)            }        }    }</code></pre><p>当然我们也可以通过authentication来添加服务器的认证信息, 也可以定义快照(snapshot)仓库</p><pre><code>apply plugin: &#39;maven&#39;  // 添加maven插件uploadArchives {  repositories {      mavenDeployer {          repository(url: &quot;maven仓库地址&quot;){              authentication(userName: &quot;yourUserName&quot;, password: &quot;yourPsw&quot;)              }          snapshotRepository(url: &quot;maven snapshot仓库地址&quot;){              authentication(userName: &quot;yourUserName&quot;, password: &quot;yourPsw&quot;)          }      }  }</code></pre><h2 id="POM文件的自定义"><a href="#POM文件的自定义" class="headerlink" title="POM文件的自定义"></a>POM文件的自定义</h2><p>我们可以针对POM做自定义处理, 最常见的就是设置版本号等等</p><pre><code>apply plugin: &#39;maven&#39;  // 添加maven插件uploadArchives {  repositories {      mavenDeployer {          repository(url: &quot;maven仓库地址&quot;)          }          pom.groupId = &quot;com.maven.test&quot;          pom.artifactId = &quot;myLibrary&quot;          pom.version = &quot;1.0.0&quot;          pom.packaging = &quot;aar&quot;      }  }</code></pre><p>针对上面的设置, 我们依赖引用的就应该是</p><pre><code>implementation &quot;com.maven.test:myLibrary:1.0.0&quot;</code></pre><p>Maven默认每个项目只会处理一个artifact, 当我们library没有设置productFlavor和buildType时, 默认上传的是release的variant.<br>当我们两个variant代码不同, 依赖不同时, 需要生产不同的POM进行上传,这种情况下我们需要显示声明每个artifact, 并针对每个POM进行自定义上传.<br>在这方面我们可以分别参考<a href="https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/maven/MavenDeployer.html" target="_blank" rel="noopener">MavenDeployer</a>和<a href="https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/maven/MavenPom.html" target="_blank" rel="noopener">MavenPom</a>开放的API</p><pre><code>// 上略mavenDeployer {            repository(url: &quot;仓库地址&quot;)            android.libraryVariants.all {variant-&gt;                def isFlavor = !variant.flavorName.isEmpty()                def _name = &quot;${variant.name}&quot;                // 生成多个pom                addFilter(_name){artifact, file-&gt;                    true                }                // 对应pom属性设置                pom(_name).artifactId = project.archivesBaseName + &quot;-&quot; + _name                pom(_name).version = &quot;1.0.0&quot;                pom(_name).groupId = &quot;com.maven.test&quot;                pom(_name).packaging = &#39;aar&#39;                // 自定义pom的依赖集                pom(_name).withXml{                    def root = asNode()                    def depsNode = root[&quot;dependencies&quot;][0] ?: root.appendNode(&quot;dependencies&quot;)                    def addDep = {                        if (it.group == null) return // Avoid empty dependency nodes                        def dependencyNode = depsNode.appendNode(&#39;dependency&#39;)                        dependencyNode.appendNode(&#39;groupId&#39;, it.group)                        dependencyNode.appendNode(&#39;artifactId&#39;, it.name)                        dependencyNode.appendNode(&#39;version&#39;, it.version)                        if (it.hasProperty(&#39;optional&#39;) &amp;&amp; it.optional) {                            dependencyNode.appendNode(&#39;optional&#39;, &#39;true&#39;)                        }                    }                    // 添加基本依赖                    configurations.api.allDependencies.each addDep                    configurations.implementation.allDependencies.each addDep                    // 添加特殊依赖                    if (isFlavor) {                        configurations[&quot;${_name}Implementation&quot;].allDependencies.each addDep                        def flavorName = variant.flavorName                        configurations[&quot;${flavorName}Implementation&quot;].allDependencies.each addDep                        configurations[&quot;${_name}Api&quot;].allDependencies.each addDep                        configurations[&quot;${flavorName}Api&quot;].allDependencies.each addDep                    }                }            }        }</code></pre><p>相关demo可以看<a href="https://github.com/YuTianTina/ForMultiUploadMaven" target="_blank" rel="noopener">这里</a></p><h2 id="依赖对应的组件库"><a href="#依赖对应的组件库" class="headerlink" title="依赖对应的组件库"></a>依赖对应的组件库</h2><p>在成功发布后, 我们仓库内容应该如下图<br><img src="https://github.com/YuTianTina/ForMultiUploadMaven/blob/master/demopic.png" alt="pic"><br>假设我们的flavor分别为full和simple,当我们去依赖的时候, 就可以通过</p><pre><code>releaseImplementation &quot;com.maven.test:libraryNameFullRelease:1.0.0&quot;debugImplementation &quot;com.maven.test:libraryNameFullDebug:1.0.0&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;为了精简目前底层的基础组件库, 拆分出必要依赖项目(有一定精简)和完全的依赖项目,&lt;br&gt;第一想法是在library上构建变种(Variant)版本, 一次发布所有的变种,在研究了一些相关的资料后,&lt;br&gt;最后完美解决&lt;br&gt;
    
    </summary>
    
    
      <category term="android" scheme="//litten.me/tags/android/"/>
    
      <category term="gradle" scheme="//litten.me/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>ObjectBox-Java (android)使用手册</title>
    <link href="//litten.me/2017/12/19/ObjectBox%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>//litten.me/2017/12/19/ObjectBox使用说明/</id>
    <published>2017-12-19T02:53:00.059Z</published>
    <updated>2017-12-19T08:51:48.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前前言"><a href="#前前言" class="headerlink" title="前前言"></a>前前言</h2><p>本篇主要是方便自己记忆所写, 基本是撸完官方文档后的笔记</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ObjectBox是一款由greenrobot出的基于noSql的ORM数据库, 但又支持表关系的定义以及事务的处理, 另外在性能上有着非常卓越的表现<br>(关于性能比较, 可以看<a href="1">这篇</a>),<br>同时可以接入rxJava的扩展库, 并与google最新出的框架组件(Android Architecture Components)中的LiveData结合使用, 支持Kotlin.<br>目前版本更新到1.2.1<br><a id="more"></a></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ol><li>在项目根目录的gradle添加它的依赖仓库地址<pre><code class="groovy">buildscript { ext.objectboxVersion = &#39;1.2.1&#39; repositories {     jcenter()     maven { url &quot;http://objectbox.net/beta-repo/&quot; } } dependencies {     classpath &#39;com.android.tools.build:gradle:2.3.3&#39;     classpath &quot;io.objectbox:objectbox-gradle-plugin:$objectboxVersion&quot; }}allprojects { repositories {     jcenter()     maven { url &quot;http://objectbox.net/beta-repo/&quot; } }}</code></pre></li><li>在应用项目模块(app module)中添加插件<pre><code class="groovy">apply plugin: &#39;com.android.application&#39;apply plugin: &#39;io.objectbox&#39;</code></pre></li></ol><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol><li>准备<code>ObjectBox</code>对象单例并实例化, 可以放在application的<code>onCreate()</code>中<pre><code class="java">// MyObjectBox类文件这时候是引用不到, 它是根据实体类自动生成(build), 用来设置BoxStore对象boxStore = MyObjectBox.builder().androidContext(applicationContext).build();</code></pre></li><li><p>添加一个对象类, 添加<code>@Entity</code>注解, 进行表映射</p><pre><code class="java">@Entitypublic class User{ // 主键, 必须有, 并且必须是long类型 @Id private long id; private String userName; private int userAge; // 必须有 public User(){}}</code></pre><p>P.S 这时候记得build一下, MyObjectBox就自动生成了</p></li><li>这时候我们就可以通过<code>Box&lt;User&gt;</code>对象来针对这张表做增删改查工作了<pre><code class="java">Box&lt;User&gt; userBox = boxStore.boxFor(User.class).build();</code></pre></li></ol><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><p><code>Box</code>分别有<code>put</code> 添加or修改, <code>query</code> 查找, <code>remove</code> 移除 等开放API可调用.<br>在调用<code>put</code>时, 当Entity的Id不设置, 则会自动为其赋值, 并新增数据. 当有设置Id, 并在表内有对应Id, 则会被覆盖, 相当于更新对应数据.<br>另外关于<code>@Id</code>,有几点需要注意:</p><ul><li><code>0</code>和<code>-1(0xFFFFFFFFFFFFFFFF)</code>不能作为Id的值使用</li><li><code>0</code> 或者<code>null</code>(如果类型是Long, 但不建议使用Long, 使用long的速度会更快)会是通知永远新增一笔新数据</li><li>如果<code>put</code>一个id比当前最大id大的对象, ObjectBox可能会抛出异常</li><li>如果要自己分配id, 可以使用注解<code>@Id(assignable = true)</code></li></ul><p>相关的方法, 可以参考<a href="2">JavaDoc</a>中关于<code>Box</code>和<code>QueryBuilder</code>类中的方法</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>除了本文其他地方已提到的注解, 补充几个比较大概率会用到的, 其他的建议大家可以看看<a href="http://objectbox.io/files/objectbox-java/current/" target="_blank" rel="noopener">JavaDoc</a>中的<code>io.objectbox.annotation</code>包:</p><pre><code class="java">@Entitypublic class User{    @Id    private long id;    @Index    private String uid;    @NameInDb(&quot;userName&quot;)    private String name;    @Transient    private boolean country;}</code></pre><ul><li><code>@Index</code>: 因为在ObjectBox中主键是必须设置为long类型的id, 当我们业务上需要另外主键时, 可以再标注<code>@Index</code>, 在ObjectBox中查询时根据他标注的字段来查询, 会加快查询速度</li><li><code>@NameInDb</code>: 字段在数据库中的命名</li><li><code>@Transient</code>: 忽略字段, 不在表中生成</li></ul><h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><p>ObjectBox可以实现大部分的数据迁移自动化, 当我们要删除或者新增一个字段的时候, 针对数据库我们是不需要做任何操作的.</p><p>但是当我们需要重命名字段名或者表名, 或者需要更改字段类型时, 我们需要使用<code>@Uid</code>通知ObjectBox</p><p>下面我们会分别举两个例子:</p><ol><li><p>重命名操作, 实体类重命名或者字段重命名操作流程都一样, 区别只在于是在在哪里放<code>@Uid</code>, 以实体类重命名为例:</p><ul><li><p>在类名上添加<code>@Uid</code></p><pre><code class="java">@Entity@Uidpublic class User{ @Id private long id; private String userName; private int userAge; public User(){}}</code></pre></li><li><code>rebuild</code>一下, 在<code>Gradle Console</code>中会找到下面类似一段<pre><code>错误: [ObjectBox] UID operations for entity &quot;User2&quot;:[Rename] apply the current UID using @Uid(6966387148602341622L) - [Change/reset] apply a new UID using @Uid(2383770126231565339L)1 个错误</code></pre></li><li><p>copy <code>[Rename]</code>的<code>@Uid</code>值6966387148602341622L, 并针对实体类进行重命名</p><pre><code class="java">@Entity@Uid(6966387148602341622L)public class User2{ @Id private long id; private String userName; private int userAge; public User2(){}}</code></pre></li><li>重新编译, 就已经迁移成功, 这时候<code>@Uid(6966387148602341622L)</code>这条代码就没有用了, 相关记录会在<code>objectbox-models/default.json</code>中体现</li></ul></li><li><p>变更字段类型, 要注意的是, 会导致原类型字段Column的数据会被清空, 大体流程与重命名流程大致相同, 但是赋值的<code>@Uid</code> 需要使用的是<code>[Change/reset]</code>的值, 表示是一个<code>新字段</code>.</p></li></ol><p>P.S 前文提到了<code>objectbox-models/default.json</code>这个JSON文件, 这个文件相当于是我们做Migration时处理的文件记录, 所以是需要加入VCS控制</p><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><ul><li>以后补充</li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>ObjectBox的所有操作都是在事务中运行的, 只是这个对我们来说是透明的, 我们不需要关注, 但是当我们需要进行多个操作的时候, 通过显示事务来控制, 可以大大提高app的效率和一致性.<br>在<code>BoxStore</code>中, 提供了四个方法来执行显示事务:</p><ul><li><code>runInReadTx</code> : 在事务中运行给定的Runnable, 不可并发处理</li><li><code>runIxTx</code> : 只读事务, 可以并发处理</li><li><code>runInTxAsync</code> : 在单独的线程中运行, 事务完成后会回调callback(可能为空)</li><li><code>callInTx</code> : 和<code>runIxTx</code>类似, 不过允许返回值并可以抛出一个异常</li></ul><p>要注意的是, 事务的提交开销较大, 所以在使用隐式事务时, 譬如大批量调用<code>put</code>时, 我们需要统一写到一个事务里去提交</p><pre><code class="java">for(User user: userList){  user.plusAge();  box.put(user);}</code></pre><p>以上的demo我们应该优化为下面这种:</p><pre><code class="java">for(User user: userList){ user.plusAge();}box.put(userList);</code></pre><h2 id="数据库查看"><a href="#数据库查看" class="headerlink" title="数据库查看"></a>数据库查看</h2><ol><li>在项目app gradle文件中, 必须在<code>&#39;io.objectbox&#39;</code>插件apply之前依赖一下代码<pre><code class="groovy">debugCompile &quot;io.objectbox:objectbox-android-objectbrowser:1.2.1&quot;releaseCompile &quot;io.objectbox:objectbox-android:1.2.1&quot;</code></pre></li><li>清单文件申请权限<pre><code class="java">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</code></pre></li><li>然后在BoxStore构建<code>之后</code>, 加入以下代码<pre><code class="java">if(BuildConfig.DEBUG){         new AndroidObjectBrowser(boxStore).start(this);}</code></pre></li></ol><p>运行后, 就可以从设备的通知栏点击进入查看数据库, 也可以通过在cmd中输入<code>adb forward tcp:8090 tcp:8090</code>, 打开浏览器, 输入<a href="http://localhost:8090/index.html" target="_blank" rel="noopener">http://localhost:8090/index.html</a> 网址查看</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>关于它和rxJava如何使用, 如何做数据的观测, 以及和LiveData的搭配使用, 鉴于目前篇幅过长, 而且LiveData我目前还没有玩过, 所以暂时不写. 后续可能会新补一篇.</p><p>具体可以看<a href="https://github.com/YuTianTina/DatabaseChoice" target="_blank" rel="noopener">Demo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前前言&quot;&gt;&lt;a href=&quot;#前前言&quot; class=&quot;headerlink&quot; title=&quot;前前言&quot;&gt;&lt;/a&gt;前前言&lt;/h2&gt;&lt;p&gt;本篇主要是方便自己记忆所写, 基本是撸完官方文档后的笔记&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;ObjectBox是一款由greenrobot出的基于noSql的ORM数据库, 但又支持表关系的定义以及事务的处理, 另外在性能上有着非常卓越的表现&lt;br&gt;(关于性能比较, 可以看&lt;a href=&quot;1&quot;&gt;这篇&lt;/a&gt;),&lt;br&gt;同时可以接入rxJava的扩展库, 并与google最新出的框架组件(Android Architecture Components)中的LiveData结合使用, 支持Kotlin.&lt;br&gt;目前版本更新到1.2.1&lt;br&gt;
    
    </summary>
    
    
      <category term="android" scheme="//litten.me/tags/android/"/>
    
      <category term="ObjectBox" scheme="//litten.me/tags/objectbox/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="//litten.me/2017/12/19/hello-world/"/>
    <id>//litten.me/2017/12/19/hello-world/</id>
    <published>2017-12-19T02:05:09.797Z</published>
    <updated>2017-12-19T02:05:09.797Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
